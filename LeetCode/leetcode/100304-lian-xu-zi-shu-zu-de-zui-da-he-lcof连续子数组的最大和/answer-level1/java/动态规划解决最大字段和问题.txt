要想使用动态规划解决实际问题必须要了解其三要素，具体什么是动态规划三要素自己去百度。我对动态规划的理解就是较大的问题的解可以通过较小问题的解
所推出，这也就是确定动态转移方程。那么怎么确定动态转移方程呢？这里先不要急，我们先假设dp[i]是以i结尾的最大字段和，这里我们不知道该连续字段的启始下标是什么，也没必要知道因为题目求的是最大连续字段和的值。那么假设dp[i]是当前以i结尾的最大字段和，那么该问题的子问题是什么？很明显是
dp[i-1],这就表示了他前一个以i-1结尾的连续最大字段和的值。那么dp[i]和dp[i-1]有什么关系呢？我们知道i和i-1之间差了一个num[i]，而它就是推出动态转移方程的关键。num[i]其实就是dp[i]和dp[i-1]的一个中介,假如num[i]的值是小于0的那么根据最优子结构dp[i]的值是问的选的就是说你要还得要不要还得要没有选择的余地，那么毫无疑问他的值和前一个子问题一样dp[i]=dp[i-1]。当num[i]>0的时候这个时候就不同了，这时手上有牌可打了，dp[i]的取值就有了两个num[i]和dp[i-1]+num[i]，num[i]的意思就是从当前下标i重新构造连续最大字段和，dp[i-1]+num[i]表示接上上一段最大字段构造出当前的最大字段和。然后在确定该问题的baseCase，显而易见当i=0的时候dp[0]=num[0]。至此动态转移方程推导完毕。
dp[i] ={ num[i],i=0 | max(num[i],dp[i-1] +num[i]) i>0 },然后再用一个变量记录变化的dp[i]的值即可，代码如下：
```
   public int maxSubArray(int[] nums) {
        int n=nums.length-1;
        int []dp=new int[nums.length];
        int max= dp[0]=nums[0];;
        for (int i = 1; i <=n; i++) {
            //dp[i]为以i为结尾的最大字段和，然后在计算的过程中更新字段和的最大值
            dp[i] = Math.max(nums[i], dp[i-1]+nums [i]);
            if (dp[i]>max)max=dp[i];
        }
        return max;
    }
```

