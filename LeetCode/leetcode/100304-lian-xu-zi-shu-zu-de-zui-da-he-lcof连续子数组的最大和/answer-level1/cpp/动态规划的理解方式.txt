这个比较难理解,主要是叙述的不好.

很明显是一个动态规划题,因为要求了时间复杂度为O(n),不能使用暴力的算法.

动态规划的核心就是,从第一步开始,每一步的选择都会对下一步造成影响.

找到状态转移方程是非常关键的,本质上来讲,就是找到f(n)和f(n-1)之间的关系.

那首先就要明白f(n)代表的是什么,一般来说,f(n)代表的是要求解的答案对吧,但是这道题并不是,为什么呢?

因为,答案要求是连续的数组,而每次状态转移,推进一步之后,新加入的元素nums[i]可能根f(n-1)并不是连续的,所以如果把f(n)理解成"数组长度为n的连续子数组最大值",就找不到状态转移方程,这也是我之前做的时候,百思不得其解的地方.

如果把f(n)当作"以nums[n]为结尾的最大子数组(和最大)",是不是逻辑就很清晰了,因为随着算法的推进,每次新加入的nums[n]和之前的f(n-1)就是连续的数组了,由此,f(n)终于和f(n-1)产生了逻辑上的联系,状态转移方程出来了:f(n)=max(num[n],f(n-1)+num[n]),含义是:每次新加入一个元素num[n],以这个元素为结尾的子数组中,可能是它自己独立作为子数组和最大,也可能是它自己联合f(n-1)组成的新数组和最大,取一个最大的即可.

这样for一遍下来,从f(1)到f(n)中,就存储了n个数据,每个数据都表示以它为结尾的子数组中和最大的值,其实这也就相当于穷尽了所有的子数组的可能性.
所以只需要取出f(1)到f(n)中最大值,即为答案.

所以再回顾我刚才说的,f(n)并不是答案,f(1)到f(n)中的最大值,才是答案.

代码:
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int dp = nums[0];
        int res = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            dp = max(dp + nums[i], nums[i]);//f(n)表示的是以当前元素为结尾的子数组最大值,则f(k)应该等于max(num[k],f(k-1)+num[k]),意思就是加入的新元素自己作为数组大,还是和之前的最大数组组合起来的新数组大,保留一个最大的
            res = max(res, dp);//res不断保存f(n)在推进过程中出现过的最大值,这一步很关键
        }
        return res;
    }
};
