### 解题思路
该题如果不仔细审题，很容易想当然的使用递归解法，从而导致运行错误。细心看题后发现，答案需要取模，我不知道利用递归解法该如何取模。因此，本题使用迭代求解：
* n<=0时，数列为0
* n==1时，数列为1
* n>1时，n的大小即代表循环相加的次数，设当前值为0，下一个值为1。迭代求解，并取模。

本题考查斐波那契数列，解题者不仅需要知道递归实现，也要知道迭代实现，考察的比较全面。本题的时间复杂度为O(N)，空间复杂度为O(1)。

### 代码

```c
int fib(int n)
{
    int result = 0;
    if(n <= 0)
    {
        result = 0;
    }
    else if(n == 1) 
    {
        result = 1;
    }
    else
    {
        int i=n-1;
        int curr = 0, next = 1;
        while(i--)
        {
            result=(curr+next)%1000000007;
            curr=next;
            next=result;
        }
    }
    return result;    
}
```