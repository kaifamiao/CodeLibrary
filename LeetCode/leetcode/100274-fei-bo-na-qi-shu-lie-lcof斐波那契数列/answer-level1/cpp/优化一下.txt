 在使用动态规划数组后，我们发现其实最终的答案只和他的前两个数有关。所以我们定义ｆ表示前一个数，ｇ表示当前数（也是最终答案）。
当ｎ＝０时，很明显，当前数也是０，但ｆ等于多少呢？这时我们看ｎ＝２时，ｇ＝１，所以我们推出当ｎ＝０时，下标为－１（假设存在）的数的值就是１（ fib(-1) + fib(0) = fib(1) ）；
 最关键的递推式怎么写？假设当前ｆ为第一个斐波那契数，ｇ为第二个斐波那契数，那么如果我们要求第三个斐波那契数，我们需要更新ｇ的值，等于前两个数之和　g = g + f　，好的，此时ｇ变为了第三个斐波那契数，ｆ还是第一个，我们还要更新ｆ的值。很明显，ｆ需要更新为第二个数，第二个数＝第三个数－第一个数：f = g - f ；
 代码如下：
```c++
class Solution {
public:
    int fib(int n) {
        int g = 0, f = 1;
        while (n--) {
            g = g + f;
            f = g - f;
            g %= 1000000007;
        }
        return g;
    }
};