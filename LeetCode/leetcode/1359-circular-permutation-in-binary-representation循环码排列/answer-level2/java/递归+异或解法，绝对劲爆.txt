经过好几个小时的挣扎，终于解出了此题，看了下题解，都是写的"格雷码"、"截断"什么的，这些我都不太了解，在此介绍我的方法。
拿n == 3 为例，先给大家展现一组数据。
```
十进制      二进制          操作
0          000             
                           ^= 1  
1          001             
                           ^= (1 << 1)  
3          011             
                           ^= 1  
2          010             
                           ^= (1 << 2)
6          110             
                           ^= 1  
7          111             
                           ^= (1 << 1)  
5          101             
                           ^= 1  
4          100             
```
上面这一组数据，每行数据都是上一行的值，经过右侧的运算得出的，当然除了第一行。我也推算了n == 4 的情况，也是符合上述的操作规律。看到最右侧的一列操作，大佬们可能有思路了。
差不多是这样的，
```java 
int v = 0;
f(n) {
    f(n - 1);
    输出(v);
    f(n - 1);
}
```
但是我还要给大家展示另一组数据。
```
十进制      二进制          操作
3          011             
                           ^= 1  
2          010             
                           ^= (1 << 1)  
0          000             
                           ^= 1  
1          001             
                           ^= (1 << 2)
5          101             
                           ^= 1  
4          100             
                           ^= (1 << 1)
6          110             
                           ^= 1  
7          111             
```
通过这组操作，我们可以看出，上面的规律并不仅仅可以从0开始。
下面上代码

```
代码块
class Solution {
    List<Integer> res = new ArrayList<>(); // 存放输出结果
    int v = 0; // 循环的开始值
    public List<Integer> circularPermutation(int n, int start) {
        res.add(start); // 先把开始值加进来
        v = start;
        print1(n - 1);  // 当n==3时，我们的操作最大只能是 1<<2，所以传入 n - 1
        return res;
    }
    void print1(int n) {
        if (n == 0) { // 作为跳出条件
            res.add(v ^= 1);
        } else {
            print1(n - 1);
            res.add(v ^= (1 << n));
            print1(n - 1);
        }
    }
}
```
代码的时间和空间复杂度肯定不怎么好，就是想给大家分享下我的思路。
如果有问题，大家可以随便问；如果讲解有错误，欢迎大家批评指正。
赶紧去学下 "格雷码"、"截断" 啦。