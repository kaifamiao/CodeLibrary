二进制的加法无外乎就以下几种情况，
1. 1+1 = 0    （有进位）
2. 1+0 = 1    （无进位）
3. 0+0 = 0    （无进位）
4. 0+1 = 1    （无进位）

仔细一看，在不考虑进位的情况下，这个不就是二进制的异或操作嘛。所以，我们就可以把加法分成无进位的异或结果，a^b  与保存的进位相加，循环直到没有进位为止，就可以得到结果了。

再分析二进制加法中进位怎么能保存，因为只有 1+1的时候会产生进位，这不就是与操作嘛，a&b   但是进位需要在更高的一位，所以我们就左移一位嘛就搞定了，
所以，进位就可以这样保存

c = (a&b)<<1;

这样就可以用  a = (a^b) ^ c 得到一轮结果 ，但是有可能还会有进位，所以需要将这个放在循环里面就可以了。

        while (b)
        {
            auto carry = ((unsigned int ) (a & b))<<1 ; // 记录a+b的进位，直到进位为0是退出
            a = a^b;   //结果相加
            b = carry;  //循环
        }
        return a;


分析是参考引用各位大侠写的加法原理，只是以前没有更细致的研究过，C++实现，补充一下


