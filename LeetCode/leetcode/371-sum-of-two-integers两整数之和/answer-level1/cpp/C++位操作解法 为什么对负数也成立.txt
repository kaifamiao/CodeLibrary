借鉴大家的思路，再加上自己的理解过程，希望能对和我一样的新手的理解有所帮助

二进制计算中，
1+1=0(进位)
1+0=1(无进位)
0+1=1(无进位)
0+0=0(无进位)
我们可以将其拆成两个步骤，先进行位加(与异或运算相同，真值表 0 1 1 0)，再加上进位(与运算，真值表 1 0 0 0)

代码如下：
```
    int getSum(int a, int b) {
        while(b){
            int carry = unsigned(a&b) << 1;
            a ^= b;
            b = carry;
        }
        return a;
    }
```

# 进一步的理解：
关于carry：   
进位为向前一位加，所以得到相应的进位值后需要再左移一位
c++(或者说leetcode的c++编译器)中关于负数的移位要求很奇怪，我的理解是对应进位过程只考虑对应0或1，不考虑正负，这点和下面的补码部分对应

为什么负数也成立：
首先是基础的补码知识
我们都知道计算机中负数的存储用补码，相应处理方法是，正数不变，负数由相应正数取反再加一得到，那对负数进行这样的操作的原因是什么呢

以钟表为例，顺时针走3格和逆时针走9格表示的含义相同；同样，补码中负数的存储，就是在逆时针走，只是此时表盘上不只有12格了而已
int类占四个字节32位，第一位是符号位；按数学方式考虑，对正数a取反之后，得到2^32-1-a，再加上1，正好得到2^32-a，-a此时表示为2^32-a。也就是说，表盘上一共有2^32格；
表盘的前一半，顺时针走得快，也就是大概2^31个正数，0到2^31，符号位为0；
表盘后一半，逆时针走得快，同样大概2^31个负数，(2^32-0) 到 (2^32-2^31) ，符号位为1；

补码的好处呢，就是减法此时可以换成加法的形式，举个例子，
4 - 5，变成了 4 + (-5)，按照上面的数学方式理解也就是 4 + (2^32-5) = 2^32-1，结果落在表盘的后一半，还是负数，得到-1；

至于为什么这个方法负数同样适用，就得益于补码的这个特点，它**消除了加法中的符号特性，计算机可以直接对数进行二进制加，结果再利用补码存储**。
上面的用异或和与操作一起模拟的，实现的就是二进制加法的过程；**保证结果正确的，是补码本身**。