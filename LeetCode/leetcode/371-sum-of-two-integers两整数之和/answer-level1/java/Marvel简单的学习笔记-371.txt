### 解题思路
借本题复习一下位运算的一些知识点。
正数的原码、反码、补码均相同。
负数的原码除开符号位后取反得到反码，反码加一得到补码。
最高位为符号位，0表示正数，1表示负数。
为了统一正数负数的运算，计算机使用补码存储和表示数值。

接下来开始模拟位运算进行两整数求和的过程：
首先不考虑进位，则这样不进位的加，不借位的减就是按位异或（XOR）。代码表示为：`a ^ b`
接下来该考虑进位了，显然，当两个数的同一位均为1时，这个位需要向高位进1。问题是如何知道哪些位要向高位进1？
使用按位与，两个位均为1时，按位与的结果才为1，其余情况均为0，刚好也符合向高位进1的条件。代码表示为：`a & b`
按位与之后，需要向高位进1的位现在均为1，其余位为0，既然要向高位进1，则这些1应该左移一位，代码表示为：`(a & b) << 1`，然后和不考虑进位时的结果加和（按位异或），才算实现了一次进位。
同理，第二次按位异或也是采取上述操作，没有考虑进位，按位异或，然后再考虑进位。这样会得到一个新的进位，如此这般循环往复，会不断得到新的进位，将其整合到结果中，直至不需要进位（进位carry为0），我们就得到了最终的和。

### 代码

```java
class Solution {
    public int getSum(int a, int b) {
        int res = a ^ b;
        int carry = (a & b) << 1;
        while(carry != 0)
        {
            int temp = (res & carry) << 1;
            res ^= carry;
            carry = temp;
        }
        return res;
    }
}
```