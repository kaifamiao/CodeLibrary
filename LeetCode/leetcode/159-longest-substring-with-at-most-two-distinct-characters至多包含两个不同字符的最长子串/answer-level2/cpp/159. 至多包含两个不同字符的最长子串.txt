### 解题思路
此处撰写解题思路

### 思路：
1. 首先建立一个hash表mp，i是起点，每次for遍历s字符串的时候，都会让mp[s[i]]++。
2. 在i从左往右进行遍历的时候，观察是否什么时候元素数量超过了2个。
3. 代码中会计算好hash表中只有2个字符时的最大长度。

### 解释变量
1. i则是遍历整个字符串s的指针，一开始就一个一个地往前遍历，当mp中有2个以上元素的时候，停止i的前进。
2. 这个时候出现了变量j，j是窗口的起点，i则是窗口的终点。
3. 注意：这次的i和j和以前的题不一样，之前i是起点，j是终点。这里，i是用来计算最大长度的小指针，j是限制只有2个元素窗口的起点，i是窗口的终点。
3. 窗口移动的“开关键”是mp中size()大于2，大于2之后，窗口移动的目的是因为这个窗口不能容纳2个以上的不同元素。
4. 如果有2个以上的不同元素，就往前一个一个地移动，直到窗口中又重新剩下2个不同的元素。
5. ans是一直在计算最大长度的(不像i和j都有自己work的“时间段”)，当出现第3个不同元素的时候，虽然i++了，但是其实j++了，所以对ans的更新没有影响。
6. 那么为什么ans的长度是(i - j + 1)呢？因为二者都是从0开始的


### 代码

```cpp
class Solution {
public:
    int lengthOfLongestSubstringTwoDistinct(string s) 
    {
        unordered_map<char, int> mp;

        int i = 0;
        int j = 0;

        // 为什么把ans设置成INT_MIN就不行，设置成0就通过？
        int ans = 0;

        for (i = 0; i < s.size(); i++)
        {
            mp[s[i]]++;

            // 我们的目标就是让窗口中的元素只有2个
            // 如果超过了2个，就把当前终点j对应的字符s[j]删掉一个
            while (mp.size() > 2)
            {
                mp[s[j]]--;

                if (mp[s[j]] == 0)
                {
                    mp.erase(s[j]);
                }
                j++;
            }
            ans = std::max(ans, i - j + 1);
        }
        return ans;
    }
};
```