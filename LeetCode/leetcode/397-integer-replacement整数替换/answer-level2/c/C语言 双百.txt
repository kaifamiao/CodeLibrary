思路： 奇偶直接看最低位是否为1，这个很简单；
代码解释：
其他场景分2种情况，如果m小于等于3，这种m直接减1，然后除以2就能得出结果。

当m大于3的时候，其实就是看最低的2位，奇数的情况下，这2位只有2种情况（11或01），如果是01直接减1，如果是11，显然+1之后会出现2个0，
此时由于除以2就是做右移操作，肯定不会比减1变成10再往后计算次数多。

执行结果：通过
显示详情执行用时 :0 ms, 在所有 C 提交中击败了100.00%的用户
内存消耗 :5 MB, 在所有 C 提交中击败了100.00%的用户
```
int integerReplacement(int n)
{
    int step = 0;
    long long m = n;
    while (m > 1) {
        if ((m & 1) == 0) {
            m = m >> 1;
        } else {
            if (m <= 3) {
                m--;
            } else {
                if ((m & 3) == 3) {
                    m++;  /* 如果是11就++ */
                } else {
                    m--; /* 如果是01就-- */
                }
            }
        }
        step++;
    }
    return step;
}
```
