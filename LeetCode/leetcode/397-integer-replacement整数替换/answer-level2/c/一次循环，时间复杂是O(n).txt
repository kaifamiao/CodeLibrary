正整数n的二进制为1XXXXXXXXXXXXXX
1、如果最后位是0，n为偶数；最后一位是1，n为奇数
2、如果最后一位0，直接除2，即右移一位，操作次数是1；
3、如果最后一位是1，要选择+1 或-1，然后除2，即右移，操作次数是2； +1或-1，关键要看对bit 2 的影响，因此考虑后两位，可能为11或者01
    如果是11，如果选择-1，变成10，待右移后最后一位还是1，还是要操作2次；如果选择+1，变成两位变成00，右移后最后一位是0，只需要右移一位，操作一次。由此如果最后两位是11，选择+1；
    同理可得，如果最后两位是01，选择-1
4、考虑加速
    如果最后两位是X1，经过+1或-1后，变成00，此时可直接右移2次，操作次数+3
5、考虑边界
    最后两位是11，选择+1。如果n是可表示的最大正整数，比如64个1，加+1后进位，将无法表示。因此选择直接将11 先置0， 再右移两位，再选择加1。
    上述的算法，默认n最二进制表示为两位，最大为11，即十进制的3，此为边界

int integerReplacement(int n){
    int count = 0;
    while(n > 3){
        if(n & 1){
            if(n & 2){
                n = (n ^ 3) >> 2;
                n++;
                count += 3;                
            }else{
                n = (n ^ 1) >> 2;
                count += 3;
            }            
        }else{
            count++;
            n = n >> 1;
        }
    }
    if(n == 3){
        count += 2;
    }else if(n == 2){
        count++;
    }
    return count;
}/*  */