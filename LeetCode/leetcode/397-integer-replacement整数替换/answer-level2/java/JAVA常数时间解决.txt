常数时间内解决
最多只需遍历一个长度为32的数组两次
解题思路：
偶数可以直接右移，奇数需要加一或者减一。
考虑一下加一和减一的代价，如果在n的二进制表示中有两个或以上1连续，选择加一，只有一个1，选择减一。
如7,二进制表示111，选择+1, 111 -> 1000 -> 100 -> 10 ->1;
27,二进制表示11011 -> 11100 -> 1110 -> 111 -> 1000 -> 100 -> 10 -> 1
5, 二进制表示101 -> 100 -> 10 -> 1

所以编程思路如下：
首先统计int类型的32位上，每一位是0还是1。
然后遍历数组，无论是0还是1，首先count++（0直接右移，1代表+1或者-1）。
针对1的情况，统计连续的1的个数oneNum，无论有多少个连续的1，都需要再右移oneNum位,如果oneNum > 1，即有两个或以上的1，还需要再将前一位置1（如100111，首先第一步操作加1得到101000，然后右移三位得到101，一共四步操作。然后以此类推）。

唯一的一个例外是，当最后剩下两位11，这时候只需要2步操作即可完成，但在之前的操作中，首先count++,又加了oneNum(2)，多加了一步，需要减掉。

```
class Solution {
    public int integerReplacement(int n) {
        int[] bits = new int[32];
        int max = 0;
        //统计每一位上为1还是为0,0代表偶数可以直接右移，1代表需要加1或者减1的操作
        for (int i = 0; i < 31; i++) {
            bits[i] = n & 1;
            n >>= 1;
            if (bits[i] == 1) {
                max = i;
            }
        }
        int count = 0;
        for (int i = 0; i < max; i++) {
            //无论是0还是1，至少需要一步操作，0为直接右移，1为加1或者减1
            count++;
            if (bits[i] == 1) {
                int oneNum = 1;
                while (i + 1 <= max && bits[i + 1] == 1) {
                    i++;
                    oneNum++;
                }
                //连续的1的个数大于1，则选择加1的操作，并将前一位置1；否则选择减1的操作
                if (oneNum > 1) {
                   bits[i + 1] = 1;
                }
                count += oneNum;
                //唯一的特殊情况，当最高位存在连续两个1，即最后剩下11（3）的时候，此时用减1的操作只需要两步，但上面加了三步，需要减一
                if (oneNum == 2 && i == max) count--;
            }
        }
        return count;
    }
}



```
