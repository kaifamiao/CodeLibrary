1、偶数没有任何疑问，无符号右移即可。
2、奇数时的两个选择，其实有迹可循：
例子：101111 - - > (110000 or 101110)?
首先明白，使用n + 1或n - 1 替代 n 都会计一步，可以理解为“转化1代价”，那么最舒适的情况当然是1越少越好(1000000[注：为偶数])，一路右移通畅无阻。如例子中所示，此时选择 n + 1 一次可以处理掉 (4 - 1 = )3 个 1，而选择n - 1稍后仍然要在其他的3 个 1 上消耗时间。显而易见前者是更高效的。
但这里要注意两个特殊的情况：
3的特殊性：按照上面偶数的处理方式 n + 1 和 n - 1都会消耗掉一个 1 ，但 n + 1 方式下路线为：3 - > 4 - > 2 - > 1，n - 1 方式下路线为3 - > 2 - > 1;所以将此时的累计值直接加二处理掉即可。
Integer.MAX_VALUE(2147483647)溢出兼容
Integer.MAX_VALUE会被算法使用奇数处理逻辑 +1 导致溢出为Integer.MIN_VALUE(0x80000000),此时做31次无符号右移即可得到1，这也是选用无符号右移的原因。

```
class Solution {
    public int integerReplacement(int n) {
        int count = 0;
        while (n!=1){
            //与运算判断最后一位来区分奇偶
            if((n & 1) == 0){
                //偶数直接无符号右移，
                //2147483647 会被奇数处理算法加一溢出为负数，
                //若选用带符号右移将无法回到1.
                n >>>=1;
                count++;
            }
            else {
                //识别奇数的上一位是否为1，即 以 10 结尾(xxxx01)还是以11结尾(xxxx11)
                if((n & 2) == 0){
                    //01结尾最优则应当 用 n -1 取代 n
                    n -= 1;
                    count++;
                }else {
                    //11结尾除3这个特殊情况外，其余选用 n + 1取代 n，原因如上
                    if(n == 3){
                        //3的特殊性处理，原因如上
                        count+=2;break;
                    }else {
                        n += 1;
                    }
                    count++;
                }
            }
        }
        return count;
    }
}
```
时间复杂度：O(logn):无论n取值如何，其实至多为 32位 0 1取值遍历2便即可解决。
空间复杂度：O(1):只需一个额外空间存储结果值即可。