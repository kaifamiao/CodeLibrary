### 解题思路
动态规划的思路，跟青蛙跳台阶的题目比较像，
- 假设dp数组表示预约时长，dp[i]即表示在位置i处，满足要求情况下的最大预约时长；
- 因为按摩师不接受相邻的预约，所以当前位置i处的最大预约时长，
  - 要么来自i-2位置处的最大预约时长，即dp[i-2]；
  - 要么来自i-3位置出的最大预约时长，即dp[i-3]；
  - 然后，从这两个位置来源中选取最大的那一个，与当前位置处的预约时长相加，即是当前位置处所能满足要求的最大时长，计算公式即为：dp[i] = nums[i] + max(dp[i-2], dp[i-3])，其中nums[i]表示当前位置的预约时长；
  - 为什么不能是i-4呢，假设是i-4,我们从下面的位置序列来看，
  - [i-4, i-3, i-2, i-1, i],可以发现，位置i-4和位置i之间还可以有一个i-2，本题中预约时间均大于等于0，那么自然加上中间的i-2肯定是要比不加更大的，而i-4又是i-2的子结构，所以我们只需要判别i-2和i-3位置处的最大值即可；
- 另外，还需要注意初始条件，从上述分析可以看到，当前位置i处的最大时长，要向前看2-3个数，所以我们的初始条件要将预约序列中的前3个位置先给出来，然后才能正常进行动态规划；
- 最后返回的时候，要注意，应当返回最后两个位置中的最值，因为我们的dp每次往前看的是i-2,i-3的位置，还有i-1的位置没有兼顾到，所以在最后要和i-1位置处的取值进行比较；

### 代码

```python3
class Solution:
    def massage(self, nums: List[int]) -> int:
        if not nums:
            return 0
        lgth = len(nums)
        if lgth <= 2:
            return max(nums)
        
        dp = [0]*lgth
        # 设置初始条件
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        dp[2] = max(nums[0]+nums[2], dp[1])
        
        for i in range(3, lgth):
            dp[i] = max(dp[i-2], dp[i-3]) + nums[i]
            
        
        return max(dp[lgth-1], dp[lgth-2])   # 返回最后两个位置中的最值
```