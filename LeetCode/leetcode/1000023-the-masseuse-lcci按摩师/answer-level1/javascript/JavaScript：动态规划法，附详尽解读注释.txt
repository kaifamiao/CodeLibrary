首先，读题，发现题目要求——找到**最优**的预约集合。

求最优解问题，一般都可以想到使用动态规划（Dynamic Programming）来解决。

动态规划有三个重要的概念：
1. 最优子结构
2. 边界
3. 状态转移方程

接下来，逐一分析下在这道题中，这三个概念是如何被体现出来的。

### 最优子结构
由于无法接受相邻的预约，所以，第`i`个预约的状态，取决于第`i-1`个预约是否接受：
- 第`i`个预约接受： 第`i-1`个预约必定不可以接受。
- 第`i`个预约不接受：第`i-1`个预约接受与否随意。

所以关键点在于，需要区分出“**是否接受**”这一状态。

已知，本题会传入一个数组，表示按摩师接受到的所有预约请求，则可以构造一个二维数组来容纳这个状态（是否接受）的维度。
- `dp[i][0]`：第一个索引`i`表示在预约数组`[0, i]`中的第`i`个预约，第二个索引`0`表示该预约**不接受**，其值则存储这种状态下的总分钟数。
- `dp[i][1]`：第一个索引`i`表示在预约数组`[0, i]`中的第`i`个预约，第二个索引`1`表示该预约**接受**，其值则存储这种状态下的总分钟数。

### 边界
动态规划的核心就是“大事化小，小事化了”。即问题可以分解为若干个子问题，这种形式十分适合用“自底向上”的视角来解决。

既然是自底向上，那么就必须梳理出初始状态，即边界。

第`i`个预约的状态值和第`i-1`个预约的状态值相关，第`i-1`个预约的状态值由与第`(i-1)-1`个预约相关。以此类推，第2个预约就只和第1个预约相关。

所有可以得出边界值，第1个预约请求的状态：
- `dp[0][0] = 0`：第一个预约请求不接受，所以时长等于0。
- `dp[0][1] = nums[0]`：第一个预约请求接受，所以时长等于nums数组首项的值。

### 状态转移方程
状态转移方程是解决动态归纳问题的核心突破点，一旦方程成立，则问题就迎刃而解。

可以将状态转移方程简单的理解为“**梳理不同阶段间的联系**”。

之前分析得出，第`i`个预约的接受与否，取决于第`i-1`个预约是否接受。则预约时长就有两种状态：
- `dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1])`：如果第`i`个预约请求不接受，则它的总预约时长就应当取「第`i-1`个预约**接受**总时长」和「第`i-1`预约**不接受**总时长」之中的最大值。
- `dp[i][1] = dp[i - 1][0] + nums[i]`：如果第`i`个预约请求接受，则它的总预约时长就直接是「第`i-1`个预约不接受的总时长」加上「第`i`个预约接受的时长」。


### 代码实现
当这三个关键概念都梳理清楚后，代码逻辑就跃然纸上：
1. 构造二维数组，用于存放每个预约的最大时长
2. 初始化边界值
3. 建立状态转移方程
4. 得出结果

值得一提的是，在JavaScript世界中，并没有原生的二维数组构造API，所以需要手动去实现。
```
let dp = new Array(Length).fill(undefined).map(ary => [0, 0]);
```
有一个小小的Feature值得JSer去关注，`Array.prototype.fill()`的参数是**引用类型**时,无论这个引用类型是如何生成的，数组中的元素都会指向同一个对象，故需要再利用`Array.prototype.map()`来返回一个新的数组，隔断引用。
```
let foo = new Array(2).fill([0]);
foo[0][0] = 1;
foo[0][0] === foo[1][0]; // true
```
下面是完整的代码实现：
```
/**
 * @param {number[]} nums
 * @return {number}
 */
var massage = function(nums) {
    const Length = nums.length;

    if (Length <= 1) {
        return Length === 1 ? nums[0] : 0;
    }


    /*
    关键点
    构造二维数组
    dp[i][0]：前i个预约中，第i个预约不接的最长预约时间
    dp[i][1]：前i个预约中，第i个预约接的最长预约时间
    */
    let dp = new Array(Length).fill(undefined).map(ary => [0, 0]);

    dp[0][1] = nums[0];

    /*
    关键点
    状态转移方程
    第i个预约不接受：总预约时长取「第i-1个预约接受总时长」和「第i-1预不接受总时长」之中的最大值
    第i个预约接受：总预约时长就是「第i-1个预约不接受的总时长」加上「第i个预约接受的时长」
    */
    for(let i = 1; i < Length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
        dp[i][1] = dp[i - 1][0] + nums[i];
    }

    /*
    最后一次预约可以接受，也可以不接受，取二者最大值。
    */
    return Math.max(dp[Length - 1][0], dp[Length - 1][1]);
};
```
Tip：本篇文章只着重于阐述“动态规划解题的思路”，并没有对时间/空间复杂度进行优化，读者可自行使用“备忘录算法”等措施来进行进一步的优化，本处就不再深入探讨了（其实是写累了，脑细胞耗尽，要去喝肥宅快乐水了~）。
