1. 这题首先我们可以把数组长度小于3的情况单独拎出来，因为不能连续，则长度为一和二时只能取其中最大的那个预约
2. 然后我们可以运用动态规划解法，动态规划的核心首先就是，**我们需要创建一个长度和输入相同的list来存遍历至每个预约时的当前最优解**
3. 接下来，对于遍历到第一个,因为只有一个，我们必须取他，遍历到第二个预约时，我们在第一个和第二个中取更大值
4. 进入for loop 对剩下的情况进行求解，因为我们不能取连续，所以每当遍历到当前客人时，最优解就是 不接待他和接待他中的较大值
5. 不接待他的话，我们则维持接待前一个客人时的时常，即dp[i-1]
6. 接待他的话，我们需要取接待第一个客人到当前客人的前两位中的较大值（此处不能直接取dp[i-2]，因为可能存在前面客人更优的情况）加上当前客人的时长。
7. 最后返回dp里的最大值就可


具体代码如下：

```
class Solution:
    def massage(self, nums: List[int]) -> int:
        if not nums:
            return 0

        if len(nums) < 3:
            return max(nums)

        dp = [0]*len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0],nums[1])
        for i in range(2,len(nums)):
            dp[i] = max(dp[i-1],max(dp[:i-1])+nums[i])

        return max(dp)
```
