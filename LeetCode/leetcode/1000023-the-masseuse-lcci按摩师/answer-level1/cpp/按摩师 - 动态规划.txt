### 解题思路
1. 动态规划常常会考虑是否有后效性。所谓后效性，就是前面的选择会影响后面的选择，如该题的，接受了第`i`位顾客的预约，就无法接受第`i+1`位顾客的预约。我们无法单纯的通过定义`dp[n]`这样的数组来看出它的状态(就是前面是否选择了接受预约)

2. 因此解决具有后效性的问题，常常加多一维来表示状态。如代码中的定义的`dp[n][2]`; `dp[i][0]`代表我们没有接受第`i+1`位顾客的预约，`dp[i][1]`代表接受了第`i+1`位顾客的预约。这样定义`dp`就可以看出`dp`的状态了。因此我们处理第`i+2`位顾客时，可以通过判断是否接受了第`i+1`位顾客的预约来进行更新。

3. 结果返回`dp[n-1][0]`和`dp[n-1][1]`中值较大的那个

### 代码

```cpp
class Solution {
public:
    int massage(vector<int>& nums) {
        if(nums.empty()) return 0;
        int n = nums.size();
        // 0代表不选，1代表选
        int dp[n][2];
        memset(dp, 0, sizeof(dp));
        dp[0][1] = nums[0];
        for(int i = 1; i < n; i++){
            dp[i][0] = max(dp[i-1][1], dp[i-1][0]);
            dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]);
        } 
        return max(dp[n-1][0], dp[n-1][1]);
    }
};
```