### 解法一 通过三维数据来解决，但是在大K的情况会超时
通过三维来进行表示，一维下标表示第几天，二维下标表示最大的交易次数，三维表示持有或者未持有股票。
每天会有两种状态:
1. 今天持有股票，有两种可能
    - 昨天就持有股票，今天不卖。所以最大利润就等于昨天持有股票的利润一样。dp[i-1][k][1];
    - 昨天没有股票，今天买入。所以最大利润就等于昨天未持有股票的最大利润减去今天要买的股票价格.dp[i-1][k-1][0]-price[i];(这边k为何要减1？因为今天要买入，今天最大交易笔数为k，所以昨天的最大交易笔数相对今天而言要减1，因为要预留给今天买入。)
    - 今天持有股票的最大利润取上面两种情况的最大值dp[i][k][1]=Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-price[i]);
2. 今天未持有股票，有两种可能
    - 昨天就没有股票，今天不买。所以最大利润就等于昨天未持有股票的利润。dp[i-1][k][0];
    - 昨天有股票，但是今天卖了。所以最大利润等于昨天持有股票的最大利润+今天卖出的股票价格.dp[i-1][k][1]+price[i];
    - 取上面两者的最大值dp[i][k][0]=Math.max(dp[i-1][k][0],dp[i-1][k][1]+price[i]);
```
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length<=1 || k<=0) return 0;
        int length=prices.length;
        //一维下标表示第几天，二维下标表示最大的交易次数，三维下标,0表示未持有，1表示持有。所对应的值为最大利润。
        //如何理解二维下标？比如说到第到五天，我可以交易一笔或者交易两笔，但是我们如果要利润最高，并不代表交易的次数越多就利润越高。所以我们需要记录所有的情况。
        int dp[][][]=new int[length][k+1][2];
        for(int i=1;i<=k;i++){
            //第一天不用管k的次数问题，只要k次数大于0，那么就可以买
            dp[0][i][0]=0;
            dp[0][i][1]=-prices[0];
        }
        //从第二天开始遍历每天的价格
        for(int i=1;i<length;i++){
            //到当天可能交易的最大笔数。
            for(int j=1;j<=k;j++){
                //当天持有股票
                //1、昨天就有股票,今天不操作,因为今天不操作，所以K不用变化。
                //2、昨天没有股票,今天买入,因为今天要买入，今天最大交易笔数为j，所以昨天的最大交易笔数相对今天而言要减1，因为要预留给今天买入。
                dp[i][j][1]=Math.max(dp[i-1][j][1],dp[i-1][j-1][0]-prices[i]);
                //当天未持有股票
                //1、昨天未持有股票，今天不操作，j不用变
                //2、昨天持有股票，今天卖出，也不会影响到j。
                dp[i][j][0]=Math.max(dp[i-1][j][0],dp[i-1][j][1]+prices[i]);
            }
        }
        //最大利润为到最后一天,最大交易次数，手上未持有股票的利润。
        return dp[length-1][k][0];
    }
}
```
### 解法二 在解法一的基础上进一步优化，并处理大K的问题。
1. 优化一：大k的情况
    - 一次交易对应一次买一次卖，那么在n天内，最大交易次数为n/2；所以当k>n/2时，等价于不限次数交易。
    - 所以在k>n/2时，不需要考虑k，直接按最大利润处理即可。
2. 优化二：将三维数组降为到二维.
    - 从解法一可知当前的利润只跟前一天的最大利润有关，所以我们只需要存储前一天的利润即可，而不需要通过数组存储每一天的利润。
3. 优化三：将K反过来遍历.
    - 因为在今天未遍历k之前，当前二维数组里面所有的值都是前一天的最大利润。
    - dp[i][k][1]=Math.max(dp[i-1][k][1],dp[i-1][k-1][0]-price[i]);
    - 从上面公式可看到当遍历到i天K次时，会用到i-1天的k-1次最大利润。
    - 但是我们降维后公式为dp[k][1]=Math.max(dp[k][1],dp[k-1][0]-price[i]);
    - 注意区别，dp[k][1]是代表今天，而dp[k][1]和dp[k-1][0]还是代表的昨天。
    - 而如果我们k从小到大遍历，dp[k-1][0]会在dp[k][1]之前先计算，也就是被今天的值给覆盖了，所以将k倒序更合理。
    - **但其实k从小到大遍历并不会影响最终的结果。**
```
class Solution {
    public int maxProfit(int k, int[] prices) {
        if(prices.length<=1 || k<=0) return 0;
        int length=prices.length;
        if(k>length/2){
            //一次交易对应一次买一次卖，也就说在prices长度内，最多交易length/2次。如果k超过了这个长度，等价于不限次数的买卖。
            int maxProfit=0;
            for(int i=1;i<length;i++){
                if(prices[i-1]<prices[i]){
                    //如果今天价格小于昨天的价格,那么今天跟昨天的差就是利润
                    maxProfit+=prices[i]-prices[i-1];
                }
            }
            return maxProfit;
        }
        //一维下标表示最大的交易次数，二维下标,0表示未持有，1表示持有。所对应的值为最大利润。
        int dp[][]=new int[k+1][2];
        for(int i=1;i<=k;i++){
            //第一天不用管k的次数问题，只要k次数大于0，那么就可以买
            dp[i][0]=0;
            dp[i][1]=-prices[0];
        }
        //从第二天开始遍历每天的价格
        for(int i=1;i<length;i++){
            //到当天可能交易的最大笔数。
            for(int j=k;j>=1;j--){
                //当天未持有股票
                //1、昨天未持有股票，今天不操作，j不用变
                //2、昨天持有股票，今天卖出，也不会影响到j。
                dp[j][0]=Math.max(dp[j][0],dp[j][1]+prices[i]);
                //当天持有股票
                //1、昨天就有股票,今天不操作,因为今天不操作，所以K不用变化。
                //2、昨天没有股票,今天买入,因为今天要买入，今天最大交易笔数为j，所以昨天的最大交易笔数相对今天而言要减1，因为要预留给今天买入。
                dp[j][1]=Math.max(dp[j][1],dp[j-1][0]-prices[i]);
            }
        }
        //最大利润为到最后一天,最大交易次数，手上未持有股票的利润。
        return dp[k][0];
    }
}
```
