首先，我们分解一下具体问题：

假如我们知道了 i - 1 和 i + 1 个孩子分配的糖果个数，那么给第 i 个孩子分配糖果个数的问题就迎刃而解了。

所以，我们把解决 i 的问题 **转换为了 i - 1 和 i + 1 的子问题**，看起来是递归呐。

当然了，递归涉及到很多重复计算，那就动态规划喽。然而如果我们试图直接寻找转移方程，会发现非常的困难。

那么我们把问题转换一下，变成：

1. 相邻的孩子中，评分高 **且站在右边** 的孩子必须获得更多的糖果
2. 相邻的孩子中，评分高 **且站在左边** 的孩子必须获得更多的糖果

针对第1个问题，我们把解决 i 的问题 转换为了 i - 1 的子问题；针对第2个问题，我们把解决 i 的问题 转换为了 i + 1 的子问题

因此，针对问题1，我们从前到后扫描一遍即可（**其实是一次最简单的动态规划，类似于求最大子序列和或者斐波那契数那种**）；针对问题2，再从后到前扫描一遍，此时，与前一遍扫描计算的结果相比，取最大值即可。  

```python

class Solution:
    def candy(self, ratings: List[int]) -> int:

        res = [1 for _ in range(len(ratings))]
        
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i-1]:
                res[i] = res[i - 1] + 1
        
        for i in range(len(ratings)-2,-1,-1):
            if ratings[i] > ratings[i+1]:
                res[i] = max(res[i],res[i + 1] + 1)
        # print(res)
        return sum(res)

```