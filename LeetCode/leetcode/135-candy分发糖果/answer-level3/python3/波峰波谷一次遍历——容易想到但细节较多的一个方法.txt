波峰波谷是这道题比较容易想到的一个思路，但是实现起来需要多雕琢一些
1. 首先要做的是将评分数组分割成若干个波峰波谷，结合题目要求以及可能的复杂情况，这里要求波峰波谷严格单调，但允许上坡或者下坡的长度为0
2. 确定了一个波峰和波谷，评分最高点的学生得到的糖果树等于长度最大的那个坡的长度（比如上坡更长，那么上坡至少要满足1，2，3...的分配，因此波峰处分配的糖果数便是上坡段的长度，同样的，如果下坡路程更长，那么波峰处分配的糖果数等于下坡的长度），每一个波峰波谷的糖果数可以用三角形面积公式算出来

相比于说的，实际的代码理解起来要更容易些，下面给出python代码


```python []
class Solution:
    def candy(self, ratings: List[int]) -> int:
        total = 0
        n = len(ratings)
        i,cnt = 0,0

        while(i<n):

            j = i+1
            #确定波峰，up down代表长度，这里让他们都包含波峰点，因此长度至少为1
            while(j<n and ratings[j]>ratings[j-1]): j+=1
            mid = j
            up = j-i

            #确定波谷
            while(j<n and ratings[j]<ratings[j-1]): j+=1
            down = j-mid+1

            if up<down: up,down = down,up
            #计算这一趟波峰波谷需要的糖果数量，波峰的糖果数与上坡/下坡中最长的一程有关，所以把波峰归到最长的一程中
            total += (up*(up+1)//2 + (down-1)*down//2)


            #准备下一个波峰波谷，这里还是踩了很多坑的- - 如果是一段平的话，也就是实际上不存在上坡和下坡，那么让i+1，不然的话，存在了上坡和下坡，那么因为波谷会被下一个波峰波谷公用为起点，所以会在下一次的分配中再次被分配一个糖果，记录下公用的波谷数量
            if j==i+1:
                i = i+1
            else:
                i = j-1
                cnt += 1

        return total-cnt
```



