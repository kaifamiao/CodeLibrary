### 解题思路
太难了  搞了15次   终于。。。。
我的思路：分两种情况：1.(x<0&&x!=-2147483648)||x>0 这种情况将值取绝对值。
                    2.x=-2147483648 这种情况返回0；
主要操作：对数据取整 若！=0 就对应取余 且有个n（取个位 n=10,十位 n=100) 余数存入向量；
         后面从向量开头开始遍历元素 将元素与对应n相乘求和 n=n/10 ；
         最后 判断初始x是什么情况来决定输出；
卡住的地方：向量元素与n相乘可能会溢出
解决办法：将相乘的值除10，这样能保证 相乘后在数据范围内合法，但这最大只能判断前9位 ，如果有10位的话 就判断前9位合法且最后一位也是合法的。
初学者。
### 代码

```cpp
class Solution {
public:
    int reverse(int x)
    {vector<int>a;
    int y=0,n=1,i=1,j=0,l=x;
    if((x<0&&x!=-2147483648)||x>0)//情况一
      {x=abs(x);
    while(x/10!=0)//取整非0
    {
        a.push_back(x%10);//取余存入向量
        x=x/10;//取整 留下次循环
        n=n*10;//按取余位数递增
        j++;//记录元素个数
    }
    a.push_back(x);//当取整为0时到达最大的位，将值存入向量
    j++;
    for(i=0;i<j;i++)//循环遍历向量
   {if(a[i]*(n/10)>214748364-(y/10)||(a[j-1]>7&&a[i]*(n/10)>214748364-(y/10)))//将相乘的值除10，这样能保证 相乘后在数据范围内合法，但这最大只能判断前9位 ，如果有10位的话 就判断前9位合法且最后一位也是合法的
   {
       y=0;break;//如果溢出为0
   }
        y=y+a[i]*n;//递加
    n=n/10;}
    }
    if(l<0&&l!=-2147483648)//如果x是负的最后结果取负
    {y=y*(-1);
    }
    else if(l==-2147483648)//如果x=-2147483648可直接置0，因为此数反转必溢出
    {y=0;}
    return y;
    }
};
```