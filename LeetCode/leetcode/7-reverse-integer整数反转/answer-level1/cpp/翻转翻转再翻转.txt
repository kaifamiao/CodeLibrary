### 解题思路
要实现这个思想
主要解决两个问题
- 如何使整数翻转
- 如何判断溢出
### 逆序
- 翻转是什么，大声的告诉我，没错就是逆序。那逆序是什么就是栈。
- 例如数据23456依次存入栈再出栈我们就得到了逆序后的数据
但是我们用到栈的话需要额外的辅助空间
我们把数据23456看成是伏在水面上的一层层的木板
2
3
4
5
6
每一位是一块木板
现在我们依次抽出，并依次从下面上浮
0 - 2 - 3 - 4 - 5
0 - 0 - 0 - 0 - 6
.
0 - 0 - 2 - 3 - 4
0 - 0 - 0 - 6 - 5
.
.
.
. 
0 - 0 - 0 - 0 - 2
0 - 6 - 5 - 4 - 3 
每一位乘以10就是将该位上浮
我们将x%10视为入栈
x*10视为出栈
```
pop = x%10; // 当前木板 -> 入栈
x/10; // 下一块木板
rst = rst*10 + pop //木板上浮，当前木板插入  -> 出栈 
```
### 判断溢出
INT_MAX为 2147483647
INT_MIN为-2147483648
我们原本得到的数据应该都是在INT_MIN ~ INT_MAX之间
但是翻转以后可能会越界，抛出error
- 应该在出栈前进行判断，抛出越界
- 越界(正数)
    - 如果当前数据*10 > INT_MAX 
    - == INT_MAX，pop > 7 出栈后会导致越界
- 负数同理
### 感悟
你看这一进一出多美妙，溜了 

### 代码

```cpp
class Solution {
public:
    int reverse(int x) {
        // 判断溢出
        // 栈
        // -2147483648 ~ 2147483647
        // 十位
        int rst = 0; // 余数
        int pos_tag = INT_MAX/10;
        int neg_tag = INT_MIN/10;
        while( x!=0 )
        {
            int pop = x%10;  // 入栈
            x /= 10;
            if(rst > pos_tag||(rst == pos_tag && pop > 7)) return 0;
            if(rst < neg_tag||(rst == neg_tag && pop < -8)) return 0;
            rst = rst * 10 + pop; // 出栈
        }
        return rst;
    }
};
```