> 关注公众号【算法码上来】，每日算法干货马上就来！

![宣传图片.jpg](https://pic.leetcode-cn.com/b69e1cf548fd019f7661893e9c8789242915a0be27ea6e9a280f6f0a5679472b-%E5%AE%A3%E4%BC%A0%E5%9B%BE%E7%89%87.jpg)

## 题解
首先我们要明确一个显而易见的事实：
* 每一行、每一列要么不翻转，要么翻转一次，再多是等价的，没有意义。

### 二进制枚举
因为行列数最多 $20$ ，所以我们可以枚举每一行的翻转状态（$0$：不翻转，$1$：翻转）。

然后对于每一列，我们只需要看不翻转的 $1$ 多，还是翻转后 $1$ 多就行了。

这样的时间复杂度是 $O(2^{R}C)$，极限情况下是 $2e^7$ 左右，还是可能会超时的。

### 贪心
再仔细观察，我们可以发现要想最终和最大，第一列必须全为 $1$ 。

证明很简单，对于任意一行，如果它的第一位是 $1$ ，那么这一位的二进制数值就是 $2^{C-1}$ 。反之如果这一位是 $0$ ，那么即使后面所有位全为 $1$ ，总数值也只能达到 $2^{C-1}-1$ 。所以第一位是一定要为 $1$ 的。

这样就很简单了，每一行的翻转情况其实是确定的。如果第一位是 $1$ ，就不翻转，否则就翻转。

然后每一列还是看不翻转的 $1$ 多，还是翻转后 $1$ 多。

这样的时间复杂度只有 $O(RC)$ 。

那么可能有人会问：为啥不把每行第一位全翻转为 $0$ ，然后翻转第一列使得每行第一位全 $1$ 呢？其实这样是等价的，完全就相当于将之前的方法倒转过来（翻转不翻转操作颠倒）。

## 代码
### c++
```cpp
class Solution {
public:
    int matrixScore(vector<vector<int>>& A) {
        int n = A.size(), m = A[0].size();
        for (int i = 0; i < n; ++i) {
            if (A[i][0]) continue;
            for (int j = 0; j < m; ++j) {
                A[i][j] ^= 1;
            }
        }
        int res = (1<<(m-1)) * n;
        for (int j = 1; j < m; ++j) {
            int cnt = 0;
            for (int i = 0; i < n; ++i) {
                cnt += A[i][j];
            }
            cnt = max(cnt, n-cnt);
            res += (1<<(m-1-j)) * cnt;
        }
        return res;
    }
};
```