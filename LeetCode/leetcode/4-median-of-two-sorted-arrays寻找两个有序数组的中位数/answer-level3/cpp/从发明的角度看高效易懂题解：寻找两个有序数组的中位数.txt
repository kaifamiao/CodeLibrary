# 这个问题到底需要我们求什么？
这道题其实思路想通了很简单。什么是两个数组的中位数？就是两个按有序合并后排在中间的那个数。这样**这个问题就可以转化为求第k小的那个数（如果合并后数组长度是奇数的话，偶数那就是求第k小和第k+1小那两个数）**。
举个例子：
{1,2}与{0}的中位数就是合并后{0,1,2}中的中间那个数即中位数是“1”，它可以转化为求第2小的数。
{1,2}与{0,5}的中位数就是合并后{0,1,2,5}中的中间那两个数求平均(1+2)/2.0 = 1.5，它可以转化为求第2小和第3小的平均。
现在问题来了：如何求两个有序数组有序合并后第k小的数？

# 如何求两个有序数组有序合并后的第k小的数？
很自然可以想到用两个双指针从两个数组头遍历模拟合并找到第k小数。这个很容易也很简单。但是它复杂度是O(m+n)，不符合题目中的O(log(m+n))的需求。

那么我们可不可以改进它呢？因为它是有序数组所以我们可以利用**“有序”**这个特性可以不逐步逐步的从头遍历，而是最好每次可以跳开一大段这样就能节省很多时间。
比如：我想找arr1 = {1,2}和arr2 = {0,5}合并后第k小的数。这意味着我只需要从两个数组找k个超级小的数就达到目的了。
**规律1**：并且这k个数一定要么是从arr1中的头几个取，要么是从arr2中头几个取。因为越到后面数字越大。不存在说某个数组头几个数不是前k小中的但是后几个数是属于前k小的。
**规律2**；合并后数组中的前k小的数要么是从arr1中至少取前k/2个数，要么是从arr2中取前k/2个数。
上面这两个规律有什么意义呢？
我们可以先暂时做出2个猜测。
**猜测1**：最终合并后的数组中前k小的数是包含arr1中所取前k/2个数
**猜测2**：最终合并后的数组中前k小的数是包含arr2中取k/2个数
利用规律1和规律2我们可以知道`猜测1`和`猜测2`中有一个一定是成立的。这样子我们就一下子知道了合并后数组中前k/2个数是哪些数了，而我们是想求前k个数。所以一下子减少了一半的计算量时间复杂度是O(log(k))的。
**问题又来了，如何知道“猜测1”与“猜测2”哪个是对的**？
其实非常简单，**唯一的判断标准就是“较小的那段一定是属于合并后数组中前k小”**。
很自然的想到我们只需判断arr1中第k/2个数与arr2中第k/2个数的大小。较小的那段一定属于前k个数中的一部分。比如：{0,1...}与{2,3....}，我们通过比较两个数组中第2个数大小后可以100%确定{0,1}一定是属于前k小的。就这样不断重复，每次排除k/2个数，然后就可以找到合并后数组的前k小所有数。从而可以找到第k小数。

# 求两个数组合并后的第k小数的伪代码
伪代码：
```python
arr1 = {0,1,4,...}
arr2 = {1,2,3,...}
k = 2
begin1 = 0
begin2 = 0 
while(k>1)
{
    half_k_index = k/2 - 1
// {这里记得判断下是否数组越界}
    if (arr1[begin1 + half_k_index] < arr2[begin2 + half_k_index])
    // 合并后数组的前k小数中包含arr1中的那前k/2个数
    {
        begin1 = begin1 + half_k_index + 1
    }else{// 合并后数组的前k小数中包含arr2中的那前k/2个数
        begin2 = begin2 + half_k_index + 1
    }

    k = k - k/2 
    // 为何不是k = k/2，这是因为如果k=3, 
    // 此时k/2 == 1,所以剩下2个数而不是剩下1个数
}
```

# c++编程实践
```c++
/**
找第k大数
*/
int getTopK(vector<int>& nums1, vector<int>& nums2, int k) {
	int begin1 = -1, begin2 = -1; // 合并后数组前k个在两个数组所选择的数的最后一个元素的下标
	int end1 = nums1.size() - 1, end2 = nums2.size() - 1;

	// 处理两个数组有一个是空数组的情况
	if (end1 < 0)
		return nums2[k - 1];
	if (end2 < 0)
		return nums1[k - 1];

	while (k > 0)
	{

		// 处理数组越界的情况
		if (begin1 + (k + 1) / 2 > end1)
		{
			begin2 += k - (end1 - begin1);
			k = (end1 - begin1);
			continue;
		}
		if (begin2 + (k + 1) / 2> end2)
		{
			begin1 += k - (end2 - begin2);
			k = (end2 - begin2);
			continue;
		}


		// 更小的那段一定是属于合并后那前k个数
		if (nums1[begin1 + (k + 1) / 2] < nums2[begin2 + (k + 1) / 2])
			begin1 += (k + 1) / 2;
		else
			begin2 += (k + 1) / 2;

		k = k - (k + 1) / 2;

	}


	// 处理某个数组一个都不取的情况
	if (begin1 < 0)
		return nums2[begin2];
	if (begin2 < 0)
		return nums1[begin1];

	return max(nums1[begin1], nums2[begin2]);
	// begin1与begin2是各自的最后一个元素但是最终合并后数组中最大元素是两者更大的那个
}

double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
	int k = (nums1.size() + nums2.size() + 1) / 2;
	double median = (double)getTopK(nums1, nums2, k);
	if ((nums1.size() + nums2.size()) % 2 == 0)
	{
		median = (median + getTopK(nums1, nums2, k + 1)) / 2.0;
	}
	return median;
}
```
