答案参考高亮回答：
[https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/)

接下来说一下自己的理解

**中位数：将一个集合划分为两个长度相等的子集，其中一个子集中的元素总是大于另一个子集中的元素。**

中位数又分为左中位数和右中位数，假定左侧开始下标为left,右侧结束下标为right,(left<=right),则有：

左中位数 int midLeft = left + (right - left)/2 = (left + right) >> 1;
右中位数 int midRight = left + (right - left + 1)/2 = (left + right + 1)>>1;

由于题目设定为有序数组，接下来只讨论有序数组的情况，根据中位数的定义，我们可以知道

对于奇数数组{1,2,3}     左子集{1,2}，右子集{2,3},中位数 = (2 + 2)/2 = (左子集最大值 + 右子集最小值)/2
对于偶数数组{1,2,3,4}   左子集{1,2}，右子集{3,4},中位数 = (2 + 3)/2 = (左子集最大值 + 右子集最小值)/2

**基于上述定义，定义几个变量：**
N:长度
L:左子集元素个数
LM:左子集最大值 = NUM[L]
RM:右子集最小值 = NUM[R]

对于奇数数组{1,2,...,N} 有 L = N/2 + 1;	LM = NUM[L-1];RM = NUM[L];
对于偶数数组{1,2,...,N} 有 L = N/2;		LM = NUM[L-1];RM = NUM[L];

验证：
{1,2,3}         N = 3;L = 3/2 + 1 = 2; 正确
{1,2,3,4,5}     N = 5;L = 5/2 + 1 = 3; 正确

{1,2,3,4}       N = 4,L = 4/2 = 2; 正确
{1,2,3,4,5,6}   N = 6,L = 6/2 = 3; 正确

**由于奇数个数的数组存在共用的情况，对奇数数组进行扩充，至2*N，然后按照偶数数组的求法求取L（最终结果/2得到正确的下标）**
{1,#,2,#,3,#}           2N = 6, L =  6/2 = 3; LM = NUM[(3-1)/2] = 2;RM = NUM[3/2] = 2; 正确
{1,#,2,#,3,#,4,#,5,#}   2N = 10,L = 10/2 = 5; LM = NUM[(5-1)/2] = 3;RM = NUM[5/2] = 3; 正确

{1,#,2,#}           	2N = 4, L =  4/2 = 2; LM = NUM[(2-1)/2] = 1;RM = NUM[2/2] = 2; 正确
{1,#,2,#,3,#,4,#}   	2N = 8,	L =  8/2 = 4; LM = NUM[(4-1)/2] = 2;RM = NUM[4/2] = 3; 正确

结论:
**对于长度为N的数组NUM,如果求取中位数可以使用以下公式：**
L = 2N/2;
LM = NUM[(L-1)/2];
RM = NUM[L/2];

**对于长度为N的数组NUM,如果取左侧L个元素作为左子集(L<=N)),则左值LM,右值RM存在以下关系：**
LM = NUM[L-1];
RM = NUM[L];

回归题目，我们如果不对数组长度进行扩充，假定num1取C1个元素,num2取C2个元素，那么理论上C1+C2=(M+N)/2，举例验证一下：
{1,3} 	{2,4,6} C1+C2=(3+2)/2=2个 个数不符合(应该为3)
{1,2,3} {4,5,6} C1+C2=(3+3)/2=3个 个数符合
会发现只有当m+n和为偶数的时候才会得出正确的结果

我们对数组进行扩充，假定num1取C1个元素,num2取C2个元素，那么理论上C1+C2=M+N，举例验证一下：
{1,#,3,#} 	  {2,#,4,#,6,#} C1+C2=5
C1=1;C2=4;	  左侧子集{1} 		{2,#,4,#} 	个数符合(应该为3)
C1=2;C2=3;	  左侧子集{1,#} 	{2,#,4} 	个数符合(应该为3)
C1=3;C2=2;	  左侧子集{1,#,3} 	{2,#} 		个数符合(应该为3)
C1=4;C2=1;	  左侧子集{1,#,3,#} {2} 		个数符合(应该为3)

{1,#,2,#,3,#} {4,#,5,#,6,#} C1+C2=12
C1=1;C2=4;	  左侧子集{1} 		{2,#,4,#} 	个数符合(应该为3)
C1=2;C2=3;	  左侧子集{1,#} 	{2,#,4} 	个数符合(应该为3)
C1=3;C2=2;	  左侧子集{1,#,3} 	{2,#} 		个数符合(应该为3)
C1=4;C2=1;	  左侧子集{1,#,3,#} {2} 		个数符合(应该为3)

**所以，我们需要对两个数组长度进行扩充，num1 扩充至 2n，num2 扩充至 2m，对于扩充后的数组，假定取num1左侧C1个元素，取num2左侧C2个元素，则有：**
LM1 = num1[(C1-1)/2];
RM1 = num1[C1/2];
C1+C2=M+N;
LM2 = num2[(C2-1)/2];
RM2 = num2[C2/2];

最终结果符合：
LM1<=RM1;
LM2<=RM2;
MAX(LM1,LM2)<=MIN(RM1,RM2);

注意：对数组扩充后开有一个明显的好处，极值判断，如{}{1}这种情况的处理等。

对数组num1进行二分查找确定最终的C1，从0-2N;

**着重解释一下：C1 C2 为个数，而非下标，通过个数取下标，同样B1和E1也代表个数，因此可以取0-2N**

代码如下：
```
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2)
{
	int N = nums1.size();
	int M = nums2.size();

	if (N>M)
	{
		return findMedianSortedArrays1(nums2, nums1);
	}

	int LM1 = 0, RM1 = 0, C1 = 0;
	int LM2 = 0, RM2 = 0, C2 = 0;

	int B1 = 0, E1 = 2 * N;

	while (B1<=E1)
	{
		C1 = (E1 + B1) / 2;
		C2 = M + N - C1;

		LM1 = (C1 == 0)?INT_MIN:nums1[(C1 - 1) / 2];
		RM1 = (C1 ==2*N)?INT_MAX:nums1[C1 / 2];

		LM2 = (C2 == 0) ? INT_MIN : nums2[(C2 - 1) / 2];
		RM2 = (C2 == 2 * M) ? INT_MAX : nums2[C2 / 2];

		if (LM1 > RM2)
		{
			E1 = C1 - 1;
		}
		else if (RM1 < LM2)
		{
			B1 = C1 + 1;
		}
		else
		{
			break;
		}
	}
	return (max(LM1, LM2) + min(RM1, RM2)) / 2.0;
}
```
