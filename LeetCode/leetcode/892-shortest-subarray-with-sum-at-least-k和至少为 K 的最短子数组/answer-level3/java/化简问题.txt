如果题目没有负权的话，这就纯粹是一个时间复杂度为N的题目。从左右一端出发，累加(反正是递增数列)，如果找到满足的数列后，成为一个滚动数组，不同的从右侧向左侧挪动，  while (sum - A[begin] >= K || A[begin] <= 0)  sum -= A[begin++];
但是题目中存在负权，如果要解决负权问题，就需要确定入口点从右侧或者从左侧作为入口将负权消灭掉。
比如 6 -1 -1 -1 -1 可以看作 2 0 0 0 0这是从左侧当作输入口，之后转化为第一类问题。