# 解题思路

在N>=2时，除数字5以外的9个数字都是可到达的。

每跳一步，数字的变化如图所示：
![QQ截图20200226000022.png](https://pic.leetcode-cn.com/7eaa506cae552733d5dc771c92d943a122e30eeef648460d6e3ec81fccfe76d8-QQ%E6%88%AA%E5%9B%BE20200226000022.png)

图片表示，当骑士处于“1”处时，下一跳将在“6”或“8”；骑士处于“4”处时，下一跳将在“3”或“0”或"9";骑士处于“0”处时，下一跳将在“4”或“6”…………

我们可以发现，1、3、7、9处于对称位置；2，8处于对称位置;4，6处于对称位置。因此，我们可以将数字分为4个状态，命名为A、B、C、D。其中A:{1,3,7,9},B:{2,8},C:{4,6},D:{0}。

我们用f(X,n)表示：在状态X下，跳跃n步能够得到不同数字的个数。则状态转移方程为：
```
f(A,n)=f(B,n-1)+f(C,n-1)
f(B,n)=2*f(A,n-1)
f(C,n)=2*f(A,n-1)+f(D,n-1)
f(D,n)=2*f(C,n-1)
```
解释为：
处于状态A中的数字(1,3,7,9)通过一次跳跃要么变成状态B(2,8)，要么变成状态C(4,6)
处于状态B中的数字(2,8)通过一次跳跃有两种方式变成状态A(1,3,7,9)
处于状态C中的数字(4,6)通过一次跳跃有两种方式变成状态A(1,3,7,9)，还有一种方式变成状态D(0)
处于状态D中的数字(0)通过一次跳跃有两种方式变成状态C(4,6)

通过迭代，我们即可求解。

**代码**
```Python []
class Solution:
    def knightDialer(self, N: int) -> int:
        if N==1: return 10
        #分别为状态A,B,C,D
        nums=[1,1,1,1]
        for _ in range(N-1):
            nums=[nums[1]+nums[2], 2*nums[0], 2*nums[0]+nums[3], 2*nums[2]]
        #状态A有4个数字，B有2个数字，C有2个数字，D有1个数字
        return (4*nums[0]+2*nums[1]+2*nums[2]+nums[3])%1000000007
```
**复杂度分析**
- 时间复杂度：O(n)
- 空间复杂度：O(1)

