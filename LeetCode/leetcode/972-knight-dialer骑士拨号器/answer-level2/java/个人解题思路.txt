这个我的想法（仅参考）
首先将0-9的数字分组，可以看到{1,3,7,9}为一组，{2,8}为一组，{4,6}为一组，{0}为一组
先建立一个size=4数组nums
0表示0, 1表示1, 2表示2, 3表示4
不难看出最后的结果为:nums[0] + nums[1]\*4 + nums[2]\*2 + nums[3]\*2
----开始跳棋
然后每次跳都可以看做一棵数的深度+1

    while(深度+1){
        //当前深度为0
        0：的深度(n)等于 4的深度(n+1)+6的深度(n+1)，
        1：的深度(n)等于 8的深度(n+1)+6的深度(n+1)，
        2：的深度(n)等于 7的深度(n+1)+9的深度(n+1),
        4：的深度(n)等于 0的深度(n+1)+3的深度(n+1)+7的深度(n+1)
    }
对于这一道题的想法，我是从叶子节点开始往根节点推。
代码写的有点乱

    class Solution {
    public int knightDialer(int N) {
        if(N == 1)
            return 10;
        int[] nums = new int[4];
        int[] nums2 = new int[4];
        for (int i = 0; i < 4; i++) {
            nums2[i] = 1;
        }
        
        while (N > 0) {
            N--;
            count(nums, nums2);
            int[] temp = nums;
            nums = nums2;
            nums2 = temp;
        }
        int num = nums[0];
        //直接乘4会超界
        num += (nums[1] * 2) % 1000000007;
        num %= 1000000007;
        num += (nums[1] * 2) % 1000000007;
        num %= 1000000007;
        num += (nums[2] * 2) % 1000000007;
        num %= 1000000007;
        num += (nums[3] * 2) % 1000000007;
        num %= 1000000007;
        return num;
        
    }
        public void count(int[] n1, int[] n2) {
            n1[0] = (n2[3] * 2) % 1000000007;
            n1[1] = (n2[2] + n2[3]) % 1000000007;
            n1[2] = (n2[1] * 2) % 1000000007;
            n1[3] = (n2[0] + (2 * n2[1]) % 1000000007) % 1000000007;
        }
    }