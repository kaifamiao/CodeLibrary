每次提交完答案，为了学习如何写出更为高效的代码，我都习惯看一眼 0ms 的提交。这道题 0ms 提交的代码第一眼真的吓了一跳。
```
class Solution {
public:
    int countPrimeSetBits(int L, int R) {
        int res=0;
        for(int i=L;i<=R;i++)
        res+=(665772>>__builtin_popcount(i))&1 ;
        return res;
    }
};
```
看到魔数 `665772` 的时候，我第一反应是：这难道是一个前所未闻的非常牛的求质数的算法？
但是仔细想来又觉的不太可能，于是查询了一下 `__builtin_popcount(i)` 函数的功能，是求一个无符号数的二进制表示中 `1` 的个数。
再来看看魔数 `665772` 的二进制表示：
```
           19  18  17  16  15  14  13  12  11  10  9  8  7  6  5  4  3  2  1  0
665772 = ( 1   0   1   0   0   0   1   0   1   0   0  0  1  0  1  0  1  1  0  0 )
```
原来他只是将 `1 ~ 19` 中的是否为质数的关系编码到二进制中。




