评论区看到的好方法。
解法也很简单，就是先搞个1位2进制数1，这个二进制数小于等于N的时候，将1左移1位，循环到他大于N，这时候再将这个数-1，就得到了与N二进制位数相同的很多1的二进制数，然后相减即可。
问题是如果N的二进制位最高位的1已经在int的极限的时候（不包括标志位），然后再移动这个数的那个1就会移到标志位去了。。然后就会出现一些问题，可以设置为long long解决吧，但是测试用例没有这样的例子，所以这样就非常完美。

```
class Solution {
public:
    int bitwiseComplement(int N) {
        if (!N) return 1;
        int num = 1;
        while (num <= N) num <<= 1;
        return num - 1 - N;
    }
};
```