这个题可以用约瑟夫环解决。你如果是第一次做这个题肯定不知道，方法就是总结出来的嘛，见多了就知道了。

理解约瑟夫环，我们采用倒推，我们倒推出：最后剩下的这个人，在最开始的数组中的位置。

1. 剩下最后一个人（简称“他”）的时候，人数为1，他的位置`pos = 0`。
2. 那么他在上一轮也是安全的，人数为2，他的位置`pos = (0 + m) % 2`；
3. 那么他在上上轮也是安全的，人数为3，他的位置`pos = ((0 + m) % 2 + m) % 3`；
4. 那么他在上上上轮也是安全的，人数为4，他的位置`pos = (((0 + m) % 2 + m) % 3) % 4`；
5. ...
6. 那么他在游戏开始的第一轮也是安全的，人数为n，他的位置`pos`就是最后的结果。

即如果从下向上反推的时候：那么假如他**前一轮**的索引为pos，那么**当前轮次**的位置就是 `(pos + m) % 当前轮次的人数`。

最后，由于给出的数字是`nums = 0,1,2..,n-1`，即`nums[i] = i`，因此找出`pos`就相当于找到这个数字。

所以pos = 0开始，代表了最后结果只剩下了1个人，这个人处于第0个位置。

循环从数组长度有2个开始，即上一轮剩下了两个人。

循环到数组中剩下n个人结束，即到达了题目要求的那么多人，此时的pos就是最后剩下的那个人的在n个数字中位置。

Python代码如下：

```python
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        pos = 0
        for i in range(2, n + 1):
            pos = (pos + m) % i
        return pos
```

欢迎关注[负雪明烛的刷题博客](https://blog.csdn.net/fuxuemingzhu)，刷题800多，每道都记录了写法！

力扣每日一题活动建群啦，一起监督和讨论，我自建监督网址：[http://group.ojeveryday.com/#/check](http://group.ojeveryday.com/#/check)，加入方式可以在监督网址中看到。

![image.png](https://pic.leetcode-cn.com/cddebf5d29d0715c42576d230c0867cecfc8cd672f1e22cf6bb77061dcfe1a88-image.png)
