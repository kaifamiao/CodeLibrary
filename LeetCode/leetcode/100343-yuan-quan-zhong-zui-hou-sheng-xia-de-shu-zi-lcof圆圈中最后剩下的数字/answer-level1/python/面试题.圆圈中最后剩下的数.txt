### 解题思路
- 一开始用队列，出队m-1个，全都入队；然后出队1个，不入队；超时！
- 直接计算该出队的index就好了
- 数m个人，假设第一个人的编号为i,则第m个人的编号为（i+m-1），注意溢出处理为（i+m-1）%len(deque)
- pop(i)杀掉i,从它的下一个开始继续数m个；下一个的编号并不是i+1,在i弹出的瞬间，队列向前递补，i的下一个(i+1)获得新的编号i,所以不需要将i进行加1操作，就可以开始新的计数。
- 
- 关于溢出：假设队列长为10，数的第m个人是队列的第13人（不存在），溢出的三人应该从头数，也就是第3个（13%10=3）；换成编号也一样，队列编号为0-9，第m个人编号为12，溢出，合理编号为12%10=2（就是第三个嘛）


### 代码

```python3
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        i,a = 0,list(range(n))
        while len(a)>1:
            i = (i + m -1)%len(a)
            a.pop(i)
        return a.pop()
```