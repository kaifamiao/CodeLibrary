我们用 `f(n, m)` 表示从 n 个数中每次删除第 m 个数（共删除了 n - 1 次），最后留下的那个数的**序号**。

我们从 `f(n, m)` 场景下删除的第 1 个数是从序号 0 开始，向后数 m 个数得到的。删除第一个数后，将剩下 n - 1 个数，此时场景变为 `f(n - 1, m)`，用于表示从 n - 1 个数中每次删除第 m 个数最后留下的数的**序号**。

在往下看之前，我们先达成一个共识：**`f(n, m)` 与 `f(n - 1, m)` 得到的数是同一个数（最后剩下的数在每一轮中都不可能被删除），只是在它们所在的场景下，这个数字的序号不同罢了。**

那么，何谓「所在场景，序号不同」？

这里所说的「序号」与**所在场景下首次选取删除数字的出发点有关**，我们直接看下题目给出的 `n = 5, m = 3` 这个例子，已知答案为 3。

### 不同场景下的不同序号

#### f(n, m) 场景

此时 `n = 5`，由于我们从第 1 个数字出发，所以从第 1 个数字开始编号：

```
数字：
0 1 2 3 4
序号：
0 1 2 3 4
```

可以看到答案 3 在该场景下的序号为 3。

#### f(n - 1, m) 场景

此时，我们已经在 `f(n, m)` 场景下删除一个数了，这个数是 2，因此我们要从 3 开始重新编号：

```
数字：
0 1 3 4
序号：
2 3 0 1
```

答案 3 在该场景下的序号为 0。

### 两者序号的关系

我们知道，从 `f(n - m)` 场景下删除的第一个数的**序号**是 `(m - 1) % n`，那么 `f(n - 1, m)` 场景将使用被删除数字的下一个数，即序号 `m % n` 作为它的 0 序号。

设 `f(n - 1, m)` 的结果为 `x`，`x` 是从 `f(n, m)` 场景下序号为 `m % n` 的数字出发所获得的结果，因此，我们可以得出：`m % n + x` 是该数字在 `f (n, m)` 场景下的结果序号。即：

```
f(n, m) = m % n + x
```
但由于 `m % n + x` 可能会超过 n 的范围，所以我们再取一次模：

```
f(n , m) = (m % n + x) % n = (m + x) % n
```

将 `f(n - 1, m)` 代回，得到递推公式：

```
f(n, m) = (m + f(n - 1, m)) % n
```

有了递推公式后，想递归就递归，想迭代就迭代咯~

### 具体实现

```python
sys.setrecursionlimit(100000)

class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        return self.f(n, m)

    def f(self, n, m):
        if n == 0:
            return 0
        x = self.f(n - 1, m)
        return (m + x) % n
```

各位大佬的图实在画得太好了，我就不献丑了（逃

----

## 🐱

- 我的题解项目：[点击前往](https://github.com/JalanJiang/leetcode-notebook)
- 如果你对做题和分享题解感兴趣，欢迎加入 [LeetCode 刷题小分队](https://github.com/leetcode-notebook/leetcode-notebook.github.io/blob/master/README.md)
- 如果你觉得文章写得不错，欢迎关注公众号「编程拯救世界」，公众号专注于编程基础与服务端研发，定期分享算法与数据结构干货~

![](https://pic.leetcode-cn.com/ae3bd6547d0aa946436706f70167767b1cdee1429535ad0d6535d46c684365ae-file_1576126672599)