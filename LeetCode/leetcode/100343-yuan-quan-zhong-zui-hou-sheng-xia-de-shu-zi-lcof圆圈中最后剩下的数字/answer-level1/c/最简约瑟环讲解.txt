### 解题思路
此处撰写解题思路
方法一：递归法：
   我们假设f(n,m)最后一个安全的index为y,即f(n,m)=y,但是对y的印象大家不要约束在[0,n]之间，它可以大于m,比如在{0,1,2,3}，其中n=4,设m=2,则此时的y为6，也就是相当于{0,1,2,3,0,2,0}这样的顺序，还看不明白？刚开始是{0,1,2,3},在第一轮中1,3被删除,后续加上未被删的元素等。。。。所以，y是可以大于m的，此时f(n,m)删除第一个元素后就还剩n-1个元素，强调它是由f(n,m)删除一个元素后的结果，不是完整的有[0,n-2],f(n,m)删除的第一个元素index为n%m-1,假设以这个点为0，则安全索引的index设置为x,即为f(n-1,m)=x;下面开始：
   f(n,m)%n=(m%n-1+x+1)%n; 
   解释：（m%n）-1为第一步删除元素的index,x+1为从0移到x需要x+1步，此时我们令y=y%n,将index换到[0,n]中,让曾经的y成为一个中介，现在依然有f(n,m)=(m%n-1+x+1)%n;这个化简为f(n,m)=(m+x)%n;即为：
f(n,m)=(m+f(n-1,m))%n;这个时候我们就可以用迭代法开始迭代了，由于是从大——>小，所以在空间上的复杂度为n,下面为了简化到1，即从小推到大；

方法二：迭代法：
    前面推导的式子为：
    f(n,m)=(m+f(n-1,m))%n;
    f((n-1),m)=(m+f(n-2,m))%(n-1)
    ....
    n=i时，f(i,m)=(m+f(i-1,m))%i
    ...
    f(2,m)=(m+f(1,m))%2
    而且f(1,m)=0，代码中f就是不断更新的f(i,m);
### 代码

```c
int lastRemaining(int n, int m){
    if(n<=0||m<0)  return 0;
    int f = 0;
        for (int i = 2; i != n + 1; ++i)
            f = (m + f) % i;
        return f;  
}
```