总体思路：在循环中不断删除元素，列表不断变小，直到长度变成1，则结束循环。

### 算法描述：

1.初始“起点坐标” = 0

2.通过 【（起点坐标 + 步幅m  - 1） % 当前列表长度】这个公式，计算要删除元素的下标del_index，然后删除该元素, 删除元素后形成了新列表。

3.在新列表中，设置新列表中的“起点坐标” 为del_index

说明：为了在新列表中使用【（起点坐标 + 步幅m  - 1） % 当前列表长度】计算要删除元素的下标，需要计算新列表中的“起点坐标”是多少？ 其实就是在旧列表中被删除元素的下标del_index。

4.如果当前列表长度不是1，回到步骤2.

### 代码实现：

```
class Solution:
    def lastRemaining(self, n: int, m: int) -> int:
        num_list = []
        for num in range(n):
            num_list.append(num)
        start = 0
        # 在循环中不断删除num_list中的元素，直到剩下最后一个元素为止
        while len(num_list) != 1:
            cur_len = len(num_list)
            start = start % cur_len
            # 计算当前列表中，要删除的元素的下标
            del_index = (start + m  -1) % cur_len
            # 删除当前列表中的该元素
            del num_list[del_index]
            # 删除一个元素后，列表变成了新列表，要计算新列表中要删除的元素，计算起点就是刚刚删除元素的下一个位置P
            # 位置P在新列表中的下标，就是刚刚删除元素在上一个列表中的下标，举例解释如下：
            # 比如：列表[1,2,3,4]经过计算，需要删除下标为2的数字3，删除后新列表为[1,2,4]
            # 那么这时新列表的计算起点是数字4，数字4的在新列表中的下标，就是刚刚删除的数字3在上一个列表中的下标2.
            # 所以这里要设置新列表的计算起点start为上一个列表中已删除元素的下标
            start = del_index
        return num_list[0]
```
