**递推思路：** 设`f(n,m)`为`n`个数字时，每次删除第`m`个最后会剩下的那个数的序号，则`f(n-1,m)`为`n-1`个数字时，每次删除第`m`个最后剩下的那个数的序号,这里的需要理解`f(n-1,m)`的序号跟`f(n,m)`序号值是不同的，但是它们代表了一个环中相同的位置，因为序号开始的位置随着`n`的变化而变化，一开始序号从第一个位置开始编号，到删除了第一个数变为只有`n-1`个数之后，序号变为从被删除位置的下一个数开始编号，所以我们可以通过`n-1`的序号值知道它在`n`时的序号值为：`f(n,m) = f(n-1,m) + m` ,这里可能有点难以理解：因为从`n`个数删除一个到`n-1`个数，然后从被删除位置的下一个重新开始编号，所以需要 `+m` 得到它 `n` 个数时的序号，最后，由于 `f(n-1,m) + m` 可能大于 `n` ，我们需要取余，所以最终得到：`f(n,m) = (f(n-1,m) + m) % n`

当只有一个数时`n=1`，`f(1,m) = 0`（代表剩下数的序号在`n=1`时是 0），可以从 `f(1,m)` 递推到 `f(n,m)`

```go
func lastRemaining(n int, m int) int {
    var f int 
    for i := 2; i <= n; i++ {
        f = (f + m) % i;
    } 
    return f;
}
```