### 解题思路
第一次做也是一脸懵逼，看约瑟夫环的讲解也是一脸懵逼，过了许久终于开了窍。

约瑟夫问题是个著名的问题：N个人围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。

基本思想就是递归。
n个人接力报m，从第一轮开始那个能活下来的天选之子就出现了。我们这里把他在n个人中的下标（索引）记为f(n,m)，第二轮这个人还是平安无事，
我们把他在n-1个人中的下标（索引）记为f(n-1,m)，那么最后一轮的时候，这个人的位置明显就是f(1,m)=0。
能递归的重要条件就是在最简单的情况下我们知道答案。

接下来就是寻找f(n,m)与f(n-1,m)之间的关系。

第一轮报数，是第m个人被杀，我们把他向前移动m个，这样他就被移动到了n个人的最后一个。相当于所有人的小标前移m，在新的顺序下杀掉最后一个人。
剩下的人的下标就是n-1人情况时的下标值。
我们之所以要将新一轮开始报数的人下标设为0，是因为1个人时，我们的f(1,m)=0,这是在一人情况下他的下标。
同样对于那个天选之子，(f(n,m)-m)%m=f(n-1,m),也就是f(n,m)=(f(n-1,m)+m)%m.


### 代码

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int res=0;
        for(int i=2; i<=n; i++){
            res = (res + m)%i;
        }
        return res;
    }
};
```