__注：本人是在看了大量题解后自我总结，从其他角度考虑得到此题解，建议先看其他题解__
### 解题思路
我采取倒退的思想。
最后一次，也就是结束时，结果编号一定是0；
使用re变量，初始化为0；
第一次倒退后，数列长度变为2，re编号应变为0+m%2;
第二次倒退后，数列长度变为3，这次恢复的数字在长度为3的数列中序号为m%3，re编号在其后re处(此处的re为上一个re的代数值)；
…………
第n次倒退后，数列长度变为n+1，这次恢复的数字在长度为n的数列中序号为m%n，re编号在其后re处(此处的re为上一个re的代数值)
如此就可以进行迭代，代码如下：

### 代码

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int re=0;
        for(int i=2;i<n+1;i++){
            re=(m%i+re)%i;
        }
        return re;
    }
};
```
