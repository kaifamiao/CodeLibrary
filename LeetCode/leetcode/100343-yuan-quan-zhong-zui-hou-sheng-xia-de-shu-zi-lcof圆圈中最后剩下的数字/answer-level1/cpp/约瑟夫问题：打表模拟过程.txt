# 约瑟夫环

约瑟夫问题：N个人(编号0，1，2，3，4，...，N-1)围成一圈，第一个人从1开始报数，报M的将被杀掉，下一个人接着从1开始报。如此反复，最后剩下一个，求最后的胜利者。

约瑟夫问题，也叫枪毙问题

## 普通解法

链表或数组模拟整个游戏过程

时间复杂度高达O(nm)，当n，m非常大(例如上百万，上千万)的时候，几乎是没有办法在短时间内出结果

## 公式法

递推公式：`f[N][M] = (f[N-1][M] + M) % N`

当N=10，M=3时，打表模拟约瑟夫环游戏过程(黄色表示每一轮枪毙掉的位置，绿色表示幸存者在这一轮的位置):

![约瑟夫环游戏过程](https://pic.leetcode-cn.com/29f65c9dd7f2897a8894333105da51c6be94fd224856444ebb5e3d50002067bb.png)

f[N][M]表示 N个人报数，每报到M时杀掉那个人，最终胜利者的下标

```cpp
f(1,3): 只有1个人了，那个人就是胜利者，胜利者下标是0
f(2,3) =（f(1,3) + 3）%2 = 3%2 = 1, 剩2个人，胜利者下标是1
f(3,3) = (f(2,3) + 3))%3 = 3%3 = 1, 剩3个人，胜利者下标是1
f(4,3) = (f(3,3) + 3) % 4 = 0, 剩3个人，胜利者下标是0
...
f(10,3) = 3
```

以上就是约瑟夫环的逆推过程

## 代码实现

### 递归版本

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        if (n == 1) return 0;
        return (lastRemaining(n-1, m) + m) % n;
    }
};
```

### 递推版本

```cpp
class Solution {
public:
    int lastRemaining(int n, int m) {
        int live = 0; // 活下去的那个人的位置
        for (int k = 2; k <=n; k++){ // K 个人
            live = (live + m) % k; //约瑟夫环问题公式
        }
        return live;
    }
};
```

[从零开始学算法](https://muyids.github.io/simple-algorithm)





