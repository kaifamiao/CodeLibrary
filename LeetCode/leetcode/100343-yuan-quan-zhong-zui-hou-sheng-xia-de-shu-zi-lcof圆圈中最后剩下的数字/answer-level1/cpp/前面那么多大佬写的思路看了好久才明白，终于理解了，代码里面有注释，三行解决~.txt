```
int lastRemaining(int n, int m) {
        /* 
        * n=4, m=5,那么数字是0,1,2,3(编号为0,1,2,3)——注意区分编号与数据，每一轮都会重新编号
        * 第一轮(n=4)：0,1,2,3(编号为0,1,2,3)
        *         这一轮删除数据的编号为m%n-1=5%4-1=0, 这时第二轮数据变为1,2,3(删除0，重新编号：0,1,2)
        *         第二轮开始的数据为1，是第一轮编号为m%n=5%4的数据,即第一轮删除的数据(0)后面的第一个数据1
        * 第二轮(n=3)：1,2,3(重新编号为0,1,2)
        *         这一轮删除数据的编号为m%n-1=5%3-1=1,这时第三轮的数据变为3,1(删除2，重新编号：0,1)
        *         第三轮开始的数据为3，是第二轮编号为m%n=5%3的数据,即第二轮删除的数据(2)后面的第一个数据3
        * 第三轮(n=2)：3,1(重新编号：0,1)
        *         这一轮删除数据的编号为m%n-1=5%2-1=0,这时第四轮的数据变为1,(删除3，重新编号：0)
        * 第四轮(n=1)：1(重新编号为0)
        *         只有一个数据了，就是所求，即最后答案为1，但是它在第四轮中编号为0
        * note:当前轮编号为0的数据是上一轮删除的数据后面的第一个数据即m%n(每轮只删除一个数)
        *      故当前轮编号为i的数据在上一轮中编号为上一轮m%上一轮n+i
        *      且最后一轮中只有一个编号为0的数据
        * 
        * 根据第四轮的结果反推其在第三轮中的编号(第四轮编号为0的数据是第三轮编号为m%n=5%2的数据)：
        *         最后的结果1在第三轮中的编号=(第四轮编号为0的数据在第三轮中的编号+第四轮结果对应的编号)%n
        *                                  =(5%2+0)%2=1
        * 根据第三轮的结果反推其在第二轮中的编号
        *         最后的结果1在第二轮中的编号=(第三轮编号为0的数据在第二轮中的编号+第三轮结果对应的编号)%n
        *                                  =(5%3+1)%3=0      
        * 根据第二轮的结果反推其在第一轮中的编号
        *         最后的结果1在第一轮中的编号=(第二轮编号为0的数据在第一轮中的编号+第二轮结果对应的编号)%n
        *                                  =(5%4+0)%3=1
        * 第一轮中，数据与编号是对应的，所以结果在第一轮中对应的编号就是第一轮中对应的数据 
        * 递推公式：f(n)=(m%n+f(n-1))%n,若不溢出可以简化为(m+f(n-1))%n
        */
        if(n==1)
            return n-1;
        return (m+lastRemaining(n-1, m))%n;
    }
```
