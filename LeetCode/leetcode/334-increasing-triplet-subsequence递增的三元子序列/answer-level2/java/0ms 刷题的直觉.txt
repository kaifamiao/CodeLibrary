### 解题思路
最近几个星期刷了几十道题,刷顺手了感觉看到问题思考的方向和以前确实不一样了,看到题目也会有自己的抽象的理解,知道应该关注哪些东西了.比如说这题,给定一个为排序的数组,找出是否存在3元递增子序列.
首先,题目只要求返回true或者false,也就是说不一定要遍历数组中的所有的元素,如果我们从前往后遍历,只要找到了一个3元递增子序列就可以直接返回了.
对于数组中的每一个元素,返回true的情况当且仅当前面有个2元的递增子序列.如果我们保存前面所有的2元递增子序列树没有意义的.例如:8,9,5,6....这里又(8,9)(5,6)两个2元递增子序列,但如果后面的数能和(8,9)组成3元递增子序列,那肯定也能和(5,6)组成3元递增子序列,所以只需要记子序列中,最大值比较小的哪一个也行,并且(5,6)当中的5对后续也没有任何影响,后续的数也只需要和6比较就行了,所有,我们只用记一个2元递增子序列中,最大值较小的哪个值.
同理,2元递增子序列怎么来的呢?就是遍历到一个元素,发现他比前面某个元素大就可以了.这里,我们也不要用当前元素和前面每个元素对比,只需要记一些前面元素中的最小值就行了,只要比前面的最小值大,肯定能组成一个2元递增子序列.
因此,只需要用两个数来辅助,one表示前面元素的最小值,two表示前面所有2元递增子序列中最大值较小的那个较小值.之后遍历更新这两个值就行了,当一个元素比前面储存的2元递增子序列的最大值还要大时,就可以和他们组成3元递增子序列了

### 代码

```java
class Solution {
   public boolean increasingTriplet(int[] nums) {
        int one = Integer.MAX_VALUE;
        int two = Integer.MAX_VALUE;
        for (int num : nums) {
            if (num>two){
                return true;
            }else if (num>one){//这个数可以和one组成新的2元递增子序列了,更新2元递增子序列的最大值中的较小值
                two = num;
            }else {
                one=num;
            }
        }
        return false;
    }
}
```