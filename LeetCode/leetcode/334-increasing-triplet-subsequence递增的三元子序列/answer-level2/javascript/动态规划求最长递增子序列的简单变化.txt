可能是以前学过算法的原因，看完这道题之后脑子里首先想到的就是动态规划求最长递增子序列问题。该问题的具体解题思路我这里就不多写了，表达起来有点麻烦，这里我就以一个简单的例子来说明下思路：

假设有数组`nums = [10, 22, 9, 33, 21, 50, 41, 60]`，另外定义一个数组来保存当前位置的最长结果`longest = []`，模拟计算过程：

1、第一个数字`nums[0] = 10`，由于是第一个，默认为1，则`longest.push(1) => [1]`

2、第二个数字`nums[1] = 22`，遍历在它之前的值，发现`22 > 10`，则`longest.push(1 + 1) => [1, 2]`

3、`nums[2] = 9`，遍历发现10和22都比它大，则设为默认`longest.push(1) => [1, 2, 1]`

4、`nums[3] = 33`，它比10和22都大，而10对应的长度为1，22对应的长度为2，取大者，则`longest.push(2 + 1) => [1, 2, 1, 3]`

5、`nums[4] = 21`，它比10和9大，但比22和33小，而10和9对应的长度都为1，因此`longest.push(1 + 1) => [1, 2, 1, 3, 2]`

6、`nums[5] = 50`，它比前面所有的数字都大，其中它们对应的最大长度是33对应的3，因此`longest.push(3 + 1) => [1, 2, 1, 3, 2, 4]`

...

以此类推，最终得到`longest = [1, 2, 1, 3, 2, 4, 4, 5]`

到这里为止，我们可以得到的结果可以有：

1、该序列的最长递增子序列最多可以包含5个数字

2、该序列的最长递增子序列（含5个数字）的结果只有1个

回到本题，题目仅要求判断提供的数组中是否存在包含3个长度的序列即可，因此我们完全不必要得到最终的`longest`结果，只要得到的结果中出现了3即可。

本人的解题代码如下，时间复杂度是O(n*(n-1))：
```
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var increasingTriplet = function(nums) {
    let longest = [], count;
    for(let i = 0; i < nums.length; i++) {
        count = 1;
        for(let j = 0; j < longest.length; j++) {
            if(nums[i] > nums[j] && count <= longest[j]) {
                count = longest[j] + 1;
            }
        }
        longest.push(count);
        
        if(count >= 3) {
            return true;
        }
    }
    return false;
};
```

总结：使用动态规划解决该问题应该算不上满足题目的时间复杂度O(n)的要求，而且就提交结果看，我提交的代码耗时应该也算多的，看了下其他人的讨论和代码，发现就本题而言，暴力计算效率更高，但是就算法本身而言，还是值得学习的。
