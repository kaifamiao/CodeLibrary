# 前因
Here comes a very stupid C++ learner~
第一次写题解记录下自己的思考，颇有些紧张，有不妥之处望各位见谅~
评论区这道题目的解答都十分精彩，但小白我总觉得对我捉急的智商有些负担过大：于是花了些时间整理出更适合自己理解的方式。
如若叙述有误实属能力经验欠火候，望各位评论区大神多多斧正~

# 解题方法
这道题目的解法不必多说，小白我第一次见十分惊艳，以下摘抄一下C++代码：
(感谢评论区各位大神的思路，尤其感谢[@fxxuuu](/u/fxxuuu/)提供的充满启发性的评论[https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/c-xian-xing-shi-jian-fu-za-du-xiang-xi-jie-xi-da-b/](https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/c-xian-xing-shi-jian-fu-za-du-xiang-xi-jie-xi-da-b/))

```
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        const int numSize = nums.size();
        if (numSize < 3) return false; // 大小不足3肯定没有长度为3的递增序列
        
        int small = INT_MAX; 
        int mid = INT_MAX;  // 这里small和mid都初始化为超出范围的大数
        
        for(int i = 0; i < numSize; ++i) {
            if(nums[i] <= small) 
                small = nums[i]; // 如果出现比small更小的值则直接替代之
            else if(nums[i] <= mid) 
                mid = nums[i]; // 如果出现比small大但比mid小的值，则取代mid
            else
                return true; // 如果出现比mid大的值证明长度为3的递增序列存在
        }
        
        return false; // 都跑到这里了，那就是没有
    }
};
```

# 愚蠢分析
这个题目的理解或许会在用更小的值替代`small`处出现疑惑：为什么`small`被代替后不会影响整体的判断结果呢？
我们来看一组例子。这里定义一个数组，取名叫`A`好了：
```
A = [ 100, 10, 4, 5, 1, 2, 3 ]
```
我们通过把`small`和`mid`看作是状态量而非单纯的数字量来解答疑惑。

## 梦开始的地方
我们先来找里面的**长度为2的递增数组**。这个任务非常简单，说白了就是找找数组里面有没有比上一个数字大的数。
用本题的思路带入如下(就是个代码简化版)：
```
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        const int numSize = nums.size();
        if (numSize < 2) return false; // 大小不足3肯定没有长度为3的递增序列
        
        int small = INT_MAX; // 这里small初始化为超出范围的大数
        
        for(int i = 0; i < numSize; ++i) {
            if(nums[i] <= small) 
                small = nums[i]; // 如果出现比small更小的值则直接替代之
            else
                return true; // 如果出现比small大的值证明长度为2的递增序列存在
        }
        
        return false; // 都跑到这里了，那就是没有
    }
};
```

我们代入`A`，过程就变成了`small`从`100`一直变到`4`，然后因为接下来的数字`5`更大，所以跳出返回`true`。
为什么要一直用更小的数字覆写`small`呢？以上的例子给出了答案:

**只有让`small`尽可能变小，才可能正确找到递增关系。** `(1.1)`

So far我们还停留在**`small`代表一个数字的阶段**，下面是我从另一个角度理解的`small`的含义：

**`small`代表数组`A`中存在一个一个长度为`1`，且其中最大值(也就是最后一个值)为`small`的递增数列** `(1.2)`

这里把`small`从一个单纯的数字看作了一个**带数字的状态量**。听起来有点绕哦。搞个例子：
上面过程中的`small = 100`代表什么呢？代表`A`里面有一个长度`1`，并且结尾处的，也就是整个序列的最大值是`100`的递增序列:当然因为长度是`1`，所以看起来没啥实感。

那么`small`一定是整个数组里面的最小值吗？显然不，因为只要接下来的数字更大就好了。

如果`(1.1)`和`(1.2)`没有问题，那么我们就可以继续了:即使现在可能您还依旧一头雾水。

## 向上推演到长度3
现在拉回到这个题目，也就是用`small`和`mid`找到数组中**长度为3的递增序列**。我们依旧要和上面的数组`A`过不去，这里copy一遍：
```
A = [ 100, 10, 4, 5, 1, 2, 3 ]
```

解答也copy一遍：
```
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        const int numSize = nums.size();
        if (numSize < 3) return false; // 大小不足3肯定没有长度为3的递增序列
        
        int small = INT_MAX; 
        int mid = INT_MAX;  // 这里small和mid都初始化为超出范围的大数
        
        for(int i = 0; i < numSize; ++i) {
            if(nums[i] <= small) 
                small = nums[i]; // 如果出现比small更小的值则直接替代之
            else if(nums[i] <= mid) 
                mid = nums[i]; // 如果出现比small大但比mid小的值，则取代mid
            else
                return true; // 如果出现比mid大的值证明长度为3的递增序列存在
        }
        
        return false; // 都跑到这里了，那就是没有
    }
};
```
我们要找的是**长度为3的递增序列**，现在我们先倒推一下:我们怎么判断这个长度3的序列是递增的？

**第3个数比已经确定的长度为2的递增序列的最后一个数大** `(2.1)`

OK，根据`(1.1)`，我们要做的事情从**找长度为3的递增序列**，变成了**令长度为2的递增序列的最后一个数尽可能变小，并确定数组中是否存在元素比这一元素更大**，来观察是否有递增关系存在:这是我们判断的依据。

下面我们回到代码。我们从`mid`被赋值这一步讨论起：
1. 按照`(1.2)`的结论，`small`代表`A`里面有(存在)一个长度`1`，并且结尾处的，也就是序列最大值是`4`的递增序列。
2. 此时还在逛大街的`small`突然被震慑住了:来了个比我大的(不是开车)。于是`mid`代替`small`接管了这个值，因为根据`(1.1)`的结论`small`的特性是欺软怕硬，只会被更新为比当前自身值更小的值:这个特性在新的任务中被保留了(两份代码中`small`的行为相同)。
3. 接下来`small`又一次遇到了自己心爱的软柿子，也就是数字`1`，于是此时`small`成为了`1`，`mid`值依旧为`5`。

*砸瓦鲁多！*到这里的代码分析并不困难，值得注意的是**`mid`只有在遇到比`small`大的值才被更新**，这个特性使得我们可以仿照`(1.2)`给出`mid`表征的状态量:

**`mid`代表数组`A`中存在一个一个长度为`2`，且其中最大值(也就是最后一个值)为`mid`的递增数列** `(2.2)`

在这里可以具象化为`A`里面有一个长度`2`，并且结尾处的，也就是序列最大值是`5`的递增序列。并且也因为**`mid`在这过程中没有改变**，我们还可以得出下一个结论(有可能存在数学上的不严谨)：

**`small`接下来的取值并不影响`mid`所指示的递增序列的存在性** `(2.3)`

`mid`所指示的序列最大值是`5`的递增序列是一定会存在于数组`A`中的，这一点也很好理解哦。

**`mid`的更新指的是已找到的长度为2的递增序列的最大值的变小**，以期能**正确找到递增关系**(`1.1`)。所以如何让`mid`里面的值尽可能的小？答案很好猜:让`small`里面的值尽可能变小，那么比`small`大的`mid`就存在变得更小的可能性。

所以所以，回头看一下`(2.1)`，是不是合上了？`mid`里面的值就是`A`里面某一个**长度为2的递增序列的最后一个数**，下面的情况可以这样讨论:
1. 存在第3个数比`mid`里面的值大 -> 存在**长度为3的递增序列**
2. 循环未结束 && 不存在第3个数比`mid`里面的值大 -> `mid`会被尽可能向下更新(因为`small`在被一直向下更新)
3. 循环结束 && 不存在第3个数比`mid`里面的值大 -> 不存在**长度为3的递增序列**

同上一part，`mid`不一定是整个数组内的最小数字，只需要有一个数字比当前的`mid`更大就可以返回`true`。当然最惨的莫过于`mid`都找不到，`A`就是一个完完全全的非递增数组了。

这样我们就可以继续模拟这个过程啦:
- `small = 1`, `mid = 5` => 已找到的长度为2的递增序列中，最大值最小的是5
- `small = 1`, `mid = 2` => 已找到的长度为2的递增序列中，最大值最小的是2
- `small = 1`, `mid = 2` => `3 > 2`，返回`true`

## 向上推演到长度n
我们要找的是**长度为n的递增序列**，类似的道理，我们的标准是:

**第n个数比已经确定的长度为(n-1)的递增序列的最后一个数大** `(3.1)`

根据`(1.1)`，我们要做的事情从**找长度为n的递增序列**，变成了**令长度为(n-1)的递增序列的最后一个数尽可能变小，并确定数组中是否存在元素比这一元素更大**，来观察是否有递增关系存在。

**完 全 一 致。**

这里我们换用`Q(1)`, `Q(2)`, ..., `Q(n-1)`来表示:

**`Q(i)`代表数组`A`中存在一个一个长度为`i`，且其中最大值(也就是最后一个值)为`Qi`的递增数列** `(3.2)`

同样的有:

**`Q(1)`, ..., `Q(i - 1)`接下来的取值并不影响`Q(i)`所指示的递增序列的存在性** `(3.3)`

上述的`i`是小于`n`的正整数取值。接下来的过程和上面的分析方法相同。

这就是[@user5707F](/u/user5707f/)在题解[https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/di-zeng-de-xyuan-zi-xu-lie-tong-yong-jie-fa-wei-hu/](https://leetcode-cn.com/problems/increasing-triplet-subsequence/solution/di-zeng-de-xyuan-zi-xu-lie-tong-yong-jie-fa-wei-hu/)当中提到的通用解法。

# 写在最后
第一次写题解不太熟练(哈哈哈哈哈哈哈哈哈哈写了好久)，里面很多措辞也并不完全准确(嘻嘻我错了)，希望能开个好头，以后做点高质量内容~
谢谢各位看官的耐心，为了offer加油鸭！