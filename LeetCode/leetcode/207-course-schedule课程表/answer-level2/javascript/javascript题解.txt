[207.课程表](https://leetcode-cn.com/problems/course-schedule/submissions/)   

[力扣 JS 题解。](https://github.com/GuYueJiaJie/blog/blob/master/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/README.md)   

题解参考[大神解答](https://leetcode-cn.com/problems/course-schedule/solution/tuo-bu-pai-xu-by-liweiwei1419/)


## 拓扑排序

```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
    if (numCourses < 0) return false;
    
    if (prerequisites.length === 0) {
        return true;
    }
    
    let res = []; // 保存拓扑排序的结果
    let queue = []; // 存储入度为0的节点
    let degreeArr = new Array(numCourses).fill(0); //存储各个节点的入度
    for (let item of prerequisites) {
        degreeArr[item[0]]++
    }
    for (let i = 0; i < numCourses; i++) {
        if (degreeArr[i] === 0) {
            queue.push(i);
        }
    }
    
    while (queue.length > 0) {
        let num = queue.shift();
        res.push(num); // 把入度为0的点存进结果数组res
        for (let item of prerequisites) {
            if (item[1] === num) {
                // 删除前面入度为0的点
                // 则后面的点入度减1
                degreeArr[item[0]]--;
                if (degreeArr[item[0]] === 0) {
                    // 如果入度减一后入度为0，则存进队列
                    queue.push(item[0])
                }
            }
        }
    }
    return res.length === numCourses; // 如果拓扑排序的数组结果长度等于给定长度，则满足要求
};
```

## DFS

```javascript
/**
 * @param {number} numCourses
 * @param {number[][]} prerequisites
 * @return {boolean}
 */
var canFinish = function(numCourses, prerequisites) {
    if (numCourses <= 0) return false;
    
    // setArr是一个set数组，数组中的每一项元素都是set
    // 每一个set都表示当前下标i节点的后续节点的集合
    let setArr = new Array(numCourses);
    // 初始化setArr
    for (let i = 0; i < numCourses; i++) {
        setArr[i] = new Set()
    }
    for (let item of prerequisites) {
        setArr[item[1]].add(item[0]);
    }
    
    // marked是标记数组，记录每一个节点的访问状态，初始为0
    // 为1表示正在访问当前节点或当前节点的后续节点
    // 为2表示当前节点以及当前节点的后续节点均已访问结束，且没有遇到环
    let marked = new Array(numCourses).fill(0);
    
    for (let i = 0; i < numCourses; i++) {
        if (dfs(i, setArr, marked)) {
            // 有环则返回false
            return false;
        }
    }
    return true;
};

// 判断聊表是否有环
function dfs(i, setArr, marked) {
    if (marked[i] === 1) {
        return true
    }
    
    if (marked[i] === 2) {
        return false
    }
    
    marked[i] = 1;
    
    let set = setArr[i];
    for (let value of set) {
        if (dfs(value, setArr, marked)) {
            return true;
        }
    }
    marked[i] = 2; // 访问结束，且没有环
    return false;
}
```