看着题解的一大堆"入度表"、"领接矩阵"什么的，对于一个没有学过拓补排序的人来说真的有点头疼...想着会不会有人和我一样，就试着写了一下自己的理解。下面是自己参照精选题解摸索出来的代码和理解。

关于我理解的入度表：他会记录每个节点的信息，信息包括这个节点指向多少个其他节点。在这道题目中可以数组做表结构：用数组下标作为节点值，用对应的值表示指向的节点的数量。

这个方法的主要思想是找出所有"没有指向其他节点的节点"，这里看成是"没有尾巴的节点"，然后把他们统统放到一个"收集没有尾巴的节点的队列"里，再进行对他们进行遍历，遍历的过程是这样的：
  1. 比如当前遍历的是节点A，然后我们要把所有指向这个节点A的节点找出来。
  2. 对于找出来的节点，我们剪掉这些节点的一个分支(尾巴)，表示删除了节点A。 
  3. 然后一次针对节点A的遍历就完成了，可以对节点A说拜拜啦~ 要把节点总数-1 把节点A出队。
     在这个过程中要注意：如果这个节点剪掉分支A之后没有其他节点了，那就要把这个节点push到"收集没有尾巴的节点的队列"里面去。
  4. 然后继续对所有没有尾巴的节点进行遍历..总的来说他就是一直在剪尾巴，直到队列里面的节点数量为0，就再也不执行循环了。

如果所有节点的尾巴都被他剪完了，节点总数就会返回0，表示所有节点都被处理过了。
但是也会有剪不完的时候：
  如果有一个节点：他的尾巴和另一个节点的尾巴纠缠在一起了(两个节点互相指向对方)，那么他们永远不会成为没有尾巴的节点，也不会进入队列。因为在为他们那互相纠缠的尾巴总是没办法剪到：
  1. 例如prerequisites=[[1,0],[1,2],[0,1]]，可以看做1->0 1->2 0->1。这时候入度表为[1,2,0]，队列为[2]，因为队列里面有1个元素，所以可以执行循环。但是对节点2遍历完之后，由于节点1的分支数量-1 != 0，节点1的尾巴没剪干净，无法进入队列。但是2又出队了，所以队列为空，循环不得不就结束了。这个时候没有被处理的节点总数量为2，因为节点0和节点1没有进入队列剪尾巴。
  2. 又例如prerequisites=[[1,0],[0,1]]这种。由于他们互相引用，所以有入度表[1,1]，队列为空，不能执行循环。所以0和1都没有被剪尾巴，没有被处理完的节点总数量为2。
  它的原理也不难: 只有在一个节点会被收集到队列里面才能剪尾巴，而且每个节点都只能剪掉它对应的尾巴：像1和0这种互相引用的节点，只有遍历才0能剪掉1->0这个尾巴、只有遍历1才能剪掉0->1这个尾巴。但是由于0和1都有尾巴所以不能被遍历，不能遍历就没办法剪掉尾巴，有尾巴就不能遍历，不能遍历就没办法剪掉尾巴......
  所以，最后我们利用剩余节点的数量，就可以判断是不是有互相纠缠的节点啦！

如果你读完了上面这一段又臭又长的话，非常感谢你愿意看我的不怎么地道的理解~ 也恭喜你，接下来就可以开始写代码啦啦啦！！


```
function canFinish(numCourses, prerequisites) {
    //创建一个入度表 记录每个节点指向多少个其他节点
    let TableForNum = new Array(numCourses).fill(0)
    prerequisites.forEach(nodeCouple => {
        let node0 = nodeCouple[0]
        TableForNum[node0]++
    })
    //得到一个"收集没有尾巴的节点的队列" 
    let queue = []
    //把没有尾巴的节点值放到队列里面去
    TableForNum.forEach((nodeBranch, nodevalue) => {
        nodeBranch === 0 && queue.push(nodevalue)
    })
    //当队列中有元素的时候执行循环
    while (queue.length > 0) {
        //得到现在要处理的节点
        let needDealNode = queue.shift()
        //没有被处理的节点-1
        numCourses--
        //循环所有的节点关系数组 找到指向这个节点的节点
        for (let i = 0; i < prerequisites.length; i++) {
            let nodeCouple = prerequisites[i]
            //看看这个节点是不是指向现在要处理的节点needDealNode
            if (nodeCouple[1] != needDealNode) continue
            //如果是指向的 就把这个节点的尾巴-1 相当于剪断这条尾巴
            //如果刚好这个节点没有尾巴了 就推到没有尾巴的队列里面去
            if (--TableForNum[nodeCouple[0]] == 0) {
                queue.push(nodeCouple[0])
            }
        }
    }
    //最后判断是不是所有的节点都被处理过了
    return numCourses === 0
}
```


