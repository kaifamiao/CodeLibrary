对于任意偶数，将其分为两个数，当且仅当两数相等时积最大（因为对于任意`2n, n^2>(n-i)(n+i)=n^2-i^2, where i<n`）;

受此启发，直觉上，我们应该能感觉到将任意数字均分时能够取得最大乘积。

# 那么，我们到底应该将这个数字分为多少份呢？

答案是将任意数组字分为`3m+2n`时结果最大。

这是因为，首先，如果对2，3进行拆分，2只有一种拆分方法就是1+1；3有两种拆分方法 1+2；1+1+1；

对于这两个数字，无论如何拆分得到的拆分单元的乘积均小于原始值；

而对于任意n>3, 拆分为两个数得到的乘积(n/2)^2 (n为偶数时)或 (n/2)((n+1)/2)*(n/2)（n为奇数时）均大于n;

因为对于函数`y=(n/2)^2-n` 或 ` (n/2)((n+1)/2)*(n/2)-n `在n>3时均有y>0（且求导可发现在n>=3时单调递增）;

也就是说，当n>3时，对n进行拆分得到的数字的乘积一定大于原始值；

也就是说，2和3是该问题的最小不可分单元；

# 那应该 拆分成多少3和多少2呢？

答案是尽可能多的3，剩余的值拆分为2；

这是为什么？先举个栗子（要不别举了，还是吃掉吧）：以6为例，3*3>2*2*2

推而广之：因为6是2和3的最小公约数，也就是说，对于待拆分n, 应该优先拆出3（但同时要保证拆出来的所有元素都>=2）

综上：

```
class Solution {
public:
    int integerBreak(int n) {
        if(n==2||n==3) return n-1;
        int res=1;
        while(n>4){
            res*=3;
            n-=3;
        }
        return res*n;
    }
};
```