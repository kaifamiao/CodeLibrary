### 解题思路
# **动态规划：**

1. 方程：dp[i] = max(dp[i-j] * j) 
2. dp[i]表示对于i，按照题目描述，所能获得的最大乘积

**思考点：**

- 循环从4开始计算，因为dp[2|3]是非常特殊的值，它们都小于本身（2|3）
- 但是根据经验来看，大部分数或者说3以后的数拆分成的整数相乘的结果必定 >= 该数本身，
- 且随着数越大，乘积也会超出本身越多

- 凭着感觉将dp[2]设置为2，dp[3]设置为3，这是因为当我们后续的计算用到dp[2|3]时，
- 我们希望dp[i]的乘积形式是2|3*dp[i-2|3]的，而不是(1 X 1)|(1 X 2) X dp[i-2|3]这样的
- 也就是说，对于后续的计算，2和3是原子，不可拆分，
- 最后将dp[2]和dp[3]改过来即可返回dp
![捕获1.PNG](https://pic.leetcode-cn.com/8737fe9d051ce3f9993b7920e1b5ca2597044523e92c7b8b793c4d69ea3eaeb1-%E6%8D%95%E8%8E%B71.PNG)


### 代码

```python
class Solution:
    # dp[i] = max(dp[j] * (i-j)) 
    def integerBreak(self, n: int) -> int:
        if n == 2:
            return 1
        dp = [1]*(n+1)
        dp[2] = 2
        dp[3] = 3
        for i in range(4,n+1):
            # >=2 个整数相乘必定不会小于这个数本身，所以初始化最大值为i
            # 可以说越大的数拆分成的整数相乘的结果必定超出该数越多
            # 比较特殊的情况只存在于2,3,因为它们的拆分中用到了1,循环之前已经设置了i=2|3的dp值
            # 显而易见，大部分数的拆分都会避免用到1因为1乘其他数并不能使得已经得到的结果变大
            max_val = i
            # dp[i]一定>dp[i-1]所以不需要对dp[i-1]*1进行判断了
            for j in range(2,i-1):
                temp = dp[i-j]*j
                if temp > max_val:
                    max_val = temp
            dp[i] = max_val
        dp[2] = 1
        dp[3] = 2
        print(dp)
        return dp[-1]

        
```