先上代码:
```
class Solution:
    def integerBreak(self, n: int) -> int:
        MAX=0;memo=[1,1]
        for i in range (2,n+1):
            for j in range (1,i):
                MAX=max((i-j)*memo[j],(i-j)*j,MAX)
            memo.append(MAX)
        return memo[n]
```
与很多人一样，我用的是动态规划的思想，之前学的算法导论中的DP思想用的推导式，但是我这里就没用了，因为我不想去按照一个固定的去理解别人的一模一样的思路，这里我记录下我花了一天的时间去接触这道题。
这道题与斐波那契、爬楼梯的思想还真不一样，原因就在于如果我们用DP的话，这道题用的是O(N^2)的解法，我们姑且不谈论题解区的大佬们用O(N)的时间复杂度去解决了这个问题，但是我相信，他们能优化到O(N)是因为他们深刻的理解了动态规划，所以在此基础上进行了优化。我们姑且亦不谈论数学找规律的解法，因为我觉得这道题的思想如果用找规律的话，那么你一点都成长不了，我作为一个DP小白，我试图用一个DP的思想去接受它。
![image.png](https://pic.leetcode-cn.com/f0c7544fb6d81a0f0d49c7dd2c4ed53c9fcde414fcb30cdc11a449ef5b540ebe-image.png)

如上图所示，我们拿4举例子，4可以由(3,1)、(2,2)、(1,3)组成，我们将touple元组的左边固定不动，去尝试拆分右边的数，可以看到2能被拆分为(1,1),3能被拆分为(2,1),(1,2)。
现在就有一个问题了：我们能不能设立一个memo数组来记录对于2或者3这个数的时候，他的最优解能够存储在Memo数组中。
我们尝试写了下代码，
```
memo=[1,1]
for j in range (1,n):
    MAX=max((n-j)*memo[j],(n-j)*j,MAX)
memo.append(MAX)
```
上面的n就是我们传进来的n，当n=2的时候，我们能够得到对于2的最优解，所以我们的memo数组中多了一个对于n=2这个数的最优解是1，好的，我们再用这份代码计算n=3的时候，3对应的最优解，我们知道3的最优解肯定需要知道2这个最优解对吧？那么当我们执行代码的时候发现， list out of index了，这的原因就是因为我们没有记录n=2的时候的最优解，所以在j=2的时候，我们的memo可是一直都是[1,1]的。
那么我们现在知道了，当n=3之所以不能执行的原因是因为我们的memo数组中压根就没有存2的最优解，也就是说在 ` for j in range (1,n)`这一步中 n =2 的时候 memo=[1,1,1], 想让n=3的时候能在这个memo=[1,1,1]的基础上去找到2的最优解的值，也就是memo[2]。 那么我们就需要有一个让 n 从2到n的变化，这样我就能记录每一个最优解的值然后存到memo中了，所以我们增加代码:
```
for i in range (2,n+1):
    for j in range (1,i):
        MAX=max((i-j)*memo[j],(i-j)*j,MAX)
    memo.append(MAX)
```
我们的i就是一个可以连续变化的数，i可以一直记录到对于n这个数的最优解，我们的memo可以存储对于i这个数来说他的最优解是什么，注意我没有用到memo[i]=MAX,其实memo.append(MAX)的意思就是在i-1的后面追加，也就是memo[i]了。
现在我们再回过头来分析一下这句话:
```MAX=max((i-j)*memo[j],(i-j)*j,MAX)```
还是拿上面那张图来解释，当我们的i=3的时候，也就是需要记录i=3的时候的最优解的时候，我们可以看到(2,1)和(1,2)这两个组合，我前面说过，touple中左边的是不拆分的，右边的药拆分的，所以我们的MAX其实就是一个比较拆分的话和不拆分的话的最大值哪个大，将最大的那个值赋值给memo。
我曾尝试的去给memo这个数组去定义一个含义，直到我将它解释为是一个容器，里面装的就是对于n=？的一个最优解的容器。
自底向上的理解这个问题的难处就在于你去存储每一个底部的值，然后上面去利用底部的这个值的过程。
递归的自顶向上的理解过程就是我不去记录某些操作是否重复执行，我关心的是能否利用递归的特性去达到底部。