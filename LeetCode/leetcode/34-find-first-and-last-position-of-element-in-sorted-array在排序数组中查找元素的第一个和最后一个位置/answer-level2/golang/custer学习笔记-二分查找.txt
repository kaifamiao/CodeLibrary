### 解题思路 - 线性查找

- 从左向右扫描数组，第一个等于目标值的下标，
- 然以后从右向左扫描数组，找到第一个等于目标值的下标，
- 于是可以得到目标值在数组中的开始和结束下标
 
这个方法需要遍历下标两次，因此时间复杂度是O(n)，n是数组长度。

不需要额外的存储空间，因此空间复杂度是O(1)。

### 代码

```golang
// 线性查找方法 Time: O(n), Space: O(1)
func searchRange(nums []int, target int) []int {
  if nums == nil || len(nums) == 0 { // 数组为空或长度为0
    return []int{-1, -1} // 直接返回[-1,-1]
  }
  n := len(nums)       // 否则把数组长度赋值给n
  start, end := -1, -1 // 初始开始和结束下标都为-1

  for i := 0; i < n; i++ { // 先从左向右扫描数组
    if nums[i] == target { // 找到第一个等于目标值的数字
      start = i // 记录开始下标
      break     // 然后跳出循环
    }
  }

  for j := n - 1; j >= 0; j-- { // 先从右向左扫描数组
    if nums[j] == target { // 找到第一个等于目标值的数字
      end = j // 记录结束下标
      break   // 然后跳出循环
    }
  }
  return []int{start, end} // 最后返回这对开始和结束下标即可
}
```

### 解题思路 - 二分搜索变形
我们知道有序数组中查找一个数字，可以使用二分搜索在O(logn)的时间完成

这个题目本质上也是在一个有序数组中查找一个数字，区别在于目标值在数组中可能有多个，

要找到这多个目标值在数组中的开始和结束下标，于是我们可以对二分搜索算法做一些改变。

二分搜索算法的核心思想是每次拿目标值和数组中间的数值对比，

- 如果目标值小于中间数字，就继续去数组左半边继续查找，
- 如果目标值大于中间数字，就继续去数组右半边继续查找，
- 如果目标值等于中间数字，则返回它的下标

由于数组中可能包含多个目标值，所以我们需要先改变一下原始的二分搜索算法。

在找到等于目标值的下标时，不返回，而是在右边一半部分继续查找，

这样一来，我们最终找到的就是目标值在数组中的结束下标。

那怎么查找目标值的开始下标呢。很简单，我们只需要查找比目标值小1的数字的结束下标，

再加上1得到的就是目标值的开始下标。

我们最后得到目标值的开始和结束下标后，还要进一步验证它们范围的有效性。才能返回正确的开始结束下标。

这个方法使用了二分搜索的一个变种，因此时间复杂度和二分搜索一样都是O(logn).

不需要使用额外的存储空间，空间复杂度是O(1)。

### 代码

```golang
// 二分搜索变体方法 Time: O(logn), Space: O(1)
func searchRange(nums []int, target int) []int {
  // 先处理边界情况
  if nums == nil || len(nums) == 0 {
    return []int{-1, -1}
  }
  // 调用辅助函数得到目标值的结束下标
  end := binarySearchLastOne(nums, target)
  // 调用辅助函数查找target-1,返回的下标再加1,就得到目标值得开始下标
  start := binarySearchLastOne(nums, target-1) + 1
  // 如果最后计算得出的开始下标大于等于0小于等于结束下标
  // 并且结束下标小于数组长度
  if start >= 0 && start <= end && end < len(nums) {
    return []int{start, end} // 即得到一对有效解返回即可
  }
  // 否则说明目标值不在数组中
  return []int{-1, -1} // 返回[-1,-1]
}

// 辅助函数 查找目标值得结束下标
// 注意，当目标值不在数组中时返回的high是比目标值小的数字里最大的那个数字
// 如果目标值比数组中所有的数字都小，返回的high等于-1
func binarySearchLastOne(nums []int, target int) int {
  // 初始化low和high为数组的头尾下标
  low, high := 0, len(nums)-1
  for low <= high { // 当low小于等于high时循环执行以下操作
    // 先计算low和high的中间下标mid
    mid := low + (high-low)/2
    // 如果目标值小于nums[mid]就更新high到左边查找
    if target < nums[mid] {
      high = mid - 1
    } else { // 否则更新low到右边查找
      low = mid + 1
    }
  }
  return high // 最后返回high即可
}
```