这道题的思路为：


假设数组A的第一个元素A[0]=1，那么我们一定不希望翻转A[0...K-1]这部分数组。这样的话，接下来就可以不考虑A[0]，而考虑子问题A[1...n-1]了。
而假设数组中第一个元素A[0]=0，那么我们需要翻转A[0...K-1]这部分数组，从而将A[0]变为1。
因此，这道题可以用贪心算法来解决，我们从前向后遍历，找到1时跳过，找到0时，就翻转从它开始的长度为K的子数组。


优化：
以上方法的时间复杂度为O(n*k)，在k非常大的时候会导致超时。
究其原因，在于遍历过程中，我们对每个元素，都要花费O(k)的时间来记录它翻转的次数。
而实际上，当遍历到i+1位置时，对于A[i+1]，如果我们知道A[i]是否翻转过，以及A[i-K+1...i]这个子数组是否翻转过，那么就可以在常数时间内算出A[i+1]是否翻转过。
如果A[i-K+1...i]这个子数组没有翻转过，那么A[i]和A[i+1]这两个元素的翻转情况应该是完全一致的。
相反，如果A[i-K+1...i]这个子数组翻转过，那么A[i]和A[i+1]这两个元素的翻转情况应该相反。
因此，我们可以维护一个长度为n的数组hint，hint[i]表示以A[i]结尾的子数组A[i-K+1...i]是否翻转过；用一个变量flip保存当前元素是否被翻转过。
这样，尽管空间复杂度增加到O(n)，但时间复杂度也降低到O(n)。


代码及注释如下：
```
class Solution {
public:
    int minKBitFlips(vector<int>& A, int K) {
        int count = 0, i = 0, n = A.size();
        bool hint[n+1] = {false}, flip = false;
        for (i=0; i<n; i++){
            // 当A[i]==1时，如果flip==true，表示A[i]已被翻转过，所以我们要再次把它翻转回来
            // 当A[i]==0时，如果flip==false，表示A[i]未被翻转，所以我们要把它翻转
            if (A[i] && flip || !A[i] && !flip){
                // 已经没有长度为K的子数组可以翻转，返回-1
                if (i + K > n)
                    return -1;
                // 因为对从i开始长度为K的子数组进行了翻转，按照hint的定义，要将hint[i+K-1]更新为true
                hint[i+K-1] = true;
                // 翻转次数+1
                count ++;
                // flip表示A[i]的翻转情况
                flip = !flip;
            }
            // 如果hint[i]为假，那么A[i+1]的翻转情况应该和A[i]一致；否则相反，flip需要更新
            if (hint[i])
                flip = !flip;
        }
        return count;
    }
};
```
