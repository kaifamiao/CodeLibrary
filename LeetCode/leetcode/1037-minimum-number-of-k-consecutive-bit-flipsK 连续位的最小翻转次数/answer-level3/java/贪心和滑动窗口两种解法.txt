### 解法一：贪心算法
  当我们从某个位置开始准备翻转`K`位数字时，由于无法影响到该位置前面的数字，所以必须遇到0就翻转。不然该位置或者前面有`0`时，它无法变成`1`。很明显该题具有贪心性质！因此我们的策略也很简单：只要遇到`0`，就翻转从该位置开始的`K`位连续数字。c++编码试过了，会出现时间超限，因此以下给出可以Accept的Java实现：

### 解法一代码
```
class Solution {
    public int minKBitFlips(int[] A, int K) {
        int ans = 0;
        int len = A.length;
        for(int i=0;i<len;i++){
            if(A[i] == 0){
                if(i + K > len) return -1;
                ans++;
                for(int j=i;j<i+K;j++)
                    A[j] ^= 1;
            }
        }
        return ans;
    }
}
```


### 解法二 滑动窗口
  由于解法一在K非常大的时候，会出现时间超限，因此我们考虑是否可以不用真的去翻转数字，而只统计需要翻转的次数即可。这里定义一个变量`ans`记录翻转次数，维护一个大小为`K`的窗口。考虑对于第`i`个位置，它当前的值会受到从第`i-K+1`位置**起**的数字是否翻转影响，假如`i-K+1`的数字翻转了，那么第`i`个位置也被翻转了。以此类推可以看出从`i-K+1`到`i-1`位置假如被翻转了都会翻转第`i`个位置。
  假如处理完`[i-K+1, i-1]`窗口所有的数字时，第`i`个位置已经被翻转了**偶数次**。由于我们不是真的翻转，而只是统计，那么当前`A[i]`是0还是0，是1还是1。假如当前位置是**0**，那么经过了前面的**偶数次**翻转时候，它还是**0**。所以我们自然需要对第`i`个位置进行翻转，因此需要将记录翻转次数的`ans++`即可。假如当前数字是**1**，则我们跳过，处理下一位数字。
  而假如我们在处理完`[i-K+1, i-1]`窗口所有的数字时，第`i`个位置已经被翻转了**奇数次**，假如当前位置`A[i]`的值是**1**，那么经历过奇数次翻转之后，它变成了**0**，因此需要将它翻转为**1**，`ans++`。假如`A[i]`为**0**，经历过奇数次翻转后，它已经变成**1**了。我们只需要跳过，处理下个位置。
  如上分析，我们只要处理经历过奇数次翻转之后且`A[i]`为**1**，经历过偶数次翻转之后且`A[i]`是**0**的这两种情形。题目给出假如当前位置是**0**且和后面构不成`K`位连续数字的时候返回-1，我们只需要在第`i`位加个判断： `i+K > A.size` 时，返回-1即可。
  最后还有一个问题，我们怎么直到当处理`A[i]`时，它已经被翻转了多少次？只需要采用一个队列，将`[i-K+1, i-1]`这个窗口内所有被翻转的数字的**下标**加入到这个队列来。当我们处理`A[i]`时，只要看当前的队列长度，就知道`A[i]`被翻转的次数！
  能讲的都讲完了，下面给出代码！

### 解法二代码

```
class Solution {
public:
    int ans = 0;
    queue<int> q;
    int minKBitFlips(vector<int>& A, int K) {
        for(int i=0;i<A.size();i++){
            // 维护长度为K的窗口
            if(!q.empty() && q.front() + K == i)
                q.pop();
            //判断当前位置是否需要翻转
            if(q.size()%2 == A[i]){
                if(i + K > A.size()) return -1;
                ans ++;
                q.push(i);
            }
        }
        return ans;
    }
};
```
