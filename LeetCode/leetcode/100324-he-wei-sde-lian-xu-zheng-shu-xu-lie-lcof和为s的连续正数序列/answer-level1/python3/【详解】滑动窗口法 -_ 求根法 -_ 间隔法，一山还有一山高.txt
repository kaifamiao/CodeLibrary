![image.png](https://pic.leetcode-cn.com/cecbbce64d98b556c40b234f649df1ec8141af3314c6746a19d1c99134bc222e-image.png)

### 0 - 概述
这个题用数学思想去做还蛮有意思，不少细节值得大家仔细品一品。滑动窗口相对来说，结合图片或者动态gif来理解会非常简单，只需要根据双指针范围内数组之和与target进行判断，符合条件的数组添加进入结果列表中，然后动态地维护两个指针缓缓前进，直到右边界到达target的中值即可。

### 1. 滑动窗口

什么是滑动窗口呢？
可以先来先理解一下**窗口**的概念

假设target是9，我们的脑海中可以快速的浮现出一个从1到9的数组。这时候不妨再想象一下，数组下方有个两个指针，一个指向1，一个指向5，两个指针形成的这个数组范围，就是所谓的窗口。如下图所示：
![image.png](https://pic.leetcode-cn.com/b7bbf8306beaf1f05af3f46d33846a9f54543d74894ddcf81bf3e1e712dbabce-image.png)
请问**滑动**作何解释？
左右指针通过平移，会改变了窗口的范围，从而引起窗口的滑动，这就是所谓的滑动窗口
![image.png](https://pic.leetcode-cn.com/652fac6fe71a55076fad3550487de0574616521e0e7ea93d96e0694f0afda358-image.png)

针对目前这个题，我们可以把左指针`i`指向1，右指针`j`指向2，然后就能计算出当前窗口范围各数字的和，`cur_sum = sum(list(range(i,j+1)))`，如果`cur_sum`小于target，说明当前窗口数字之和过小，这时候咱们可以令`j += 1`，这样我们的新窗口就向右边扩大了。同样的道理，如果`cur_sum`大于target，这说明我们当前窗口数字之和过大，这时候就令`i += 1`，这样窗口的左边界就向右边移动了一个单位，就使得窗口变小了。

观察上图，前面窗口的指针是`i=1,j=5`，形成的窗口就是`[1,2,3,4,5]`，那么`cur_sum`就是1+2+3+4+5=15

由于左指针`i`向右平移，后面窗口的指针是`i=4,j=5`，形成的窗口就是`[4,5]`，那么`cur_sum`就是4+5=9

代码如下：
```
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        # 初始化窗口指针和输出列表
        i, j, res = 1,2, []

        # 滑动窗口的右边界不能超过target的中值
        while j <= target//2 + 1:
            # 计算当前窗口内数字之和
            cur_sum = sum(list(range(i,j+1)))
            # 若和小于目标，右指针向右移动，扩大窗口
            if cur_sum < target:
                j += 1
            # 若和大于目标，左指针向右移动，减小窗口
            elif cur_sum > target:
                i += 1
            # 相等就把指针形成的窗口添加进输出列表中
            # 别忘了，这里还要继续扩大寻找下一个可能的窗口哦
            else:
                res.append(list(range(i,j+1)))
                # 这里用j+=1，i+=1，i+=2都可以的
                j += 1
        
        return res
```
可能会有小伙伴问到，为什么`j <= target//2 + 1`？其实这是很直观的一个事情，直接举例子归纳就行~

你看：9 = 5 + x，x是不可能比5大的
再看：15 = 8 + x，x是不可能比8大的
所以这就考验总结出一个规律：即一个大于1的正整数，总是小于，它的中值加上一个比中值大的数。

**所以，当右边界跨过中值的那一刻，窗口内的和就永远也无法触及到target了。**

滑动窗口的方法简单易懂，但由于要不停地遍历，所以时间上效率较低。数学法会有所提升。

![image.png](https://pic.leetcode-cn.com/80cf1a535fa10ee8e9af85b216421bf733c71fe7df3714fa1f6cb4c60f2a88ed-image.png)

### 2. 求根法

由于连续的正整数数列是一个相当标准的等差数列，我们可以考虑一下把窗口内的数组用等差数列的求和方式进行求和。等差数列之和的公式为：
$$
S_{n}=\frac{n}{2}\left(a+a_{n}\right)
$$
其中
$$
\begin{array}{c}
S_{n}：数列之和 \\
n：项数\\
a：首项\\
a_n：末项\\
\end{array}
$$
我们假设x为首项，y为末项，则x-y+1为项数
$$
\frac{(x+y) *(y-x+1)}{2}=S_n
$$
现在我们的目标是找到一个x，y形成的区间使得区间之和等于target，我们把target简写为t，就有：
$$
\frac{(x+y) *(y-x+1)}{2}=t
$$
再把这个式子彻底展开来，写成方程的样子：
$$
x^{2}-x-y^{2}-y+2t=0
$$
**大家注意了！这里把x当做一个未知数，然后再假设y是已知的,t是题目给定的
所以我们可以把 $-y^{2}-y+2t$ 这部分当做是常数**

根据求根公式：
$$
x_{1,2}=\frac{-b \pm \sqrt{b^{2}-4 a c}}{2 a}
$$
根据题意可知x永远是正整数，所以直接可以去掉负数根，就得到：
$$
x = \sqrt{y^2+y-2t+\frac{1}{4}}-\frac{1}{2}
$$
这个式子就很有**灵性**了~
不信咱们可以来试一试~

假设我们的target=9，那么显然，y必是小于等于target中值的，target中值为5，所以我们把y从5到1进行枚举，就能得到不同的x的值，结果如下：

y = 5 时, x = 4.0
y = 4 时, x = 2.0
y = 3 时, x = (0.5000000000000001+2.3979157616563596j)
y = 2 时, x = (0.5000000000000002+3.427827300200522j)
y = 1 时, x = (0.5000000000000002+3.968626966596886j)

可以看到 y = 3, 2, 1时，x都不对，这里的后缀 j 代表x是一个复数(不在实数范围内)。另外还有一种可能的情况就是，x在求解时，会出现x=1.7171717这种非整数的解，我们需要及时筛除！

那么也就是说，根据x的公式，由于t是题目给定的，我们只要不断地枚举y就能求出相应的x来，只要把不符合条件的x，如复数，非整数等筛选掉，即可得到正确的x，由此形成的范围[x,y]就是我们要找的答案~

代码如下：
```
class Solution:
    def findContinuousSequence(self, target: int):
        # 创建输出列表
        res = []

        # y不能超过target的中值,即y<=target//2 + 1,range函数左开右闭,所以这里是+2
        for y in range(1,target//2 + 2):
            # 应用我们的求根公式
            x = (1/4 + y**2 + y - 2 * target) ** (1/2) + 0.5
            # 我们要确保x不能是复数，且x必须是整数
            if type(x) != complex and x - int(x) == 0:
                res.append(list(range(int(x),y+1)))
        
        return res
```
这个代码的效果比滑动窗口略胜一筹

![image.png](https://pic.leetcode-cn.com/768f4d38ccdf369d150a375c058ddfcfe35a2d1c2681dce5384ac3676f9693c2-image.png)

### 3. 间隔法

再度回首我们的求和公式：
$$
\frac{(x+y) *(y-x+1)}{2}=t
$$
我们在这里引入一个概念**间隔**（小声比比：不要怕，这不是支持向量机的间隔，没有那么复杂）

这个**间隔**就是末项y减去首项x，也就是首项和末项隔开多远的意思，可令$i=间隔$ 

易知 $i = y -x$, 代入求和式则有：
$$
\frac{(2x+i) *(i+1)}{2}=t
$$
进一步化简：
$$
2xi + 2x + i^2 +i=2t\\
$$
$$t = x(i+1) +\frac{i(i+1)}{2}$$
最终可得
$$
x = \frac{t- \frac{i(i+1)}{2}}{i+1}
$$

**我跟大家讲，这个式子可了不得！**

你可能会问，这一波怎么说？

之前求根公式需要枚举y来解出不同的x，再根据条件筛选出正确的x，这样的枚举从某种意义上来说也是浪费资源的表现，x的筛选需要进行类型判定，也稍稍复杂了一些。

而这里，要求出x，考虑到x必须是正整数，所以$\frac{i(i+1)}{2}$要小于t，否则就会出现负数。这是**条件1**

再就是 $t- \frac{i(i+1)}{2}$ 除以 $i+1$ 必须得到整数。这是**条件2**

根据这两个条件，就可以轻易地求出x来，最后根据$i = y -x$反推出y，此法妙极~

代码如下：
```
class Solution:
    def findContinuousSequence(self, target: int) -> List[List[int]]:
        # 我们的间隔从1开始
        i, res = 1, []
        
        # 根据上面的条件1，限定i的大小，即间隔的范围
        while i*(i+1)/2 < target:
            # 根据条件2，如果x不为整数则扩大间隔
            if not (target - i*(i+1)/2) % (i+1):
                # 如果两个条件都满足，代入公式求出x即可，地板除//会把数改成float形式，用int()改回来
                x = int((target - i*(i+1)/2) // (i+1))
                # 反推出y，将列表填入输出列表即可
                res.append(list(range(x,x+i+1)))
            # 当前间隔判断完毕，检查下一个间隔
            i += 1

        # 由于间隔是从小到大，意味着[x,y]列表是从大到小的顺序放入输出列表res的，所以反转之
        return res[::-1]
```
这个结果，确实很强~

![image.png](https://pic.leetcode-cn.com/f74e4a2318192adf4248bae7e1742ed308191cf799db0b74fb27e9f7acfe6f21-image.png)
