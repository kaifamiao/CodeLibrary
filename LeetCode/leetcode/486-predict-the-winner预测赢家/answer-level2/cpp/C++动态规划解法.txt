1.这题拿到首先想到的是贪心算法，想每次都拿最大的，但是好像不行，有些情况明显不适用，比如{1,5,233,7}这个测试用例，
对于这种情况，若贪心算，则会先拿7，但是拿7的话，233就会被后手拿了

2.然后用动态规划当i==j时，dp[i][j] = nums[i];首先给这个初始值赋值，然后再继续进行计算
当i!=j时，若先手取左端nums[i]，后手则为dp[i+1][j],若先手取右端nums[j]，
后手则为dp[i][j-1]，dp[i][j] = max(nums[i]-dp[i-1][j], nums[j]-dp[i][j-1]);
注意下面两个for循环的顺序，必须要有顺序才能够完成

例如测试用例{1,5,2}，动态规划出来的数组为{{1,4,-2}，{0,5,3}，{0,0,2}}
```cpp
bool PredictTheWinner(vector<int>& nums) {
	int n = nums.size();
	//dp[i][j]代表在i,j范围内，先手比后手拿到最好的多多少。
	vector<vector<int>> dp(n, vector<int>(n, 0));
	//当i==j时，取得的在i-j范围内，最大值即为nums[i]；
	//注意这个下面的初始化顺序，若测试用例为{1,5,2}；
	//是从dp[0][1],dp[1][2],然后顺序是dp[0][2]；
	for (int i = 0; i < n; ++i) dp[i][i] = nums[i];
	for (int len = 1; len < n; ++len) {
		for (int i = 0, j = len; j < n; ++i, ++j) {
			//当先手拿num[i](左侧),后手拿的最好值为dp[i+1][j]
			//当先手拿num[j](右侧),后手拿的最好值为dp[i][j-1]
			dp[i][j] = max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);
		}
	}
	//返回dp[0][n-1],因为开始是0，最后一次是n-1,代表在0~n-1范围内先手是否能比后手多
	return dp[0][n-1] >= 0;
}
```
