需要考虑的状态有：
1、数组（下表范围）；
2、**先手**玩家分数；
3、*后手*玩家分数。
考虑数组dp[i][j][0]为**先手**玩家在数组[i, j]范围内能够得到的最大分数；
考虑数组dp[i][j][1]为*后手*玩家在数组[i, j]范围内能够得到的最大分数；
则答案为 dp[0][n-1][0] >= dp[0][n-1][1]，其中n为数组长度。

转移方程：
dp[i][j][0] = max(dp[i+1][j][1]+nums[i], dp[i][j-1][1]+nums[j])
dp[i][j][1] = sum(nums[i, j]) - dp[i][j][0]        (其中sum(nums[i, j])表示nums下标范围i~j的分数总和)

边界：
dp[i][i][0] = nums[i]
dp[i][i][1] = 0
其中i = 0~n-1
如图中灰色位置

计算顺序如图，计算黄色位置需要依赖于蓝色位置，答案位于最右上角

![dp.png](https://pic.leetcode-cn.com/934c0a385077d42e8e145cb24da994e2a9ae56ecaa3aef1165672c8211b3ed08-dp.png)

空间优化：从图中的依赖和计算顺序可以看到，可以只保存一行数据。