## 解法

这个问题的重点是合理地理解题目中所定义的公因子的含义。在求解该题的时候，我将这个公因子理解为两个字符串中重复出现的一种模式。

以`ABABAB`与`ABAB`为例，其重复的模式为`ABAB`，而通过该模式的重复拼接，可以得到这两个字符串，差别就在于两个字符串所包含的模式的个数不同而已。

如果一个字符串和另一个字符串之间存在公因子，那么较短的字符串必然和较长的字符串的前面一段字符串重合，且除去较长的字符串中前面和较短字符串等长的字符串后，较长的字符串所剩余的后半部分的字符串也必然和另一个字符串存在公因子。

此时，对于较长的字符串剩余的子字符串和另一个字符串递归进行上述的比较过程。通过反复地削减字符串的长度，最终必然剩下两个等长的字符串。而对于具有公因子的两个字符串来说，所剩余的两个字符串必然是相等的，即为最大公因子。

而对于不存在公因子的两个字符串，会存在如下的情况：

* 较短的字符串和较长的字符串的前部分不匹配，直接判为不存在公因子；
* 虽然前部分匹配，但经过递归约减之后，剩余的等长字符串不相等。

该问题的求解过程描述起来较为复杂，但只要举几个例子就能很清楚地发现规律。要是仍旧无法理解，就看具体的实现代码，如下所示：

```c++
class Solution {
public:
    string gcdOfStrings(string str1, string str2) {
        if (str1.size() == str2.size()){
            if (str1 == str2)
                return str1;
            return "";
        }

        string result;
        if (str1.size() > str2.size()){
            if (str1.substr(0, str2.size()) == str2)
                result = gcdOfStrings(str1.substr(str2.size()), str2);
        } else {
            if (str2.substr(0, str1.size()) == str1)
                result = gcdOfStrings(str1, str2.substr(str1.size()));
        }
        return result;
    }
};
```

在代码实现的过程中，每一个字符最多被使用两次，因而时间复杂度为$O(n)$。