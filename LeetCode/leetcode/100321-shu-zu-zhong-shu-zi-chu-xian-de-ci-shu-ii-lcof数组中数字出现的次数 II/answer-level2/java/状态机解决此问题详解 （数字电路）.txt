## 知识出处 ##
- 状态机应该是大学数字电路学的东西
- 先设计电路逻辑
- 然后化简就可以得到此题的答案
- 但是我看别人答案也有些困惑就是输入是0，数值不变
- 这是因为在计数器里都是二进制，0代表没有输入，1代表有输入，切记

## 电路设计
### 整体设计
- 初始值 a=0,b=0 :: (00)
- 有一值 a=0,b=1 :: (01)
- 有二值 a=1,b=0 :: (10)
- 有三值 a=0,b=0 :: (00) 回到初始

### 输入0 (相当于没输入，不变)
![001.PNG](https://pic.leetcode-cn.com/4405d9028032ea172b926f1089eb5fffa8bd56307a9cde7f70441f0028f5de2d-001.PNG)
### 输入1 （这里的**c全部是二进制**）
![002.PNG](https://pic.leetcode-cn.com/848e8b892c0464e3b92ad8891b0979a5a54f49ec2db35b0a781028011ab2073d-002.PNG)
### 归纳公式 (上下两个表总结)
- a=1 必有上表`a为1 && b为0 && c为0`，或者下表`(a为0 && b为1 && c为1)`
- a=(a&~b&~c) + (~a&b&c) 
	- 这里为什么可以用加号，上面得到或的关系
	- 观察这两个公式不可能同时成立，只有一个可以成立，另一必然为0
	- 加零没有意义,加号后面化简好理解
- b=(~a & ~b & c) + (~a & b & ~c)

### 化简公式 
#### b的获取 ####
- 分配律　a∪（b∩с）=(a∪b）∩（a∪с）
- b = ~a & (~b & c + b & ~c) = ~a & (b^c) 分配律
- `~b & c + b & ~c` 这一部分我始终没有查到，上课学的都忘了希望下面有人告诉我
#### a的获取 ####
- 为什么要分开，因为这两个思想完全不一样
- 第一个公式我们是在a,b,c基础上做改动，化简公式没问题
- 但是第一个公式的改变b值动了,新a值也就会变化,我们可没有a=1,b=1的情况

----------
- 我先划个横线让大家冷静一下，
- 一开始 a,b,c 根据初始三条件我们得到b的公式
- a-没动 c-没动 b-这玩意动了->带入公公式我这里简称xb
- a-没动 c-没动 b-xb
- 得到下面这个公式，这个我改了`~xb`这块,b公式是先执行的，在编程里头b现在已经确定
- `a为1 && c为0 && ~xb  || a为0 && c为1 && ~xb`
- 而a和b不能同时取1，所以在我们确定b的同时必须遏制a等于1，就是多了一个限制条件
- 所以我一直强调a,c，限制没有变，b公式得出我们多以一个限制，a和b不能同时为1
- 好了现在化简
- `a = a & ~c & ~xb + ~a & c & ~xb = ~xb & (a^c)` --同理

#### 清晰展示得出的公式
- b =  ~a & (b^c)
- a =  ~xb & (a^c)

## 代码
### 不化简代码 (注意不化简有中间变量，所以不存在化简中的问题) ###
```
public static int singleNumber(int[] nums) {
    int a = 0, b = 0;
    for (int c : nums) {
        int tempA = (~a & b & c) + (a & ~b & ~c);
        b = (~a & ~b & c) + (~a & b & ~c);
        a = tempA;
    }
    return b;
}
```
### 化简代码 ###
```
public int singleNumber(int[] nums) {
        int a=0,b=0;
        for (int c : nums) {
            b = b ^ c & ~ a;
            a = a ^ c & ~ b;
        }
        return b;
    }
```


