以下讨论目标为正的情况。负数反过来就行啦：

无论如何，如果我把前n个数全加起来都小于目标，那肯定前n凑不出目标值。

一旦前n等差数列之和刚刚大于目标（等于的话恭喜你已经得到结果了），那么问题就在于我在这个n基础上需要修改什么？
如果 和 比 目标大一个偶数（假设为2a），那么恭喜，你只需要把a的符号从正变成负就行了，这样不就比之前的和小了 2a吗：）  ，那么a是不是一定小于n呢？当然啦！因为+n之前，和是小于目标的，（小于目标的数）+n-目标=2a，所以a肯定能在n前面找到哈哈哈哈哈哈。

所以差为偶数，那么n还是你要的最小结果！

好的，差别为偶数说了，那如果是奇数呢？ 当然不一样啦！ 你无论把之前的等差数列中多少+ 变成 -，最终的结果变化的数值都是偶数！所以GG。 那么，如果再加上n+1后，总和与目标的差变成了偶数，那不就成了吗！ 所以，在差值为技术的情况下，当n+1为奇数，也就是n为偶数时， n+1就是你要的结果！

最悲催的情况，n+1它。。。也是偶数！ 泥马最后差值还是奇数，不要慌，这个时候n+2是奇数稳稳的，再加上n+2不就行了吗？所以，在差值为技术的情况下，当n为奇数时， 结果为n+2！

是不是很棒！

那么问题来了，在我们的等差数列和恰好>=目标的时候，如何得到n的正整数解呢？（去翻中学课本吧，一元二次函数求根公式了解下，反正我是早忘了哈哈哈哈哈哈）

附上代码：

```python3 []
def get_n(sum_result):
    c = -2*sum_result
    res = ((1-4*c)**(1/2)-1)/2
    if res == int(res):
        return int(res)
    else:
        return int(res)+1

class Solution:
    def reachNumber(self, target: int) -> int:
        target = -target if target<0 else target

        n = get_n(target)
        sum_result = (n**2+n)/2
        if (sum_result-target)%2 == 0: # include sum_result==target
            return n
        elif n%2==0:
            return n+1
        return n+2
```