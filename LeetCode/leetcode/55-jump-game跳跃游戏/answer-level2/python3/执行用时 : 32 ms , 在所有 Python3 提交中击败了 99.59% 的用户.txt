我一开始是从头往后推，结果。。。。超时。因为路径太多了，一条失败了又探索另一条，非常消耗时间。

1. 先分类。第一位是0的，直接返回FALSE；如果第一位的值是大于等于字符串长度减一的，直接TRUE；
2. 如果字符串里没有0，直接TRUE；
3. 把问题反过来思考，从终点倒推，只要找到一种跨越0的可能性，一直倒推到第一个0节点（而不是第一个节点），那么就成功；但如果在倒推过程中有一个0不能跨越（长度不能超过9），那么就整个失败。

用跳跃+单线的思路，改进后快非常多。