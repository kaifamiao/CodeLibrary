![1.png](https://pic.leetcode-cn.com/4039ee00e2879c61322ba2dc17b759e465af25e5fa6fd5f60bd1f4ead6ff789d-1.png)

### 解题思路
如果数组中都是大于0的数字，那么必然能够到达最后一个位置，只有0的存在会影响结果造成无法到达，所以我们只需在遍历时讨论0出现的情况。

当0出现时，如果0前面的子数组是[4,3,2,1]（一个逐1减小的子数组），那么会造成无法到达的结果（因为不管怎么跳跃都会到达0）。只要有一个数字比当前所在位置逐渐增大的结果要大（比如前面的子数组是[4,3,2,2]，本来末尾1的位置变成了2），那么在这个位置能够跳过0，继续跳跃至最后一个位置。

因此可以从末尾开始遍历此数组，碰到0时遍历0前面的子数组，如果发现出现了能够跳过0的情况，那么就忽略这个0，继续向前找其他的0。如果最后能遍历完这个数组，说明可以到达最后一个位置。代码中采用index来记录遍历的位置，用count来记录逐渐减小的数组的减小大小。Python解法类似。

### 代码

```java
class Solution {
    public boolean canJump(int[] nums) {
        //如果数组中只有1个元素，那么必然是true（可到达最后一个位置）
        if (nums.length == 1) {
            return true;
        }
        //如果数组中的第一个元素就是0，那么必然是false（不可到达最后一个位置）
        if (nums[0] == 0) {
            return false;
        }

        //由于前面已经将边界情况排除，此时数组的长度必然大于2，初始化的index用于记录倒数第二个元素的index（无需讨论最后一个元素的数字大小）
        int index = nums.length-2;
        while (index > 0) {
            if (nums[index] == 0) { //遇到了0
                int count = 1; //用count记录减小的大小
                int i = index;
                for (i = index; i > 0; i--) { //遍历0前面的子数组
                    if (nums[i-1] > count) { //出现了能够跳过0的情况，跳出for循环（不继续检查后面的数字能否跳过0）
                        break;
                    } else { //还未出现能够跳过0的情况，减小的大小增加1
                        count++;
                    }
                }
                if (i == 0) { //如果index被遍历到了0还没有找到能够跳过0的情况，那么就不能到达终点（如[4,3,2,1,0,1]）
                    return false;
                }
            }
            index--;
        }
        return true;
    }
}
```