### 解题思路
遍历，从第一个数开始，看他能最远走到哪里，记录最远走到的距离
然后再算第二个人数最远走到哪里，一直更新每个数最远可以走到那里；
如果最后最远走的距离大于等于数组长度减一，则证明可以走到最后
备注：如果数组中某一位是0，且之前数字走到的最远距离小于等于当前数组的下标，
       说明她走到0这个位置的时候，就不可能再向后走了，直接返回false
### 代码

```cpp
//遍历，从第一个数开始，看他能最远走到哪里，记录最远走到的距离
//然后再算第二个人数最远走到哪里，一直更新每个数最远可以走到那里；
//如果最后最远走的距离大于等于数组长度减一，则证明可以走到最后
//备注：如果数组中某一位是0，且之前数字走到的最远距离小于等于当前数组的下标，
//       说明她走到0这个位置的时候，就不可能再向后走了，直接返回false
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int length = 0;
        //循环的次数为长度减2（最后一位不用判断）
        for(int i=0;i<nums.size()-1;i++)
        {
            //保存当前位可以走到的最远的位置
            int temp = nums[i]+i;
            //判断特殊情况
            if(nums[i] == 0 && length <= temp)
            {
                return  false;
            } 
            //更新最远位置
            if(temp>length)
            {
                length = temp;
            }
            
        }
        //根据看可以走到的最远位置，返回相应结果
        if(length>=nums.size()-1)
        {
            return true;
        }
        else
        {
            return false;
        }

    }
};
```