这个题贪心策略比较明显，就是让每条船浪费的空间尽可能小，那我们会想到让重的人与轻的人组合，所以我们需要排序。这个时候我们可以采用双指针的方法，从序列两边开始检索，对于最右边的每一个人（也就是当前最重的人），如果最左边的人（也就是当前最轻的人）与他组合都超过了limit的话，那么他只能独自享受一条船了。如果最轻的人可以与他匹配的话，那么就让他们坐同一条船。

有人也许会问，贪心策略不是让每条船浪费的空间尽可能小吗？事实上，这里确实没有完全按照贪心策略来，而是一种“结果等价”的策略。如果按照贪心策略的话，对于最重的人，应该这样挑左边的一个人，使得两人体重之和尽可能逼近limit。可以，但没必要，举个例子{1, 3, 4, 5}，limit = 8，{5, 3}，{4, 1}和{5, 1}，{4, 3}结果是一样的，因为我们在前期节约的空间总会在后期被浪费掉。我们采取的贪心策略可以说是“尽可能让每一个人与别人搭伙上船”。

```C++ []
class Solution {
public:
    int numRescueBoats(vector<int>& people, int limit) {
        const int n = people.size();
        int boat = 0;
        sort(people.begin(), people.end());
        int i = 0, j = n - 1;
        while(i <= j){
            if(people[j] + people[i] <= limit){
                i++;
            }
            j--;
            boat++;
        }
        return boat;
    }
};
```



