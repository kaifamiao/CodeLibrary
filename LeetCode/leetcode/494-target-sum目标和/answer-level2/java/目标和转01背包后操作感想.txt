### 解题思路
1. 如何转化成01背包问题就不说了，这个东西难想，不通用。
2. 再讲述一下本题的01背包问题解决思路。这个题的01背包问题和经典的01背包问题不太相同。导致动态转移方程很难想清楚。以下通过题解的形式我自己理一理思路，并用以保存。
3. 首先，用dp数组来表示容量为i的背包有多少种解法，或多少种装法。dp[0]=1，其余为0.这是初始化状态，当容量为0时，什么数都不选，这是一种已知解法，先保存起来（后序可能有别的0，当然也会更新dp[0]的解法数）。
4. 然后进行背包问题的经典思考，针对每一个数num，我都可以选，或者不选。如果选了，对于容量为i的背包，还有i-num的容量，那么我的容量为i的背包的解法应该为我原来保存的解法数dp[i]，加上如果我加入了num数的解法数dp[i-num]，即dp[i] += dp[i-num]。如果不选，则我还是只有原来保存的解法数不变。
5. 思考完之后，就要写代码，遍历nums数组容易理解。针对每一个num数时，怎么处理，需要好好琢磨。在dp数组中，如果背包容量大于等于num数，那么我都可以选择num数放进包中，因为小于的容量根本撑不下。所以对于大于等于num数的dp数组的下标，都应该在当前次遍历中更新。
6. 我的第一感觉，更新的顺序无所谓。for(int i = num; i <= halfOfSum; i++)和for(int i = halfOfSum; i >= num; i--)应该都没有问题。但是你品，你细品，当我从小到大更新时，根据公式dp[i] += dp[i-num]中的i-num,我是不是会在更新大容量背包解法时，用到我刚更新完的小容量背包的信息。可能你觉得这个没问题啊，不就是得用小容量背包的解法来保证不重复运算吗？话是这么说没错，但是你得看是小容量背包是处在什么状态下。
7. 分一段接着说。就这道题来说，如果你先更新了小容量背包，那小容量背包的解法中就已经包含了加入num后的解法。那么，当你再更新大容量背包时，如果用到刚更新的小容量背包，那你还能再考虑加入num后的解法吗，显然不能，因为你重复考虑num数了。就好比，同学聚会，你的同学刚讲了一个大八卦，想让大家伙嗨皮一下，然后效果很好，气氛upup。然后你随后又把八卦重复了一遍，也想让大家伙嗨皮一下，然后果然效果也很好，气氛upup。但是看似效果一样但是实质则不同啊，因为大家伙再笑话你啊。。
8. 说了一个不太对也不太好笑的校花。总而言之，和普通的动态规划填表格一样，我们要用到之前的计算结果，所以填表格，但是在本轮次迭代中，正常情况下不能使用新的结果的。就这样吧。

### 代码

```java
class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        if (nums == null || nums.length == 0) return 0;
        int sums = 0;
        for (int num : nums) sums += num;
        if (sums < S || (S + sums) % 2 == 1) return 0;
        int p = (S + sums) / 2;
        int[] dp = new int[p + 1];
        dp[0] = 1;
        for (int num : nums) {
            for (int i = p; i >= num; i--) {
                dp[i] += dp[i - num];
            }
        }
        return dp[p];
    }
}

```