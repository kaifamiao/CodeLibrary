#### 新手~~

开始思考的时候，也想到是背包问题的典型应用（当然典型的递归就不用说了）；
但产生的和为负数情况时感觉奇怪，就没有深入思考，试图换另一种方法。挺难的！
 “初始的数组的和不会超过`1000`。”这句话也是挺重要的。
 后面借助评论区的帮助理清了以上信息。

 不过还是有两个难点：

 1、单纯的原背包问题是当前`i,j`情况下，由前面的信息获取极限值；
 该题的`i,j`代表的含义是精确的。并且`i,j`是为了奉献他人的（既一加一减，一般奉献对象是两个），不像原背包问题为自己服务；
 - 比如：    ```dp[i][j - nums[i] + 1000] += ...;//j为j - nums[i]服务；```

2、也是上面的这行代码:
- ```dp[i][j - nums[i] + 1000] += dp[i - 1][j + 1000];```
后面为什么不是`dp[i][j + 1000]`我刚开始是有想法的...
后来手动写了几个后发现：当前的`j`对应的`nums[i]`值，只是上一行`（i-1)`中有效数值的中间使用工具：
举个列子： `arry: 300,400...`
          `dp[][]`默认为`0`；下标从`0`开始；
		  第一步：`i=0;dp[i][300]=1;dp[i][-300]=1;`
		  第二步：`i=1;dp[i][300+400]=1;dp[i][300-400]=1...`//由来：`dp[i][300+400]+=dp[i-1][300]=1`, 这里就是对应“只是上一行`（i-1)`中有效数值的中间使用工具”
我刚开始是这样写的：
```
if (dp[i][j]) {
	if(j+nums[i]<=1000)
		dp[i][j + nums[i] + 1000] += dp[i][j + 1000];
	if(-1000<=j-nums[i])
		dp[i][j - nums[i] + 1000] += dp[i][j + 1000];
	}
```

代码和解题都参考了评论区
### 代码
```cpp
class Solution {
public:
	int findTargetSumWays(vector<int>& nums, int S) {
		if (S > 1000)
			return 0;//根据题设条件
		vector<vector<int>>dp(nums.size(), vector<int>(2001,0));
		dp[0][nums[0] + 1000] = 1;
		dp[0][-nums[0] + 1000] += 1;//特殊的一种情况
		for(int i=1;i<nums.size();i++)
			for (int j = -1000; j <= 1000; j++){
				if (dp[i-1][j+1000]) {//dp[i-1][j+1000]有效时，可以保证j + nums[i] + 1000，j + nums[i] + 1000有效
					dp[i][j + nums[i] + 1000] += dp[i - 1][j + 1000];
					dp[i][j - nums[i] + 1000] += dp[i - 1][j + 1000];
				}			
			}
		return dp[nums.size() - 1][S+1000];
	}
};
```