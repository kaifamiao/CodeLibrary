对每个元素都往后查找，需要判断三种情况：
1. 连续遇到相同元素，很简单，直接计数即可；
2. 遇到不同元素，遇到第一个就要往后查看多一个元素，如果又相同了则继续计数，消耗掉交换机会，如果仍然不同，往后面在遇到相同元素不可直接计数（进入不可计数状态），同样消耗交换机会。注意此时说的消耗交换机会，是消耗了但是还没找到可交换的匹配元素。
3. 交换机会消耗了，就要看是否可以找到与之匹配的元素，分为往后继续遍历查找和向前查找，只要找到一个即可，因为交换机会只有一次
```
class Solution {
    public int maxRepOpt1(String text) {
        int res=1,length=text.length(),count=0,c;
        boolean b,d,t;
        char a;
        for(int i=0;i<length;i++){//遍历
            a=text.charAt(i);
            b=true;d=false;t=true;//b标志是否没到要交换阶段，d表示是否找到了可交换的相同元素，t表示遇到相同元素是否计数
            count=0;c=i;//每循环一次进行初始化，c用来标志i，方便后面往前查找可交换元素
            for(int j=i;j<length;j++){//从第i往后面遍历
                if(t&&text.charAt(j)==text.charAt(i))count++;//可计数时且遇到相同元素，计数器加一
                else {
                    if(b&&j+1<length&&text.charAt(j+1)==text.charAt(i)){//遇到第一个不同元素时需要往后判断多一个，如果仍然相等且交换机会没有用则可以计数
                        count++;
                        c=j-1;//c表示下一次外层循环要到达的i位置，因后面还要用到原来的i，故中间变量c暂时存放
                        j++;//此时计数表示可以将后面的相同元素交换到这里，故j要额外往后面多走一步
                    }
                    else {//如果往后多判断一个仍然不等，那就是没救了，所以以后遇到与第i个元素相同的元素时需要判断是否交换的情况，而不能直接计数
                        t=false;//表示不可计数
                        if(!b&&text.charAt(j)==a){//继续往后遍历，如果可交换且找到再break
                            count++;
                            d=true;//标志为交换元素已找到，后面的往后遍历就不用进行了
                            break;//找到立即退出循环，不要浪费时间
                        }
                    }
                    b=false;//一遇到不同元素就表示到了要交换的阶段，将b置为false
                }
            }
            if(!b&&!d)//如果在要交换阶段且继续往后遍历没找到交换的相同元素
                for(int j=0;j<i;j++)//往前看，注意不要看到已经计数的
                    if(text.charAt(j)==a){
                        count++;
                        break;//找到立即退出循环，不要浪费时间
                    }
            if(count>res)res=count;
            i=c;
        }
        return res;
    }
}
```
时间复杂度：O(n^2)，因为有两重遍历
空间复杂度：O(1)