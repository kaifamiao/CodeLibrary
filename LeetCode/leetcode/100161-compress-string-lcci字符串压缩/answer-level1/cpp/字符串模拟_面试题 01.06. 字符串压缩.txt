### 解题思路
    /*
     * 从左往右遍历字符串，使用字符ch记录当前要压缩的字符，使用cnt记录当前压缩字符ch出现的次数。
     * 如果当前遍历到的字符s[i]等于当前压缩字符ch，则将当前压缩字符次数cnt加1。
     * 如果当前遍历到的字符s[i]不等于当前压缩字符ch，表示当前压缩字符结束，需要更新新的压缩字符。
     * 所以先将压缩完毕的字符及其次数添加到返回结果中，再将s[i]赋值为ch，并将cnt置为1，重新开始计数。
     * 因为最后的压缩字符和次数还未添加到结果中就跳出循环了，所以要在循环外额外添加上。
     * 最后判断压缩后的字符串长度是否小于原字符串长度，返回字符串长度较小的字符串。
     * */
### 代码

```cpp
std::string compressString(std::string S) {
    if(S.empty()){
        return S;
    }
    
    // 返回字符串
    std::string str;
    
    // 记录当前压缩字符
    char ch = S[0];
    // 记录当前压缩字符出现的次数
    int cnt = 1;

    for(char s : S){
        // 如果当前压缩字符与s[i]不等，
        // 则更新当前压缩字符
        if(ch != s){
            // 再更新压缩字符前，
            // 将压缩结束的字符和次数添加到结果中
            str += ch + std::to_string(cnt);
            // 更新压缩字符
            ch = s;
            // 重置次数
            cnt = 1;
        } else{
            // 当前压缩字符和s[i]相等时，
            // 将当前压缩字符的出现次数加1
            cnt++;
        }
    }

    // 添加上最后的压缩字符和出现次数
    str += ch + std::to_string(cnt);

    // 返回字符串长度较小的字符串
    if(str.length() >= S.length()){
        str = S;
    }

    return str;
}
```