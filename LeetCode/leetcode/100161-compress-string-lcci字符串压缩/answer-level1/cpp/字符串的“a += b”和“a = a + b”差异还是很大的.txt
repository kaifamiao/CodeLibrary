### 解题思路
我一直感觉LeetCode的简单难度的题都没那么简单，因为检测用例都很刁钻。
本题看起来超简单，但我做的时候却出现了超内存的问题，无法AC。
我的解题思路跟官方答案相同，非常直接，就不重复了，重点说一下对"+="这个符号的感受。
在我最初写的超内存的代码中，对结果字符串"result"进行了"result = result + temp + to_string(count)"的操作；而官方答案是用了"+="的操作，就不会超内存。
可以看出，对于字符串使用"a = a + b"的操作会开辟一块内存进行"a+b"的操作，再将结果赋值给a；而对于"a += b"，应该是直接将字符串b拷贝到字符串a所在地址后方，不会另外开辟内存。
在字符串长度不算很长的情况下，这两种操作也许区别不大。但本题的检测用例使用了非常长的字符串，需要占很大的内存，因此使用了"a = a + b"就出现了超内存的情况。
所以，对于字符串的连接，如果能使用"+="，尽量就使用吧。不仅是简洁，更重要的是能省下内存，避免在不知情的情况下就爆内存，导致无法AC或者其他麻烦。
本人小白，如果以上分析有问题，请大神指正。


### 代码

```cpp
class Solution {
public:
string compressString(string S) {
	string result;
	if (S.size() == 0)
		return result;

	//新生成的字符串的长度，一旦超过原字符串，立刻跳出循环
	bool flag = 0;//因长度超过原字符串跳出循环时，置1
	int i = 0;//遍历字符串的index
	int count = 0;//计算相同字符的个数
	char temp;

	//对于字符串中第一个字符
	temp = S[i];//对比字符置为第一个字符
	count = 1;//计数1
	i++;

	while (i < S.size())
	{
		//不是第一个字符，则将当前字符与对比字符进行比较
		
			if (S[i] != temp)//如果当前字符与对比字符不同
			{
				result += temp + to_string(count);//将上一次的字符添加进结果字符串
				temp = S[i];//将对比字符改为当前字符
				count = 1;//数量记为1
				i++;
			}
			else
			{
				count++;
				i++;
			}

		//如果压缩后的字符串长度不小于原字符串，跳出循环
        
		if (result.size() >= S.size())
		{
			flag = 1;
			break;
		}
        
	}


	if (flag)//如果有跳出字符串的情况
		return S;
	else
	{

		//前面的程序只能把当前字符之前的录入结果，因此需要追加结尾的处理
		//如果到了最后一个字符
		result += temp + to_string(count);
		return result.size()>=S.size()? S:result;
	}

}

};
```