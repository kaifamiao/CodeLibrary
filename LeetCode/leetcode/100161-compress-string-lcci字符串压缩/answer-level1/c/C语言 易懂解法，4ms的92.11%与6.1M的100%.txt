- 写完后发现众多C语言的题解里，方法形形色色，有些不易理解，有些走了弯路，比较起来我的C语言解法代码也算简短的了，而且结果上还过得去，所以这里分享一下我的思路
1. 首先要明确这道题的几个关键点：
    - 怎么知道长度溢出，退而选`return S`本身；
    - 重复字符的计数，需要从整型转为字符型；
    - 如果计数超过10,或100，甚至1000,10000，怎么确保我的转换不会出错，转换后的字符长度保持不变？（比如有11个a，就变成`a11`，其中“11”占了两个字符位）

2. 就上面这些问题来想出解决办法：

    1) 一开始判断，凡是长度 <=2 的 S 一定是返回本身。其余的在最后比较两者长度，相同或超过都视为返回 S 本身；（我把字符串末尾'\0'也计入）

    2) 对于从整型转为字符型的办法，最蠢的就是每加一次`count`，就把对应字符改变一次新的`count`值。我们要思考，既然每次count增加，字符都要变化，而且变化的规律和整型本身是一致的，为何不先等`count`自己加到无法再加的时候，再来把它转给字符呢？

    3) 鉴于2)中的思考，我们就不难发现，第三个关键点已经引刃而解了。因为对于整型本身而言，无需考虑进位等等麻烦事，我们只要`count`的最终结果，无论你多长，我的转换只要一次。转换采用while中每次对10取余的方法，从低位到高位依次赋值给字符串；结束这个过程后就立马跳到下一个字母的计数，此时就要先录入字母，并准备新一轮计数器（`++index`），重新把`count`赋值为1

- 我的思路中有一个点要理解，就是我的循环从1开始，也把字符串结束符'\0'也考虑在循环过程。前者其实看个人做法，后者要注意是我用来让他确定最后需要结束`count`增长从而实现整型到字符的转换的，从而也实现了给压缩后的新字符串结尾赋'\0'，一举两得。不过这样的话结尾的两者比较时，要比较的应该是原字符串的长度+1，不要忘了哦
<br>

```
char* compressString(char* S){
    int size = strlen(S);
    if (size <= 2) return S;
    char* str = (char*)malloc(sizeof(char) * (2 * size));
    str[0] = S[0];
    int count = 1, index = 1;
    for (int i = 1; i < size + 1; i++) {
        if (S[i] == S[i - 1]) {
            count++;
        }
        else {
            int num = (int)log10(count) + index;
            index = num;
            while (count) {
                str[num--] = count % 10 +'0';
                count /= 10;
            }
            str[++index] = S[i];
            count = 1;
            ++index;
        }
    }
    if (index >= size + 1) return S;
    return str;
}
```
