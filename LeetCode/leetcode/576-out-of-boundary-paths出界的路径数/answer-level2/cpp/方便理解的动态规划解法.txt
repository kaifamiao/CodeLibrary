### 解题思路
一、状态表示
    首先想办法利用多维数组将所有状态表示出来，这是动态规划算法的起点，根据题意我们最多可以移动N次，也就是说，我们移动的次数也可以小于N，这时我们就需要在数组中开辟一个维度来表示我们目前移动的次数，然后我们还需要两个维度来表示目前球所在的位置，所以dp数组可以建成dp[N][m][n]这三个维度，由于我们知道起点，我们可以将dp数组理解为从起点出发，移动N次到当前位置的路径数量。
二、状态转移
    由于所有状态的起点相同，所以当前状态只与上个状态有关，由于球可以上下左右移动，所以我们可以将移动一步就到当前位置的状态作为上个状态，并写出转移方程：**dp[a][b][c]=dp[a-1][b-1][c]+dp[a-1][b+1][c]+dp[a-1][b][c-1]+dp[a-1][b][c+1]** 这里a表示移动次数，b，c表示球的位置。
    这里还没完，我们还需要考虑边界，根据题目给出的第二个示例，我们知道，一个位置可以有三种（最多四种）方式穿过网格边界，所以我们开dp数组的时候不能只多开一行一列，要开成dp[N+1][m+2][n+2](N+1是为了防止他给的N是0),这样才方便将所有出界方式都考虑到，而起点就很好得出了，dp[0][i][j]=1,从起点移动0次到起点当然就是一种情况了。
三、结果保存
    根据上面的步骤，我们虽然可以得到从起点开始移动n次到达a,b的路径数，但这还不是结果，我们还要思考a,b移动一次后出界的可能情况，当m,n满足**b-1==0||b+1>m||c-1==0||c+1>n**时，我们就能够在a,b只移动一步就将球移出边界，计算结果的时候，四种情况满足几种就加几次就好了。
    最后别忘了把dp的类型开成long long,万一在状态转移的时候溢出可就难受了，下面请看代码.
### 代码

```cpp
class Solution {
public:
    int findPaths(int m, int n, int N, int i, int j) {
        int MOD=1000000007;
        typedef long long LL;
        LL dp[N][m+2][n+2];
        LL ans=0;
        memset(dp,0,sizeof(dp));
        dp[0][i+1][j+1]=1;
        for(int a=0;a<N;a++)
            for(int b=1;b<=m;b++)
                for(int c=1;c<=n;c++){
                    if(a>0)
                    dp[a][b][c]=dp[a-1][b-1][c]+dp[a-1][b+1][c]+dp[a-1][b][c-1]+dp[a-1][b][c+1];
                    if(b-1==0) ans+=dp[a][b][c];
                    if(b+1>m)  ans+=dp[a][b][c];
                    if(c-1==0) ans+=dp[a][b][c];
                    if(c+1>n)  ans+=dp[a][b][c];
                    dp[a][b][c]%=MOD;
                    ans%=MOD;
                }
        return ans;
    }
};
```