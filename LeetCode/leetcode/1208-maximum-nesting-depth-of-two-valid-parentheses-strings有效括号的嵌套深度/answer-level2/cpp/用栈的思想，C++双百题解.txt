### 解题思路
先给我得瑟一会。这道题目乍一看，让人眼花缭乱，再仔细一看，不就是把这些括号分成两个部分，使他们括号叠加在一起的数量尽可能的少就行了。
这还不简单，就是将叠加的部分尽可能的平分给两个栈就好了。遇到'('只需要对比一下两个栈的数量，谁少就给谁。
![1111. 有效括号的嵌套深度.png](https://pic.leetcode-cn.com/171e52ae2ae3cac5b2563302706687e7c96f8532001ce120fe8cfb98bcc60653-1111.%20%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%E7%9A%84%E5%B5%8C%E5%A5%97%E6%B7%B1%E5%BA%A6.png)
虽然用的是栈的思想，但是因为只用'()'，所以并不需要真的创建两个栈，只需要用两个int类型的变量代替栈中'('的数量就可以了，遇到')'就做出栈的操作。详细的代码可以看下面。

### 代码

```cpp
class Solution {
public:
    vector<int> maxDepthAfterSplit(string seq) {
        int sl = seq.length();//计算字符串的长度
        vector<int> sum(sl);
        int one = 1, two = 0;//表示两个栈
        for(int i = 1; i < sl; i++){//遍历字符串
            if(seq[i] == ')'){//先考虑')'
                if(two != 0){//如果第二个栈里面还有'('
                    two--;//先将它出栈
                    sum[i] = 1;//并在结果数组里面标记出来
                }
                else{//如果第二个栈里面没有'('
                    one--;//肯定在第一个栈里面，因为是一一对应的，把他出栈
                    sum[i] = 0;//并在结果数组里面标记出来
                }
            }
            else{//再考虑'('
                if(two < one){//如果第二个栈里面'('的个数比第一个栈少
                    two++;//第二个栈入栈操作
                    sum[i] = 1;//并在结果数组里面标记出来
                }
                else{//如果第二个栈里面'('的个数大于等于第一个栈
                    one++;//第一个栈入栈操作
                    sum[i] = 0;//并在结果数组里面标记出来
                }
            }
        }
        return sum;
    }
};
```