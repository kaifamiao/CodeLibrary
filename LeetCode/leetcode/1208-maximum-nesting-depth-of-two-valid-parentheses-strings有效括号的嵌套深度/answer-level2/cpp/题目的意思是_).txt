# 题目的意思就是:
- 有一个有效的括号字符串，有效的意思是每个左括号都有一个右括号所对应，比如“()()”或“(())”之类的。有这个字符串之后，抽出两个字符串，他们满足 1.仍然是有效的括号字符串。2.深度最低。

- 深度就是指嵌套的括号层数，比如“()”深度为1，“(())”深度为2，这道题不用算深度。
- 现在就围绕有效和深度最低来想一种策略，因为每个左括号必有一个右括号与之对应，此时遇到第一个左括号，把它和它的右括号放到第一个字符串里，然后遇到第二个左括号，把它和它对应的右括号放到第二个字符串里。直到所有括号都分配完了两个字符串就满足上面的两个要求。
- 如何进行分配呢，你可以画几个括号，起始坐标用0表示，如果当前左括号index为偶数，那么它对应的右括号为奇数，如果当前左括号index为奇数，它对应的右括号为偶数。因为一旦对应左括号的右括号出现了，那么中间肯定有n对匹配的括号(n可以为0)，这样一个数加偶数再加1奇偶肯定变化。
- 用一个和括号字符串等大的数组，它的值为0或者1，表示当前括号被分给第一个字符串还是第二个字符串。遍历括号字符串，左括号按照自身index的奇偶来分配到0或1，右括号和对应的左括号index奇偶颠倒，所以自身索引加1的奇偶性来分配到0或1。
## 补充一点
- 对于相邻的括号对，对深度的增加没有什么影响，比如“()()()”。
- 对于连续的左括号，对深度增加会有影响，比如“((()))”或"(()())"。连续的左括号的index奇偶交替，所以就可以交替的放入两个字符串里，因此可以保证两个字符串的深度不会超过1，保证最大深度最低。
```cpp
class Solution {
public:
    vector<int> maxDepthAfterSplit(string seq) {
        vector<int> ans( seq.size(), 0 );

        for ( int i = 0; i < seq.size(); ++i ) {
            if ( seq[i] == '(' )
                ans[i] = ( i & 1 );
            else
                ans[i] = ( ( i + 1 ) & 1);
        }

        return ans;
    }
};
```