1、题目给出的seq是个有效的括号，就像写代码的时候‘(’和‘)’是对等的，就是能编译成功的那种括号组合
2、题目那么长，实际上能表达的意思就是把seq分成2组，A组和B组，并且使他们各自的嵌套数最相近
3、我们知道每个 ( 对应一层嵌套，那么怎样才能让A B的嵌套层数最相近呢？
这就像一堆苹果，A B小孩分（不识数的哈），要求最平均的分苹果,那就是给A一个，再给B一个，然后再给A，再给B一个，最后就能出来最平均的分法了
在这个题目也一个，左往右遍历seq，遇到 (,先给个A，下一个再给B，一直循环下去就能得到嵌套层数最相近的了

肯定会先遇到 (，假设A的是0(实际看着示例来着)，那把vec第一个值设为0
第二个遇到的还是 （，这个时候需要给B了，那就把vec的第二个值设为1
第三个遇到的是 ），这个 ）肯定的跟B一对的，将vec的第三个值也设为1
。。。
。。
。
end
最后就能得到全是0和1的返回值vec。


```
class Solution {
public:
    vector<int> maxDepthAfterSplit(string seq) {
	//肯定会先遇到 (，假设给A的是0，实际看着示例来着
	int d = -1;
	vector<int> ret;
	for (char& c : seq)
		//遇到第一个 ( 
		if (c == '(') {
			++d;
			ret.push_back(d % 2);
		}
		else {
			ret.push_back(d % 2);
			--d;
		}
		return ans;
    }
};
```
