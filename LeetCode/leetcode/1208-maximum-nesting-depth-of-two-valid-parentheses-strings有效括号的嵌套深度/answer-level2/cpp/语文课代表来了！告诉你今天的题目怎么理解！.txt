大家反馈看不懂题目，所以今天题目已经被修改了，下面以最新题目为讲解。

# 题目讲解

题目已经讲解了“有效括号字符串”和“嵌套深度”，相信大家都能理解。主要的是“划分规则“和”返回结果“没懂。

## 划分规则讲解

已知输入是个“有效括号字符串”，现在要把输入“分成两个不相交的有效括号字符串”。其实就是把输入字符串划分成两个有效括号字符串 A 和 B。

题目说的“不相交”有点多余，就像给两个小朋友分糖果🍬，肯定不能把一个糖果🍬同时分给两个小朋友啊。题目就把这种分配方式叫做“不相交”。

## 返回结果讲解

返回结果是要求只包含 0 或者 1 的数组，标记了每个 `(` 或者 `)` 应该划分给 A 或者 B。

如果一个字符划分给 A 那么就把字符对应的输出为 0，如果划分给 B 那么就把字符对应的输出为 1.

# 解题方法

题目要求划分成两个有效括号字符串的深度最小，那么只需要让每个有效括号字符串的深度都尽可能低，即 A 和 B 的最大括号嵌套的深度应该最低。所以我们要使这两个字符串的括号深度尽可能均匀。

从左到右遍历字符串，需要知道 A 和 B 加在一起总的**未补全的左括号**的数目，让这些**未补全的左括号**尽量平分给 A 和 B。

所以，重点就是 A 和 B 根据总的**未补全的左括号**轮流认领新的左括号就行了。

具体做法：

1. 遇到左括号，如果**未补全的左括号**个数是奇数，把新的左括号给 A, 如果**未补全的左括号**个数是偶数，把新的左括号给 B。并且会让未补全的左括号数目加一；
2. 遇到右括号，右括号属于A或者B呢？和最后一个左括号分配给A或者B一致。并且会让未补全的左括号数目减一；


看下题目的示例：

示例 1：

    输入：seq = "(()())"
    输出：[0,1,1,1,1,0]

![image.png](https://pic.leetcode-cn.com/d8528792137863698581438c6b507c3df1ebeafe064eb210769f6a115319e0a7-image.png)


把输入分成了两个字符串，红色的 A 和 蓝色的 B。这样划分之后红色的深度是 1， 蓝色的深度也是 1. 如下图所示。
![image.png](https://pic.leetcode-cn.com/6fd888ae2f278a76bfc15fd4d48e1e9b8dee51a16f97d66c10f8bb3233985cbe-image.png)

示例 2：

    输入：seq = "()(())()"
    输出：[0,0,0,1,1,0,1,1]

![image.png](https://pic.leetcode-cn.com/72185f33ade41690f82917ee0d96718a36d7483bca64dab18b2a49c38c18b5a3-image.png)


把输入分成了两个字符串，红色的 A 和 蓝色的 B。这样划分之后红色的深度是 1， 蓝色的深度也是 1. 题目的输出只是其中一种结果，下面两种划分分式都可以通过题目测试。如下图所示。
![image.png](https://pic.leetcode-cn.com/0f33a2cefe323eed4eacdb13c67ad0eb87f5cdc2644ea045589fb9bffc440d6f-image.png)

# 代码

根据上面的分析，我们不需要使用栈结构，只需要记录**当前未补全的左括号数目**就知道应该把 A 和 B 分配给谁了。

代码注释很详细，相信你一定能看懂。

C++代码如下。

```cpp
class Solution {
public:
    vector<int> maxDepthAfterSplit(string seq) {
        const int N = seq.size();
        // 结果
        vector<int> res(N, 0);
        // 未补全的左括号数
        int count = 0;
        // 当前遍历到的结果的位置
        int pos = 0;
        // 遍历每个字符
        for (char c : seq) {
            if (c == '(') {
                // 未补全的左括号数增加了
                count ++;
                // 如果未补全的左括号数是奇数，当前新的左括号分配给A，结果中写0；
                // 如果未补全的左括号数是偶数，当前新的左括号分配给B，结果中写1；
                res[pos] = 1 - count % 2;
            } else {
                // 右括号属于A或者B呢？和最后一个左括号分配给A或者B一致
                res[pos] = 1 - count % 2;
                // 未补全的左括号数减少了
                count --;
            }
            // 结果的位置跟当前遍历到的字符相一致
            pos ++;
        }
        return res;
    }
};
```

## 欢迎关注[负雪明烛的刷题博客](https://blog.csdn.net/fuxuemingzhu)，leetcode刷题800多，每道都讲解了详细写法！

**重要**：力扣每日一题活动建群啦，一起监督和讨论，我自建监督网址：[http://group.ojeveryday.com/#/check](http://group.ojeveryday.com/#/check)，加入方式可以在监督网址中看到。

![image.png](https://pic.leetcode-cn.com/cddebf5d29d0715c42576d230c0867cecfc8cd672f1e22cf6bb77061dcfe1a88-image.png)