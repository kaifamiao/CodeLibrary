先上代码
```
class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        ans = []
        d = 1        #可以是1也可以是0，因为本质是分类，%2不影响
        for c in seq:
            if c == '(':
                d += 1
                ans.append(d % 2)
            if c == ')':
                ans.append(d % 2)
                d -= 1
        return ans
```
先解释 %2,实际上 %2创建了一个如下推栈  d _________ 2

+1 则成为            ______d____2        此时%2 等于1 

此时可以 +1 或者 -1

在-1时候 _____d_____2退回 d_________2    此时%2 等于0

+1 再 +1 则成为 **推满**      ___________d   此时%2 等于0

我们希望-1的情况时，先匹配而不是直接退0，即遇到()时
（ ）
1  1
在遇到连续两个括号(( 时
（（
 1 0
所以我们将append写在d -= 1前
**在遇到）时直接延用上一个NUM，然后再做退栈处理。**
这样在遇到( ( 时候 正确地作 1 0分配（**两个相同 +1 +1 则推一栈，推一栈NUM就变化**）

在遇到 ( )时，也能正确 1 1，同时退回0点（**两个不同的 +1 -1 ，退一栈，但在退一栈前赋值这样NUM不变化**）
但是( ) ( 的第三个依然推不满！ 依然为1   即隐式退栈（inexplicit）
 
这样就把如果有（）（）（）（）的重复杜绝了，并且时刻准备在出现（（时候进1，即正确的分层并且做好了完美的统计。