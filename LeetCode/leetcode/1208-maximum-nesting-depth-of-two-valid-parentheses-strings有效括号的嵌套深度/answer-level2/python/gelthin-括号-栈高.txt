### 解题思路
看了标签是 贪心和二分，但似乎 二分不可能啊


#### 参考了官方题解的解法 1
本质还是对一个左括号 '(', 考虑其前面又多少个未被匹配的左括号（被匹配了的左括号不用处理），然后这些个左括号相邻两个需要分别分配给 A 和 B.

#### 官方题解的第二种解法甚至都不用记录栈的高度，
直接可以通过当前'(' 的下标来判断应该赋值给 A 还是 B, 而对')', 也是可以直接通过其下标来判断是否应该赋值给 A 还是 B

+ 设对一个左括号 '(', 其前面有 a 个左括号， b 个右括号，(a>= b), 那么，其下标应该是 ind = a+b = (a-b) + (b + b)
也就是说其前面有 a-b 个未被配对的左括号，如果我们要求第 1 个未被配对的左括号赋给A(0), 那么第2个赋给B(1), 那么只需要判断奇偶性，以及第一个是奇还是偶即可。这个应该赋给 (a-b)%2 = (a-b+2b)%2 = ind%2

+ 对右括号则可以同样分析。设其前面有 a 个左括号， b 个右括号，(a>=b+1), 那么，其下标应该是 ind = a+b = (a-b) + (b + b)现在其应该和最后一个左括号分配给同样的 A 或 B, 虽然不知道最后一个左括号的下标，但知道其前面必然有 a-b-1 个未被匹配的左括号， 那么其应该赋给 (a-b-1)%2， 那么这个右括号也应该赋给 (a-b-1)%2 = (ind-1)%2

这里就是有一点难想清楚：
+ (left()), 设 left 是一个已经完成了全部匹配的子串， 那么 left 后的()是与 left 毫不相干的。


### 代码

```python3
class Solution:
    def maxDepthAfterSplit(self, seq: str) -> List[int]:
        # 考虑 (left)right
        # 将 (left) 装入一个栈之后，相邻两个左括号分别赋给 A, B, 这恰好可以使用栈的高度来判断       
        # 当然也许这里 left 可以再分， ((left1)left2) 这里可以处理完 (left1) 再处理 left2
        # 通过栈的高度可以很好处理
        ans = []
        d = 0 # 使用一个变量 d 来模拟栈, 记录栈的高度
        for x in seq:
            if x == '(':
                d += 1
                ans.append((d+1)%2)  # 为了使 1,0 与实例预期结果对应
            else:
                ans.append((d+1)%2)
                d -= 1
        return ans

```