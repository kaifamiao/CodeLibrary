### 解题思路
#写给自己，如有问题欢迎指正#
首先明白基本的概念，单调栈是指数组从栈中弹出的顺序是单调递增或者单调递减的。
这道题目可以简单理解为：对于当前成员，找到下一个比自己大的成员。
当我们使用单调栈时，则如果后面的成员比前面的成员大，会把前面的成员从栈里面弹出。先被弹出栈的成员是小成员，因此是递增单调栈。

单调栈的过程：
1. 栈为空，73入栈。
2. 判断74，74比73大，满足“温度升高”条件，等效于在该时刻找到了对于73的最低升高温度的判断，因此**74触发了73的弹出**，此时二者的下标差也表示了73等待温度升高经过的天数，把结果存入73对应的位置。
74把73弹出后，栈空，74入栈。
3. 判断75>74, 74被75触发弹出，75和74的坐标差为经过的天数。75入栈。
4. 71<75, 71入栈。
5. 69<71, 69入栈。
6. 72>69, 72触发了对69的弹出，72和69的下标差表示69等待温度升高的天数1天。栈顶元素更新为71。72>71,72触发了对71的弹出，二者差值写入71对应数组。栈顶元素更新为75，75>72, 72入栈。
7. 76>72,把72弹出，更新72对应的天数。76>75,把75弹出，更新75的天数。栈空，76入栈。
8. 73小于76，入栈。
9. 全部元素判断结束后，最后两个元素76和73没有被人弹出，因此没有符合要求的条件，即为0。

声明一个数组作为栈；stack[0]表示栈底
top = 0的时候表示栈为空
栈顶元素则为stack[top - 1]; top指向当前栈顶元素的下一个数组位置
数组中存放的应该是温度对应的序号值，不是真正的温度值。

### 代码

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
 // 声明一个数组作为栈；stack[0]表示栈底
 // top 指向0的时候表示栈为空
 // 栈顶元素则为stack[top - 1]; top指向当前栈顶元素的下一个数组位置
int* dailyTemperatures(int* T, int TSize, int* returnSize){
    int *stack = (int *)calloc(TSize, sizeof(int));
    int top = 0;
    int *res = (int*)calloc(TSize, sizeof(int));

    stack[top++] = 0; // stack[0] = 0; top++;
    for (int i = 1; i < TSize; i++) {
        // 1.当栈顶元素大于需要判断的元素时，将新元素入栈
        if (T[stack[top - 1]] >= T[i]) {
            stack[top++] = i; // stack[top] = new; top++;
        } else {
            // 栈非空时，把所有栈中比新元素小的元素都弹出
            while (top > 0 && T[stack[top - 1]] < T[i]) {
                res[stack[top - 1]] = i - stack[top - 1];
                top --;
            }
            stack[top] = i;
            top++;
        }
    }
    *returnSize = TSize;
    return res;
}

```