我们从暴力搜索算法开始，寻找可以优化的点：
    1、Brute Method：对于每个给定的i (0 < i < TSize), j从i + 1开始往后搜索，直到找到第一个T[j]大于T[i]的元素，并返回。
       因此算法的复杂度为O(n^2)。
    2、暴力搜索算法可以优化的地方在于：**对于每个i能否快速找到后续第一个比T[i]大的元素**。
       我的思路是：从后往前做，建立两个数组：res[i]保存结果，index[i]代表从i + 1到TSize - 1中第一个比T[i]大的元素T[j]索引。
       初始时，有res[TSize - 1] = 0,index[TSize - 1] = -1 (-1为特殊标记，代表后续没有元素比T[i]大)。
    3、后续流程如下：
```
        for (int i = TSize - 2; i >= 0; i--) {
            for (int j = i + 1; j < TSize; ) {
                if (T[j] > T[i]) {   //找到第一个大于T[i]的元素T[j],记录结果
                    index[i] = j;
                    res[i] = j - i;
                    break;
                } else {             //T[j]小于T[i]时继续往后找，不过相比于暴力方法(一个接一个搜索)，该处会发生跳跃，优化寻找时间
                    if (index[j] == -1) {  //搜索了整个数组，也没找到比T[i]大的元素，返回结果0
                        index[i] = -1;
                        res[i] = 0;
                        break;
                    } else {
                        j = index[j];  //T[j]小于T[i],所以可以往后赵到第一个比T[j]大的预算，即对应于index[j]。
                    }          
                }
            }
        }
```
      演示案例：
        T   73 74 75 71 69 72 76 73
        i   0  1  2  3  4  5  6  7
      index  1  2  6  5  5  6 -1  -1
       res    1  1  4  2  1  1  0   0  = index[i] - i