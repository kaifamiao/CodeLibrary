提交结果：
执行用时 :6 ms, 在所有 Java 提交中击败了98.61% 的用户
内存消耗 :43.6 MB, 在所有 Java 提交中击败了85.34%的用户

思路：先瞎bb几句，开始我也是没啥头绪，直接暴力笨方法查找，每一次从下一个个开始往后面遍历查找，想都不用想，时间复杂度差得很，差不多应该是n²。但是明显一个中等题不应该这么简单就做出来了，所以开始寻找一个时间复杂度更低的算法，眼睛瞟到温度在30-100之间，脑海里突然就有了个思路。
   举个例子，假设有100天，最后一天的温度是98度，因为初始状态nums【98-30+1】是0，也就是后面没有更高的温度，result【99】==0；此时要更新比98度低的所有温度对应的nums数组为99，表明最近一个比自身温度要高的是第99天，当然nums每次辩题都会更新。然后到倒数第二天，假设他的温度是60度，现在nums【60-30+1】应该是99，所以result【98】==99-98==1，然后更新比60度低的所有温度对应的nums数组为98，一直遍历下去就完事了。


代码：
```
public int[] dailyTemperatures(int[] T) {
        int result[]=new int[T.length];//结果集
        int nums[]=new int[71];//记录下一个比这个温度大（30加上索引值）的是第几天，初始值为0
        for (int i = T.length-1; i >=0; i--) {//从后面往前面遍历
            if (nums[T[i]-30]==0)result[i]=0;//后面都不比这天温度高
            else result[i]=nums[T[i]-30]-i;//后面有比这天温度高的，并且最近的一天记录在nums数组中了
            for (int j = 0; j < T[i] - 30; j++) {
                //更新nums数组，所以比当天温度低的温度值对应的nums内容都更新为当天
                nums[j]=i;  
            }
        }
        return result;
    }
```
