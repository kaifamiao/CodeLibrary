首先看数据范围2 * 10^9，一定是不能暴力遍历判断了，那就考虑一下数据预处理，由样例可知，首先一位数都符合规则，即一位数都是步进数，然后有
10,12|21,23|32,34......||98,101
10 = 1*10 + 1%10 - 1 
12 = 1*10 + 1%10 + 1
21 = 2*10 + 2%10 - 1
23 = 2*10 + 1%10 + 1
......
98 = 9*10 + 9%10 - 1

101 = 10*10 + 10%10 + 1
即1---8生成对应的下两个步进数都可以 `i * 10 + i % 10 +/- 1` ,余数为0(从10开始算起)的只有+1，余数为9的只有-1
这样从10开始每10个数里最多有两个数符合规则，大大减少数据个数
下面上代码
```python
def countSteppingNumbers(low,high):
    l = list(range(10))
    i = 1
    while l[i] * 10 + l[i] % 10 - 1 <= high:
        if l[i] % 10 == 9:
            l.append(l[i] * 10 + l[i] % 10 - 1)
        elif l[i] % 10 == 0:
            if l[i] * 10 + l[i] % 10 + 1 <= high:
                l.append(l[i] * 10 + l[i] % 10 + 1)
        elif l[i] * 10 + l[i] % 10 + 1 <= high:
            l.append(l[i] * 10 + l[i] % 10 - 1)
            l.append(l[i] * 10 + l[i] % 10 + 1)
        else:
            l.append(l[i] * 10 + l[i] % 10 - 1)
        i += 1
    # print(l)
    for j in range(len(l)):
        if l[j] >= low:
            m = j
            break
        else:
            m = len(l)
    return l[m:]
```
首先先生成0---最大值范围的步进数，在从中找到最小值的位置，对列表切片，如果找不到大于最小值的数，即范围中没有步进数，返回空列表
在生成步进数的时候除了要注意余数为0和9的特殊情况，还有两种可能
1.`l[i] * 10 + l[i] % 10 + 1 <= high`
这种情况下对应的l[i]一定能生成+/-1，而不超出范围
2.`l[i] * 10 + l[i] % 10 - 1 <= high < l[i] * 10 + l[i] % 10 + 1`
这种情况下只能生成-1

while循环的条件是`l[i] * 10 + l[i] % 10 - 1 <= high`，所以在余数为0的时候需进行判断，为9的时候一定有-1符合范围
