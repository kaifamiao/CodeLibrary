### 解题思路
无论是比较排序O(nlogn)还是计数排序O(max-min)方式，都是基于一个“排序后取奇数位元素的和”这一想法的。
———————————————————————————————————————
关于为什么“取奇数位的和”就可以得到“不同配对方式下sum(min)的最大值”，有很多题友给出了自己的想法。有些是带有贪心思想的，但没有给出“此情况贪心法可以求得全局最优解”的证明；有些是基于数学归纳法的，但是在递推设计方面有些非一般化的设定(比如新增加的2个数比已有数字都大)；多多少少都有些往结论上靠的嫌疑，换句话说在证明过程中用到了结论中的部分信息(循环论证)。

思考了一天多的时间，结合官方题解想到了一种证明方式(并不优雅，但应该是严谨的)，欢迎批评指教；
———————————————————————————————————————
问题重述：将2n个数两两分组为(xi,yi)(i=1,2,...,n)，求不同分组方式下∑min(xi,yi)的最大值？
1、对各种分组方式，交换组内两个数字的位置为(ai,bi)使得ai<=bi，只需求不同分组方式下∑ai的最大值；
2、∑ai最大 <==> ∑ai和∑bi最接近 <==> ∑bi-∑ai = ∑(bi-ai)最小（不要求组间存在大小关系，无条件成立）；
3、将所有数字看做数轴上的点，∑(bi-ai)最小 <==> 数轴上2n个点分为n组，每组两个点组成的线段和最小；
4、如果有4个点组成的两条线段存在重叠，总能重新组合这4个点使得2条线段和变小，从而使得所有线段和变小；
5、在2n个点中任意两点组成的线段不重叠的组合方式是唯一的；（最大值不连第二大必有重叠，依此类推）
结合4和5，问题得证！

### 代码

```java

// 比较排序算法
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int sum = 0;
        for(int i = 0; i < nums.length; i += 2)
            sum += nums[i];
        return sum;
    }
}

// 计数排序算法
class Solution {
    public int arrayPairSum(int[] nums) {
        int[] arr = new int[20001];
        for(int num: nums)
            arr[num + 10000] ++;
        
        int sum = 0;
        boolean hasLeft = false;
        for(int i = 0; i < 20001; i ++)
            if(arr[i] > 0)
                if(hasLeft){
                    sum += arr[i] / 2 * (i - 10000);
                    hasLeft = arr[i] % 2 == 0;
                }else{
                    sum += (arr[i] + 1) / 2 * (i - 10000);
                    hasLeft = arr[i] % 2 == 1;
                }
        return sum;
    }
}
```