### 思路：
        
首先输入的 `abc` 并不对应 `xyz`，首先需要将输入的 `abc` 从小到大排序，排序后的才是 `xyz`，每次移动之后，最小的那个又命名为 `x`，最大的又命名为 `z`,中间的那个命名为 `y`。比如：起初输入 `a=5`,`b=8`,`c=1`,我们将其排序然后依次命名：`x=1`,`y=5`,`z=8`, 我们现在移动 `x=1` 上的石头，将其放到 `6` 上，这时坐标轴有三
个位置分别为：`5`，`6`，`8`,那么最小的那个值 `5` 就命名为 `x`，最大的值 `8` 命名为 `z`,中间的值 `6` 命名为 `y`。下一
次移动我们可以移动 `x=5` 的石头或者 `z=8` 的石头，比如把 `z=8` 的石头放到 `7` 上，此时
`x=5`,`y=6`,`z=7`，发现连续，无法再移动了。
        
        排序后(a<b<c)，目标是使  abc  连续。那么最小移动次数和最大移动次数可分为6种情况：
        <1> abc连续：此时无法移动了，最小移动次数 = 最大移动次数 = 0 
        <2> bc连续，ab不连续(ab要是连续就成了第一种情况了): a  bc, 最小移动次数就是把a移动到b-1    
            位置，这样abc连续，移动次数为1；最大移动次数就是a慢慢的成为b-1，最大移动次数为b-1-a,
            故最小次数为1，最大次数为b-1-a
        <3> ab连续，bc不连续。即: ab   c 类似于<2>，最小移动次数为1，最大移动次数为c-1-b 
        <4> c和b隔一个空位，ab不连续(连续的话就成了情况<3>的特例)，即 a    b c，此时最小移动次数
            的做法是把a移动到b与c的空位上，这样 bac 连续了，因此最小移动次数为1，最大移动次数是，
            a慢慢成为b-1，c慢慢成为b+1(即c往左移动一个),因此最大次数是：b-1-a+1= b-a
        <5> a与b之间隔一个空位，bc不连续。即： a b    c ，类似于<4>，最小次数为1，最大次数为
            c-b
        <6> 除上述五个情况外的剩下的情况，即 a      b       c，最小次数做法是：把a移动到b+1,这时
            成为b,b+1   c，把c移动到b+2,此时 b,b+1,b+2 连续，即最小次数为2，最大次数的做法是：
            a慢慢成为b-1，c慢慢成为b+1，最大次数是：c-1-b+b-1-a = c-2-a

### 代码：
```python [-Python]
class Solution(object):
    def numMovesStones(self, a, b, c):
        """
        :type a: int
        :type b: int
        :type c: int
        :rtype: List[int]
        """
        a,b,c = sorted([a,b,c])        # python特有的赋值方式
        if c-2==b-1==a:                # 第一种情况
            return [0,0]
        elif c -1 == b:                # 第二种情况
            return [1,b-1-a]
        elif b-1 == a:                 # 第三种情况
            return [1,c-1-b]
        elif c-2==b:                   # 第四种情况
            return [1,b-a]
        elif b-2==a:                   # 第五种情况
            return [1,c-b]
        else:                          # 第六种情况
            return [2,c-a-2]
```