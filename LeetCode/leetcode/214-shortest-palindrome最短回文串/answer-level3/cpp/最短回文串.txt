#### 方法一：暴力法 [通过]

**直觉**

根据问题，我们只能在字符串的开头插入字符。因此，我们可以从字符串开头找到最大的回文子串，然后反转剩余的子串并附加到开头。这必然是正确的答案，因为不可能通过在开头插入字符来得到更短的回文。

举例而言: 字符串 $\text{“abcbabcab”}$。从开头找到的最大回文子串是 $\text{“abcba”}$，剩下的部分是 $\text{“bcab”}$。因此要求的字符串是 $\text{“bcab”}$ 的反转（= $\text{“bacb”}$）+ 原字符串（ = $\text{“abcbabcab”}$）= $\text{“bacbabcbabcab”}$。

**算法**

* 创建原字符串 $s$ 的反转，记为 $\text{rev}$。这将用于从字符串开头找到最大的回文子串。
* 从 0 到 $\text{size(s)}-1$ 遍历变量i:
    * 若 $s[0:n-i] == rev[i:]$ (亦即：$s$ 从 $0$ 到 $n-i$ 的子串等于 $\text{rev}$ 从 $i$ 到结尾的子串 g)，则从 $0$ 到 $n-i$ 的子串为回文子串。
    * 我们首先寻找更大的回文子串。这样，一旦得到最大的回文子串，就可以返回结果。


```C++ [solution 1]
string shortestPalindrome(string s)
{
    int n = s.size();
    string rev(s);
    reverse(rev.begin(), rev.end());
    int j = 0;
    for (int i = 0; i < n; i++) {
        if (s.substr(0, n - i) == rev.substr(i))
            return rev.substr(0, i) + s;
    }
    return "";
}
```

**复杂度分析**

* 时间复杂度: $O(n^2)$。
    * 我们遍历了整个字符串 $s$。
    * 在每次迭代中，我们比较了与待比较子串长度成线性关系的子字符串。
    * 因此，总时间复杂度为 $O(n*n) = O(n^2)$。

* 空间复杂度: $O(n)$。这是反转字符串使用的额外空间。

---
#### 方法二：双指针与递归 [通过]

**直觉**

在方法一中，我们通过子字符串匹配（$O(n)$）找到了最大回文子串。如果我们可以减小字符串的大小来搜索子字符串,而是不每次都检查完整的子字符串,就可以使该过程更加高效。

例如字符串 $\text{“abcbabcaba”}$。 考虑两个指针 $i$ 和 $j$。初始化 $i = 0$。$j$ 从 $n-1$ 到 $0$ 迭代，每当 $\text{s[i]==s[j]}$ 时，将 $i$ 增加 1。现在，我们只需要 在$\text[0,i)$ 范围内搜索。这样，我们就缩小了从开头寻找最大回文子串的搜索长度。$\text{[0,i)}$ 必然包括最大回文子串。其正确性证明如下：若字符串全部为回文，则$i$会自增$n$次。若结尾有其他字符，$i$ 会自增回文子串的长度。于是，即使 $\text{[0,i)}$ 并不总是紧界，但它总包含从开头开始的最长回文子串。  

算法的最好情况是整个字符串为回文序列，最坏的情况是类似于 $\text{“aababababababa”}$ 的字符串，其中 $i$ 会达到 12 (你可以自己试试)，这样我们就需要在 [0,12) 范围内检查。同样的，这次会得到 ${i=10}$。这样，每一步只能减少 2 个元素。于是，所需的步数是线性的（$n/2$）。

如算法部分所示，这种长度缩短可以很容易地利用递归完成。

**算法**

$\text{shortestPalindrome}$ 是递归的，使用 $s$ 为参数:

* 初始化 $i=0$
* 从 $n-1$ 到 $0$ 迭代 $j$:
    * 若 $\text{s[i]==s[j]}$，$i$ 自增 $1$
* 若 $i$ 等于 $s$ 的大小，则整个字符串为回文串，返回整个字符串 $s$
* 否则:
    * 返回从 $i$ 到结尾的子字符串的反转 + 对从开头到 $i-1$ 的子字符串进行 $\text{shortestPalindrome}$ 过程 + 从 $i$ 到结尾的子字符串


```C++ [solution 1]
string shortestPalindrome(string s)
{
    int n = s.size();
    int i = 0;
    for (int j = n - 1; j >= 0; j--) {
        if (s[i] == s[j])
            i++;
    }
    if (i == n)
        return s;
    string remain_rev = s.substr(i, n);
    reverse(remain_rev.begin(), remain_rev.end());
    return remain_rev + shortestPalindrome(s.substr(0, i)) + s.substr(i);
}
```

**复杂度分析**

* 时间复杂度: $O(n^2)$。
    * $\text{shortestPalindrome}$ 的每次迭代与子串长度成线性，如前文所言，递归调用最多进行 $n/2$ 次。
    * 设算法的时间复杂度为 T(n)。由于在最坏情况下，每一步字符串都可以分成2部分，我们只使用其中的一部分。因此，时间复杂度可以表示为 $T(n)=T(n-2)+O(n)$。于是，$T(n) = O(n) + O(n-2) + O(n-4) + ... + O(1)$，也就是 $O(n^2)$。

* 空间复杂度: $O(n)$ 额外空间，用于存储 $\text{remain-rev}$ 。

---
#### 方法三：KMP [通过]

**直觉**

我们看到，问题可以归结为从开头寻找最大的回文子串。

熟悉 KMP(Knuth–Morris–Pratt) 算法的人可能会发现，这个问题和 KMP 中的查找表概念十分类似。

*KMP算法概述:*

KMP算法是一个时间复杂度为 $O(n+m)$ 的字符串匹配算法，其中 $n$ 和 $m$ 分别是待匹配文本和字符串的长度。KMP算法的核心是部分匹配表（查找表）$f(s)$。部分匹配表的目的是存储字符串 $b_{1}b_{2}...b_{s}$ 中正确前缀的长度，使得该前缀同时也是 $b_{1}b_{2}...b_{s}$ 的后缀。该表对匹配十分重要，当我们试着对 $b_{1}b_{2}...b_{n}$ 匹配一个文本串，且已经匹配了前 $s$ 个位置，但此时匹配失败，则 $s$ 的部分匹配表值就是 $b_{1}b_{2}...b_{n}$ 中可能从此处继续匹配的最长前缀。这样，我们就不必从头开始匹配，而是可以从已经匹配的前缀继续。

生成部分匹配表的算法简单而直观，如下所示：

```
f(0) = 0
for(i = 1; i < n; i++)
{
	t = f(i-1)
	while(t > 0 && b[i] != b[t])
		t = f(t-1)
	if(b[i] == b[t]){
		++t
	f(i) = t
}
```

* 这里我们首先令 $f(0) = 0$，这是因为此时没有可用的前缀。
* 接下来，从 $1$$ 到 $n-1$ 迭代 $i$:
    * 令 $t=f(i-1)$
    * 每当 t>0 且 $i$ 处的字符与 $t$ 处的字符不匹配，令 $t=f(t)$，表示匹配失败，必须考虑更短的前缀（这里是 $b_{f(t-1)}$），直到匹配成功或 t 达到0。
    * 若 $b_{i}==b_{t}$，t 自增 1
    * 令 $f(i)=t$

下图展示了算法的过程:

![image.png](https://pic.leetcode-cn.com/3b131fecf94c50ee7ed6fc29385ff6c354e5e81157f56debfdf6092fde16bd47-image.png){:width=600}
{:align=center}

*等等！我明白了！！*

在方法一中，我们反转了原始字符串 $s$ 并存储为 $\text{rev}$。然后从 $0$ 到 $n-1$ 迭代 $i$，判断 $s[0:n-i] == rev[i:]$。仔细考虑一下这条语句，如果将 $\text{rev}$ 连接到 $s$ 上，那么这条语句其实就是找到与后缀相同的最长前缀。赢了！

**算法**

* 利用 KMP 算法的部分匹配表声场算法。
* 创建新字符 new_s = s + "#" + reverse(s)，并使用该字符串进行部分匹配表生成。
  	* 中间的 "#" 是必要的。如果没有#，两个字符串可能会发生混淆，造成错误的答案。举例而言，字符串 $\text{“aaaa”}$。如果不在中间插入 "#"，新字符串会是 $\text{“aaaaaaaa”}$， 最长前缀大小会成为 7，这显然是错的。因此，中间的分隔符是必要的。
* 返回最大回文子串后的子串的反转（长度为 n-f[n_new-1]）+ 原字符串 $s$

```C++ [solution 3]
string shortestPalindrome(string s)
{
    int n = s.size();
    string rev(s);
    reverse(rev.begin(), rev.end());
    string s_new = s + "#" + rev;
    int n_new = s_new.size();
    vector<int> f(n_new, 0);
    for (int i = 1; i < n_new; i++) {
        int t = f[i - 1];
        while (t > 0 && s_new[i] != s_new[t])
            t = f[t - 1];
        if (s_new[i] == s_new[t])
            ++t;
        f[i] = t;
    }
    return rev.substr(0, n - f[n_new - 1]) + s;
}
```


**复杂度分析**

* 时间复杂度: $O(n)$。
    * 内层 while 循环的每一次迭代中，$t$ 都会减小，直到 t 达到 0 或匹配成功。此后，t 会自增。因此，在最坏的情况下，t 会被减少 $n$ 次，增加 $n$ 次。因此，该算法为线性复杂度，最多 $(2 * n) * 2$ 次。

* 空间复杂度: $O(n)$。这是反转字符串和拼接字符串的额外空间。