### 解题思路

我们可以先设定一组数据进行模拟，找出其中的规律。
假设一组数据为：1376542，则其下一个为1423567，怎么得来的呢？
可以看到1376542的数字**从后往前**看都是依次增大，直到3位置才不一样，开始减少；
然后在从**后面往前**找到一个比3大的第一个数；
交换这个不一样的3和第一个比他大的这两个数，最后将原数组中，3后面的数倒置，就能得到结果。
1 3 7 6 5 4 2
1 4 7 6 5 3 2
1 4 2 3 5 6 7

可以按照上述思路编写代码，数组问题考虑使用双指针，一个定义为最后一个的下标，记为j(用来第二次从后往前找)，最后一个定义为倒数第二个的下标，记为i（用来第一次找到减少的值）。
第一次从后往前迭代找到第一个减少的数，即nums[i]。然后再从后面往前迭代找到**比第一个减少的位置的数大的数**,即nums[j]，交换这两个数，然后将i后面的值都进行倒置，即为结果。


### 代码

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {

        if(nums.size()<=1)//为空或只有一个值，直接返回
        {
            return;
        }
        
        int i = nums.size()-2;//i用来从后往前找到第一个递减的值
        int j = nums.size()-1;//j用来从后往前找到第一个比nums[i]大的值

        //因为需要相邻nums[i]和num[i+1]两个数比较，所以作为数组下标的i的取值是0-nums.size()-2
        while(i >= 0 && nums[i] >= nums[i + 1])//迭代找到第一个递减的值
        {
            i--;
        }

        if(i >= 0)//若i为0，则当前值为最大，返回最小的值
        {
            while(j >= 0 && nums[j] <= nums[i])//迭代直到找到第一个比nums[i]大的数
            {
                --j;
            } 
            swap(nums[i],nums[j]);//找到后交换
        }

        #if 0
        for (int k = i + 1; k < (nums.size()+i+1) / 2; k++)//倒置，及找到中心点将两边交换
		{
            swap(nums[k], nums[nums.size()+i - k]);
        }
        #else
        reverse(nums.begin() + i+1,nums.end());
        #endif

    }
};
```