### 解题思路
注释和代码已经写的很详细了，请直接参考即可

### 代码

```java
class Solution {
    // 题干的意思是：找出这个数组排序出的所有数中，刚好比当前数大的那个数
    // 比如当前 nums = [1,2,3]。这个数是123，找出1，2，3这3个数字排序可能的所有数，排序后，比123大的那个数 也就是132
    // 如果当前 nums = [3,2,1]。这就是1，2，3所有排序中最大的那个数，那么就返回1，2，3排序后所有数中最小的那个，也就是1，2，3 -> [1,2,3]
    // 但是暴力法并不是最优解，复杂度太高
    // 应该采用尾指针从右向左寻找
    // 一个例子
    // 1 2 3 5 1 1
    // 经过观察的答案是
    // 1 2 5 1 1 3
    // 变化方法是从尾部开始向前找，过程如下：
    // 找到第一个下降的数字，和其后半部分刚好大于他的数字交换
    // 1 2 3 5 1 1
    //           ^ ----------没找到
    // 1 2 3 5 1 1
    //         ^   ----------1等于最后一个，没有呈现下降的趋势，不动
    // 1 2 3 5 1 1
    //       ^     ----------5更大了，不动
    // 1 2 3 5 1 1
    //     ^       ----------3比5小，呈现下降的趋势了
    // 1 2 5 3 1 1
    //             ----------交换3和5
    // 1 2 5 3 1 1
    //             ----------交换了之后把3 1 1整体改变顺序，改为 1 1 3，得到了最终答案
    //             ----------之所以能够整体改变顺序，是因为后面的本来就是排好序的，换走的仅是一个最小值的值
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        // 找到第一个下降趋势的元素
        while (i >= 0 && nums[i + 1] <= nums[i]) {
            i--;
        }
        // 找到i后面刚好大于位置i的元素
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            // 交换位置i和位置j的元素
            swap(nums, i, j);
        }
        //  反转位置i+1之后的元素
        reverse(nums, i + 1);
    }

    private void reverse(int[] nums, int start) {
        int i = start, j = nums.length - 1;
        while (i < j) {
            swap(nums, i, j);
            i++;
            j--;
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```