### 解题思路

**一：理解题意**

参考了评论区的说明才看懂题目…所以解释下题意，不妨把数组里的数按顺序合在一起，比方说[1,3,2]就可以看作是132这个数，那么下一个排列的定义就可以理解为：**给定一个数的组成元素，找到比这个数大的且最接近的数**，对132来说，那就是213，即[2,1,3]。如果是[3,2,1]这样的降序数组，那其实对应的321已经是最大的数了，因此题目规定回到最小的数，就是123，可以看作是一个循环。如果按顺序列出所有的排列的话就是，123，132，213，231，321，再回到123……一直循环



**二：分析题意**

看成是数之后，就方便多了，题目也转换为，如果给定一个数，要求用其组成元素，让你找到比这个数大的且最接近的数。

拿2431和1324举例，我们肯定能立刻给出3124和1342的答案，但是这个思路是如何的呢？

既然是要求最接近，那么肯定是从数的最低位开始往高位观察，1324的话就是这种情况，只要把24调换成42就行了，但是对于2431，就要改动到最高位，差别就在于在保留最高位不动的情况下，对于低位的31，431这样从大到小的降序排列来说，都已经是最大的值了，要改变为更大的数，只能从更高位去改(把这种很自然的思考过程用语言描述真是一件费劲的事，感觉越说越复杂了…真是让人头大…)嗯…那么…总而言之，从最低位开始寻找或者说观察，如果数字排列从左到右一直都是符合从大到小的降序，那么我们就要向更高位来考虑，直到降序排列出现改变，对于52431来说，这个拐点就在2，4，我们显然要把2替换掉，考虑到要是最接近的大的数，那就从其低位的431中筛选出比2大的那个最小值，即3，那么52变成53，由于要最接近，剩下的3位就应该是选择构成最小数的排列方式，即升序排列124，所以结果就是53124。

最后，如果一直是降序排列到数组结束，这就是能组成的最大的数的排列了，直接反过来改成升序排列就行了。



**三：具体实现**

参照上面的无敌详细的思考过程，具体的解题思路就是：从后往前遍历数组，会出现两种情。

情况1：整个数组是降序排列的，那么就直接对数组做升序排列。

情况2：如果数组不是严格从大到小降序的，则会出现nums[i] 比nums[i-1]大的情况，那么就需要（1）在nums[i:]中找出比nums[i-1]大的最小的元素进行交换。（2）完成交换后，再把nums[i:]按从小到大进行排序即可。

对于情况二，（1）由于在nums[i]>nums[i-1]情况出现之前，nums[i:]部分的数组是降序排列的，所以我们可以按从末尾nums[-1]往nums[i]的顺序，与nums[i-i]的值比较大小，只要有值满足比nums[i-1]大，就交换值，并跳出循环。（2）对于nums[i:]的排序，实际上就是对nums[i:]进行倒序处理，为什么这样说呢？假设与nums[i-1]交换的值为nums[z],nums[z]大于nums[i-1]，且nums[i-1]一定是小于nums[z]左边的数，大于nums[z]右边的数，因此在交换前后，nums[i:]都是降序的，在交换之后，因此完成升序排列只需要进行倒序操作就可以了。

![图片.png](https://pic.leetcode-cn.com/ac607a2d36fcc18f789f569e7729e3161ac9f173bc888ea5e24c103bcc830860-%E5%9B%BE%E7%89%87.png)




ps. 写的过程中数次感到意识模糊与表达无力，啊…这大概就是语言表达与逻辑思考结合的魅力所在吧…不管怎么样，总算是硬着头皮写完了…这可能是过于详细到适得其反的典型…

### 代码

```python3
class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        #从后往前遍历数组
        for i in range(len(nums)-1,0,-1):
            if nums[i] > nums[i-1]:
                #从后往前找nums[i:]中，比nums[i-1]大的最小的数并完成交换
                for j in range(len(nums)-i):
                    if nums[i-1] < nums[-1 -j]:
                        nums[i-1], nums[-1 -j] = nums[-1-j], nums[i-1]
                        break
                #对nums[i:]进行倒序交换
                for k in range((len(nums)-i)//2):
                    nums[i + k], nums[-1-k] = nums[-1-k], nums[i+k]
                return    
        #如果是最大排列，直接对nums升序排列
        nums.sort()
```