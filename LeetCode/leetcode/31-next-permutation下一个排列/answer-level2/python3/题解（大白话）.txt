### 解题思路
首先，下一个排列是如何来的呢？
按照一般思路
12345
12354
12435
12453
.....
**序列 = 前几位 + 数字s +最长不减序列t**
需要操作的部分 = 数字s +最长不减序列t

我们通常是将位数低的几位重新排列（位数越高，大的越多），找到稍微比他大一点的排列，也就意味着我们只需要找到尽可能低的位数中，可能存在的更大一点的数字。

假设有 12345 的排列，我们当然从 个位->十位->百位来寻找是否有稍微大一点的排列

那么就可以从后往前遍历，遍历到每个位置i，
1.当前数字比后一个数字大或相等，则nums[i:]仍为不增序列，继续向前遍历
2.当前数字比后一个数字小，则只需要改变[i:]为某种顺序即可得到下一个排列

问题转化为 -> 后i位数字是否为不减序列
找到首个不减序列后,如 12354 的不减序列为 354
因为54是递减序列，已是最大排列，当然是最大排列，则下一个排列需要将354的首位稍微提高，即必比3大最小的数字->4，
交换首位和比他稍大的数字，3和4 变为453
交换首位后，后面的位数自然需要变为最小的排列即完全递增序列
因为之前的3后面已是递减序列，因此直接倒置即可
解题中为了方便也可以先倒置后面的，再找到稍大的数字交换


### 代码

```python3
#交换L数组的i,j 位置
def swap(L, i, j):
    a = L[i]
    L[i] = L[j]
    L[j] = a

#将L的后 n位倒置
def swap1(L, n):
    l = len(L)
    for i in range(int(n/2)):
        swap(L, l-n+i, l-1-i)

class Solution:
    def nextPermutation(self, nums: List[int]) -> None:
        """
        Do not return anything, modify nums in-place instead.
        """
        l = len(nums) #l的长度
        for i in range(l-1): 
            # 找到前面比后面一个小的数字
            if nums[l-1-i] - nums[l-1-i-1] <= 0:
                pass
            else:
                swap1(nums,i+1)
                s = l-1-i
                for j in range(i+1):
                    if nums[s-1] <nums[s+j]:
                        swap(nums,s-1,s+j)
                        return 
        swap1(nums,l)

```