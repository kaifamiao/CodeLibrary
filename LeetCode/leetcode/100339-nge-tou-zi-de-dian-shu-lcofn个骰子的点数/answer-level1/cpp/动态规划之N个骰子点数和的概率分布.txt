# 1. 思路
## 1.1 动态规划的思路
这道题一开始除了暴力枚举，其实没有什么思路，但是通过手算n等1、2、3的情况还是可以发现一些规律的。
|点数和|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|n=1|1|1|1|1|1|
|n=2||1|2|3|4|5|6|5|4|3|2|1|
|n=3||0|1|3|6|10|15|21|25|27|27|25|21|15|10|6|3|1|
记$S_n^i$为当有n个骰子点数和为i的可能数，则有:
$$S_n^i = \sum_{j=i-6}^{i}S_{n-1}^{j}, n>1$$
推导出这个迭代方程，就很容易会想到使用动态规划来解决这个问题，边界是当n=1。
但是这个迭代方程有一个问题，就是当i<7时，$S_{n-1}^{j}$中的点数和非法，为了解决这个问题，对上述表格进行必要补0，得到:
|点数和|0|0|0|0|0|1|2|3|4|5|6|7|8|9|10|11|12|
|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|-|
|n=1|0|0|0|0|0|1|1|1|1|1|1|0|0|0|0|0|0|
|n=2|0|0|0|0|0|0|1|2|3|4|5|6|5|4|3|2|1|
这样迭代方程也适用于边界情况了。
## 1.2 使用滑动窗口优化$S_n^i = \sum_{j=i-6}^{i}S_{n-1}^{j}$
相比于直接计算6个数的和，使用滑动窗口可以降低一部分计算量。
# 2. 代码思路
1. 初始化二维数组cnts[N][M],N为骰子个数，M为N个骰子的最大点数+5
2. 使用状态转移方程，遍历迭代n个骰子每种点数和的个数,n>1
3. 当sum<=0时，则说明后面的迭代已经没有必要，参与计算的都是0
4. 根据个数计算出概率
# 3. 代码
```c++ []
class Solution {
public:
    vector<double> twoSum(int n) {
        int cnts[11][71] = {0,0,0,0,0,1,1,1,1,1,1};
        for(int i=1; i<n; i++){
            int sum=1;
            for(int j=i+5; sum>0; j++){
                cnts[i][j] = sum;
                sum-=cnts[i-1][j-6];
                sum+=cnts[i-1][j];
            }
        }
        int* begin = cnts[n-1]+n+4;
        int* end = cnts[n-1]+6*n+5;
        vector<double> answer(begin, end);
        n = pow(6, n);
        for(auto& e : answer){
            e /= n;
        }
        return answer;
    }
};
```
# 4. 总结
这是也到比较经典的动态规划题，但是一开始比较难找到切入点。这道题的方法，就是先手算下n较小的具体情况，找找规律，找到状态转移方程后，问题就好解决了。