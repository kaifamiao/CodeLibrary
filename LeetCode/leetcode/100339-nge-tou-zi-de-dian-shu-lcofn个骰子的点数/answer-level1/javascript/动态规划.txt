## 思路
通过动态规划来解决，已知若是1个骰子，则6面出现的概率都是一样的，即1/6  
若是两个骰子，则可以在原来1个骰子的基础上进行概率计算，已知两个骰子的排列为
```
1+1
1+2 2+1
1+3 2+2 3+1
1+4 2+3 3+2 4+1
1+5 2+4 3+3 4+2 5+1
1+6 2+5 3+4 4+3 5+2 6+1
2+6 3+5 4+4 5+3 6+2
3+6 4+5 5+4 6+3
4+6 5+5 6+4
5+6 6+5
6+6
```
这里将上面的单个排列看做是`sum = x + y`，`x`为一个骰子【也可以理解为新的一个】甩出来的点数，`y`为前几个骰子甩出来的和，这里由于总的骰子数为2，因此前几个骰子实际上就是上一个骰子。   
其计算公式为`dp[ sum ] = dp[ sum ] + dp[ y ] * 1/6`。由于`x`只能甩出`1~6`个数，因此概率肯定是`1/6`，因此需要匹配的`dp[ y ]`需要乘上`1/6`。由此不断叠加得到`n`个骰子甩出来的概率。

## 代码
```javascript
/**
 * @param {number} n
 * @return {number[]}
 */
var twoSum = function(n) {
  let dp = [ 1/6, 1/6, 1/6, 1/6, 1/6, 1/6 ];
  for (let i = 2; i <= n; i++) {
    const temp = [];
    for (let j = 1; j <= 6; j++) {
      for (let k = 0; k < dp.length; k++) {
        const sum = k + j - 1;
        temp[ sum ] = (temp[ sum ] || 0) + dp[ k ] * 1/6;
      }
    }
    dp = temp;
  }
  return dp;
};
```