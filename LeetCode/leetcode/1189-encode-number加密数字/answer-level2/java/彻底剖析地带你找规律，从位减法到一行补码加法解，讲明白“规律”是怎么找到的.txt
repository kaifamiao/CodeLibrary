
# 找规律
既然是找规律，那么就老实的一个一个列下来，先不去做偶然的发现

0 的时候 0位字符串， 只能表示从0开始的1个数字
1 的时候 1位字符串 “0”，可以表示从1开始的2个数字
2 的时候 1位字符串 “1”，可以表示从1开始的2个数字
3 的时候 2位字符串 "00",可以表示从3开始的4个数字
..
6 的时候 2位字符串 “11” 可以表示从3开始的4个数字
7 的时候 3位字符串 “000” 可以表示从7开始的8个数字
..

这不就是一个长度有规律增长的二进制串么，每次增长都从零开始计数，直到全一。
所以要凑二进制字符串，首先判断能用多少位二进制位，然后判断在其内部排第几个，即为二进制字符串的数值。

# 分解问题
1、得到返回的字符串的位数k
如果当前数字是n，找到k满足 1+2+4+..+2^(k-1) <= n < 1+2+4+..+2^(k-1)+2^k
比如  1+2<= 6 < 1+2+4 所以6是2位，再比如 1+2+4<= 7 < 1+2+4+8 所以7是3位
问题来了如何找到这个k呢，从编码后是二进制字符串，我们自然可以想到上述不等式能否用二进制来表示，
也就是 11..1（k个1）<= n的二进制表达 < 111...1(k+1个1)
于是乎，n的二进制表达的位数，就告诉了我们k是多少。
如果n的二进制表达式全为1，取到了等式左边的等号，那么显然 k=n的二进制表达位数，
    比如前述n=7=111时，k=3
如果n的二进制表达式不全为1，就没取到等式左边的等号，落在区间内，显然 k = n的二进制表达位数-1， 
    比如前述n=6=110时，k=3-1=2


2、得到k位二进制的数值
如果当前数字是n的二进制表达式正逢全1，就返回 k位0，(实际上是减去了k位的全1)，
    比如n=7=111，k=3，返回 000 （111-111）
否则减去 k位全1 。高位用0填充，补齐成k位的二进制字符串即可，
    比如 n=6=110，k=2，110-11=10，正好是2位，不用补零，返回10
    比如 n=4=100，k=2，100-11=1，只有1位，高位补1位零，返回01

所以梳理一下，先 获得 原数字的二进制表示，然后根据二进制表示的位数，得到全1的二进制减数，原数减去全1减数后，高位补零即为编码
```
if (num == 0 ){
    return "";
}
String input = Integer.toBinaryString(num);
StringBuilder allone = new StringBuilder();
allone.append("1".repeat(input.length()));

// 1, 11, 111,...
StringBuilder ans = new StringBuilder();
if (allone.toString().equals(input)) {
    return ans.append("0".repeat(input.length())).toString();
}

//minus
String a = allone.substring(1);
Integer allOneInt = Integer.valueOf(a, 2);
String y = Integer.toBinaryString(num - allOneInt);
// 01, 001, 010....
return "0".repeat(Math.max(0, input.length() - y.length() - 1)) + y;
```

# 补码解法
以上这么直接的解法就算结束了么？是不是感觉稍微有点复杂？全1和不全1的要分开处理。这里因为结果总是一个和原数字的二进制长度k有关的长度的二进制串。且总是减去一个k位全1，于是就想到补码。
比如 n = 111 , 返回 000； n=1000, 返回 001； n=01, 返回 00 


将原数看成是一个固定位数的符号数，熟悉补码的同学可以知道，如果固定数字为k位，减去k位全1的二进制减数，相当于加上1个k位的二进制1。
    比如 n=7=(0)111，k=3
    n=7=(0)111-(0)111=(0)111+(0)001 = (1)000 
    再比如 n=6=(1)10, k=2
    n=6=(1)10-(0)11=(1)10+(0)01 =(1)11

补码也可以用时钟来理解，把分针从 4 拨到 6 既可以顺时针拨动 2 格，也可以逆时针拨动 12-2 = 10 格。
最高位因为加法发生的进位也可以类比时钟的12进制，当你拨动分针超过一圈，就会有一个小时的进位，但我们只考虑分钟的数值，就和这里只考虑k位数值，不会产生影响。


因此利用了补码原理后，更简单的方法就是，直接加1，然后截得低k位的二进制表达即可。好处在于全1的特殊情况，和高位补零都无需单独处理，转成补码（比如7和6，一个减111，一个减11）一律是加1即可。

```
Integer.toBinaryString(num + 1).substring(1)
```


