### 题意分析
首先，读题。

不得不说，这次的题目真的有些拗口，主要是这句话导致的——它选择四个基本方向中的一个（北，东，西和南），然后朝那个方向移动，「直到它选择停止、到达棋盘的边缘或移动到同一方格来捕获该方格上颜色相反的卒」。

简单来说，就是，车可以一直朝着一个方向移动，除非：
- 超出棋盘边界
- 遇到象
- 捕获到卒

### 逻辑梳理
遇到这三种情况的任意一种，车就不能再朝着这个方向移动，只能再次从起点，更换方向，继续捕卒任务。

所以本次的题目如何想做出来，其实很简单，只需处理好四个关键点：
- 车的初始坐标的确定
- 车在四个方向上的移动
- 限制条件的判定
- 捕获量的统计

这四个关键点中，重点解释官方是如何处理**车在四个方向上的移动**这一步的。

首先我们将棋盘抽象成由X（行）和Y（列）组成，则X（行）设定为西——>东方向，Y（列）设定为北——>南方向。即上北，下南，左西，右东，则`x`表示在X上的位置，`y`表示在Y上的位置。

很轻易地可以总结出：
`(0 + x, 1 + y)`：x坐标不变，y前进一格，则是由**西向东**移动。
`(1 + x, 0 + y)`：x坐标前进一格，y不变，则是由**北向南**移动。
`(0 + x, -1 + y)`：x坐标不变，y后退一格，则是由**东向西**移动。
`(-1 + x, 0 + y)`：x坐标后退一格，y不变，则是由**南向北**移动。

把上述的坐标由上到下，将加号“`+`”视为分割线，你会发现，`x`的位置移动，由数组`[0, 1, 0, -1]`构成，`y`的位置移动，由`[1, 0, -1, 0]`构成，这就是官方那两个方向数组的由来。

方向数组的确定，给解题带来极大的遍历，因为只需要两层循环就可以遍历所有方向：
- 外层循环遍历4次，因为有4个不同的方向。
- 内层循环判断在车同一方向上的每次移动是否可以捕获到卒。

值得一提的是，在官方的题解代码中，本处的内层循环是从`0`开始，个人觉得没有必要。因为`0`乘以任何数都为`0`，就等同于车没有进行位置的移动，直接从`1`始就行，避免浪费计算。

```
// 官方代码
for (let i = 0; i < 4; ++i) {
    // 个人觉得step从1开始更恰当
    for (let step = 0;; ++step) {
        ...
    }
}
作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/available-captures-for-rook/solution/che-de-ke-yong-bu-huo-liang-by-leetcode-solution/
来源：力扣（LeetCode）
```

当然也简单粗暴地使用4个`for`循环来依次遍历东南西北四个方位的移动操作，这里就不附上该种方法的代码实现了。

顺嘴提一句，关于**车的初始坐标的确定**，通常写法都会如下：
```
// 车的坐标
let x, y;

// 遍历棋盘，找到初始状态下车的位置
for(let i = 0; i < 8; i++) {
    for(let j = 0; j < 8; j++) {
        if (board[i][j] === 'R') {
            // 找到车
            x = i;
            y = j;
        }
    }
}
```
这种的写法，会有一个隐式的遗漏——**数组中的所有元素都会被遍历一次**。

即使你在内部循环中加了`break`语句，也只是退出了内层循环，最外层的循环依旧会继续执行。

不过，如果你的语言支持`label`的话，是可以直接退出多重循环的。

在JavaScript世界中，`label`已经被天然支持了，对该语法不熟悉的同学可以查看MDN上的这篇[文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/label)，本处就不具体展开讨论了。
```
// 车的坐标
let x, y;

// 声明label
loop:
// 遍历棋盘，找到初始状态下车的位置
for(let i = 0; i < 8; i++) {
    for(let j = 0; j < 8; j++) {
        if (board[i][j] === 'R') {
            // 找到车
            x = i;
            y = j;
            // 利用label来退出最外层循环，减少遍历的数组元素
            break loop;
        }
    }
}
```



### 代码实现
以下是具体的代码实现，结合注释食用更佳~
```
/**
 * @param {character[][]} board
 * @return {number}
 */
var numRookCaptures = function(board) {
    // 捕获量
    let captureAmount = 0;
    // 车的坐标
    let x, y;

    // 声明label
    loop:
    // 遍历棋盘，找到初始状态下车的位置
    for(let i = 0; i < 8; i++) {
        for(let j = 0; j < 8; j++) {
            if (board[i][j] === 'R') {
                // 找到车
                x = i;
                y = j;
                // 利用label来退出最外层循环，减少遍历的数组元素
                break loop;
            }
        }
    }

    // 车在X轴上移动的方位
    const dx = [0, 1, 0, -1];
    // 车在Y轴上移动的方位
    const dy = [1, 0, -1, 0];

    // 外层循环，依次走4个方向
    for(let i = 0; i < 4; i++) {
        // 内层循环，向同一个方向一直走下去
        // 官方这里是从第0步开始走，我觉得没必要还造成浪费，直接从第一步开始走就行了
        for(let j = 1; ; j++) {
            // 车在X轴移动后的坐标
            const moveX = x + j * dx[i];
            // 车在y轴移动后的坐标
            const moveY = y + j * dy[i];

            // 车不能走出棋盘范围 且 不可以碰到象
            if (moveX < 0 || moveX >= 8 || moveY < 0 || moveY >= 8 || board[moveX][moveY] === 'B') {
                break;
            }
            // 捕获到卒
            if (board[moveX][moveY] === 'p') {
                captureAmount++;
                // 题目要求：捕获到小卒后，这个方向就不能在继续前进了
                break;
            }
        }
    }

    // 返回捕获数量
    return captureAmount;
};
```



