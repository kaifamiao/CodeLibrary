### 解题思路
思路一：看到二进制串第一念头肯定是遍历啦，但输入的是32位的无符号整数，所以直接遍历行不通。对二进制串进行遍历的一个好方法是移位运算，即将最后一位二进制位向右移。而判断二进制的一位是0还是1的最好方法就是将其与1进行与&操作了，只有当该位为1时，它与1才等于1。此处注意两点：
1. 区别算术右移和逻辑右移：算术右移要考虑符号位[1]11010001，当为负数时右移左首添加的是1，为正数时添加0；而逻辑右移不需要考虑符号位，直接添0即可。当然这里输入的是无符号整数，不需要考虑这么多啦～
2. 移位运算的操作：移位运算的操作可以是n>>1，也可以是n/2(可能略慢一点点点)，两者没有本质的区别，编译器会进行优化。

本题和leetcode191题的描述有些区别，输入的如果是负数，不经过(unsigned int)强制转化，使用位移操作则循环就会无限下去，导致程序卡死，所以函数形参必须是uint32_t类型的。
```cpp
int hammingWeight(uint32_t n) {
    if(n<0){
        return 0;
    }

    int c = 0;
    while (n){
        //&与操作判断是否为1
        if(n&1){
            c++;
        }

        // 移位和除2都是算术右移
        n = n >> 1;
//        n /= 2;
    }

    return c;
}
```

思路二：题意是使用汉明重量来计算，而汉明重量可以通过与特殊数据进行与&操作获取1的位数，这一功能在密码学计算上有很好的使用，具体可以看百度[汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F)。上面提出的几种算法，确实优化的非常快！代码我只列出了其中一种。
```cpp
int hammingWeight2(uint32_t n) {
    n = (n & m1) + ((n >> 1) & m1);
    n = (n & m2) + ((n >> 2) & m2);
    n = (n & m4) + ((n >> 4) & m4);
    n = (n * (h01) >> 24);

    return n;
}
```