初步思考这个题目，很快能得出一个规律：*质数只能复制一个A，并一直粘贴*
这是因为粘贴的过程就相当于是对剪贴区的A的数量进行乘法操作
举例：
剪贴区含有3个A，粘贴一次相当于3×2，两次相当于3×3
而质数的因数只有1和本身，所以质数p的操作次数=复制1次+粘贴p-1次=p

对于合数，显然需要通过扩增因数的方式来节省步骤数，经过简单的实验，很快能得出第二个规律：*操作次数等于因数之和*
举例：
如果要获得18个A，而18能分解为18=9×2,那么需要分两步操作
1.复制1次A+粘贴8次=9次操作
2.复制1次9个A+粘贴1次=2次操作
两步一共需要2+9=11次操作
然而明显可以发现，在第一步有缺陷，9个A有可能可以通过更快的方式获得，而不是通过一次粘贴一个的方式
为此，为了更快的获得9个A,在第一步可以继续分解9,直到不能分解为止。此时第二条规律才真正成立

由此引出质因数的分解，如18=2×3×3，此时一共需要2+3+3=8次操作，比2+9=11次操作要更快
如何解释这种，**质因数的总和要小于其他分解方式的总和**的现象呢？也就是要解释为什么p=ab时,a+b<p
现在简单证明这个结论：当a>=2且b>=2时，ab>=a+b
证明： 
ab>=a+b ➡
ab-b>=a ➡
(a-1)b>=a
而b>=2
所以(a-1)b>= 2a-2
而2a-2>=a在 a>=2时显然成立
因此(a-1)b>=2a-2>=a
### 代码

```java
class Solution {
    public int minSteps(int n) {
        if(n==1){
            return 0;
        }
        return divideAndAdd(n);
    }

    public int divideAndAdd(int x){
        if(x==2){
            return 2;
        }
        for(int i=2;i<x;i++){
            int j=x/i;
            if(x==j*i){
                return divideAndAdd(j)+divideAndAdd(i);
            }
        }
        return x;
    }
}

```