这道题我看了别人的代码才想出来，在这总结一下，有不足或者理解不到希望指正
首先分析这个题，它是要求可以恰好到达n的最少的步数，我们先来分析一下，对于一个数，如果它没有除了1及它本身意外的可以整除的数字，那么这个数就只能copy1次，然后不断的复制，这种数字也叫作质数，当然与它相对应的就是合数，也就是它可以有一些其它的因子，下面举几个合数的例子：
18=1\*18=2\*9=3\*6=2\*3\*3
24=1\*24=2\*12=3\*8=4\*6=2\*2\*2\*3
这里我们首先把1*n排除，因为这样是最大的到达n的步数，我们考虑后面的几种情况，因为对于两个大于等于2的正整数，a\*b>=a+b,所以例如18=2\*9它的意思就是将一个Acopy一次，paste一次，成两个A，然后再copy一次，paste八次就好了，这一共就是11次，但是如果把18分解为2\*3\*3,那么意思就是把Acopy一次，paste一次，两个A，然后再copy一次，paste两次，六个A，然后copy一次，paste三次，18个A，这一共是8次，这就验证了前面的道理，就是a\*b>=a+b,也就是把数字分的越小，得到的最后的结果值就是答案
由上，意思就是把一个数字分解为不能再分解的最小的质数，然后相加就是最后的答案
这里的分解有一定的贪心策略，就是每一次都希望copy，paste的值比较大，这样需要的步数就比较小
```
class Solution {
    public int minSteps(int n) {
        //这道题的数学思想应该是将一个数字分解为所有不能再分解的质数的乘积
        int res=0;
        //找寻从2-n的所有的可以被n整除的质数，如果此时的n为一个质数，那就不能再分解了
        for(int i=2;i<=n;i++){
            //这里的思路就是每一次希望可以通过一个大的数通过copy，paste来成为n，所以除以的都是第一个可以整数的数字
            while(n%i==0){
                res+=i;
                n/=i;
            }
        }
        return res;
    }
}
```
