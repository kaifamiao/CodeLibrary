高大上的dp都有答案了，我出一个暴力dp。
通常，对于DP问题，我们需要确定原问题的最优子结构，并将其解与子问题联系起来。
首先，那么原来的问题是dp(n)，我们定义dp(i)为在记事本上得到i个 A的最小步数。
我们有以下base case:dp(1) =0，因为最初在记事本上已经有一个“A”。
现在关键的部分是如何把dp(i)和它的子问题联系起来。
显然，dp(i)取决于在记事本上获得i 'A的取决于子问题。现在问问你自己这些问题:
    1.	子序列的操作能以复制结束吗?显然不行。因为复制没有改变“A”的数量，这个步骤可以删除，所以以复制结束肯定不是最小步骤。
    2.	子序列的操作只能包含粘贴吗？答案仍然是否定的，因为在开始时没有复制字符，所以粘贴不会改变记事本上的“A”的数量(一个特殊情况是当n = 1时，但我们甚至不需要任何操作)。
因此，我们得出结论，子序列的操作必须以粘贴结束，并且存在至少一个拷贝操作。但是，从最后一次粘贴的角度来看，它只关心上次复制的字符，即已经复制子序列的”A”的个数，我们假设他的长度为j，之后每次复制长度都是增加j。
所以从j 个A到i 个A的总步数是i /j。因为我们的目标是最小化得到i 'A'的步数，所以我们假设从1个A到j个A为dp(j)，因此在这种情况下得到i 'A'的步数dp(i)等于dp(j) + i/j。
上面论述了从j 个A到i 个A的总步数是i /j， 因为步数必须为整数，所以i/j必须为整数，所以i%j 必须等于0。
最后，状态方程：
	dp(i) = min(dp(j) + i/j) where 1 <= j < i && i % j == 0.
```
    public static int minSteps(int n) {
        //dp(i) = min(dp(j) + i/j) where 1 <= j < i && i % j == 0.
        int[] dp = new int[n + 1];
        dp[1] = 0;
        for (int i = 2; i <= n; i++) {
            int min = Integer.MAX_VALUE;
            for (int j = 1; j < i; j++) {
                if (i % j == 0) {
                    min = Math.min(min, dp[j] + i / j);
                }
            }
            dp[i] = min;
        }
        return dp[n];
    }
```
