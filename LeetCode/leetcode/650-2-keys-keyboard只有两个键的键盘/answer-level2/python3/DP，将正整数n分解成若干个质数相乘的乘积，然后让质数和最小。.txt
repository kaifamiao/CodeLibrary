### 解题思路
先看n <= 10 的情况，以表格的形式展现，第一列是n，第二列是输出，第三列是解释。
n ： 输出
1 : 0
2 : 2   质数
3 : 3   质数
4 : 4 （4 = 2 * 2  输出 = 2 + 2   先把A复制、粘贴，变成AA，在把AA复制、粘贴变成AAAA,四次操作搞定。）
5 : 5   质数
6 : 5   （6 = 2 * 3  输出 = 2 + 3   先把A复制、粘贴，变成AA，在把AA复制、粘贴、粘贴变成AAAAAA,5次操作搞定。）
7 : 7   质数
8 : 6   （8 = 2 * 2 * 2 输出 = 2 + 2 + 2）
9 : 6   （9 = 3 * 3     输出 = 3 + 3）
10: 7   （10 = 2 * 5    输出 = 2 + 5）
大致找到规律了。n个A，如果n是质数，就输出本身；如果不是质数，就拆成质数，把质数相加后输出。
题目就是要求我们
**找出这些质数组合，然后使得质数组合的和最小**
**找出这些质数组合，然后使得质数组合的和最小**
**找出这些质数组合，然后使得质数组合的和最小**
重要的话说三遍。
有规律，就可以使用dp算法了。
核心代码：
dp[i] = min(dp[i], dp[int(i/j)] + j)
这一步就是在践行上面那句重要的话。
内外循环的目的是让n不断的拆分，直到拆分到是质数为止，比如12 = 2 * 6，这时候6还可以再拆分成2 * 3，这是自顶向下的理解。不过代码用dp写的，实际运行过程中是自下而上的。
### 代码

```python3
class Solution:
    def minSteps(self, n: int) -> int:
        if n == 1: return 0
        dp = [i for i in range(n+1)]
        dp[1] = 0
        dp[2] = 2
        for i in range(3, n+1):
            for j in range(2, i):
                if i % j == 0:
                    dp[i] = min(dp[i], dp[int(i/j)] + j)
        return dp[n]
```
希望对大家有所帮助。
贴一道相类似的题目。第343题，异曲同工。
[https://leetcode-cn.com/problems/integer-break/description/](https://leetcode-cn.com/problems/integer-break/description/)
没怎么回答过问题，觉得还不错就点个赞。