### 公式
```
f(1) = 0
若 n > 1, 从 [2,n] 找到 n 的最小约数 k
f(n) = k + f(n/k)

在找约数的过程中，考虑素数就行了，合数不可能是最小约数
我们可以提前写个程序计算 1000 以内的素数打印出来
在程序里定义这个素数表格，减少计算对合数的判断

关于得到这个素数表格，可以另写一个程序得到这个表格，也可以用模板元编程在编译期就计算出来！
```


### ***Talk is cheap. Show me the code.***

```cpp
class Solution {
public:
    int minSteps(int n) {
        static int PrimeTable[] = {
            2,   3,   5,   7,   11,  13,  17,  19,  23,  29,  31,  37,  41,
            43,  47,  53,  59,  61,  67,  71,  73,  79,  83,  89,  97,  101,
            103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167,
            173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239,
            241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,
            317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,
            401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467,
            479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569,
            571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
            647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733,
            739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823,
            827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
            919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009};

        int res = 0;
        int i = 0;
        while (PrimeTable[i] <= n) {
        	while (n % PrimeTable[i] == 0) {
        		res += PrimeTable[i];
        		n /= PrimeTable[i];
        	}
        	i++;
        }
        return res;
    }
};

```
### NPNT 
![Xnip2020-02-28_00-03-21.jpg](https://pic.leetcode-cn.com/9891b9a33c0f37cd63c31ca7fd3c46d980723707ecae3ea5b55c48abc6d3afbc-Xnip2020-02-28_00-03-21.jpg)
