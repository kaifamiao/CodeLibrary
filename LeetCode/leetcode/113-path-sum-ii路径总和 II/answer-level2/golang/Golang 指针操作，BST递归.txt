æ„Ÿè°¢ç´ æœªè°‹é¢, â¤â¤ğŸ’–ğŸ’–âœ”âœ”ï¼Œ[æˆ‘çš„è€å¸ˆ**èŠ±èŠ±é…±**è§†é¢‘è®²è§£](http://zxi.mytechroad.com/blog/tree/leetcode-113-path-sum-ii/)ã€‚

### é€’å½’ä¾‹å­

ç»™è¿™æ£µæ ‘ï¼Œè¦æ‰¾å‡ºçš„ `sum=22`
```
      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
```

é€’å½’çš„è¿‡ç¨‹ï¼š

* `fsp(5, 22, [], [][])`
   
   * `fsp(4, 17, [5], [][])`
      
      * `fsp(11, 13, [5,4], [][])`
        * `fsp(7, 2, [5,4,11], [][])`, return
        * `fsp(2, 2, [5,4,11], [][])`, `ans=[[5,4,11]]`, return
        
      * `fsp(nil, 13, [5,4],[][])`, return

   
   . `fsp(8, 17, [5], [][])`, ç•¥

æ¯ä¸ªé€’å½’é€€å‡ºï¼Œéƒ½ä¼špopå‡ºcurã€‚

### Golang éœ€è¦æ³¨æ„çš„åœ°æ–¹

* Go é‡Œé¢çš„ sliceçš„cloneä¸æ˜¯ç®€å•çš„èµ‹å€¼ï¼Œå› ä¸ºsliceæ˜¯ä¸€ä¸ªå¾ˆå°çš„æ•°æ®ç»“æ„ï¼Œå‡ ä¸ªsliceæœ‰å¯èƒ½å…¬ç”¨åŒä¸€ä¸ªåº•å±‚çš„æ•°ç»„ã€‚å› æ­¤ï¼Œåœ¨å°†ä¸´æ—¶ç»“æœæ·»åŠ åˆ°æœ€ç»ˆç»“æœçš„æ—¶å€™ï¼Œç”±äºä¸´æ—¶ç»“æœæ˜¯ä¸€ä¸ªä¸æ–­è¢«é‡å¤åˆ©ç”¨çš„sliceï¼Œæˆ‘ä»¬éœ€è¦å°†å®ƒçš„ä¸€ä¸ªcopyæˆ–è€…cloneä¿å­˜åœ¨æœ€ç»ˆç»“æœå†…ã€‚è¿™æ ·æ‰èƒ½ä¿è¯åœ¨ä¸‹æ¬¡é€’å½’çš„æ—¶å€™æ“ä½œä¸´æ—¶ç»“æœ`cur`ä¸ä¼šå½±å“åˆ°å·²ç»ä¿å­˜å¥½çš„ç»“æœã€‚

      
```
// å¤åˆ¶sliceçš„èŒƒä¾‹
copy := make([]int, 0)
copy = append(copy, source...)
```

* Go æ²¡æœ‰ç±»ä¼¼Cçš„æŒ‡é’ˆè¿ç®—ï¼Œå¦‚æœä½¿ç”¨æŒ‡é’ˆç¨å¾®éº»çƒ¦äº†ä¸€ç‚¹ï¼Œä½†æ˜¯ç©ºé—´æ¶ˆè€—è¢«å¤§å¤§å‡å°‘äº†ã€‚


### ä»£ç 

```golang
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, sum int) [][]int {
	// The answer to be returned.
	ans := make([][]int, 0)
	// The current answer for one path.
	// This slice store the temporary list of values
	// that sum up to be the sum we want.
	// It works like an accumulator.
	cur := make([]int, 0)
	findPathSum(root, sum, &cur, &ans)
	return ans
}

func findPathSum(root *TreeNode, sum int, cur *[]int, ans *[][]int) {
	// Empty Node do nothing.
	if root == nil {
		return
	}

	// Leave Node
	if root.Left == nil && root.Right == nil {
		// We find the answer
		if root.Val == sum {
			// First append the value into the current slice.
			*cur = append(*cur, root.Val)
			// Append the final accumulator's values into answer.
			// Watch out this time we need append a *Copy* of current slice
			copy := make([]int, 0)
			copy = append(copy, (*cur)...)
			*ans = append(*ans, copy)
			// Pop this value out
			*cur = (*cur)[:len(*cur)-1]
		}
		return
	}

	// Middle stage
	*cur = append(*cur, root.Val)
	newSum := sum - root.Val
	findPathSum(root.Left, newSum, cur, ans)
	findPathSum(root.Right, newSum, cur, ans)
	*cur = (*cur)[:len(*cur)-1]
}
```