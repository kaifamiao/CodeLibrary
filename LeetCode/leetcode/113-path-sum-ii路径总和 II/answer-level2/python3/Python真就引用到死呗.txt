### è§£é¢˜æ€è·¯
å§æ§½å°¼çŽ›ï¼Œéƒ½é€’å½’äº†ä½ åˆ—è¡¨è¿˜æè¿™å¼•ç”¨å‘¢ï¼Ÿ
ç­‰ðŸ‘´èµ·æ¥ï¼Œåˆ†åˆ†é’Ÿæžä¸ªæ–°ç¼–ç¨‹è¯­è¨€æŠŠå®å¸‚åœºä»½é¢å…¨éƒ¨å äº†ã€‚
ä¸€ä¸ªèªæ˜Žçš„è¯­è¨€åº”è¯¥å¯ä»¥æ˜¾ç¤ºæŒ‡æ˜Žå¯¹è±¡æˆ–ç±»åž‹æ˜¯å¦ä¸ºå¼•ç”¨æˆ–ä¼ é€’ã€‚
Pythonå¿«çˆ¬å¼€å¿«çˆ¬å¼€ã€‚

### ä»£ç 

```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def pathSum(self, root: TreeNode, s: int) -> List[List[int]]:
        res = []

        def dfs(root, arr):
            if root:
                if not root.left and not root.right:
                    if sum(arr) + root.val == s:
                        arr.append(root.val)
                        res.append(arr)
                else:
                    arr1, arr2 = copy.copy(arr), copy.copy(arr)
                    arr1.append(root.val)
                    arr2.append(root.val)
                    if root.left:
                        dfs(root.left, arr1)
                    if root.right:
                        dfs(root.right, arr2)

        search(root, [])
        return res
```