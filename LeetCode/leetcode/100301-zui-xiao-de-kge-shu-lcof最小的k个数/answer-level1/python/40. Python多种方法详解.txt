### 解题思路
这道题最直观的想法是先进行排序，然后再取前k个数，但是这种方法的时间复杂度最小为O(nlogn)（不考虑基数排序等方法）。那么我们需要考虑其他方法，比如我们可以维护一个数据结构只保留当前遍历过的最小的k个数，这个数据结构可以是普通的数组并使用最原始的插入排序，那么整个程序的时间复杂度为O(nk)，当然还可以继续优化，比如使用大顶堆，因为实际上我们并不需要知道当前最小的k个数的大小关系，我们只需要知道当前保存的k个数的最大值便可以进行操作，这样整个程序的时间复杂度包括遍历数组、建堆、删除最大值，即O(n) + O(k) + O(nlogk) = O(nlogk)。

以上都是比较好理解**时间复杂度计算**的方法，也是比较容易想起来的方法，还有一种方法是时间复杂度为O(n)的方法，基于快排的思想，这里只是介绍方法，因为这里时间复杂度的计算我还没有想明白，该方法的时间复杂度是书上直接给出的。快排的思想是每次用一枢轴将整个数组分成两个部分，这两个部分具有整体的有序性，但是内部无序，所以每次递归的时候都是让内部变得有序，进而使得整个数组有序，这恰恰和这道题的要求不谋而合，为什么这么说呢，因为这道题虽然需要返回最小的k个数，但是**没有说要对这k个数进行排序**，所以我们可以利用快排的思想进行处理，具体的：
先进行一次快排子操作。（为了避免混淆，认为快排是由多个重复的快排子操作完成的）
（1）若枢轴最后的位置为k - 1。那么退出程序，因为正好我们得到了最小的k个数（包括枢轴）；
（2）若枢轴最后的位置小于k - 1。那么我们需要对枢轴**后面**的子序列再进行一次快排子操作，判断枢轴最后的位置；
（3）若枢轴最后的位置大于k - 1。那么我们需要对枢轴**前面**的子序列再进行一次快排子操作，判断枢轴最后的位置。

下面给出了第三种方法的实现。

### 代码

```python
class Solution(object):
    def getLeastNumbers(self, arr, k):
        """
        :type arr: List[int]
        :type k: int
        :rtype: List[int]
        """
        length = len(arr)
        if length == 0:
            return []
        def quick_sort(left, right):
            if right - left < 1:
                return 
            p = left
            q = right
            mem = arr[left]
            while p < q:
                while p < q and arr[q] > mem:
                    q -= 1
                if p < q:
                    arr[p] = arr[q]
                    p += 1
                while p < q and arr[p] < mem:
                    p += 1
                if p < q:
                    arr[q] = arr[p]
                    q -= 1
            arr[p] = mem
            if p == k - 1:
                return 
            elif p < k - 1:
                quick_sort(p + 1, right)
            else:
                quick_sort(left, p - 1)
        quick_sort(0, length - 1)
        return arr[:k]
```