前几天，菜鸡我做这个题的时候，直接用了python的sort函数，看了题解，远远没有那么简单，主要是考究你的排序算法，于是这2天学了冒泡/插入/归并/快速排序。在这里分享一下快速排序，有问题请评论，我尽量解答。如果有错误请指出，非常感谢！

# 快速排序思路：
1.在列表中[11, 99, 33 , 69, 77, 88, 55, 11, 33, 36,39, 66, 44, 22]，随意取一个数字作为基准，在该数字的左边区域都是小于它的数字，在该数字的右边区域都是大于它的数字。

2.采用递归的方法不断进行第1步骤进行分解成左右区域并进行比较大小，直到左边区域或右边区域只剩下1个元素，再一层层往上返回，最终的列表就是我们所要的结果。

3.为什么可以随意取一个数字作为基准呢，因为不断的进行比较，这个数字最终会呆在它应该呆的地方，否则会继续进行比较大小。

# 前置知识 - 递归：
递归就是调用函数本身。如下面的代码，当我们把参数4传进去的时候：result = 4 * fer(3) ，计算机并不清楚fer(3)是什么，这里它会继续往下进行，直到result = 1*fer(0)，因为代码里说如果n = 0时，result=1，计算机就知道了fer(0)=1，那么就可以从下往上依次推出结果了。
```
def fer(n):
    if n == 0:
        result = 1
    else:
        result = n * fer(n-1)
    return result

fer(4)
```

# 代码：
```
class Solution:
    def getLeastNumbers(self,nums,k):

        # 快速排序
        nums = quick_sort(nums)
        return nums[:k]

# 快速排序函数
def quick_sort(b):

    # 如果列表里就1个元素，那么直接返回列表，递归结束条件
    if len(b) < 2:
        return b
    '''
    随便选择一个元素作为基准，我这里选择的是列表里的第一个元素。
    为什么可以随便选呢？因为经过下面不断的进行比较大小，这个元素是一定要呆在自己应该呆的地方，不然就会继续比较大小
    '''
    mid = b[0]

    # 基准值左边和右边的列表
    left,right = [],[]

    # 不包含基准值
    b = b[1:]

    # 遍历列表
    for item in b:

        # 如果元素大于基准值，那么移动到右边
        if item >= mid:
            right.append(item)

        # 否则就移动到左边
        else:
            left.append(item)
    
    # 调用自身函数，不断的分解成左列表和右列表，直到列表里只有1个元素，那么再一层层返回结果，最终的结果就是我们想要的
    return quick_sort(left) + [mid] + quick_sort(right)

nums = [0,1,2,1]
k = 1
a = Solution()
a.getLeastNumbers(nums,k)
```