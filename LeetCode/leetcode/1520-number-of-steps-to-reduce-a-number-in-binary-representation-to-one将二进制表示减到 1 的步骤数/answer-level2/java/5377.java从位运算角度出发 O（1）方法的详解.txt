### 解法

```java
public int numSteps(String s) {
        char[] num = s.toCharArray();
        int count = 0;
        for(int i = num.length - 1; i >= 0; i--){
            if(i == 0 && num[i] == '1')
                return count;
            if(num[i] == '1'){
                count++;
                for(int j = i - 1; j >= 0; j--){
                    if(num[j] == '0'){
                        num[j] = '1';
                        break;
                    } else {
                        num[j] = '0';
                    }
                }
            }
            count++;
        }
        return count;
    }
```

思路分析：

* 看起来只需要将二进制字符串表示为数字，然后按要求循环计数就可以。但是题目中字符串的长度最大为500。那么java中的基本数据类型long也就64位，所以这样肯定行不通了。
* 从数字的二进制表示入手：
    * 如果一个数奇数，那么二进制位表示的最低一位肯定是1。对于奇数要将其加1，二进制的加1就需要一直向左将每一个1变为0，直到某一位是0，将0变为1（完成进位操作真累）
    * 如果一个数是偶数，那么二进制位表示的最低一位肯定是0。对于偶数除以2，相当于将有符号右移一位。
* 题目中给定的字符串已经是二进制表示，为了方便用字符数组来存放这些信息`char[] num = s.toCharArray();`，使用变量`count`来计数。
* 从二进制的低位开始进行操作，所以表示当前最低位的`i`初始化为`num.length - 1`，`i--`表示最低位变成了之前的倒数第二位，也就是该数进行除以2的操作。所以每一次`i--`都代表了偶数除以2的操作，所以循环的每一次都要进行`count++`
* 遇到当前最低位`num[i] == '1'`的情况，要进行奇数+1的操作，将`count++`，然后向前文描述的那样进行进位操作（一个内循环while）
* 注意！！！还有一个坑人的地方😡我在这bug了很久。
    * 如果没有因为进位操作将最高位变为0，那么当for循环进行到最高位的时候，如果不进行特殊处理，就会先进行奇数+1再进行偶数除以2，比正确答案操作多了两步。
    * 如果没有因为进位操作将最高位变为0，其实`i == 0`时，这个数已经是1了。所以当`i == 0 && num[i] == '1'`，直接返回`count`就可以了。
    * 如果因为进位操作将最高位变为0，最终进位到更高位的1没有在字符数组中表示，所以循环结束再返回刚好符合题意，最后剩的就是那个没有表示在字符数组中的最后一个1。
* 时间复杂度为$O(n)$，空间复杂度为$O(1)$。

运行结果：

* 1 ms

更多LeetCode题解请看我的[github](https://github.com/ustcyyw/yyw_algorithm)，地址https://github.com/ustcyyw/yyw_algorithm。还有别的小项目也很好玩~卑微求个小星星💖