**模拟：**   
从右往左，如果末尾出现1，加1后就会变成0，然后逐一更新路径上的1，直到找到一位0将其变成1，另外需要考虑路径全是1的情况。  
从右往左，如果末尾出现0，直接右移一位即可，就处理完了当前这个数。

---

**总结规律**：
+ 如果末尾字符为0，则只需要操作一次，即右移一位。
+ 如果末尾字符为1，则 **至少** 需要操作两次。第一次是加1，让当前末尾字符由1变成0，第二次操作是执行上一步右移。其中，加1的过程是向左去找到对应的0，将其变成1，途径的所有1都变成0。这个时候就会需要考虑如果前边全部都是1的话，例如111这种场景，转换后成为1000，除开原本的两次操作外，还需要加一次多出来的那一位的操作。   
---   
因此，可以得到具体的判断条件，去编写代码：
```
    public static int numSteps(String s) {
        if (s.length() == 0) return 0;
        int res  = 0;
        int rightIndex = s.length()-1;
        char[] cs = s.toCharArray();
        while (rightIndex!=0) {
            // 处理末尾为1
            if (cs[rightIndex] != '0') {
                // 向左执行加1
                int i = rightIndex-1;
                for (;i>0;i--) {
                    if (cs[i] == '0') {
                        cs[i] = '1';
                        break;
                    }
                    else {
                        cs[i] = '0';
                    }
                }
                // 左边全是1 多出来1位
                if (i == 0) {
                    res += 3;
                }
                // 向左执行加1后，自身变成0，还需要执行一次右移
                // 因此当前这一位的操作数就是2.
                else {
                    res += 2;
                }
            }
            // 末尾为0
            else {
                res++;
            }
            rightIndex -- ;
        }
        return res;
    }
```
感谢各位同学能看到这里~代码比较粗糙，感谢不嫌弃~^_^
