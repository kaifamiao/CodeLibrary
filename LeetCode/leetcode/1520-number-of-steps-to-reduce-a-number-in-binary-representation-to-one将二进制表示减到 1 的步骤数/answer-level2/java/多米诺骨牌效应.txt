* 由于是二进制，偶数除2就是右移一位，奇数加1就进位
1. 想象一下推多米诺古牌，'1'的位置代表有牌，'0'的位置代表无牌
2. 从最后一个'1'处推动（+1），然后对倒下的牌（右移）计数，遇到'0'则需要继续手动加牌（+1）
3. 那么推动一下计数+1，每倒一张牌计数+1，每加一张牌计数+1
4. 其实总结下来就是从倒数第一个'1'开始，对'1'的数量计数+1，对'0'的数量计数+2，推动一下计数+1
5. 末尾的'0'不存在进位的情况，只需右移计数即可

* 考虑一个特殊情况，字符串s只有一个'1'，那么只需对末尾的'0'计数即可

```java
public int numSteps(String s) {

        int n = s.length();
        if(n == 1) return 0;

        int count = 0;

        int i = n - 1;
        //先处理字符串末尾的0，不用考虑进位，只需右移一位即可
        while (s.charAt(i) == '0') {
            i--;
            count++;
        }
        //如果除了只有第一个字符为'1'，那么就不会产生进位，处理完字符串末尾的0即可返回
        if(i == 0) return count;

        //对后续的'0'、'1'按上述讨论的方式计数
        while(i >= 0) {
            //对'1'的数量进行+1累加
            while (i >= 0 && s.charAt(i) == '1') {
                i--;
                count++;
            }
            //对'0'的数量进行+2累加
            while (i >= 0 && s.charAt(i) == '0') {
                i--;
                count += 2;
            }
        }
        //对推动多米诺骨牌的动作计数
        count++;

        return count;
    }
```
对上述代码的另一种解释：
```java
public int numSteps(String s) {
    int n = s.length();
        if(n == 1) return 0;
        int count = 0;
        int i = n - 1;
        //先处理字符串末尾的0，不用考虑进位，只需右移一位即可
        while (s.charAt(i) == '0') {
            i--;
            count++;
        }
        //如果除了只有第一个字符为'1'，那么就不会产生进位，处理完字符串末尾的0即可返回
        if(i == 0) return count;

        //后续考虑有进位的情况
        while(i >= 0) {
            //遇到末尾第一个'1'时，需要加1以及右移两步操作，而紧随其后的'1'由于进位的存在，只需要右移这一步即可
            while (i >= 0 && s.charAt(i) == '1') {
                i--;
                count++;
            }
            // //加上遇到末尾第一个'1'时所用的加1这一步
            //     count++;

            //遇到夹在'1'中间的'0'，考虑前一个数的进位，实际上需要把'0'当'1'处理，即需要加1和右移两步
            while (i >= 0 && s.charAt(i) == '0') {
                i--;
                count += 2;
            }
            // //由于进位的原因，后续遇到的末尾'1'不需要再手动加1这一步了，那么这里-1抵消后续的+1
            // if(i >= 0 && s.charAt(i) == '1') {
            //     count--;
            // }
        }
        //根据上述分析，只有末尾的最后一个'1'需要考虑加1以及右移
        count++;

        return count;
}
