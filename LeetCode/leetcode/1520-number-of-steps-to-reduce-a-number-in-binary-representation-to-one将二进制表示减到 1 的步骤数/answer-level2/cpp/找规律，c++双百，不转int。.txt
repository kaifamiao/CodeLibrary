### 解题思路和步骤
主要是找规律，二进制字符串的末尾为1就是奇数，需要加一，变为偶数再除2；如果本身已是偶数只进行除2操作。其中，对于二进制字符串，除2操作，仅仅是去掉最后一位
因此，从后向前扫描2进制字符串，分为2个方向处理：
1. 奇数引起的步骤数加一：
    a. 如果是字符串末尾是连续的"1"，加一后，一起变为0。因此，遇到1，记下标记，步骤数加一推迟到下次遇到0。例如，加一操作会使：**1011** -> **1100**
    b. 如果遇到"0"，并且后面有"1"（即，之前记过标记），步骤数需要加一。（通过找规律，如果后面有“1”，那么它前面的每一个“0”都会进位为“1”，都需要再次进行加一的步骤）
    c. 下标是0的元素，一定是"1"，不需要判断。即，代码中i>0作为循环结束条件。
    d. 扫描结束时，加一会使长度会增加1位；并且没有了再次遇到“0”的机会，前面推迟的加一没有机会执行。需要额外补充加1两次。如：**11** -> **100**
2. 每一位都需要除2，步骤数加一

### 复杂度分析    
时间复杂度：O(n)
空间复杂度：O(1)

```
class Solution {
public:
    int numSteps(string s) {
        int res = 0;
        int c = 0;
        for (int i = s.size() - 1; i > 0; i--) {
            if (s[i] == '1') c = 1; // 遇到"1"，连续的“1”会一起变“0”，记录标记。步骤数加一推迟到下次遇到“0”
            else if (c) res++;      // 遇到"0"，并且前面记录了标记，遇到的“0”都会因为之前的进位，变为“1”，成为奇数。这里，需要执行加一操作，使其变为偶数。

            res++;                  // 无论是奇数，还是偶数。每一位都需要除2，步骤数加一。
        }
        
        return res + c*2;  // 扫描结束时，奇数加一会使长度加一，并且缺少了再次遇到0的机会。这里需要额外增加两次1
    }
};
```
