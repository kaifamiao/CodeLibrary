回顾一下题目

*特殊的二进制序列是具有以下两个性质的二进制序列*：
- *0 的数量与 1 的数量相等*。
- *二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量*

你会发现如果把1和0用左括号和右括号来代替的话，那么“特殊的二进制序列”其实就是一个“合法的括号字符串”。比如 11011000 这一个特殊二进制序列就可以看成是 (()(())) 这样一个合法括号串。

而*操作*的定义

*给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作 为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)*

相邻的字符串，交换，（字典序）最大，任意次数的操作。将这些元素组合起来，你第一个能想到的肯定是“冒泡排序”。而不限次数让你把冒泡排序扩展到了排序算法。

这个交换还有一点需要理解，就是它肯定是让两个或多个在同一个层级的“子合法的括号串”进行排序，即
( () (()) ) 这样的一个字符串，肯定是最外面的括号里面中的两个子合法括号串()/(())进行交换，而不可能有其他情况发生，因为题目限制了只可能是“相邻的一个括号串和另一个括号串之间进行交换”。

那我们的思路就很简单了，拿1101100010举例来说
1.分割：将它分割成若干个相同层级的合法括号，对于这个例子而言可以分割成11011000 10两个子字符串。
2.排序: 先将它的所有子字符串进行同样的递归操作（即分割，排序，组合）我们可以分别得到 11100100 和           10，然后对其进行字典序的排序，我们发现11100100的字典序大于10。
3.组合：将其按照字典序从大到小的顺序组合在一起，答案是1110010010。

那么分割和排序该如何进行呢。
首先，分割。如果你写过有关合法括号的题目那很容易就能想到使用栈。
我们用一个变量s = 0模拟栈的运行，从我们需要分割的字符串开头进行遍历，遇到左括号（1）加1，遇到右括号（0）减一，那么每当s回归到0的时候，栈被弹出至空，我们就可以将当前这一段截取下来作为一个分割后的子字符串。
```
int s = 0; //栈
int start = 0; //分割记录点
for(int i = 0; i < S.size(); i++)
{
  if(S[i] == '1')
  s++; //入栈
  else
  s--; //出栈
  //栈排空，说明我们回到了和上一个分割记录点相同的层
  if(s == 0)
  {
    //对当前分割后的字符串进行记录
    start = i+1;
  }
}
```

排序的比较大小，就比较字典序好了。

```
static bool mycompare(const string a, const string b)
  {
    int i = 0;
    while(i<a.size())
    {
        if(a[i] == b[i])
        {
            i++;
            continue;
        }
        return a[i] > b[i]; 
    }
    return 1;
  }
```

其实我们可以发现，如果两个括号串，一个的包含的层数大于另一个，那么处理之后的字典序肯定也是同样的排序。
以及还有一些参数可以进行比较，不过这个就由你自己去发现好了，我们这里用的是最简单粗暴的写法，直接从0开始比较字典序。

最后组合就是将排序后的字符串一个一个拼接在一起就好。
代码如下

```
class Solution {
public:
  \\比较函数
  static bool mycompare(const string a, const string b)
  {
    int i = 0;
    while(i<a.size())
    {
        if(a[i] == b[i])
        {
            i++;
            continue;
        }
        return a[i] > b[i]; 
    }
    return 1;
  }
  
  string makeLargestSpecial(string S)
  {
    \\递归边界情况
    if(S.size() <= 0)
    {
      return ""; 
    }
    vector<string> ks;
    int s = 0;
    int start = 0;
    \\开始分割
    for(int i = 0; i < S.size(); i++)
    {
      if(S[i] == '1')
      s++;
      else
      s--;
      if(s == 0)
      {
        \\分割好后，对分割后的字符串进行递归，得到它的最优解法
        string temp;
        temp = "1"+makeLargestSpecial(S.substr(start+1,i-start-1))+"0";
        start = i+1;
        \\将其放入需要排序的列表
        ks.push_back(temp);
      }
    }
    \\排序
    sort(ks.begin(), ks.end(), mycompare);
    \\组合
    string result = "";
    for(int i = 0;i < ks.size(); i++)
    result += ks[i];
    return result;
  } 
};

```


