该问题的分析包含以下两点:

> 1. **什么情况下三条边能够组成两个三角形**
> 2. **如何更快地获得最大的三角形周长**

**先分析第一个问题**:满足组成三角形的三条边需要满足`三条边中的任意两条边之和大于第三条`或者`任意两条边之差小于第三条边`，这两个条件其实等价，所以我们只需要验证第一条件即可。在这时有一个技巧需要注意，即**只需验证两条较小边之和大于较大边**即可，以为较大边大于较小边，其加上一个数必然大于较小边。该条件在三边有序的条件下可以使用，三边无序时直接使用三个不等式验证更为便捷。
**现在分析第二个问题**:毫无疑问，使用较大三边的三角形组成的三角形周长必然更大。在最好的情况下，我们使用给出的三角形的第一、第二、第三长的边组成三角形则可以得到最大周长。

综合以上，可以得到以下思路：

1. 首先对给出的边长数组排序得到数组A
2. 判断A中第一、第二、第三长的三边能否组成三角形，即最长边的长度是否小于第二长边和第三长边边长之和。如可以，则返回三边之和
3. 如果第一、第二、第三长边无法组成三角形，则边长数组中的其中边和最长边同样也无法组成三角形（以为其他两边之和必然小于第二长边和第三长边边长之和，故小于第一长边边长）,所以讲第一长边从数组A中移除
4. 如果数组A的长度小于3，则给出的边长均无法组成三角形，最大边长为0，否则重新进入步骤2

代码如下：
```javascript []
/**
 * @param {number[]} A
 * @return {number}
 */
var largestPerimeter = function(A) {
    let B = A.sort((a, b) => a - b);
    while(B.length > 2){
        let bl = B.length;
        let a = B[bl-1];
        let b = B[bl-2]  + B[bl-3];
        if(a >= b) B.pop();
        else return a + b;
    }
    return 0;
};
```

运行时间116ms，消耗内存38.5 MB，提交通过。

在提交之后通过查看更为优秀的算法，发现在此问题中，无需首先将数据全部排序，可以通过边排序边验证的方法进一步优化算法，原因在于当给出的较大边能够组成三角形的时候，会直接返回结果，那些较小的边是否排序没有意义。通过测试别人给出的算法的到了最短时间的执行结果，代码如下：

```javascript []
/**
 * @param {number[]} A
 * @return {number}
 */
var largestPerimeter = function (A) {
    var temp;
    var len = A.length
    for (let i = 0; i < len; i++) {
        for (let j = i + 1; j < len; j++) {
            if (A[i] < A[j]) {
                temp = A[i];
                A[i] = A[j];
                A[j] = temp;
            }
        }
        if (i >= 2 && A[i] + A[i - 1] > A[i - 2]) {
            return A[i] + A[i - 1] + A[i - 2];
        }
    }
    return 0
};
```

耗时60ms, 内存消耗36.9 MB。