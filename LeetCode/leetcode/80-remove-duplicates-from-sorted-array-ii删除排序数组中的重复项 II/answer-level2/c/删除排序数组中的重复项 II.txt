## 前后元素对比法
**时间复杂度为O(n)，因为只遍历一次全部元素。
空间复杂度为O(1)，没有额外的辅助空间使用。**

**1. 初始化：**

（1） 定义一个计数器k，初始化为1，计算表中元素的个数；

（2） 定义一个计数器j，统计原始表中各个元素的重复次数；

**2. 遍历整个表：**

（1） 把当前的元素与它前面的对比，**如果二者元素相同（为重复元素）**：此时统计重复的计数器j + 1。题目要求只保留2个重复的元素，这里需要加入重复元素个数的判断：
        
`-   这个元素正好重复了2次 => 则进行保留。赋值为nums[k]=nums[i]，列表长度k+1；`

`-   这个元素重复多于2次 => 不进行任何操作。体现在程序上不做处理`

（2） 把当前的元素与它前面的对比，**如果二者元素不同（为新元素**）：此时把当前这个结点(nums[i])添加到新表里面去，nums[k] = nums[i],表长k+1。

以上完成这个算法。
```
int removeDuplicates(int* nums, int numsSize){
    if (numsSize == 0) return false;
    //计数器k计算表长，计数器j统计重复个数
    int j=1,k=1;
    for (int i=1;i<numsSize;i++){
        if (nums[i] != nums[i-1]){
            nums[k++] = nums[i];
            j = 1;            
        }else{
            j++;
            if (j == 2){
                nums[k++] = nums[i];
            }
        }
    }
    return k;
}
```


