双指针的功能划分是这样的
l（左指针）：指向第一个需要修改的元素，且永远不会超过 r
r（右指针）：指向第一个有效的元素（出现次数小于等于两次，且没被复制过）

之后确定需要的操作
1. 修改 l 指向的数据
2. 移动 r
3. 移动 l

会影响操作执行的情况
1. l 和 r 的位置关系
2. r 指向元素的出现次数
3. 指针指向的元素是否使用过

确定执行上面操作需要满足的条件（同级表示 ||，父子表示 &&，特殊操作会单独指明）
- 修改 l 指向的数据
    1. l 和 r 不在一起
        1. 元素没修改过

- 移动 r
    1. 当前数据与前一个相同
        1. 元素出现次数在规定次数之内
            1. l 和 r 在一起
            r 前移一个位置
        2. 元素出现次数超过规定次数
        r 前移到下一个不同元素的位置
    2. 不相同
        1. l 和 r 在一起
        r 前移一个位置

- 移动 l
    1. 当前位置修改过
    向前移动一个位置
    2. l 和 r 在一起
        1. 当前数据的出现次数在规定次数之内

最后把上面的想法揉在一起写成代码，有些判断条件相互关联，可以写在一起，会导致代码看起来和上面写的三段判断不太一样，这个见仁见智，大家各凭本事自由发挥就行，我写的也就算个参考

``` cpp
cnt = 1, l = 1, len = 1;
for (r = 1; r < nums.size();) 
// 注意这里不要修改 r 的值，因为 r 在循环里已经控制好了
{
    if(l != r)
    {
        nums[l] = nums[r];
        l++, len++, r++;
    }

    if(r < nums.size() && nums[r-1] == nums[r])
    {
        cnt++; // ←用来统计当前元素出现次数的
        if(cnt > 2)
        {
            cnt = 1;
            while(r < nums.size() && nums[r-1] == nums[r]) r++;
            // 这里↑就是加速前进
        }else 
        {
            if(l == r) l++, r++, len++;
            else continue;
        }
    }else
    {
        cnt = 1;
        if(l == r) l++, r++, len++;
        else continue;
    }

}
```
