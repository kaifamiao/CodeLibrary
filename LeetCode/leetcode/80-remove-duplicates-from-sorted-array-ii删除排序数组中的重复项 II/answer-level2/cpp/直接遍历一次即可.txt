原地删除肯定是双指针，一个指向遍历的元素，一个指向可以写入的位置，后者的大小是小于等于前者的，关键在于题目条件的转化，如何实现限制最多两次的重复出现。
我们先不考虑边界情况，只考虑中间的情况，假设当前遍历位置为i，写指针的可写入位置为current+1，对于i处的值，其写入的条件是重复小于等于2次，我们考虑已经写入的最后两位current和current-1，这两个位置的情况有两个，相等和不相等，首先考虑相等的情况，此时若i处的值和current-1或者说current处的值相同，那么，i处的值肯定不能加入；然后考虑不相等的情况，即current-1和current处值不相等，那么i处的值无论为什么，都满足题意的，即可以加入，综上所述，当i处的值与current-1处的值不相等时，i处的值可以加入，其他情况均不能加入。
接着考虑边界情况，我们只需要考虑开始即可，开始时，前两个值无论等还是不等，都要原封不动的挪到新数组里，由于新数组就是在原数组上进行修改的，因此前两位直接不动即可，只需要修改遍历指针和写入指针就行。
以上算法只需要进行一次遍历即可，时间复杂度O(n)，空间复杂度O(1)。
```
int removeDuplicates(vector<int>& nums) 
{
	if (nums.size() <= 1)
		return nums.size();
	int current = 1;           //新数组中有效位置的最后一位，新加入的数据应当写到current+1
	for (int i = 2; i < nums.size();i++) //从第三位开始循环，前两位无论如何都是要加入新数组的
	{
		if (nums[i] != nums[current - 1])  //符合条件，加入新数组
		{
			current += 1;
			nums[current] = nums[i];
		}
	}
	return current+1;
}
```