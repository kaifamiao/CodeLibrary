### 复杂度

时间复杂度：$O(n^2)$；空间复杂度 $O(n^2)$，但可以简化为 $O(n)$。

>  ⚠️ **高复杂度提醒**
>
> 这道题存在一种效率更优的贪心算法，时间复杂度 $O(n \log n)$ (优先队列)，空间复杂度 $O(n)$。请参考 [lucifer1004](https://leetcode-cn.com/problems/pizza-with-3n-slices/solution/shuang-xiang-lian-biao-tan-xin-suan-fa-shi-jian-fu/) 的题解。

### 化简问题：化为不相邻的子数列的最大和问题

这道题我认为本身不难，不管是算法上还是程序上；但难在将问题化简上。

我们需要先将题目用可以编程的思路重新描述一遍。这道题其实等价于不相邻的子数列的最大和问题。譬如对于下述数列 (9 个披萨分割) 而言，我们至多可以拿走 3 个披萨：
```
1 2 3 4 5 6 7 8 9
```
我们拿的披萨可能可以是下述情形：
```
  idx 1 2 3 4 5 6 7 8 9
case1 -   -   -
case2 -   -       -
case3 -     -   -
case4   -     -   -
```
看起来最为诡异的情形可能会是 `case1`。对于上述的 `case1`，我们可以遵循下述拿披萨的思路：
- 拿披萨 5，其它两人拿披萨 4, 6；
- 拿披萨 3，其它两人拿披萨 2, 7；
- 拿披萨 1，其它两人拿披萨 1, 9。

其它的情形也不难验证是合理的可以拿走披萨的情形。但下述的情形是不可能的：
```
  idx 1 2 3 4 5 6 7 8 9
case1 - - -
case2 -   - -
case3 -           -   -
```
上述的 `case3` 是不允许的，因为如果我们拿走披萨 1，那么披萨 9 就会被其它两人取走，反之亦然。

尽管没有严格的证明，但大致可以肯定，只要我们拿的披萨不相邻，那么我们总是可以设计一种方案，把这些披萨拿走。因此，这个问题可以化为不相邻的子数列最大和问题。

> 需要注意，这里的 **不相邻** 包括 **不同时包含首尾**。即对于上面的 9 分披萨问题而言，不仅 2 与 3 是相邻的，1 与 9 也是相邻的。

> 关于上述断言的证明是存在的，可以参考其他题解。

### 思路：动态规划

化为不相邻的子数列最大和问题后，解题思路就清晰了。这道题的一种思路可以是动态规划的方式求解。

现在我们考虑一个我曾经做错的例子：
```
slices 9 5 1 7 8 4 4 5 5 8 7 7
```
由于 **不相邻** 包括 **不同时包含首尾**，因此为了简化问题，我们先剔除最后一个披萨 `7`，考虑下述数组的不相邻子数列最大和：
```
slices 9 5 1 7 8 4 4 5 5 8 7
```

我们构造一个动态规划数组 `dp`，维度为 (4, 11)；其中 11 是披萨分割 `slice` 的大小，而 4 是 12/3 得来，表示自己最多可以拿 4 个披萨。

`dp[r][c]` 的意义是，在区间 `[0, c-2]` 块披萨中，不相邻地取走不多于 `r` 个披萨，并同时取走第 `c` 块披萨之后，最大的披萨总大小值，因此总共取走 `r+1` 块披萨。之所以不是区间 `[0, c-1]`，是因为我们规定 `dp[r][c]` 的值包含了第 `c` 块披萨，因此不能取走第 `c-1` 块披萨。详细的过程可以参考代码部分，这里列出动态规划向量 `dp` 的值：
```
dp[0]  9  5  1  7  8  4  4  5  5  8  7
dp[1]  9  5 10 16 17 13 13 14 14 17 16
dp[2]  9  5 10 16 18 20 21(22)22 25 24
dp[3]  9  5 10 16 18 20 22 25 26 30 29
```
对于上述 `dp`，取最后一列的最大值 30，即为 **不拿最后一块披萨** 的最大不相邻披萨总大小。
我们拿上述 `dp[2][7] = 22` 举例 (括弧括起来的数)。它的计算方式是
```
dp[2][7] = 22 = max({ dp[1][0], dp[1][1], ..., dp[1][7-2] }) + slices[7]
              = max({ 9, 5, 10, 16, 17, 13, 13 })            + 5
```

刚才讨论的是 **不拿最后一块披萨** 的情形。我们还要讨论 **不拿第一块披萨** 的情形。这种情形的 `dp` 动态规划数组是
```
dp[0]  5  1  7  8  4  4  5  5  8  7  7
dp[1]  5  1 12 13 11 12 13 13 13 16 15
dp[2]  5  1 12 13 16 17 18 18 21 20 23
dp[3]  5  1 12 13 16 17 21 22 26 25 28
```
最后一列的最大值为 28。

综合不拿最后一块和不拿第一块披萨的情况，我们知道最优的情况是总共拿 30 大小的披萨。验证一下结果：
```
slices 9 5 1 7 8 4 4 5 5 8 7 7
take   -       -     -   -
```

如果不区分最后一块披萨和第一块披萨，那么答案会是 32，这也是我曾经栽跟头的地方 (=△=)：
```
slices 9 5 1 7 8 4 4 5 5 8 7 7
take   -       -         -   - ** Wrong Answer! **
```

> 上述 `dp` 的设计未必是最合理的，尽管似乎能给出正确结果。其他题解有对此的讨论。

### 代码

下述为与题解叙述相同的空间复杂度 $O(n^2)$ 代码 (耗时 8ms-24ms)：

```c++
class Solution {
    // 求从 n-1 块披萨的 slices 分割中，取出整数除法的 (n-1)/3 + 1 块披萨的最大披萨总和
    // 若 n = 11, 那么取出的披萨数量是 4 块
    int maxSizeSlicesInner(vector<int>& slices) {
        vector<vector<int>> dp(slices.size() / 3 + 1, vector<int>(slices.size(), 0));
        dp[0] = slices;
        for (int r = 1; r < dp.size(); ++r) {
            int prev_max = 0;  // 表示在 [0, 0], [0, 1], ..., [0, c-2] 区间披萨，取出不多于 r 块披萨的情形下，最大披萨总和的最大值
            for (int c = 0; c < slices.size(); ++c) {
                if (c >= 2) prev_max = max(dp[r - 1][c - 2], prev_max);
                dp[r][c] = slices[c] + prev_max;  // dp[r][c] 表示 [0, c] 区间的披萨，取出不多于 r + 1 块 (包括第 c 块) 披萨的情形下，最大披萨总和
            }
        }
        return *max_element(dp.back().begin(), dp.back().end());  // 答案即是 dp 的最后一行的最大值
    }
public:
    int maxSizeSlices(vector<int>& slices) {
        vector<int> v1(slices.begin() + 1, slices.end());    // 去除第一块披萨的情形
        vector<int> v2(slices.begin(), prev(slices.end()));  // 去除最后一块披萨的情形
        return max(maxSizeSlicesInner(v1), maxSizeSlicesInner(v2));  // 取两种情形的最大值
    }
};
```

但由于每次更新 `dp[r][c]` 时，我们只用了 `dp[r-1]` 的信息，意味着可以将内存复杂度降为 $O(n)$ (耗时 4ms-8ms)：

```c++
int maxSizeSlicesInner(vector<int>& slices) {
    vector<int> dp_prev(slices);
    vector<int> dp_next(slices.size(), 0);
    int n = slices.size() / 3 + 1;
    for (int r = 1; r < n; ++r) {
        int prev_max = 0;
        for (int c = 0; c < slices.size(); ++c) {
            if (c >= 2) prev_max = max(dp_prev[c - 2], prev_max);
            dp_next[c] = slices[c] + prev_max;
        }
        swap(dp_prev, dp_next);
    }
    return *max_element(dp_prev.begin(), dp_prev.end());
}
```