
# 空间复杂度O（m*n）的方法，没有使用原地算法
因为题目要求是一次性改变，也就是**改变后的元素不会影响到之后的结果。**

比如说1变成0后，之后**如果它作为其他元素的相邻八个元素之一，依然把它当做改变前的1来使用。**

所以在原数组上改变有点困难，新建一个数组，把改变后的值全部放在新数组中，查询活细胞数目还是在原数组上查询，全部改变完后，再将新数组复制到原数组上！

空间复杂度有点尴尬，可能因为没有实现原地改变的算法吧~

# 空间复杂度O（1）的方法，使用原地算法

**如果要实现原地算法，可以采用设置标记的方法。这个方法有点自己设定密码的感觉，用数字代表不同的含义**
一共四条规则，对应四种情况

1. 原本活着的细胞，现在死了，置为-1
2. 原本活着的细胞，现在依然活着，置为1（本来也是1）
3. 原本死掉的细胞，现在复活了，置为2
4. 原本死掉的细胞，现在还是死的，置为0,（本来也是0）

然后遍历八个位置寻找活细胞的时候，如果绝对值是1，那么不管它现在是死是活，至少它改变前是活细胞

**最后，还要再遍历一下数组，将它改回题目默认的只存在0和1的状态**
- 小于等于 0的就是死细胞，置为1
- 大于0的就是活细胞，置为0

很巧妙的思路，代码我就不贴了，相信大家都能写出来，这里只附上我一开始写的笨比代码~

![6NZ6~)3BN$0@5BFYE_{W916.png](https://pic.leetcode-cn.com/9dbaa9c3497f411f8a673f9cf603af49c7ff3ce4cbc350e4087c7e82022e780e-6NZ6~\)3BN$0@5BFYE_%7BW916.png)


```
public void gameOfLife(int[][] board) {
        int m = board.length;
        int n = board[0].length;
        //有别于以往的dx和dy数组，这里有八个元素
        int[] dx = new int[]{0,0,1,-1,1,-1,-1,1};
        int[] dy = new int[]{1,-1,0,0,1,1,-1,-1};
        int[][] grid = new int[m][n];
        for(int i = 0;i < m;i++)
        {
            for(int j = 0;j < n;j++)
            {
                //标记周围的活细胞数
                int flag = 0;
                //遍历当前位置的八个相邻位置
                for(int k = 0;k < 8;k++)
                {
                    int newX = i + dx[k];
                    int newY = j + dy[k];
                    //如果越界直接跳出
                    if(newX < 0 || newX >= m || newY < 0 || newY >= n)
                        continue;
                    if(board[newX][newY] == 1)
                        flag++; 
                }
                //如果活细胞数是3，该位置上必定是活细胞，死的复活，活的继续活着
                 if(flag == 3)
                    grid[i][j] = 1;
                else{
                    //如果活细胞数是2，且原本是活细胞，可以继续存活
                    if(board[i][j] == 1 && flag == 2)
                        grid[i][j] = 1;
                    //否则该位置上记为死细胞
                    else
                        grid[i][j] = 0;
                }
            }
        }
        //改变原二维数组
        for(int i = 0;i < m;i++)
            for(int j = 0;j < n;j++)
                board[i][j] = grid[i][j];
    }
```


