![image.png](https://pic.leetcode-cn.com/d05ca546de0fc83f3bb61b4eafc030fa4d0148bab662b26cfefd6c271672d5c0-image.png)
先来一把滑翔机枪

基本的算法就不再赘述了，这里主要考虑一下进阶算法。

### 第一个进阶

首先，如果要原地操作数组，必须使数组元素既可以保存细胞当前状态，又可以表示细胞下一轮的状态，考虑到原始数组中只包含0、1两种状态，我们很容易想到可以使用不同的数字代表一些复合状态，例如：用2表示“细胞当前是存活的，但下一轮会死掉”，或者3表示“细胞当前是死亡的，但下一轮会复活”等等。这样我们就解决了数组原地操作的问题。

### 第二个进阶。

这个需要回过头来重新考虑更新细胞状态的方式，大部分情况下，我们很容易想到解决问题的方式，只要遍历整个二维数组，计算每个细胞在下一轮的状态，更新输出就可以了，代码看起来大概是这样的：
```js
var gameOfLife = function(board) {
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[i].length; j++) {
            // 通过这个方法更新每一个细胞的状态，这个时候细胞的状态是一个复合状态，如前文提到的
            updateCellState(i, j, board);
        }
    }
    // 更新board状态，将每个细胞的复合状态更新为最终状态
    updateBoard(board);
    return board;
};
```
然而，“生命的产生并不容易”，玩过生命游戏的人会很清楚，棋盘上的大部分空间都是一片死寂，显然遍历整个棋盘大部分时间是在做无用功，那么我们应该怎么去更新细胞的状态呢？

我们换一个思路来描述问题：
> 每个存活的细胞都会对周围的8个细胞造成影响，会使他们的某个属性值+1，而这个属性值又会影响到它们的存亡。当这个属性值等于2时，细胞继续维持当前的状态；当这个属性值为3时，无论这个细胞的当前状态如何，都会变为“存活”，除此之外的所有情况，该细胞都会变为“死亡”

以这种思路来描述这个问题，我们是不是对解决这个问题有了新的思路，先看代码：
```js
var gameOfLife = function(board) {
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[i].length; j++) {
            if (board[i][j] % 10 === 1) {
                updateCellState(board, i, j);
            }
        }
    }
    // 更新board状态，将每个细胞的复合状态更新为最终状态
    updateBoard(board);
    return board;
};
```
![006fbYi5gy1g2b7wn68rbg30780584jw.gif](https://pic.leetcode-cn.com/80e24d4f861e2cf0ea28b1f23ece4c2daf560c2e6e285b24d755e7b18070f330-006fbYi5gy1g2b7wn68rbg30780584jw.gif)

这他喵的有什么区别！！！

仔细看`updateCellState`函数，他们的参数是不一样的哦，其实他们的含义也不同，前者表示“根据细胞周围8铬细胞的状态更新该细胞的状态”，而后者表示“根据该细胞的状态，更新周围8个细胞的状态”，再看一看代码实现：
```js
// 更新细胞[m, n]周围的细胞状态，细胞下一轮状态通过计数来实现，存储在十位
var updateState = function(board, m, n) {
    for (let i = m - 1; i <= m + 1; i++) {
        for (let j = n - 1; j <= n + 1; j++) {
            if ((i !== m || j !== n) && board[i] && typeof board[i][j] !== 'undefined') {
                board[i][j] += 10;
            }
        }
    }
}
```
在这里，我们使用元素的“十位”作为计数，表示下一轮细胞的状态，细胞的当前状态就用“个位”来表示。这样，当遍历完所有存活的细胞后，那么这个细胞位置的元素十位就表示了该细胞周围的细胞数量，也就很容易判断下一轮的状态了。

其实就是一个简单的改变，效率一下子提高了一大截。

然后再从这里说到第二点进阶，世界这么大，用数组存储显然不合适的，那用什么合适呢？用什么都不合适！

看我们刚才的思路，“通过存活的细胞去更新周围细胞的状态”，细细一想，board的作用貌似不大。其实我们关心的只有存活的细胞，这么一来，你只要告诉我存活细胞的坐标就可以了，我可以通过存活细胞的坐标计算出下一轮存活细胞的坐标，完全脱离世界而存在。

那么，接下来让我们结束吧！