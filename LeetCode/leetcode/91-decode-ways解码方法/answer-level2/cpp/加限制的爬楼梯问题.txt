这个题是一个典型的动态规划问题，类似与爬楼梯那种，但是加了些限制。对于dp[i]来说，它能由dp[i-1]加一个字符得到，或者dp[i-2]加两个字符得到。对于前者比较简单只要家的字符s[i-1]不为'0'即可，而后者这要求s[i-2]s[i-1]是大于10小于等于26。
现在要处理的就是初始化问题，我觉得动态规划的难点一个是递归式，另一个就是初始化。跟数学中的反证法挺像的。这题的初始化只要注意一个问题就是首字符为'0'是没有解的。别的就和楼梯问题一摸一样了。
对比了6个月前写的同题代码，自我感觉还是有进步的，哈哈！
class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        if(n==0 || s[0]=='0') return 0;
        vector<int> dp(n+1);
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++)
        {
            int temp=(s[i-2]-'0')*10+(s[i-1]-'0');
            if(temp>=10 && temp<=26) dp[i]+=dp[i-2];
            if(s[i-1]!='0')
            dp[i]+=dp[i-1];
        }
        return dp[n];
    }
};