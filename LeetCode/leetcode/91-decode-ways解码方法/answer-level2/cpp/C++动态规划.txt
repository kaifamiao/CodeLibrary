### 解题思路
思路3分钟就有了，实现的路上一波10折，实现了三个小时😭
把输入的字符串s看成一个一个来的，则第 i 个字符串来了只和第 i-1, i-2 个字符串相关。用 a, b, newb 分别保存到第 i-2, i-1, i 个字符的可能情况，则：
以 '0' 开头等特殊情况先考虑，其他情况如下：
1. if s[i] == 0:
	- if s[i-1] == 0: 	# 没戏了，两个连着的 0，比如 1001, 解不了, newb = 0
	- elif s[i-1] > 3:  # 也没戏了，30这样的或0开头的，比如401, 解不了，newb = 0
	- else:             # 10, 20 这样的，此时总的 i 个字符串和 i-2个字符串的一样，比如1201, 因为10,20必须连在一起才行，所以 newb = a
2. else: # 来的数字不是 0
	- if int( s[i-1, i] ) > 26: # 前面是左闭右闭区间，注意这里是数学的区间，不是python的语法。其实就s[i-1:i]组成的数字，如果大于 26， 这两个数字只能分开，此时不增加解法，比如666，每个6必须分开。所以 newb = b
	- elif int( s[i-1, i] ) < 26: # 这时可以把 s[i-1, i] 当一个整体，比如123，有s[:i-2]='1' 字符串对应的解法，即a=2种，或把s[i] 自己当一个整体，有s[:i-1]='12' 种解法，即b=2种，所以 newb = a + b = 3. **注意**:这里要考虑 s[i-1] != 0 的情况，因为如果 s[i-1] == 0，此时b必须单独出来，比如102，不能解02. 

### 代码

```cpp
class Solution {
public:
    int numDecodings(string s) {
        if(s.length() == 0 || s[0] == '0')
        	return 0;
        	
		if(s.length() == 1)
        	return 1;
        
        int a=1, b=1;
        for(int i=1; i<s.length(); i++) {
        	if(s[i] == '0') {
        		if(s[i-1] - '0' >= 3 || s[i-1] == '0') {
        			b = 0;
        			break;
				}
				else
					b = a;
			}
			else {
				if(stoi(s.substr(i-1, 2)) > 26) {
        			a = b;
				}
				else if(s[i-1] != '0'){
					int b2 = b;  // 借助 b2 来让 new_a = old_b, new_b = old_a + old_b
					b += a;
					a = b2;
				}
			}
		}
		
        return b;
    }
};
```