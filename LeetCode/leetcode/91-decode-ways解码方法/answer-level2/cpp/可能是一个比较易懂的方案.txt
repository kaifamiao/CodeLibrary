原问题等价于：求所有的划分方法数，每种划分将字符串分割为长度为1或2的子字符串。

举个例子，给定`"12"`，我们可以在3个位置进行切割得到：
`"|12"`，`"1|2"`和`"12|"`，其中第一种切割和最后一个切割结果一样，所以共有两种划分方法。

为便于形式化描述，我们记`DW(string)`为`string`对应的答案，如`DW("12")=2`，表示`"12"`共有2种解码方法。

为了求得所有的划分方法数，我们运用动态规划。

首先我先提个问题：如果我们知道了一个字符串的答案，在其左侧增加一个字符，新的字符串的答案怎么计算？

还是那上面的例子来说，现在我们有`DW("12")=2`，如何求`DW("112")`？

新的字符串我们可以在两个位置进行划分得到：`"1|12"`和`"11|2"`，然后利用已知的结果进行计算：

`DW("112") = DW("12") + DW("2")`

**注意：** 这是在`|`左侧的部分在映射中的情况，如果不是则为0。举个例子，`DW("012")=0`。

清楚了这些就比较容易写代码了：

```c++
class Solution {
public:
    int numDecodings(string s) {
        int n = s.length();
        vector<int> dw(n + 1, 0);
        dw[n] = 1; 
        if (s[n - 1] != '0') dw[n - 1] = 1;
        for (int i = n - 2; i >= 0; i--) {
            if (s[i] != '0') {
                dw[i] += dw[i + 1];
                string s1 = s.substr(i, 2);
                if (s1 >= "10" && s1 <= "26") {
                    dw[i] += dw[i + 2];
                }
            }
        }
        return dw[0];
    }
};
```
