### 解题思路
这道题目是典型的动态规划问题，比较麻烦的是0的出现，这样就会导致一些额外的判断。
首先设置一个dp数组，dp[i]的含义是前i个字符可以编码的总数。由于编码最多涉及到两个字符，所以我们可以建立起状态转移方程(不涉及0):
    若s[i]单独编码，则 dp[i]=dp[i-1];
    若s[i-1]s[i]可以(s[i-1]s[i]在10到26之间)放在一起编码，则dp[i]=d[i-2]
那么我们可以得到下面的转移方程：
    dp[i]=dp[i-1]+dp[i-2]; //s[i-1]和s[i]可以联合编码
    dp[i]=dp[i-1];         //s[i]单独编码，但是s[i-1]s[i]不在1-26范围内
这样，状态转移方程就完成了，但还要考虑0的情况:
1.如果0在字符串开始，那么一定无法编码，因为找不到对应的编码规则。
2.如果0在字符串中间，且不是连续的0，那么0必须和前一个非0的数字凑成小于等于26的两位数
3.如果出现连续的0，那么不可能完成编码

时间复杂度，我们只是遍历了字符串，所以为O(N),空间复杂度为O(N)
### 代码

```cpp
class Solution {
public:
    int numDecodings(string s) {
        int n=s.size();
        if(n==0)
            return 0;
        vector<int> dp(n,0);
        if(1<=s[0]-'0'&&s[0]-'0'<=9)
            dp[0]=1;
        else
            return 0;
        for(int i=1;i<n;i++){
            /*如果数字==0，就直接退出，不可能匹配*/
            if(s[i]-'0'>0)
                dp[i]=dp[i-1];
        
            int tmp=stoi(s.substr(i-1,2));
            if(tmp>=10 &&tmp<=26){
                if(i-2>=0)
                    dp[i]+=dp[i-2];
                else
                    dp[i]+=1;
            }else{
                if(tmp==0)
                    return 0;
            }
            
              
        }
        return dp[n-1];
    }
};
```