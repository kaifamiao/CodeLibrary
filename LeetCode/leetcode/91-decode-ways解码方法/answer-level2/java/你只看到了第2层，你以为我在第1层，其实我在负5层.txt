### 解题思路
![QQ截图20200316174510.png](https://pic.leetcode-cn.com/b8606f10ac7616a8bcdce34640eb5b76c4ac231a344fd46416f6dcc92f0e8b3f-QQ%E6%88%AA%E5%9B%BE20200316174510.png)

类似于斐波那契数列，和70.爬楼那道题梯很像，因为爬楼梯是一次只能前进1个或2个格子，这里可能的数字组合也只能是1位或2位数字组合在一起，
爬当前楼梯可能的爬法是爬前一阶楼梯和爬前两阶楼梯可能的爬法之和，
算入当前数字在内的数字组合是前一个数字可能的组合方法和前两个数字可能的组合方法，
所以第i位数字可能的数字组合m[i]=m[i-1]+m[i-2]

只不过这里比爬楼梯难在一点上，就是对组合的判断,要满足1<=s[i-1...i]<=26,否则m[i]=m[i-2],尤其是对出现‘0’的判断
### 代码

```java
class Solution {
    public int numDecodings(String s) {
        if(s.charAt(0)=='0') return 0;//以0开头的字符串，0是非法字符，只有在“10”，“20”这两种情况下出现才合法，这里直接0打头，摊牌了，没法玩了
        int[] m=new int[s.length()];
        m[0]=1;//单独一个不是0的数字（1~9）必合法
        for(int i=1;i<s.length();i++){
            if(s.charAt(i)=='0'){//当前数字为‘0’
                if(s.charAt(i-1)=='0') return 0;//连续两个0，整个字符串非法，没法解
               else{
                    if(s.charAt(i-1)>'2') return 0;//0前头不是1，也不是2，非法组合
                    else m[i]=i-2<0?1:m[i-2];//“10”或者“20”的情况，只能把10，20绑定在一起解码，如“110”只有1种解码方法
                }
            }else{//当前数字不为0
                if(s.charAt(i-1)=='0') m[i]=m[i-1];//如“1105”，指到5时，5不能和前面的0组合，0只能和1绑定在一起，所以还是1种解码方法
                else{//前面数字也不是0
                    if(Integer.parseInt(s.substring(i-1,i+1))<=26) m[i]=(i-2)<0?2:(m[i-1]+m[i-2]);//只要满足1...26之间就合法，如“11”可解码成2种
                    else m[i]=m[i-1];//如“138”，只有1种解法
                }
            }
        }
        return m[s.length()-1];
    }
}
```