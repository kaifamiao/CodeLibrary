### 方法一：动态规划

- 核心思想：当前序列 `s (0,i-1)` 在末尾加上一个字符 `s[i]`时，对于解码次数的影响

- `s[i] = '0'`

  - `s[i-1]`可以和 `s[i] = '0'`组合起来生成一个合法的数字 `[10,26]`,则：
    - `dp[i] = dp[i-2]`
  - `s[i-1]`不可以和 `s[i] = '0'`组合起来生成一个合法的数字 `[10,26]`,则：
    - **return 0 ,非法情况**

- `s[i] != '0'`

  - `s[i-1]`可以和 `s[i] != '0'`组合起来生成一个合法的数字 `[10,26]`,则：
    - `dp[i] = dp[i-2] + dp[i-1]`
  - `s[i-1]`不可以和 `s[i] != '0'`组合起来生成一个合法的数字 `[10,26]`,则：
    - `dp[i] = dp[i-1]` （`s[i] != '0'`自身可以转化，但是对于解码数无影响，例如：`133 + ‘2’`）

- 需要注意的地方(非法情况)：

  - | 非法情况                                                     |
    | ------------------------------------------------------------ |
    | **0**12   以0开头                                            |
    | 10**0**   当前字符为0，且当前字符和之前的字符组合“00”也不再(10,26)的范围 |
    | 33**0**   当前字符为0，且当前字符和之前的字符组合“30”也不再(10,26)的范围 |

```java
class Solution {
             public int numDecodings(String s) {
                 if(s == null || s.length() == 0) return 0;
                 if(s.charAt(0) == '0') return 0;    // 首字符为0无法转换,非法      
                 // dp[i] 到第i个字符时,所有的解码方式 
                 int[] dp = new int[s.length()+1];
                 dp[0]=1;dp[1]=1;
                 for(int i=2;i <= s.length();i++){
                    // i：第i个字符
                    int preNum = s.charAt(i-2) - '0'; // 前一个数字
                    int curNum = s.charAt(i-1) - '0'; // 当前数字
                    int num = preNum * 10 + curNum;   // 两个字符组合产生的数字
                    if(curNum == 0 && (preNum < 1 || preNum > 2)){
                        // 当前0无法转换，且和前一个字符组合-->'c0'也是非法
                        // 非法字符串，无法转换
                        return 0;
                    }
                    if(curNum == 0 && (preNum == 1 || preNum == 2)){
                        // 当前字符为0，无法转换
                        // 当前字符为0可以和之前的字符组合起来转换---dp[i-2]
                        // 所以当前的dp[i]的解码数就是dp[i-2],
                        // 第(i-1 和 i)个字符组合起来产生一个字符对于解码数无影响
                        dp[i] = dp[i-2];
                    }else if(10 <= num && num <= 26){
                        // (1)当前字符不为0,可以自己转换            dp[i-1]
                        // (2)当前字符可以和之前的字符组合起来转换    dp[i-2]
                        dp[i] = dp[i-1] + dp[i-2];
                    }else{
                        // 当前字符不为0,可以自己转换    dp[i-1]
                        // 不可以和之前的字符组合起来转换
                        dp[i] = dp[i-1]; 
                    }
                 }
                 return dp[s.length()];
             }
         }
}
```

### 方法二：动态规划 + 空间压缩

由于只用到了`dp[i-1] ，dp[i-2]`所以只用两个变量存起来，然后不断递推