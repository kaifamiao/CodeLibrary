思路：这题动态规划的思路比较明显
1. 遍历字符串，记录每个数字索引n处，前n个字符的解码方法数量f(n)=f(n-1)+f(n-2)；
2. 但是，首先要注意两位数的取值范围10~26，计算f(n-2)判断s[n-1:n+1]是否处于范围内；
3. 其次，要注意字符‘0’及其位置，计算f(n-1)要判断s[n]是否等于‘0’，‘0’是否出现在字符串开头。

```
class Solution:
    def numDecodings(self, s: str) -> int:
        l = len(s)
        f = [0 for i in range(l)]
        
        if s[0] == '0':return 0         #开头出现‘0’，则无法解码
        
        f[0], f[-1] = 1, 1            #为f[1]作准备
        for i in range(1, l):
            p = int(s[i-1:i+1])
            #检查当前字符s[n]==0，且是s[n-1:n+1]是否处于两位数范围内
            f[i] = f[i-1] * int(s[i] != '0') + f[i-2] * int(9<p<=26)
        
        # print(f)
        return f[-1]        #返回所有字符的解码数量

执行结果：通过示详情
执行用时 :48 ms, 在所有 python3 提交中击败了69.22%的用户
内存消耗 :13.9 MB, 在所有 python3 提交中击败了5.21%的用户
```
