解决这道题一个比较高校的解法便是动态规划。

首先，大家还记得爬楼梯问题么，一共有n个台阶，一次只能向上走一阶或者两阶，问一共有多少种走法？
这是个很经典的动态规划问题，用dp[n]表示爬完n个台阶的方法总数，那么最后一步可能是走了一阶，也可能是走了两阶，而走了一阶的方法总数等于爬完n-1个台阶的方法综述，最后一步走两阶的方法综述等于爬完n-2阶方法总数，因此不考虑边界的话可以有公式：
dp[n] = dp[n-1]+dp[n-2]

再回来考虑这道题目，实际上也可以看作爬楼梯问题，每次解码一个数字或者两个数字。我们用dp[i]表示解码字符串s[:i]（包含s[0],s[1],...,s[i-1])的方法总数,考虑dp[i+1]的计算，即解码s[:i+1]的可能情形：
1. s[i]存在字典中，即s[i] ！= '0'（因为测试都是数码串，因此可以这么写），此时解码s[:i+1]可以通过解码字符子串s[:i]和最后一个字符s[i]得到
2. s[i-1:i+1] （即s[i-1]和s[i]构成的字符串）在字典中，在python中即 s[i-1:i+1]>='10 and s[i-1:i+1]<= '26'，此时解码s[:i+1]也可以通过解码字符子串s[:i-1]和最后两个个字符s[i-1:i+1]得到

上面是s[:i+1]可能的解码方法的来源，可以看到它相当于一个加了条件约束的走楼梯问题，因此动态转移公式可以写成：
1. dp[i+1] = 0.          if s[i] == '0' and (s[i-1:i+1] < '10' or s[i-1:i+1]>'26')
2. dp[i+1] = dp[i].      if s[i]!= '0' and (s[i-1:i+1] < '10' or s[i-1:i+1]>'26')
3. dp[i+1] = dp[i-1].    if s[i] == '0' and (s[i-1:i+1] >= '10' and s[i-1:i+1]<='26')
4. dp[i+1] = dp[i]+dp[i-1]. if s[i] != '0' and (s[i-1:i+1] >= '10' and s[i-1:i+1]<='26')

写在程序里，上面的条件判断可以写成简单的两个if判别语句：

```python []
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if n==0: return 0
        dp = [1,0]
        dp[1] = 1 if s[0]!='0' else 0 
        for i in range(1,n):
            dp.append(0)
            if s[i]!='0':
                dp[i+1] += dp[i]
            if s[i-1:i+1]>='10' and s[i-1:i+1]<='26':
                dp[i+1] += dp[i-1]
        
        return dp[-1]
```
该算法的时间代价为O(N),空间代价O(N).

进一步优化，可以保持dp数组的大小为2（因为再之前的数据是用不到的），时间代价O(N),空间代价O(1).
```python []
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if n==0: return 0
        dp = [1,0]
        dp[1] = 1 if s[0]!='0' else 0 
        for i in range(1,n):
            dp.append(0)
            if s[i]!='0':
                dp[-1] += dp[-2]
            if s[i-1:i+1]>='10' and s[i-1:i+1]<='26':
                dp[-1] += dp[-3]
            dp.pop(0)
        
        return dp[-1]
```




