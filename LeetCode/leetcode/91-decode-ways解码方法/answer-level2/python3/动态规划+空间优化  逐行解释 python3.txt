# 题解
注意这几种情况，是无法解码的：

 1. 以0开头，如："0123","000"
 2. 0前的数字大于2，如："215021"。0前数字小于等于2时，是可以解码的，如："20105"。
## 动态规划
所以，算法设计如下：
 1.  特判，若$s$为空或者$s[0]=="0"$，返回$0$
 2. 初始化$dp=[0,...,0]$，长度为$n+1$，$dp[0]=1,dp[1]=1$，$dp[1]=1$表示第一位的解码方法，$dp[0]$的作用，在于两位时，如："12"，$dp[2]=dp[1]+dp[0]$。
 3. 遍历$s$，遍历区间$[1,n)$：
 	+ 若$s[i]=="0"$：
 		+ 若$s[i-1]=="1" or s[i-1]=="2"$：此时，到当前位置的解码方法$dp[i+1]$和上上一位的相同，因为上一位和本位置结合在了一起。$dp[i+1]=dp[i-1]$
 		+ 否则，返回$0$，表示无法解码
 	+ 否则：
 		+ 判断何时既可以自身解码也可以和前一位结合：若上一位$s[i-1]=="1"$，则当前位既可以单独解码也可以和上一位结合。或者上一位$s[i]=="2"$则此时，若$"1"<=s[i]<="6"$，也是可以的。综上，$s[i-1]=="1" or (s[i-1]=="2" and "1"<=s[i]<="6")$ 。此时，$dp[i+1]=dp[i]+dp[i-1]$，等于上一位和上上位的解码方法之和。
 		+ 否则，$dp[i+1]=dp[i]$
 
 6. 返回$dp[n]$

### 复杂度分析
 - 时间复杂度：$O\left(n\right)$
 - 空间复杂度：$O(n)$

### Python
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        n=len(s)
        if(not s or s[0]=="0"):
            return 0
        dp=[0]*(n+1)
        dp[0]=1
        dp[1]=1
        for i in range(1,n):
            if(s[i]=="0"):
                if(s[i-1]=="1" or s[i-1]=="2"):
                    dp[i+1]=dp[i-1]
                else:
                    return 0
            else:
                if(s[i-1]=="1" or (s[i-1]=="2" and "1"<=s[i]<="6")):
                    dp[i+1]=dp[i]+dp[i-1]
                else:
                    dp[i+1]=dp[i]
        return dp[-1]
```
## 空间优化
我们发现，当前位置的解码方法仅依赖于上一位和上上一位的解码方法数，因此，我们将空间优化到$O(1)$
所以，算法设计如下：
 1.  特判，若$s$为空或者$s[0]=="0"$，返回$0$
 2. 初始化$pre=1$表示上上一位的解码方法，$cur$表示上一位的解码方法
 3. 遍历$s$，遍历区间$[1,n)$：
 	+ 若$s[i]=="0"$：
 		+ 若$s[i-1]=="1" or s[i-1]=="2"$：此时，将$cur$更新为上上一步的解码方法，$cur=pre$
 		+ 否则，返回$0$，表示无法解码
 	+ 否则：
 		+ 判断何时既可以自身解码也可以和前一位结合：若上一位$s[i-1]=="1"$，则当前位既可以单独解码也可以和上一位结合。或者上一位$s[i]=="2"$则此时，若$"1"<=s[i]<="6"$，也是可以的。综上，$s[i-1]=="1" or (s[i-1]=="2" and "1"<=s[i]<="6")$ 。此时，$tmp=cur,cur+=pre,pre=cur$，表示用$tmp$保存上一位置解码方法，更新$cur$为上一步解码方法$cur$加上上步$pre$，并将$pre$更新为$tmp$。
 		+ 否则，$pre$更新为$cur$，$cur=cur$保持不变
 
 6. 返回$cur$

### 复杂度分析
 - 时间复杂度：$O\left(n\right)$
 - 空间复杂度：$O(1)$

### Python
```python
class Solution:
    def numDecodings(self, s: str) -> int:
        n=len(s)
        if(not s or s[0]=="0"):
            return 0
        pre=1
        cur=1
        for i in range(1,n):
            if(s[i]=="0"):
                if(s[i-1]=="1" or s[i-1]=="2"):
                    cur=pre
                else:
                    return 0
            else:
                if(s[i-1]=="1" or (s[i-1]=="2" and "1"<=s[i]<="6")):
                    tmp=cur
                    cur+=pre
                    pre=tmp
                else:
                    pre=cur
                    cur=cur
        return cur

```