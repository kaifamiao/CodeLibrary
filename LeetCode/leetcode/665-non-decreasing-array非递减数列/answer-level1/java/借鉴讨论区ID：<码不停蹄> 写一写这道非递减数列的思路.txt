### 解题思路
此处撰写解题思路
  首先这道题目看似很简单，刚开始拿到这道题目的时候我就想好了解题的思路：分析数组中元素的大小关系，只有当出现前一个元素比后一个元素大时，才有可能违反非递减数列。由此，我简单地想从判断前后大小关系入手，统计有多少个相邻元素出现违反非递减情况，再判断是否等于1。

  但是这道题解并未通过orz，我就想是否逻辑出现了偏差，除了相邻元素间存在违反非递减条件外，不相邻的元素间会不会也有。由此，比如[1,4,7,3,4]在这种情况下虽然相邻元素只出现了一处违反非递减情况，但是仅仅修改一处元素并不能使数组成为非递减数列。

  苦思未果之下，我参考了一些题解，浏览了讨论区的回答，看到《码不停蹄》的回答后豁然开朗。这道题目的关键在于我们不仅仅是计算出现前一元素比当前元素大的个数，而是通过修改元素大小使整个数列非递减，计算所修改元素的个数，这样一来，我们需要考虑出现矛盾情况时，我们到底该修改那个元素的值，我们可以确定的是绝不可能出现两次前一个元素大于当前元素的情况，所以我们只需要分析和当前元素相邻的元素并且出现冲突时，我们应该首先考虑修改前一个元素值，让它等于当前元素的值（如果数列为[1,2,5,3]修改前一元素2为5 当前元素为5，那么将仍然不满足非递减数列要求），但是有一种例外的情况，[1,2,3,3,2]在这种情况下，我们要将当前元素2修改为3。
  相信我们不难找到规律，若当前元素的前两个元素的值不大于当前元素时，我们只需要修改前一个元素的值，若当前元素的前两个元素的值大于当前元素时如（[1,2,3,3,2]），我们要修改当前元素2为3。
  原谅我菜鸡一样的排版和逻辑，希望大神们指正。

### 代码

```java
class Solution {
    public boolean checkPossibility(int[] nums) {
        int cnt = 0;
        int  n = nums.length;
        if(nums == null || n <= 1)
        {
            return true;
        }
        for(int i = 1 ; i < n && cnt < 2; i++){
            if(nums[i] >= nums[i-1]){
                continue;
            }
            cnt++;
            if(i-2 >= 0 && nums[i] < nums[i-2]){
                nums[i] = nums[i-1];
            }else{
                nums[i-1] = nums[i];
            }
        }return cnt <= 1;
    }
}
```