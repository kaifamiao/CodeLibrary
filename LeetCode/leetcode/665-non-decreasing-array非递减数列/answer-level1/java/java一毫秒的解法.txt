具体思路是这样的：假如这个序列是降序的话，我们至多只能改一个元素，把它变成非降序序列。那好，遇到不妥我们就只改一个元素，再判断是不是改对了。
具体如下：我们从头到尾遍历数组所有相邻的数字对，假如排在前面的数字大于排在后面的了，证明这对数影响了非降序的性质，这时，假如真的有解的话，唯一的问题要么出在前面的数字上，要么出在后面的数字上，更明白的说，就是要么前面的数过大了，要么后面的数过小了。所以，对于前面的数过大的情况，我们只需把前面的数改成后面的，数组恢复非降序性质；对于后面的数过小了，只需要把后面的数改成前面的数，数组亦恢复非降序性质，因此，在检验了这两种情况下，数组都不能变回非降序的话，就是无解了。这个算法最坏遍历数组3遍，时间复杂度O(n);
代码如下：
![image.png](https://pic.leetcode-cn.com/beff38692d35df61409e9e08a6c7781c4a0064ee6bc011743e62e4c51ceaaecd-image.png)

