### 整体分析：
根据要求，相邻的两个数必须符合后一个数大于等于前一个数，才是题目中描述的“非递减数列”。我们很容易想到，扫描数组，寻找那些下降的点-也就是前一个数大于后一个数的地方。
有以下几种情况：
1. 不存在这样的下降点==>这个数组本身就是非递减数列，无需改变任何一个数字，返回True。
2. 存在1个这样的下降点==>也许可以通过改变一个数字把原数组变成符合要求的数列，这里就包括标题中我们说的 那个例子[3,4,2,3],一会儿讨论
3. 存在>=2个这样的下降点==>肯定没有办法只改变一个数字就把原数组比阿尼成符合要求的数列，返回False

### 看看[3,4,2,3]的特点
这个测试用例只有一个下降点[4,2]，给了我们可以返回True的希望。但是仔细一看，不行。
试试把4变小？数组变成了[3,2,2,3],产生了新的下降点[3,2].
把2变大呢？数组变成了[3,4,4,3]，产生了新的下降点[4,3]。
所以问题的关键在于，对于出现的一个下降点，我们如何判断它能不能只动一个数就变成题目要求的非递减数列呢？

还是看[3,4,2,3]这个例子。
如果第一个3不存在，对于[4,2,3]来说，我们可以通过把4变小来实现目的。
如果最后一个3不存在，对于[3,4,2]来说，我们可以通过把2变大来实现目的。
所以，如果下降点的前方或后方没有别的元素了，这个下降点就可以通过改变其中的一个数来变成符合条件的数列。

如果前后还真的都有元素呢？那么对于前后元素的大小有要求。
[2,4,2,3]是可以只改一个数就实现目的的，因为前面的数2小于等于下降点的右侧元素2.
[3,4,2,4]也是可以只改一个数就实现目的的，因为后面的元素4大于等于下降点的左侧元素4.

那么我们就好判断了。
对于一个出现的下降点，如果它的前后都有元素，并且前面的元素大于下降点的右侧元素，后面的元素又小于下降点的左侧元素，那么这个下降点就无法只改动一个数字变成符合条件的数列，返回False。

### 基于以上思路写的Python3代码如下
```
class Solution:
    def checkPossibility(self, nums: list) -> bool:
        length = len(nums)
        count = 0  # 这个计数器用于统计下降点的个数
        for i in range(length-1):
            if nums[i]>nums[i+1]:
                # 判断出现的一个下降点能否只动一个数就变成符合条件的数列
                if i-1>=0 and nums[i-1]>nums[i+1] and i+2<=length-1 and nums[i+2]<nums[i]:
                    return False
                count += 1
                # 如果下降点多于1个，自然返回False
                if count >1:
                    return False
        return True

```





