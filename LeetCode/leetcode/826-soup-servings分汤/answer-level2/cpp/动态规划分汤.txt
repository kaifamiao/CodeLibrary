### 解题思路
想法诞生：每次选择策略分汤后，剩下的汤还得像上一个一样选择模式分汤。选择策略空间是一致的，所以联想到动态规划问题。
解题思路：既然是动态规划问题，开始思想转移方程的元素dp该表示什么含义（dp表示极为重要，直接关联题目能否解出）。
        题目有A,B两份汤，则设dp[i][j]表示i份A和j份B的汤 在 A先分配完的概率 + A、B同时分配完的概率/2 的和
        我们观察100,75,50,25都是25的倍数，所以将数缩小25倍，如果传入的N是像24,26这样的数，24不足25得变为25处理，26不足50得变为50处理。这里对应代码中的ceil(N/25.0)，取小数大一位。
        得到转移方程：dp[i][j] = 0.25 * (dp[i-4][j] + dp[i-3][j-1] + dp[i-2][j-2] + dp[i-1][j-3]) 
        得到初始化状态（类似于先验知识）：dp[0][0] = 0.5 (同时分配完 / 2), dp[i][0] = 0; dp[0][i] = 1;

### 代码

```cpp
class Solution {
public:
    double soupServings(int N) {
        // N = N / 25
        // 设dp[i][j] : 剩余i的A和j的B A先分配完的概率+A、B同时分配完的概率/2
        // dp[i][j] = 0.25 * (dp[i-4][j] + dp[i-3][j-1] + dp[i-2][j-2] + dp[i-1][j-3])
        if (N > 4800) return 1;
        N = ceil(N / 25.0);
        vector<vector<double> > dp(N+1, vector<double>(N+1, 0));
        dp[0][0] = 0.5;
        for (int i = 1; i < N+1; i++) {
            dp[i][0] = 0;
            dp[0][i] = 1;
        }

        // 每一个i的值都对应着每种情况的j值，所以这里 for...for循环
        for (int i = 1; i < N + 1; i++) {
            int a1 = i - 4 > 0 ? i - 4 : 0; // 不足4的全部分配完
            int a2 = i - 3 > 0 ? i - 3 : 0;
            int a3 = i - 2 > 0 ? i - 2 : 0;
            int a4 = i - 1 > 0 ? i - 1 : 0;
            for (int j = 1; j < N + 1; j++) {
                int b1 = j;
                int b2 = j - 1 > 0 ? j - 1 : 0;
                int b3 = j - 2 > 0 ? j - 2 : 0;
                int b4 = j - 3 > 0 ? j - 3 : 0;
                dp[i][j] = 0.25 * (dp[a1][b1] + dp[a2][b2] + dp[a3][b3] + dp[a4][b4]);
            }
        }
        return dp[N][N];
    }
};
```