### 解法一：二次遍历 + 去重复

首先，对所有时间求 mod 60 的余数，然后进行归类计数，余数相同的为一类。
然后，成对的时间必定 mod 60 的余数之和为 60，比如：余数 20 和 40 的时间数量为 a 和 b，他们之间的配对结果就是 a * b。
特别注意：特殊余数是 0 或 30 的时候，此时必定只和自身类别中的时间进行配对。

### 代码

实际写代码的时候，遍历数组进行统计求和会发生同一对的二次计数问题，可以在遍历时附加条件判断进行规避，或者直接把最后结果除以 2 亦可（如下代码所示）。

```java
class Solution {
    public int numPairsDivisibleBy60(int[] time) {
        int[] bucket = new int[60];
        for (int t : time) {
            bucket[t % 60]++;
        }
        int cnt = 0;
        for (int i = 0; i < 60; i++) {
            if (bucket[i] == 0) continue;
            if (i == 0 || i== 30) cnt += bucket[i] * (bucket[i] - 1);
            else cnt += bucket[i] * bucket[60 - i];
        }
        return cnt >>> 1;
    }
}
```

### 解法二：一次遍历（隐含递推）

在解法一的基础上进行精简，利用递推的方法，在进行余数统计的过程中完成配对，此处感谢[@床边故事](/u/chuang-bian-gu-shi/) 的评论提醒。

实际我们可以把余数桶认为是一个等待配对的“登记表”，每一次得到一个时间值我们都按照如下操作进行处理：

1. 假设之前的“登记表”上的已有的配对都已经被正确处理了，待处理的只有这个新的时间值
2. 检查“登记表”中是否有需要它进行配对的值，有多少个就又增加了多少个配对
3. 本次配对完成，把当前时间值登记入表，等待后面的时间和它进行配对

本解法当然不会分别记录每个新加入的时间对应的配对数量，但是每次处理新的时间会更新结果计数，实际就是递推状态的记录，实际仍然隐含了递推的想法。只要确定了最初没有处理时间时的配对数量作初始值，即可开始从头递推，显然初始值是 0。

这样，利用动态增长的“登记表”就能只使用一次遍历，并且规避了解法一中的二次计数问题，而且也不需要对余数 30 的情况进行特殊处理。

### 代码

```
class Solution {
    public int numPairsDivisibleBy60(int[] time) {
        int[] bucket = new int[60];
        int cnt = 0;
        for (int t : time) {
            int mod = t % 60;
            int remain = mod == 0 ? 0 : 60 - mod;
            cnt += bucket[remain];
            bucket[mod]++;
        }
        return cnt;
    }
}
```
