简单的数位DP，数位DP作为一种基本DP应该要掌握，此题为一题难度恰当的数位DP入门上手题。
    考虑定义DP：F[i][0/1]表示0到n的前i位组成的数值中数字2出现的次数，0/1表示是否等于“墙”，即是否等于n的前i位组成的数值。
    考虑转移方程：假设已经有前i-1个数位了，枚举第i位数位的值j，分三类：
1. j<A[i]
    这时，不管怎么取v的值，都不可能贴“墙”，所v以只更新F[i][0]，增量为F[i-1][0]+F[i-1][1]+(j==2)*(sum+1)，即前i-1位的贡献和第i位的贡献之和。其中，v为n的前i位组成的数值。
2. j=A[i]
    这时，如果之前贴“墙”，那么现在也贴“墙”，之前没贴，现在也没贴，故F[i][0]与F[i][1]都要更新。详细见代码，思路与上一情况相同。
3. j>A[i]
    现在显然不可能贴“墙”了，具体转移分析和上述情况类似。
最后答案为F[len][0]+F[len][1]，len为n的位数
时间复杂度：O(len) 空间复杂度：O(len)
```
class Solution {
    vector<int> A;
public:
    int numberOf2sInRange(int n) {
        while (n)
        {
            A.push_back(n%10);
            n/=10;
        }
        n=A.size();
        for (int i=0,j=n-1;i<j;++i,--j) swap(A[i],A[j]);
        int F[n][2];
        int v=A[0];
        F[0][0]=(int)(A[0]>2);
        F[0][1]=(int)(A[0]==2);
        for (int i=1;i<n;v=v*10+A[i],++i)
        {
            F[i][0]=F[i][1]=0;
            for (int j=0;j<A[i];++j)
            {
                F[i][0]+=F[i-1][0]+F[i-1][1]+(j==2)*(v+1);
            }
            F[i][1]+=F[i-1][1]+(A[i]==2);
            for (int j=A[i];j<10;++j)
            {
                F[i][0]+=F[i-1][0]+(j==2)*v;
            }
        }
        return F[n-1][0]+F[n-1][1];
    }
};
```
