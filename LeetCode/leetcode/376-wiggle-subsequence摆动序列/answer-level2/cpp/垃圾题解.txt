    表示看了题解后感觉自己果然是个菜鸡...最开始看这个题第一个想到的就是用动态规划找出Fn与Fn-1的关系，基于摆动这个特殊性我想到的是增加一个flag标志表示上一次代表的是上升还是下降（这里我设置-1代表fn-1是下降，1代表上升）,同时另设一个标志位end表示fn-1的最后一个字符位置（因为fn-1不一定为nums[n-1]。简单分析当flag=1时，若此时nums[n]<nums[end],更新end值，flag取反，Fn=（Fn-1）+1，nums[n]>=nums[end],Fn=Fn-1，即自动跳过这个数字去比较下一个(这是错的)，从F1开始值到求出FN的，返回FN值就可以。
    提交后出错，只通过10个样例，最开始也很疑惑然后发现当出现 100 99 88 89 87 90 这样的数组时，按我的解法就是返回2，而其实应该返回5，问题就在于我这个end值！我之前并没有在连续降序的时候更新end值，我在f1将end值定位99后，然后与88比较的时候发现还是降序，那同样是降序为何不选择一个更小的数来作为它的end值呢？它越小代表之后会出现上升的可能性就越大（类似贪心），所以当出现连续降序时跟新end为最小值，连续升序时更新end为最大值！这样一遍可过！（其实也可以不用设置dp数组，那就是时间O（n），空间O（1））这里补充说明一下第一个就是这个摆动序列一定是从第一位开始的，第二个flag初始化问题，这个要注意以下。