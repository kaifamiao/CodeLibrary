### 解题思路
##### 这道题很坑，但是很好理解，首先判断是否是邮箱，用有没有@来判断就好
- 邮箱的话比较好处理，先把所有的字符都转换为小写，再以@为标志位分割，赋值给两个变量，处理好后合并字符串返回即可；
- 如果是手机号，首先后十位肯定是号码位，如果超过十位就肯定是有国际号码位，所以先将S中的数字按顺序存储到列表中，然后根据列表长度来判断是否有国际号码位，超出几位就是几位国际号码位，也就是前边加号后边有几个星号。
##### 具体的看注释就好，写的比较蠢，但是比较好理解

### 代码

```python3
class Solution:
    def maskPII(self, S: str) -> str:
        # 先区分邮箱和手机号，根据有无@来判断
        if '@' in S:
            # 这里是邮箱
            # 先把S都转换为小写字母，然后以@来分割
            name, temp_name = S.lower().split('@')
            # 将第一部分首位取出，中间用五个星号填充
            name = '{}*****{}'.format(name[0], name[-1])
            # 返回修改后的加密邮箱
            return '{}@{}'.format(name, temp_name)
        else:
            # 这里是手机号
            # 仅将数字转换为列表
            phone = []
            for i in S:
                if i.isdigit():
                    phone.append(i)
            # 判断是否是国际号码
            # 判断长度是否是10
            # 10则为非国际号码
            if len(phone) == 10:
                # 这里是非国际号码
                # 仅将后四位暴露
                return '***-***-{}'.format(''.join(phone[-4:]))
            else:
                # 这里是国际号码
                # 将后四位暴露
                # 如果11位，那么国际位为一位
                # 如果12位，那么国际位为两位
                # 如果13位，那么国际位为三位
                if len(phone) == 11:
                    return '+*-***-***-{}'.format(''.join(phone[-4:]))
                if len(phone) == 12:
                    return '+**-***-***-{}'.format(''.join(phone[-4:]))
                if len(phone) == 13:
                    return '+***-***-***-{}'.format(''.join(phone[-4:]))

```