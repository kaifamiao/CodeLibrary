### 解题思路
代码超简单，从后往前看，用两个指针扫描两个数组，边比较边存数，第三个指针指向nums1的末尾存数，存储挪过来的大数。扫描指针移动条件是，该数组有小的数。退出条件是：nums2的索引到最左边，说明数的比较和移动全部完成。需要注意的是i可能会因为nums2中的数都比较小，一直--导致左超限。m+n需要扫描一遍，时间复杂度O(m+n)，空间复杂度O(1)。

### 代码

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // 开了三个指针，从后往前遍历，二个扫描，一个存数
        int i = m-1, j = n-1, k = m+n-1;
        // 循环条件：当nums2检查完，整个工作也完成了。
        while (j >= 0)
        {
            // 注意执行顺序，先判断i >= 0，再判断数大小，否则会报索引超限错误。
            if (i >= 0 && nums1[i] > nums2[j])
            {
                nums1[k] = nums1[i];
                i--;
            }
            // 执行else条件：不满足if中的任意一个条件。
            else
            {
                nums1[k] = nums2[j];
                j--;
            }
            k--; 
        }
    }
}
```