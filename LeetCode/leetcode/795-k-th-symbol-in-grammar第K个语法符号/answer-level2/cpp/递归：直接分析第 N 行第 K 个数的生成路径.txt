1. 首先基于用例对第 N 行进行分析：
- 我们可以发现第 N 行由两部分组成：N - 1 行的序列构成 N 行的左半部分，N - 1 行序列取反构成 N 行的右半部分。
- 直接对上面的观察进行模拟会导致位运算溢出问题，下面考虑直接对第 K 位进行分析

2. 对于第 N 行的第 K 个数，我们可以分析如下：
- 第 N 行的长度为 2^(N-1)
- 若 K <= N 行长度的一半 ，则其等于 N-1 行的第 K 个数
- 反之，则其等于 N - 1 行的第 N - K 个数取反

3. 基于上面的分析我们可以设计如下的递归算法：
- 目标函数为输入 N 行 K 位直接输出该位的值，我们可以直接利用
- 递归关系式就是上面分析的结论
- 递归基选择了第一行和第二行的结果，共三种输出

4. 算法如下：
```
class Solution {
public:
    int kthGrammar(int N, int K) {
        if(N == 1) return 0;
        if(N == 2) return K == 1? 0 : 1;
        
        // 计算上一行的长度（本行长度折半）
        int prevLen = (1 << (N - 1)) / 2;
        
        if(K <= prevLen)
            // 位于前半段，则等价于上一行同样位置的值
            return kthGrammar(N-1, K);
        else
            // 位于后半段，则等价于上一行相应位置的值取反
            // 返回值非 0 即 1，因此直接用 1 去减即可
            return 1 - kthGrammar(N-1, K-prevLen);
    }
};
```
5. 运算技巧：
- 计算上一行的长度的表达式可以简化为：prevLen = 1 << (N - 2)，但是牺牲了可读性
- 使用位运算进行取反：与 1 进行异或
