### 题目描述
在第一行我们写上一个 0。接下来的每一行，将前一行中的0替换为01，1替换为10。

给定行数 N 和序数 K，返回第 N 行中第 K个字符。（K从1开始）

例子:

	输入: N = 1, K = 1
	输出: 0
	
	输入: N = 2, K = 1
	输出: 0
	
	输入: N = 2, K = 2
	输出: 1
	
	输入: N = 4, K = 5
	输出: 1
	
	解释:
	第一行: 0
	第二行: 01
	第三行: 0110
	第四行: 01101001

注意：

N 的范围 [1, 30].
K 的范围 [1, 2^(N-1)].

### 解题思路
我们可以多写几行数据，不难发现规律：

第N行有 2^(N-1) 个字符，且前一半和上一行的字符相同，后一半是对前一半的每个字符取反（0变1，1变0）

这样我们可以对要找的某一个字符追根溯源，找到他是从哪个字符变化而来的，这一过程用递归或迭代很容易完成

例如：

第5行的数据为： 01101001 10010110 

若N = 5, K = 14

解答过程：

	N = 5:	K = 14 > 8,在后一半，是由前一半的第6个数取反而来,而第6个数又是由第第4行得来
	
	N = 4: K = 6 > 4,在后一半，是由前一半的第2个数取反而来，而第2个数又是由第3行得来
	
	N = 3: K = 2 <= 2,在前一半，是由第2行的第2个数得来
	
	N = 2: K = 2 > 1,在后一半，是由前一半的第1个数取反而来，而第1个数又是由第1行得来（第一行为0）
	
	结束，过程中共取反3次，即是由0取反3次得来，所以结果为1
	
### 代码

```java
class Solution {
    public int kthGrammar(int N, int K) {
        int cnt = 0; //记录取反的次数
        while(N > 1){
            int mid = (int)Math.pow(2, N - 2);
            if(K > mid){//在这一行的后一半，说明是由前一半的第K - mid个数取反而来
                cnt++;
                K -= mid;
            }
            N--;  
               
        }
        return cnt % 2 == 0 ? 0 : 1;
    }
}
```