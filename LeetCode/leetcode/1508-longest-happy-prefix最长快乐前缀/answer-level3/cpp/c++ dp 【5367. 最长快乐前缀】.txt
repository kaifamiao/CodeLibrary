### 解题思路
很明显这题是考察kmp中next数组的生成，这其实就是个dp算法，这里解释下状态是怎么转移的。
定义dp数组来保存当前位置的最长快乐前缀的值，**dp[i]** 表示以 **s[i]** 结尾的字符串的【最长】快乐前缀的长度
注意这里【最长】打了个框，意思是以s[i]结尾的字符串有多个快乐前缀，我们只是取最长的一个。
**dp[0]** 毫无疑问应该为0；那么 **dp[i+1]** 怎么从 **dp[i]** 转变过来呢？ 
我们先假设dp[i]中可以保存多个值分别是len1,len2,len3，那么 **dp[i+1]** 必然等于下面三个表达式中最大的一个。
**s[i+1] == s[len1-1] ? len1+1 : 0; 
s[i+1] == s[len2-1] ? len2+1 : 0;
s[i+1] == s[len3-1] ? len3+1 : 0;**
现在问题的关键是，dp数组是一维数组只能保存一个值，怎么从这个一维数组信息中获取以s[i]结尾字符串的所有快乐数组长度呢？

由于**dp[i]** 表示以 **s[i]** 结尾的字符串的【最长】快乐前缀的长度，那么子串 **s[0, dp[i]-1] == s[i-dp[i]+1, i]**，可以得出 ：
**s[i]            == s[dp[i]-1]
s[i-1]          == s[dp[i]-2]
......
s[i-dp[i]+1]    == s[0]**
我们再继续看**dp[i]-1**这个位置，最长快乐前缀长度为**dp[dp[i]-1]**，同理**s[0, dp[dp[i]-1]-1]** == **s[dp[i]-1-dp[dp[i]-1]+1**, **dp[i]-1]**，令**dp[i]-1** == **j**，代入可得： **s[0, d[j]-1]** == **dp[j-dp[j]+1, j]**
可以得出
**s[j]            == s[dp[j]-1]
s[j-1]          == s[dp[j]-2]
......
s[j-dp[j]+1]    == s[0]**
可推出：
**s[i]            == s[j]         == s[dp[j]-1]
s[i-1]          == s[j-1]       == s[dp[j]-2]
......
s[i-dp[j]+1]    == s[j-dp[j]+1] == s[0]**
可推出dp[j]也是以s[i]结尾的快乐数组长度，同理可推出以s[i]结尾的快乐数组长度依次是：
**dp[i]
dp[dp[i]-1]
dp[dp[dp[i]-1]-1]
dp[dp[dp[dp[i]-1]-1]-1]
........**
因此对于**dp[i+1]**,我们只需要:
1. 从大到小迭代 **s[i]** 结尾的快乐数组长度 **k**，初始值 **k = dp[i]**
2. 判断 **s[i+1]** 和 **s[k]** 是否相等，如果相等则 **dp[i+1] = k+1**，跳出
3. 如果不相等，则 **k = dp[k-1]** ,直至 **k=0**；
### 代码

```cpp
class Solution {
public:
    string longestPrefix(string s) {
        vector<int> dp(s.size(), 0);
        for (int i = 1; i < s.size(); ++i) {
            int k = dp[i-1];
            while (k && s[k] != s[i]) k = dp[k-1];
            dp[i] = s[k] == s[i] ? k+1 : 0;
        }
        return s.substr(0,dp[s.size()-1]);
    }
};
```