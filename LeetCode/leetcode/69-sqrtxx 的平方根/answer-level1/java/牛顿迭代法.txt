这题的解法用暴力解法是非常简单的。主要的麻烦在于如何解的更好，答案就是用牛顿迭代法。


下面这种方法可以很有效地求出根号 $a$ 的近似值：首先随便猜一个近似值 $x$，然后不断令 $x$ 等于 $x$ 和 $a/x$ 的平均数，迭代个六七次后 $x$ 的值就已经相当精确了。

例如，我想求根号 $2$ 等于多少。假如我猜测的结果为 $4$，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 $2$ 了：

> (       4  + 2/   4     ) / 2 = 2.25
> 
> (    2.25  + 2/   2.25  ) / 2 = 1.56944..
> 
> ( 1.56944..+ 2/1.56944..) / 2 = 1.42189..
> 
> ( 1.42189..+ 2/1.42189..) / 2 = 1.41423..
> 
> ….

![image.png](https://pic.leetcode-cn.com/c142efde7a7261c6c799d3269cee2f921dc5f5144a410b32afce4dbf036d0ed7-image.png)
{:align="center"}
       
这种算法的原理很简单，我们仅仅是不断用 $(x, f(x))$ 的切线来逼近方程 $x^2-a=0$ 的根。根号 $a$ 实际上就是 $x^2-a=0$ 的一个正实根，这个函数的导数是 $2x$。也就是说，函数上任一点 $(x,f(x))$ 处的切线斜率是 $2x$。那么，$x-f(x)/(2x)$ 就是一个比 $x$ 更接近的近似值。代入 $f(x)=x^2-a$ 得到 $x-(x^2-a)/(2x)$，也就是 $(x+a/x)/2$。

同样的方法可以用在其它的近似值计算中。Quake III 的源码中有一段非常牛B的开方取倒函数。

知道方程实现就非常简单了。

我用了递归
```Java []
class Solution {
    int s;
    
 public int mySqrt(int x) {
     s=x;
     if(x==0) return 0;
    return ((int)(sqrts(x)));
  }
    
    public double sqrts(double x){
      double res = (x + s / x) / 2;
    if (res == x) {
      return x;
    } else {
      return sqrts(res);
    }
    } 
}
```