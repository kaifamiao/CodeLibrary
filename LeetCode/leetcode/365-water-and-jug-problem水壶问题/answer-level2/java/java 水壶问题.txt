强势打卡，没看懂。
这一类游戏相关的问题，用人脑去想，是很难穷尽所有的可能情况的。因此很多时候需要用到「搜索算法」。

「搜索算法」一般情况下是在「树」或者「图」结构上的「深度优先遍历」或者「广度优先遍历」。因此，在脑子里，更建议动手在纸上画出问题抽象出来的「树」或者「图」的样子。

在「树」上的「深度优先遍历」就是「回溯算法」，在「图」上的「深度优先遍历」是「flood fill」 算法，深搜比较节约空间。这道题由于就是要找到一个符合题意的状态，我们用广搜就好了。这是因为广搜有个性质，一层一层像水波纹一样扩散，路径最短。

所谓「状态」，就是指当前的任务进行到哪个阶段了，可以用变量来表示，怎么定义状态有的时候需要一定技巧，这道题不难。这里分别定义两个水壶为 A 和 B，定义有序整数对 (a, b) 表示当前 A 和 B 两个水壶的水量，它就是一个状态。

题目说：
    你允许：
        装满任意一个水壶
        清空任意一个水壶
        从一个水壶向另外一个水壶倒水，直到装满或者倒空
为了方便说明，我们做如下定义：

装满任意一个水壶，定义为「操作一」，分为：
（1）装满 A；
（2）装满 B。

清空任意一个水壶，定义为「操作二」，分为
（1）清空 A；
（2）清空 B。

从一个水壶向另外一个水壶倒水，直到装满或者倒空，定义为「操作三」，其实根据描述「装满」或者「倒空」就知道可以分为 4 种情况：

（1）从 A 到 B，使得 B 满，A 还有剩；
（2）从 A 到 B，此时 A 的水太少，A 倒尽，B 没有满；
（3）从 B 到 A，使得 A 满，B 还有剩余；
（4）从 B 到 A，此时 B 的水太少，B 倒尽，A 没有满。

因此，从当前「状态」最多可以进行 8 种操作，得到 8 个新「状态」，对这 8 个新「状态」，依然可以扩展，一直做下去，直到某一个状态满足题目要求。

建议大家在草稿纸上做一个简单的计算，看一下这 8 种操作怎么写，需要注意哪些边界的情况，相信是一个不错的练习。

从当前状态可以扩展出 8 种相邻的状态；
因为状态有重复，因此是一个「有向」且「有环」的图，在遍历的时候，需要判断该结点设置是否访问过；
有序整数对 (a, b) 可以自定义成一个私有的类；
图的遍历，可以使用「深度优先遍历」和「广度优先遍历」，因为状态空间很大，广搜是相对较快；
尽量「剪枝」，跳过不必要的搜索；
当然最快的是数学方法。