首先猛男解题（我一开始的解法，毕竟先暴力解决了，才有资格谈优化）
    最简单又好理解的不就是找出所有解了：（以下每出现一种结果就对比一次z）
    首先，我们让左边的水壶容量小于右边的，那么一开始我们就有0,x,y,x+y四种结果，然后执行以下三步。
    1.将右水壶水倒入空的左水壶，产生新水量y-x，若新容量比x大，重复此步骤。
    2.将右水壶倒入空的左水壶(千万别忽略此时右水壶加满的总水量（新）)，再用满的右水壶倒入左水壶，产生新的水量，若新水量不是x的倍数，返回步骤1。
    3.若依旧没找到新水量为z，返回false。
    若还是不理解所有解的步骤，可以自己想两个数字，执行以上步骤，多试几组就明白了。

以下是c语言实现：（其实left没必要，方便理解使用而已）

bool canMeasureWater(int x, int y, int z){
    if(z==0||z==x||z==y||z==x+y)
	return true;
	int Left,i,right;
    if(x>y)								//确保x<=y 
	{
		i=x;
		x=y;
		y=i;
	}
	Left=x;
	right=y;
    if(y==0||x==0)						//不用找了 
    return false;
	while(right%Left!=0)							//全程左瓶自动倒光水 
	{
		while(Left<right)				//当右瓶水多，往左倒 
		{
			right-=Left;
			if(z==right)
			return true;				//找到目标 
		}
		i=right;
		right=y-(Left-i);			//左瓶水多，将右瓶水给左瓶，右瓶再往左倒 
		if(z==right||z==x+right)
		return true;
	}
	return false;
}

然后我们再来看看官方大神（我先看的官方）的解法（仅仅提供一点思路）
    结论是这样的：如果z是x，y，的最大公因数的整数倍（但是要不大于x,y中较大的数（不包括x+y），大于0），那么z就能得到。
    至于为什么，这是个问题，反正我看官方说的很有道理，后面我是没看懂，但是我们可以拿着这个假设自己探索：
    首先我暴力解决之后，反观我举例的几个例子，觉得好生奇怪，我按照输入x,y:所有解列出来(按照暴力法产生新水量的顺序)。
    3 5:0 3 5 8 **2** 4 **1** ；（以下不写0 x y x+y,且结果不看两个一起的新水量)
    7 13:**6** 12 **5** 11 **4** 10 **3** 9 **2** 8 **1**
    6 15:9 3 12
    写到这时，我发现好奇怪，按照暴力解法，应该是数越大结果越多，但是。。。。这。。。。
    这一定是因为6 15这一组有特别之处，经过仔细的思考（看了官方解析），没错就是因为在倒的过程中，到多少出了问题，第一组的2 1和4,第二组的6 5 4 3 2 1和12 11 10 9 8。
    先收着这个问题，我们再试一组：
    15 55:40 25 10 50 35 20 5 45 30（排序为5 10 15 20......55）
    以5为跳步？不能取3的跳步，4的跳步或者其他的跳步？
    5是15和55的什么呢？
    剩下的就交给自己去解决吧，证明的方法有很多，反证法或者综合分析法等
    以下是程序实现：
int canMeasureWater(int x, int y, int z)
{
	if(z==0||z==x||z==y||z==x+y)
	return true;
	int i;
	if(x<y)					//确保x<=y 
	{
		i=x;
		x=y;
		y=i;
	}
	if(y==0||x==0||z>x+y)	//不用找了 
    return false;
	while(x%y!=0)			//辗转相除法求最大公约数 
	{
		i=x%y;
		x=y;
		y=i;
	}
	if(z%i==0) 
	return true;
	return false;
}
