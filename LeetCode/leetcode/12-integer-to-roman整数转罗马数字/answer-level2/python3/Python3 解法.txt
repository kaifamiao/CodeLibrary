连续刷了几天的题，终于这是第一次自己做出来了。分享出来留个纪念。
我也不知道我这种解法是什么算法。
总体的解题思路如下：
1、数字可以按位分解：如数字abc（十进制），可以分解位a*10^2 + b*10^1 + c*10^0,而罗马数字刚好都有能代表1， 10， 100， 1000的符号，
所以，只要将数字按照这种方法分解，再把对应的罗马符号拼接起来就行
2、根据题意，罗马数字由特殊情况，而且是有限的，所以特殊情况都可以枚举出来
3、每个罗马数字跟十进制数的关系用字典表示，这样可以很方便的取值并拼接
第一次表达自己的思路，可能还是不太清晰明了，望见谅。
代码如下：
def intToRoman(num):
	luo_str = {1: 'I',4: 'IV', 5: 'V', 9: 'IX', 10: 'X', 50: 'L',100: 'C', 500: 'D', 1000: 'M', 40: 'XL', 90: 'XC', 400: 'CD', 900: 'CM'}
	res = ''
	if luo_str.get(num):    # 特殊情况，直接返回结果
		return luo_str.get(num)
	num_list = []
	while num > 0:  # 因为输入已经确定是整数，所以不做数据类型判断，将输入的整数从低位到高位存入一个list
		num_list.append(num % 10)
		num = num // 10
	for i, j in enumerate(num_list):    # 遍历数组，i是索引，j是值
		if luo_str.get(j * 10**i):  # j是数字，10**i代表该位数字的权值（1， 10， 100等）
			res = luo_str.get(j * 10**i) + res  # 因为是从低位开始算的，所以放在最后
		else:
			if j < 5:   # 判断该位数字是否大于5，小于5， 就是直接由 j 个代表该位数字的权值符号组成罗马数字
				res = ''.join(j*[luo_str.get(10**i)]) + res
			else:
				res = luo_str.get(5 * 10**i) + ''.join(j%5*[luo_str.get(10**i)]) + res  # 大于5的情况
	return res