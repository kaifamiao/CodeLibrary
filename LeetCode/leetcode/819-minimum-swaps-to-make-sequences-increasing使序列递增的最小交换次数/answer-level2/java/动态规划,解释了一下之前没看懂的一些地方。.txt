## 分析：

- 我们要了解这道题的选择，首先先要思考在什么情况下不管怎么交换都无法满足单调递增的条件。
- 每一次交换无非两种情况，要么交换，要么不交换，可是情况不同，选择的状态转移方程就会不同。
- 如果当前的`i`和`i-1`都是单调递增的，那么完全可以不交换，也可以交换，如果交换那么`i-1`也要交换。
- 如果当前的`i`和另一个数组的`i-1`递增，`i-1`同理。(假设第一条选择不满足)那么一定要交换，而且要么`i`交换，要么`i-1`交换就行了。
- 如果上述两个条件都满足，那么交换不交换都可以，比一下哪种情况最优就行了。
- 其他任意一种情况怎么交换都无法满足单调递增。

## 代码：

```java
class Solution {
    public int minSwap(int[] A, int[] B) {
        int len = A.length;
        int n1 = 0, s1 = 1;
        for (int i = 1; i < len; i++) {
            int n2 = Integer.MAX_VALUE, s2 = Integer.MAX_VALUE;
            if (A[i-1] < A[i] && B[i-1] < B[i]) {
                n2 = Math.min(n2, n1);//如果前面不交换，现在也不用交换，因为已经是单调递增。
                s2 = Math.min(s2, s1 + 1);//如果已经严格递增，那么直接交换显然毫无意义，一定是之前交换了导致现在不是严格递增，所以才要交换这一组数。
            }
            if (A[i-1] < B[i] && B[i-1] < A[i]) {//如果现在不是单调递增，那么要么交换这一组数，要么交换前面一组数。
                //因为根据判断条件可知，我只要交换任意i或者i-1就能让数组单调递增，但是可能会导致其他的数单调递增被破坏。
                //如果我交换i，那么i+1就可能被破坏
                //如果我交换i-1，那么就是前面那个if条件，已经判断过了。
                n2 = Math.min(n2, s1);
                s2 = Math.min(s2, n1 + 1);
            }
            //如果两个条件都满足了，那么可以交换也可以不交换。
            //如果不交换，那么检查之前s1和n1哪个更小，因为不管之前交不交换，都满足单调递增。
            //如果交换，同样检查之前s1和n1哪个更小，但是个人认为n1一定会比s1要小。
            s1 = s2;n1 = n2;
        }
        return Math.min(s1, n1);
    }

}
```