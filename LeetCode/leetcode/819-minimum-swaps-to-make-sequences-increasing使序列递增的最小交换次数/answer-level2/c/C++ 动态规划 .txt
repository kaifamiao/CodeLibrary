### 解题思路
用动态规划就需要首先确定状态变量 dp
由于题目说了只能交换相同位置的所以不需要用一个二维数组来存储,但是需要加上标志来区分前一列是否交换所以就是dp[n][2] .  dp[i][0]表示第i列的未发生交换,dp[i][1]表示第i列发生交换

**状态变量 dp[n][2]**

初始状态

dp[0][0]=0
dp[0][1]=1

接下来看状态转移方程  

首先我们来看有哪几种情况：

1. a[i]<=a[i-1] || b[i]<=b[i-1]  当前列或者前一列必须发生交换
2. a[i]<=b[i-1] || b[i]<=a[i-1]  前一列发生交换时当前列也必须发生交换
3. a[i]>a[i-1]&&b[i]>b[i-1]   可以交换也可以不交换

对于第二种情况，我们需要知道的是如果当前列与前一列符合递增条件，但是当前一列发生交换的话当前列就会变成第一种情况，这时候当前列必须再次交换相当于同时改变两个数的位置，这时候数组仍然递增.

状态转移方程： 

1. dp[i][0]=dp[i-1][1]      dp[i][1]=dp[i-1][0]+1
2. dp[i][0]=dp[i-1][0]      dp[i][1]=dp[i-1][1]+1
3. dp[i][0]=min(dp[i-1][0],dp[i-1][1])     dp[i][1]=min(dp[i-1][0],dp[i-1][1])+1


状态压缩

可以看到上面的状态转移方程只和当前状态和前一个状态有关，所以我们仅需要定义dp[2]的状态变量。

### 代码

```cpp
class Solution {
public:
    int minSwap(vector<int>& A, vector<int>& B) {
        if(A.empty()||A.size()!=B.size())
            return 0;
        int ret=0;
        int dp[2]={0,1};
        for(int i=1;i< A.size();i++)
        {
            if(A[i-1]>=A[i]||B[i-1]>=B[i])
            {
                int tmp=dp[0];
                dp[0]=dp[1];
                dp[1]=tmp+1;
            }else if(A[i-1]>=B[i]||B[i-1]>=A[i])
            {
                dp[0]=dp[0];
                dp[1]=dp[1]+1;
            }else 
            {
                int Min=min(dp[0],dp[1]);
                dp[0]=Min;
                dp[1]=Min+1;
            }





        }
        return min(dp[0],dp[1]);
        
    }
};
```