建议先看一下官方题解，再来看我的拆解。

-----
循环不变式，即 loop invariant，是循环迭代能够正确解决问题的「关键所在」。

每一个使用循环迭代解决问题的程序，都有一个或显式或隐式的「loop invariant」。

循环迭代能解决问题的核心：保证每一次子循环中的「loop invariant」。

时刻记住：循环不变式虽然是求解问题的关键，但循环不变式本身并不等同于问题答案本身。

-----
此题难想的地方在于：需要维护两个循环不变式，因为二者在迭代过程中是相互依赖的关系。这也告诉我们，**循环不变式虽然是求解问题的关键，但并不一定是问题答案本身**。

循环之前的「循环不变式」相关的变量：第一个位置处，交换所需最小次数，不交换所需的最小次数，答案是显而易见的。

循环过程中「循环不变式」相关的变量：当前元素与前一元素换或不换的依赖性
- 没有依赖：当前元素与前一元素换或不换保持独立
- 保持一致：前一元素换，当前元素也换；反之亦然
- 恰好相反：前一元素换，当前元素不换；反之亦然

直到循环终止，循环不变式始终被正确维护，答案为两个「循环不变式」相关的变量中的较小值。

```js
var minSwap = function(A, B) {
  // 迭代之前的「循环不变式」相关的变量，对第一个元素来说：
  // 不换为 0，换为 1
  let notSwap = 0, swap = 1
  // 通过循环迭代，更新不变量
  for (let i = 1; i < A.length; i++) {
    // 当前元素与之前元素的数值关系
    let case1 = A[i-1] < A[i] && B[i-1] < B[i]
    let case2 = A[i-1] < B[i] && B[i-1] < A[i]
    if (case1 && case2) {
      // 依赖性为没有依赖，如下更新可以确保「循环不变式」
      notSwap = Math.min(swap, notSwap)
      swap = notSwap + 1
    } else if (case1) {
      // 依赖性为保持一致，如下更新可以确保「循环不变式」
      swap += 1
    } else if (case2) {
      // 依赖性为恰好相反，如下更新可以确保「循环不变式」
      [notSwap, swap] = [swap, notSwap + 1]
    } else {
      // 按照题意，每一次迭代的循环不变式都能得到正确维护，不能时表示此题无解
      throw Error("No Solution")
    }
  }
  // 循环终止：答案为两个「循环不变式」相关的变量中的较小值
  return Math.min(notSwap, swap)
};
```
