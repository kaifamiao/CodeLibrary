两个数组的元素，到底要不要交换，是决定最后交换次数的关键。因此，每一列元素，都有两个状态，换或者不换。

如果只有一列：那么dp = [0, 1]
dp[0] = 0, 不做交换，总交换数为0.
dp[1] = 1, 做交换，总交换数为1，同时也满足最后的要求，是一个递增数列，因为数组只有一个元素。

如果有两列， 假设 a1 = A[i - 1], b1 = B[i - 1] 以及 a2 = A[i], b2 = B[i]， i = 1
相对的有4中情况
（1）a1 < a2 并且 b1 < b2
表明，当前列相对前一列，可以不做交换，因为条件已经满足了。
（2）a1 < b2 并且 b1 < a2
表明，当前列相对前一列，可以做交换，因为交换了条件可以满足。
（3） not a1 < a2 或者 not b1 < b2
是（1）取反，当前列相对前一列必须交换，这里的交换是相对的，如果前一列已经交换了，当前列可以不动。
（4）not a1 < b2 或者 not b1 < a2
是（2）取反，当前列相对前一列必须不能换。


**（1）（2）是可以共存的，比如[1, 3] 和 [1, 2]。且（1）（2）是模糊的，可以换，可以不换，那到底换不换？官方题解用的是（1）（2），看的人一脸萌萌的。相反（3）（4）是确定的，且互斥的。**

对于（3）
new_dp[0] = dp[1]，要想当前列不动，那么前一列必须是换过的。
new_dp[1] = dp[0] + 1，要想当前列换，前一列必须没动过。总之，对于情况（3），与前一列操作相反就对了。

对于（4）
new_dp[0] = dp[0]，要想当前列不动，那么前一列必须也不动。
new_dp[1] = dp[1] + 1，要想当前列换，前一列必须也换过。总之，对于情况（4），与前一列操作相同就对了。

但是（3）（4）并没有包括全部的情况。对于（1）（2），可换可不换，按照贪心原则，那就是能不换就不换。
new_dp[0] = min(dp[0], dp[1])，管你前面换没换过，我是取小的那个数，然后就不换了。
new_dp[1] = min(dp[0], dp[1]) + 1，管你前面换没换过，我是取小的那个数，然后换一下，因为dp[1]对应的就是当前列交换的情况，所以不管怎么样，这个数值必须对应当前列交换这个操作。

最终代码

```
class Solution(object):
    def minSwap(self, A, B):
        """
        :type A: List[int]
        :type B: List[int]
        :rtype: int
        """
        result = 0
        dp = [0, 1]
        for i in xrange(1, len(A)):
            a1, b1 = A[i - 1], B[i - 1]
            a2, b2 = A[i], B[i]
            if a1 >= a2 or b1 >= b2:
                dp[0], dp[1] = dp[1], dp[0] + 1
            elif b1 >= a2 or a1 >= b2:
                dp[0], dp[1] = dp[0], dp[1] + 1
            else:
                last_min = min(dp[0], dp[1])
                dp[0], dp[1] = last_min, last_min + 1

        return min(dp)
```






