### 解题思路
执行用时 :4 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗 :16.3 MB, 在所有 C++ 提交中击败了5.06%的用户
f[i][0]表示第i个数不交换的情况下，前i-1个数的最小交换次数
f[i][1]表示第i个数交换的情况下，前i-1个数的最小交换次数
f[i][0] = min(f[i - 1][0],f[i - 1][1],MAX_VALUE)（仅当交换有效的情况下，下同）
f[i][1] = min(f[i - 1][0],f[i - 1][1],MAX_VALUE) + 1
用大于等于MAX_VALUE的数表示无法达到此种状态

我们证明这个式子的正确性（在此只证一部分，剩下的很好推）：
假设在i和i-1元素不变且能够符合规则连接的情况下,显然f[i][0]是前i个序列的最少交换次数，f[i - 1][0]是前i-1个序列的最少交换次数
在此情况下，若f[i - 1][0] = x，则f[i][0] = y且y = x
证明：若存在y < x，则去掉i元素后，序列的递增性不变（因为i未发生交换），那么此时f[i - 1][0] = y，前i-1个元素存在一个更小的交换次数，这与x最小矛盾，因此x <= y，同时，若前i - 1个元素的最小交换次数为x，则此时前i - 1个元素的序列单调递增，加上第i个元素后不破坏该特性，因此x >= y，综上所述，x == y，题设成立

### 代码

```cpp
class Solution 
{
public:
    int minSwap(vector<int>& A,vector<int>& B) 
    {
        int n = A.size();
        int f_0 = 0;
        int f_1 = 1;

        for(int i = 1;i < n;i++)
        {
            int nf_0 = 10000;
            int nf_1 = 10000;

            if(A[i] > A[i - 1] && B[i] > B[i - 1])
            {
                nf_0 = min(nf_0,f_0);
                nf_1 = min(nf_1,f_1 + 1);
            }

            if(A[i] > B[i - 1] && B[i] > A[i - 1])
            {
                nf_0 = min(nf_0,f_1);
                nf_1 = min(nf_1,f_0 + 1);
            }

            f_0 = nf_0;
            f_1 = nf_1;
        }

        return min(f_0,f_1);
    }
};
```