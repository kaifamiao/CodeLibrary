### 解题思路
见代码注释

### 代码

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        // 删除数组元素的三种方式

        // 方式1：删除一个，移动后续所有元素；
        // int len = nums.length;
        // for (int i = 0; i < len; i++){
        //     if (nums[i] == val){
        //         for (int j = i; j < len-1; j++){
        //             nums[j] = nums[j+1];
        //         }
        //         len--;
        //         //后面移动到删除位置的元素，需要重新检测下，与for中的i++抵消
        //         i--;
        //     }
        // }
        // return len;
        // 分析：时间复杂度，O(n*m),其中 m 是移动后续元素的时间
        // 空间复杂度，数组原地操作，O(1)
        // 问题：每确定要删除的元素，移动后面元素，带来大量的时间消耗
        // 耗时：1ms，内存35.1MB


        // 方式2：双指针
        // 相当于一个指针遍历所有元素，在元素不是删除元素的时候，将元素复制到一个“新的数组”
        // 只不过这个“新数组”就是原数组。
        // int i = 0;
        // int j = 0;
        // int len = nums.length;
        // for (; j < len; j++){
        //     if(nums[j] != val){
        //         nums[i] = nums[j];
        //         i++;
        //     }
        // }
        // return i;
        // 分析，时间复杂度：最坏时间复杂度，O(3n)，最好复杂度，O(n)，所以复杂度为O(n)
        // 问题：感觉已经近乎完美了，同时保证了数组排序稳定性，但对于最坏时间复杂度
        // [3 1 2 2] val=3，后面的 1 2 2 就需要频繁复制
        // 耗时：0ms，内存35.1MB


        // 方式3：分块（首尾指针），将数组分为满足条件块，和不满足条件块
        // [3 4 4 5 6] val=4 ------>[3 5 6   4 4]
        // 首尾指针，一个指针用来检查元素，另一个尾指针，用来存储要丢弃的元素
        int i = 0;
        int j = nums.length - 1;
        while (i <= j){
            if (nums[i] == val){
                int temp = nums[i];
                nums[i] = nums[j];
                nums[j] = temp;
                j--;
                //与后面的i++抵消，检查从尾部来的元素
                i--;
            }
            i++;  
        }
        return i;
        // 分析：时间复杂度：遍历的次数，为n-m，不需要遍历整个数组了
        // 耗时：0ms, 内存：35.2MB
    }

}
```