### 解题思路
执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗 :7.7 MB, 在所有 C++ 提交中击败了100.00%的用户

小白第一次写题解，如有问题欢迎指正
看到这个题让我想起了快排的分区操作，稍作更改即可，也是使用双指针，只需将此数组分成左边全为 不等于val值 的数，右边全为 等于val值 的数即可，枢纽处的索引+1即为返回值。

# **思路：**

i为数组左边的索引，j为数组右边的索引，首先将j向左移动直到找到与val值不等的元素用于接下来的交换，然后将i向右移动直到找到与val值相等的元素，然后nums[i] 与 nums[j] 交换，直到i与j重合即完成分区。

# **需要注意的小细节：**

第一，因题目并不关注移除后数组之外的元素，因此并不需要真正删除元素，也不需要真正使nums[i]与nums[j]交换，我们只需将后面的nums[j]赋值给nums[i]即可。
第二，因一中只将nums[j] 赋值给nums[i] 为使下一次循环正确执行需要在赋值操作后--j。
第三，若数组中的元素全为val值时是需要特殊考虑的，举个例子：
    假设val=2
    {2，2，2，2} 与 {2，2，2，1，2} 
    分区后 前者为{2，2，2，2} i = 0， j = 0
        后者为{1，2，2，1，2} i = 0， j = 0
    后者正常返回 i+1 没有问题，然而前者也会返回i+1便产生了错误，因此返回时需判断i为0且nums[i]为val的情况使其返回正确的0

**如何确保的枢纽处的索引+1为返回值？**
先排除全为val的特殊情况
首先，每次都是先让j向左移动寻找 不等于val 的元素的，然后才移动的i ,所以每次**完整的循环后**保证 i及i之前的元素 都是≠val的
其次，若是i右移与j重合的情况也是必然保证 nums[i]≠val的，因为在此之前已经先让j左移找到了≠val的元素，所以i+1就是返回值。由j左移到i的情况很容易想，在此就不分析了。

### 代码

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.empty()) return 0;
        int i = 0;
        int j = nums.size() - 1;
        while(i < j) {
            while(nums[j] == val && i < j) {
                --j;
            }
            while(nums[i] != val && i < j) {
                ++i;
            }
            nums[i] = nums[j--];
        }
        if(i == 0 && nums[i] == val) {
            return 0;
        }
        return i + 1;
    }
};
```