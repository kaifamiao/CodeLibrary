### 解题思路
## 用数字代替符号
    - `(`：`1`
    - `)`：`-1`

这样当成对的括号出现时二者加结果为零
## 求和前的分析
对于字符串`S`的开头字符只会有两种不同情况：
```
    - "(..."
    - ")..."

```
对以上两种情况进行分析我们可以知道。当该字符串开头为字符`)`时，该字符肯定是无法与后面的字符进行配对的，此时我们必须添加一个字符才能配成成对括号；

而如果字符串开头为`(`时，只要后面遇到一个`)`字符就能凑成一对。

## 对数据进行求和
#### 接下来就要对我们替换后的数据进行求和了：
我们可以用`for`循环对数据进行求和，每累加一次就对`sumValue`(假设我们用`sumValue`来储存数据的和)进行判断，如果该值为`-1`（第一次循环出现`-1`说明该字符串以`)`打头，后面的循环中遇到`(`该值就会+1，遇到`)`该值就会-1，当该值减到`0`时说明到此为止的字符可以配成完整的有效括号），那么就说明在存在一个`)`无法于其前面的字符进行配对，此时把`total`的值+1，并且对`sumValue`进行清零操作（如果不进行清零会影响后面字符串的判断），然后进入下一次循环。
#### 修正统计的总量
当`for`循环执行完毕后我们所得的`total`并不是我们所需添加的字符个数，到现在为止我们只统计了无法配对的`)`的个数，还需要计算无法配对的`(`的个数，二者之和才是最后我们所求的值，那么怎么统计未成对的`(`的个数呢？还记得`sumValue`么？没错，最后求和所得到的`sumValue`就是未成对`(`的个数，我们最后只要把二者相加返回即可。

### 代码

```c
#include <string.h>
int minAddToMakeValid(char * S){
    int total=0;
    int sumValue=0;
    int everyCharValue=0;
    if(strlen(S)==0){       //空字符检测
        return 0;
    }else{
        for(int i=0;i<strlen(S);i++){
            switch(*(S+i)){         //将字符用数据代替
                case '(':   everyCharValue=1;break;
                case ')':   everyCharValue=-1;break;
                default: break;
            }
            sumValue=sumValue+everyCharValue;     //求和  统计未成对'('的个数
            if(sumValue<0){             
                sumValue=0;     
                total++;                        //统计未成对')'的个数
            }
        }
        total=total+sumValue;
        return total;
    }
}
```