首先需要明确两个概念：
- 深度，节点的深度取决于它的祖先节点的数量。
- 高度，树中所有节点深度的最大值。
![baf2f6ea1ae76ba383eb1753254340f089dac9f03664f93990d6ae54f8560970-image.png](https://pic.leetcode-cn.com/db16d656b2dafbf52e14184a64561ff0a5b55cee6d2f365b1a1a4fac9a5cdc88-baf2f6ea1ae76ba383eb1753254340f089dac9f03664f93990d6ae54f8560970-image.png)

在官方的题解中，最长路径`[9, 4, 2, 5, 7, 8]`形成了以节点2为起点的树，其左子树的高度是2（叶子节点9视角，经过节点4和根节点2），右子树的高度是3（叶子节点8视角，经过节点7，节点5和根节点2）。

转换下视角，从根节点2的视角看，叶子节点9则和它相差了2个节点（节点7和叶子节点9），叶子节点8则和它相差了3个节点（节点5，节点7和叶子节点8）。

则根节点2的左子树的节点（`[4, 9]`）为2，根节点2的右子树的节点（`[5, 7, 8]`）3。

所以现在，左子树的最长路径已知，右子树的最长路径也已知，则整棵树的最长路径当然是左子树最长路径+右子树最长路径。

稍等，要从左子树走到右子树，是不是还少了什么连接点？没错，就是根节点。通过根节点将左右子树的节点衔接起来。

所以二叉树的最长路径公式可以推到为：左子树最长路径 + 右子树最长路径 + 1，即官方的`L + R + 1`。

这个公式前提是，我们知道了左右子树的高度，那么，树的高度怎么得来呢？

答案是递归。

开头提到过，高度，是树中所有节点深度的最大值。

获取树的高度，就要比较其左右子树的高度，左右子树又有自己的左右子树，又要再比较它们高度，子子孙孙无穷匮也。所以我们需要利用递归来解决问题，并且没有子树的叶子节点是递归出口。

所以公式`max(L, R)`就是为取出左右子树的最大深度，深度得到后，再算上根节点子树所占的高度（根节点的高度占1），就是这株树的高度了。公式`max(L, R)+1`由此得来。

细心的同学可能会发现，按照现在的解释，如果仅有一棵根节点为2的树（`[9, 4, 2, 5, 7, 8]`），按照 `L + R + 1`的公式，计算的结果是6，而不是正确答案5。

这是为什么呢？

因为我们计算的是这棵树最长路径上的所有节点，还需要按照公式（`一条路径的长度为该路径经过的节点数减一`）减1才能得到最长路径。

结合代码上的细节注释，能让你更好地理解。

```
var diameterOfBinaryTree = function(root) {
    // 默认为1是因为默认了根节点自身的路径长度
    let ans = 1;

    function depth(rootNode) {
        if (!rootNode) {
            // 如果不存在根节点，则深度为0
            return 0;
        }
        // 递归，获取左子树的深度
        let L = depth(rootNode.left);
        // 递归，获取右子树的深度
        let R = depth(rootNode.right);

        /* 关键点1
        L+R+1的公式是如何而来？
        等同于：左子树深度(节点个数) + 右子树深度（节点个数） + 1个根节点
        便是这株二叉树从最左侧叶子节点到最右侧叶子节点的最长路径
        类似于平衡二叉树的最小值节点到最大值节点的最长路径
        之所以+1是因为需要经过根节点
         */
        // 获取该树的最长路径和现有最长路径中最大的那个
        ans = Math.max(ans, L + R + 1);
        /* 关键点2
        已知根节点的左右子树的深度，
        则，左右子树深度的最大值 + 1，
        便是以根节点为数的最大深度*/
        return Math.max(L, R) + 1;
    }

    depth(root);

    // 由于depth函数中已经默认加上数节点的自身根节点路径了，故此处需减1
    return ans - 1;
}; 
```
