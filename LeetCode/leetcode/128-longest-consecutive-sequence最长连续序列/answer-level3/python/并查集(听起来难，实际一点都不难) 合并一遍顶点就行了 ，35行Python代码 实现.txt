# 啥是并查集
# 如果看不懂可以先去百度，先了解并查集，然后了解路径压缩，注意要理解本质，不要拘泥于某种数据结构
# 然后再来看本篇文章，就可以了
是一种树形的数据结构，不同问题的实现起来可能不一样，例如这里用一个hash 表就实现了。
* 并是合并
* 查是查找属于哪个集合
* 集就是集合的意思， 也就是有很多个集合

例如：
> 输入: [100, 4, 200, 1, 3, 2]
> 输出: 4
> 解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。

题目中的输入可以划分为 `1 2 3 4` ， `100` ， `200`  三个集合。 然后`1 2 3 4` 属于哪个集合呢，我们给一个标志 就是4 。`100` 属于哪个集合呢 再给个标志100。200也一样。 这个标志我们可以用一个名词 `父节点` 表示（毕竟还是要强行扯到树的嘛~~）
这样一来 ，所有位于同一个集合的点 都有相同的标志，也就是父节点。

**这道题目的关键就是为点找到正确的父节点，  也就是并查集中的并， 然后某个父节点出现次数最多的次数就是本题的解**

# 怎么用并查集呢
一般情况下 是可以构建一些数据结构，类似于二叉树中的节点，链表中的节点一样，**需要记录父节点是谁， 当前值是谁**。

对于本题就没弄那么复杂，直接用一个`hash`, key 表示 当前的点值， value 表示父节点是谁。

# 怎么进行合并
合并的话 主要是根据题目的条件 **这里是如果两个值连续 ， 也就是在同一个集合中 也就是应该有相同父节点**

# 怎么查
这里使用hash 表进行查的时候 可以直接进行返回，不同的是在初始化的时候，父节点都是自身，要不断的往上探索（以达到**路径压缩**的目的，同时也减少了计算量）

其实理解了之后是不难的 ，
来python 代码, 有详细注释的哦
当然 别看就几行代码 ，每一行都是很有深意的呦~ 

```python []
class Solution(object):
    def longestConsecutive(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        # 这个hd 就可以看做一个并查集， 
        hd = dict([(item, item) for item in nums])
        # 这里是进行合并
        for item in nums:
            # 这个数组主要是为了在查找记录下查找路径，然后找到最终的父节点， 其实也就是路径压缩
            need_mod = [item]
            # 这里的 item+1 和下面的parent + 1 都是为了 和一些单独的点进行合并
            parent = item + 1
            # 下面的这个 默认横线是防止序列中有 0 出现
            pv = hd.get(parent, "-")

            # 当这个点和父节点一样的时候表示的就是还没进行过筛选 或者就是本身自己一个集合
            # 当这个点的父节点和当前点不一样的时候有两种情况 要么是没有记录 要么是之前已经找到过了它最终父节点，也就是找到了它所属集合
            while pv == parent:
                need_mod.append(parent)
                parent += 1
                pv = hd.get(parent, "-")
            
            if pv == "-":
                parent -= 1
            else:
                parent = pv
            # 统一设置一下他们的父节点 也就是路径压缩
            for tmp in need_mod:
                hd[tmp] = parent
        # 这里是合并

        _min = -0xfffffff
        cm = _min
        cn = {}
        # 这里是获取父节点最多出现的次数，和并查集没毛关系
        for item in hd:
            k = hd.get(item)
            if not cn.get(k):
                cn[k] = 1
            else:
                cn[k] += 1
            cm = max(cm, cn[k])
        # 这里是获取父节点最多出现的次数，和并查集没毛关系

        return max(cm, 0)  # 这里主要是为了防止空列表的出现
```



