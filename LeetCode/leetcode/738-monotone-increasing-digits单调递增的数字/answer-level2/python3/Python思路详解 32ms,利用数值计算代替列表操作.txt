思路：分类讨论
    1、当只有个位数时，返回N-1即可
    2、若前一位上的数字大于后一位的数字，则前一位上数字应减1，后面的数字均用9补齐。比如32,3>2,故应写29。这里利用数值计算则为3*10 - 1 = 29
        这里需要处理特殊情况，当连续多个数字相同时，比如332，应返回299。这需要在第一个3处计算3*10**2-1 = 299而不是在第二个3处计算33*10 - 1 = 329
算法设计：
    1、将N转换为列表以获取每个数位上的数字信息。
        记rs:记录列表遍历时前i位升序结果
        max_:记录列表遍历时前i位最大值
        count:记录重复数字个数
    2、遍历列表  若第i个数字小于第i+1个数字并且第i+1个数字大于前i个数的最大值
                        则重复数字个数清0
                        max_ = 列表第i+1个数字
                        rs 乘十再加上 列表第i个数字
                若第i个数字等于第i+1个数字并且第i+1个数字大于前i个数的最大值
                        则重复数字个数 + 1
                        max_不更新
                        rs 乘十再加上 列表第i个数字
                否则（此时说明第i位数字大于第i+1位数字）
                        返回 （rs整除10的count次方）再乘10的剩余位数加重复位数之和次方-1
算法分析：
    1、时间复杂度: 最坏情况下O(N),此时为列表升序排列,遍历完了所有位数
    2、空间复杂度:O(N),由于使用列表存储了信息
```
代码块
def monotoneIncreasingDigits(self,N):
    lst = [int(x) for x in str(N)]
    if len(lst) == 1:
        return N - 1
    max_ = 0
    rs = lst[0]
    count = 0
    for _ in range(len(lst) - 1):
        if (lst[_] < lst[_ + 1])&(lst[_ + 1] >= max_):
            max_ = lst[_ + 1]
            rs *= 10
            rs += lst[_+1]
            count = 0
        elif (lst[_] == lst[_ + 1])&(lst[_ + 1] >= max_):
            rs *= 10
            rs += lst[_+1]
            count += 1
        else:
            print(count)
            print(rs)
            return (rs // 10**count) * 10 ** (len(lst) - _ + count - 1) - 1
    return N
```