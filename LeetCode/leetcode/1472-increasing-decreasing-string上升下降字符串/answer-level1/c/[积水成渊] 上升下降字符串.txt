### 解题思路
调试出错点， 技巧 时间复杂度
一、调试出错点
1.1 memset函数的生命，其第三个入参是字节长度，应该是“CHARNUM * sizeof(int)”，而不是“CHARNUM”;
1.2 边界值的把握，其j的空间是[0, CHARNUM - 1],而不是[0, len - 1];
1 原因是，对输入字符串，存在len长度，需要进行len次处理；
2 而从另一维角度，字符字典，其长度为26个英文字母；

二、技巧
2.1 通过类似桶排序的方法，将很长一段字符串，压缩为长度为26的数组，数组元素填充为该字符的个数；
1 编译：cnt[s[i] - 'a']++;
2 解码：s[i++] = j + 'a'; cnt[j]--;
2.2 思路
1 题眼是找出“从剩余字符中选出最小的字符后，保证该字符比上一个添加的字符大”；
2 而对于“从比上一个添加的字符大”，变为“比上一个字符小”，此处的逻辑是可以合并的，区别是从前到后，改为从后到前；
2.3 因为字母大小写，以及阿拉伯数字在ASCII字符集中的位置
1 'a'-'z' 97-122
2 'A'-'Z' 65-90
3 '0'-'9' 48-57
2.4 节省空间
1 在将原有的s字符串，翻译为字典模式后，其空间不再需要使用；
2 本程序利用这一点，将结果再次存储在该字符串分配的空间中；

三、时间/空间复杂度
3.1 时间复杂度为n + n * (26 * 2);
因此为o(n)复杂度
3.2 空间复杂度
暂时不计算

### 代码

```c
#define CHARNUM 26
char * sortString(char * s){
    // 按照字母个数进行存储
    // for循环，正向和反向查找
    int i, j, len;
    int *cnt = (int *)malloc(CHARNUM * sizeof(int));
    memset(cnt, 0, CHARNUM * sizeof(int));
    len = strlen(s);
    i = len;
    while (i--) {
        cnt[s[i] - 'a']++;
    }
    //正向及反向查找
    for (i = 0; i < len;) {
        for (j = 0; j < CHARNUM && i < len; j++) {
            if (cnt[j] > 0) {
                s[i++] = j + 'a';
                cnt[j]--; 
            }
        }
        for (j = CHARNUM - 1; j >= 0 && i < len; j--) {
            if (cnt[j] > 0) {
                s[i++] = j + 'a';
                cnt[j]--;
            }
        }
    }
    return s;
}
```