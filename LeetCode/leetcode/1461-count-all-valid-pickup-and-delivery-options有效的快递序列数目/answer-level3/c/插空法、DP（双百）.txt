### 解题思路
这道题类似高中的排列组合题，就是几个学生照相，但谁不能排在谁的左边（虽然现在还感觉这种题有毒-,-)
1. 一般比赛hard题都是DP问题，所以从这个思路想就好
2. 我们就从1个开始讲起 1个邮件只有一种情况 就是   _P1_D1_  
3. 如果两个邮件呢？ 我们发现只要满足P2在D2前面就好 那么我们就将这俩插入到原来的排列的间隙中，原来的排列只有一个则
   选择P2在最前面：P2D2P1D1  P2P1D2D1  P2P1D1D2  
   选择P2在P1_D1中间 P1P2D2D1 P1P2D1D2
   选择P2在最后  P1D1P2D2
4. 这样我们找到规律了，我们只需要按照上述的方式将PNDN插入到之前的所有即可，即状态转移方程为 dp[i] = (2*i-2+1)*(2*i-2+2)/2*dp[i-1];
   因为对于dp[i]  前面有(2*i-2)个空可以插，根据前n项和公式可以计算全部的
5. 因为状态转移方程只需要用到前一个，所以不需要数组，直接一个pre_val保存原值即可

### 代码

```c
int countOrders(int n){
    if (n==1)
        return 1;
    if (n==2)
        return 6;
    long long pre_val=6;
    for (int i=2;i<n;i++)
        pre_val = pre_val*((2*i+1)*(2*i+2)/2%1000000007)%1000000007;
    return pre_val;
}
```