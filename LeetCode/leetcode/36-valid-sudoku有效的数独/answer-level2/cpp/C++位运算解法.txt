### 解题思路
**位运算解法**
解决本题的关键就是判断行、列或者`3x3`的宫内是否出现重复数字，使用位运算可以轻松的做到这一点，比如：
数字`1`可以用二进制`000000001`表示，数字`5`可以用二进制`000010000`表示，以此类推。


分别用 9 个 int 存放列和`3x3`宫的状态；
因为按行扫描，所以只需要一个 int 存放行的状态；
扫描 9 宫格：
1）如果当前字符是`'.'`则跳过；
2）如果当前字符是数字`n`，则将数字 1 左移 `n-1`位来表示数字`n`；
    对于第二种情况， 需要判断当前数字与已扫描的数字有没有重复：
    a）将 数字的二进制表示 与 状态 按位与运算，如果结果的二进制有 1 则数字重复，返回false；
    b）否则，将 数字的二进制表示 与 状态 按位或运算 来更新状态。
3）扫描结束返回true。


**注意**`3x3`宫状态的下标表示。

### 代码

```cpp
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        vector<int> col(9, 0);  //存放列的数字状态
        vector<int> box(9, 0);  //存放3x3宫的数字状态
        for(int i = 0; i < 9; ++i)
        {
            int row = 0;    //存放行的数字状态
            for(int j = 0; j < 9; ++j)
            {
                if(board[i][j] != '.')
                {
                    int cell = 1 << (board[i][j] -'1'); //将1移到合适的二进制位表示当前扫描数字
                    if(row & cell || col[j] & cell || box[(j/3) + (i/3)*3] & cell)  //行、列、宫，有一重复则返回false
                    {
                        return false;
                    }
                    else
                    {
                        row ^= cell;        //数字位 置1 更新 状态 
                        col[j] ^= cell;
                        box[(j/3) + (i/3)*3] ^= cell;
                    }
                }
            }
        }
        return true;
    }
};
```