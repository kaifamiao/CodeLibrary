**方法一：**
    第一个想到的就是对两个字符串进行排序，排序好后直接比较是否相等就可以了。代码很简洁
```
return sorted(s) == sorted(t)
```
但是这样时间复杂度和空间复杂度都较高，用时56ms,击败35.26%；内存消耗13.2MB，击败40.32%。

**方法二：**
    第二个方法就是利用集合，先判断两个字符串所含字母是否相等，然后再进一步判断每个字母出现的次数是否相等
```
ans = False
set_temp = set(s) #这里先把set(s)保存下来，因为后面需要用到，利用空间换时间
if set_temp == set(t):
    ans == True
    for i in set_temp:
        ans =  ans and (s.count(i)==t.count(i))
return ans #如果没有进入到if,就会返回False,如果进入了if，就会进一步判断是否相等
```

最后的结果耗时28ms，打败94,02%；内存消耗12.6，打败66.49%。可以很明显的看到时间复杂度有很大的改进。空间复杂度也有降低。我自己不太清楚python的sorted具体是怎么排序的，暂且认为这里的排序对空间也会有一定的消耗吧。



 
