
### 思路：
- 排序，然后遍历数组，如该元素为负，则变为正数，否则 `break`(此时已把列表中所有负数变为正数)
- 如果正常遍历完毕，则有两种情况：

1. `K` 用完了：列表可能遍历完了也可能没有，又说明列表中原来负数的数量要 `>=K`，我们把所有的 `K` 都用来由负变正了，直接返回列表的和即可
2. `K` 没用完：说明列表遍历完了，又说明列表原来全是负数。`K` 让所有的负数变为了正数，那么此时绝对值最小的自然是最后那个元素。求出剩余的 `K`，如果剩余的 `K` 是偶数，因为偶数次取反仍是原数，所以对列表没有影响，直接返回列表的和。如果剩余的 `K` 是奇数，那么会有一个数由正变负，肯定是选绝对值最小那个，也就是最后一个元素。返回列表的和-绝对值最小的元素 `*2`

- 如果中途跳出，说明列表中负数的数量要 `<K` 且必有非负数，此时仍然计算剩余的 `K`，然后同样根据 `K` 的奇偶性来决定是直接返回列表的和，还是返回列表的和绝对值最小的元素 `*2`
### 代码：
```Python []
class Solution:
    def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
        A,length=sorted(A),len(A)
        for i,j in zip(range(length),range(K)):
            if A[i]<0:A[i]=-A[i]
            else:break #中途跳出，说明列表中负数的数量要<K且必有非负数
        else:
            if j>=K-1:#正常遍历完毕---K用完了，列表可能遍历完了也可能没有，又说明列表中负数的数量要>=K
                return sum(A)
            else:return sum(A) if (K-1-j)%2==0 else sum(A)-2*A[-1]#正常遍历完毕---K没用完,说明列表遍历完了，又说明列表全是负数
                
        return sum(A) if (K-j)%2==0 else sum(A)-2*min(A,key=abs)
```
