学会写这一个题并没有什么🐦用，关键是要学会举一反三，因此就要积累一些常见的leetcode中位运算的技巧，其中最重要的就是lowbit运算。
### 什么是lowbit运算？
lowbit(n)运算是一个位运算的常用技巧，本题就可以直接用lowbit运算解决。
它的作用是求出n在表示成二进制的时候，最右边的1出现的位置对应的数。这么说有点晦涩，看俩例子就懂了，其实很简单：
```java
lowbit(4) = lowbit(100) = 100
lowbit(5) = lowbit(1001) = 1
lowbit(6) = lowbit(1010) = 10
```


### lowbit公式
lowbit公式非常简单：
```java
lowbit(n) = n & -n
```

### 公式证明
大家需要有一点计算机组成原理的常识，具体的我这里就不详述了，只简单提一下。在计算机中，数据的存储是以补码的形式，对于补码来说：
1. n >= 0： n的补码就是它本身
2. n < 0： n的补码为`~n + 1`，其中`~n`为n的反码

我们可以通过一个通例来证明，假设n=101...1000，中间的数字省略，直到展示出最右边的一个1。
```java
lowbit(n) = n & -n = n & (~n + 1)
n =      101...1000
~n =     010...0111
~n + 1 = 010...1000
因此lowbit(n) = n & (~n + 1) = 1000
```

### 本题的解答
知道了lowbit后，解决本题的思路就非常简单了，一行代码就可以解决。因为我们可以发现，2的整数幂都只包含一个1。换句话说n是2的整数幂，则lowbit(n) == n。
```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & -n) == n;
    }
}
```