### 解题思路
把每个数看成是其他的数字加起来的结果，比如6，看成是4+2，那只需要知道4有多少个1,2有多少个1，这样子加起来就可以了。
根据这个思路不难设计出如下的代码。

但我还在想，动态规划用于这种类型的题目，效果不错，但如果不是我事先看到这道题目是动态规划类型的题目，我也许很难想到这种做法。
这种题目是什么类型的问题，为什么可以用动态规划取得低时间复杂度的做法？

我们平时不会想到这样子的思路，如果只是简单地求6有多少个二进制的1，那我们直接不断对6做，跟1相“与”和右移就可以了。
我们平常做分治法和动态规划的题目，更多的是题目要求计算的最终状态，没有办法直接计算，必须要知道子问题的解，然后再拼起来。这是一种“迫不得已”的做法。
但这道题之所以要这样子做，是因为每个数都要计算有多少个二进制的1，太过耗时，而我们又可以利用之前的计算结果，两个相加得到新的数字的结果。

每种题目都可以有两种解法，一种是直接的思路，另一种是分治法的思路，拆分成更小的单元，然后再拼起来。
分治法不见得会比直接求解更快，例如这道题，如果只求解最后一个数有多少个二进制的1，那么分治法效率低于直接求解法。
但是分治法有个好处，就是可以顺便得到中间结果，[0,num]区间内的所有中间结果。这样子平摊下来，其实耗时反而就变少了。

所以这种题目应该是，我们要计算整一段区间的所有结果，后面的数又刚好可以由前面的数来表示，这样子的一种类型的题目。
这种题目比较适合动态规划来做，极大降低耗时。

自己总结得也许不是那么正确，欢迎评论~
代码如下。


### 代码

```cpp
class Solution {
public:
    vector<int> countBits(int num) 
    {
        //边界情况处理
        if(num==0)
            return {0};
        if(num==1)
            return {0,1};

        //初始化
        vector<int>record(num+1,0);
        record[1]=1;

        //O(N)时间复杂度的处理，不断计算后面的数，直到到达num
        //pow(2,n)这个数字，肯定只有1个二进制的1
        //其他的，由pow(2,n)加上前面的数，得到有多少个二进制的1
        int n=1,index=pow(2,n);
        while(index<=num)
        {
            record[index]=1;
            if(index+index-1<=num)
            {
                for(int plus=1;plus<index;plus++)
                {
                    record[index+plus]=record[index]+record[plus];
                }
            }
            else
            {
                for(int plus=1;plus<=num-index;plus++)
                {
                    record[index+plus]=record[index]+record[plus];
                }
            }
            n++;
            index=pow(2,n);
        }
        return record;
    }
};
```