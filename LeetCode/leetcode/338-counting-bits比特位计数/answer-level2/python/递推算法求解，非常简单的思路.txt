其实思路很简单，以2的N次方为间隔递推即可算出来，每一次都是前次比特位数加１．

2的1次方：
原始的数字   ０     １
比特位计数   ０     １

2的２次方，后２个数的比特位计数，是上面计数加１：
原始的数字   ２     ３
比特位计数   １     ２

2的３次方，后４个数的比特位计数，是上面所有的计数位加１：
原始的数字   ４     ５     ６     ７
比特位计数   １     ２     ２     ３

2的４次方，后８个数的比特位计数，是上面所有的计数位加１：
原始的数字  ８      ９      １０        １１        １２        １３        １４        １５
比特位计数  １      ２      ２          ３          ２          ３          ３          ４


依次类推下去  ．．．．．．

```
class Solution(object):
    def countBits(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        rtn = [0, 1]
        while (1):
            nu = len(rtn)
            if nu >= num+1:
                break
            for i in range(nu):
                rtn.append(rtn[i] + 1)　　＃前面所有的数加１，然后加入到返回数组
        
        return rtn[0:num+1]
```

执行结果：
通过
显示详情
执行用时 :56 ms, 在所有 Python 提交中击败了88.65% 的用户
内存消耗 :15.3 MB, 在所有 Python 提交中击败了83.69%的用户