### 解题思路
dp[i] 表示数字i对应的二进制数字中1的数目

dp[i] 是由离它最近的2的幂次方的数构成的，该数作为基准数记为2^t，该基准数二进制数中只有一个1
对应为数字i的最高位，而i的二进制剩余位的1的个数的计算就是dp[i-基准数]，该数在之前已经计算过了直接拿来用即可

dp[i] = dp[i-基准数] + 1 
基准数 = 2的幂次方中距离i最近的数

以下代码在循环中每次都要判断i == pow(2,t)所以效率不高
可以改进为先把小于等于num的2的幂次方数记录下来
然后循环计算这些幂次方数中间段的数，大家可以试试这种改进思路...

### 代码

```python
class Solution:
    # 动态规划
    # dp[i] 表示数字i对应的二进制数字中1的数目，最后计算出的dp即为返回值
    # 通过列举0-16这些数字的二进制，可以发现2|4|8|16... = 2^k
    # 所以可以以上述数字作为分割界限，分别计算每一段中的值
    def countBits(self, num: int) -> List[int]:
        if num == 0:
            return [0]
        dp = [0]*(num+1)
        dp[1] = 1
        t = 1
        for i in range(2,num+1):
            if i == pow(2,t):
                dp[i] = 1
                t += 1
            else:
                dp[i] = 1 + dp[i-pow(2,t-1)]
        return dp
```