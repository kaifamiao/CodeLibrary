### 在介绍这个方法之前，我们先把问题转化一下：
既然我们要在O(n)时间内完成任务，我们可以分成两步完成：

1. **定义一个函数pop(x)，其作用是可以在O(1)的时间内完成计算并返回对于一个32位的二进制数x中1的个数**
2. **对于每一个[0,num]内的数字进行遍历计算，最终获得问题的解**

其实对于函数pop(x)的实现有很多，这里我主要讲解一下分治法的pop(x)实现
### 举例：
对于32位整数10111100011000110111111011111111中计算1的个数：

1. **划分问题：我们既然要查有多少个1，我们完全可以把这个32位数分成前后各16位数，即1011110001100011|0111111011111111，之后，计算每一部分中1的个数**
2. **合并问题：把两部分中1的个数加起来，就是问题的最终解**

说到这里，对于分治法理解深刻的同学应该就知道怎么做了，不过不理解也没有关系，我们继续往下看：
### 划分问题
我们再对其进行划分问题，即对于一个16位的数字，划分成前后各8位数字：
10111100|01100011|01111110|11111111
还不行，继续划分：
1011|1100|0110|0011|0111|1110|1111|1111
还是看不出来什么，继续划分：
10|11|11|00|01|10|00|11|01|11|11|10|11|11|11|11
再来一次：
1|0|1|1|1|1|0|0|0|1|1|0|0|0|1|1|0|1|1|1|1|1|1|0|1|1|1|1|1|1|1|1
放心你想接着分也分不了了，这时候问题就变成了对于一个1位二进制数，求其中1的个数，显然，这非常简单：
1 --> 1
0 --> 0
1就是1,,0就是0
### 合并问题
1+1=10，1+0=01，0+1=01,,0+0=00
我们的二进制串变成了这样；01|10|10|00|01|01|00|10|01|10|10|01|10|10|10|10，也就是10|11|11|00|01|10|00|11|01|11|11|10|11|11|11|11的每一组中，前后两个数相加得到的一个2位二进制数代替原来的数字，那每组的意义也就显而易见了：
01|10|10|00|01|01|00|10|01|10|10|01|10|10|10|10
第一组中1的个数的二进制表示|第二组中1的个数的二进制表示|第三组中1的个数的二进制表示|...|第十六组中1的个数的二进制表示
合并问题：把相邻两组相加
0011|0010|0010|0010|0011|0011|0100|0100
第一组中1的个数的二进制表示|第二组中1的个数的二进制表示|第三组中1的个数的二进制表示|...|第八组中1的
个数的二进制表示
继续合并，相邻两组相加：
00000101|00000100|00000110|00001000
第一组中1的个数的二进制表示|第二组中1的个数的二进制表示|第三组中1的个数的二进制表示|第四组中1的
个数的二进制表示
继续：
0000000000001001|0000000000001110
第一组中1的个数的二进制表示|第二组中1的个数的二进制表示
最后一次：
00000000000000000000000000010111
到此，神奇的事情发生了，把这个二进制数换成十进制，即23，你在回去查查我们问题的二进制数中1的个数是不是23呢？
### 实现1：
很明显，就是23，到此，我们也就有了下面的分治算法的代码(Python3)：
```python
def pop(x, bit):
    if bit == 1: return x
    mid = bit // 2
    left = x >> mid
    right = x & (2 ** mid - 1)
    print(left,right)
    return pop(left, mid) + pop(right, mid)

print(pop(0b110110011,32)) # Output: 6
```
看看时间复杂度O(logN),但是，说好的O(1)呢？

### 改进：
承接以上的思路，我们针对题目要求的32位进行改进：
先看看这句代码：

`x = (x & 0x55555555) + ((x >> 1) & 0x55555555)`

把0x55555555换成二进制1010101010101010101010101010101和x进行与运算，根据与运算的特性可知，x的偶数位全部被屏蔽变成0，奇数位不变，对x向右移1位,,再与0x55555555进行与运算，与上一个相加，也就是***相邻两位对齐相加***，我们还是拿例子举例：
00|01|01|00|01|00|00|01|01|01|01|00|01|01|01|01   (x & 0x55555555)
01|01|01|00|00|01|00|01|00|01|01|01|01|01|01|01   ((x >> 1) & 0x55555555)
相加得
01|10|10|00|01|01|00|10|01|10|10|01|10|10|10|10，看看是不是我们第一次合并问题得到的结果，如果不能理解可以拿程序员型计算器自己试一试

`x = (x & 0x33333333) + ((x >> 2) & 0x33333333)`

0x33333333的二进制是110011001100110011001100110011
类比第一行代码，***两位两位对齐相加***，得到0011|0010|0010|0010|0011|0011|0100|0100

`x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F)`

0x0F0F0F0F是1111000011110000111100001111，***四位四位对齐相加***

如果你理解了上面的代码，那么下面的也就非常容易了

```python
x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF)
x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF)
# 0x00FF00FF is 00000000111111110000000011111111
# 0x0000FFFF is 00000000000000001111111111111111
```

我们整理一下

### 实现2：

```python
def pop(x):
    x = (x & 0x55555555) + ((x >> 1) & 0x55555555)
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
    x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F)
    x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF)
    x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF)
    return x

print(pop(0b110110011)) # Output: 6
```

看看时间复杂度O(1)，空间复杂度，我们只有一个形式参数喂，就完成了问题1的求解，那问题2就不用我说了吧，O(∩_∩)O哈哈哈~

### 总结：
1. 对分治算法的深度理解
2. 通过位运算改善代码（位运算其实十分十分强大QAQ）
3. 最终代码(Python3)：
```python
class Solution:
    def countBits(self, num):
        return [self.pop(x) for x in range(0, num+1)]
    def pop(self, x):
        x = (x & 0x55555555) + ((x >> 1) & 0x55555555)
        x = (x & 0x33333333) + ((x >> 2) & 0x33333333)
        x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F)
        x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF)
        x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF)
        return x
```

### 日后谈：
这个方法并不是我发明的，来源是IBM工程师们智慧的结晶：
>《Hacker's Delight》5–1 Counting 1-Bits

本方法是5-1中的一种方法，书中还有很多pop的相关实现，如果有阅读英文能力建议阅读原著，再次安利一下这本书，写的非常非常妙Orz，推荐阅读QAQ。网络上关于这种方法介绍几乎没有，大多都是进行移位计数，或者是n&(n-1)这种，于是我就分享出来了（IBM板载！）

### After Story：
试试用这种方法解决下面的问题：
>有如下规律的二进制串组：
>0(n=1)
>01(n=2)
>0110(n=3)
>...
>其中将第n层的0替换为01，1替换为10，可得到第n+1层
>给出二元组x=(n，k)其中有函数f(x)=n为层数，k为从左向右第k个数字，请设计一种时间复杂度为O(1)的f(x)

答案会在评论区给出

***Have a good time!***