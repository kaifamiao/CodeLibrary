首先在下只是一个每天打打游戏看看书的学了两个月基础语法的新手（无编程基础），喜欢通过基础的东西去解决问题（因为懂的语法太少了）
这次用的是制表查表，从明确想到用制表的方案去解决问题开始，到想出整个解题的核心，用时大概20分钟，我觉得题目有意思，解题过程也挺好玩，但是最重要的还是思维能力
（也就是我为什么会考虑到查表）首先正常来说简单的解法复杂度是O(n2)，但是他要求O（n）对于N个数来说要求O（n）无异于说要求每个数的确认都是常数级的。
所以我就围绕着常数级这个要求来考虑，比较快的就考虑到了（毕竟根本没见过太多东西，少就快）使用查表的方法，表 是用来查的，但是表当然不是天上来
所以这个表肯定要靠我自己去制，如何制出这个表，就花了我20分钟的时候，这个绝对是题目的核心，我想到，既然他要求复杂度那么低，一定是有比基础方案更优秀的方案存在
而更优秀的方案说明了一点：更多的潜在关系，我是基于这一点思路判断出这道题思考的方向的。请坚信这一点。
确认了方向之后，就开始找关系了，刚才提到的潜在关系，我花了20分钟找到了，这道题基本上已经解决了。
（当然由于我的代码表达能力不够优秀，加上没有规范，完成代码用了比我思考更多的时间，无语了。）

潜在关系：假设当前是偶数，/2，你会得到一个之前已经得到结果的数字，并且你可以发现他的二进制最后+个0就是当前数的二进制表示
然后如果是奇数的话，就是把他-1变成一个偶数，就可以用上一行写的思路，去得到一个已知0bxxxxx0，这个时候再加上1就等于把最后的0变成1而已嘛
所以对于偶数来说，num的二进制中1的数目跟他/2的那个数数目是一样的，对于奇数来说，比他-1）/2后的那个数的数目多了1个1
/2后的数在哪里找？自己制的啊，现在可以找了，附上代码（很难看的代码，辛苦大家了）。

class Solution(object):
    def countBits(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        lst = []
        dict_2 = {0:0, 1:1}
        if num < 2:
            for i in range(num+1):
                result = dict_2[i]
                lst.append(result)
        else:
            lst = [0, 1]
            for i in range(2,num+1):
                if i % 2 == 1:
                    k = (i - 1) / 2
                    result = dict_2[k] + 1

                else:
                    k = i / 2
                    result = dict_2[k]

                dict_2[i] = result
                lst.append(result)
        return lst