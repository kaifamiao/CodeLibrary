重操旧业哈哈哈哈..

###

### 1.遍历计算每个数二进制的1的个数
拿到这个题的比较暴力的解法是，我对于单个数字，去求得它的二进制里1的个数，如何计算呢？
一般**位运算就要优先考虑**`与运算`和`异或运算`，更新每个值考虑`右移一位`

eg：`0101`我们想知道这里有几个1，那么我就和1进行操作，也就是`0001`，如果相与是1，说明最后一位是个1，然后右移一位得到`0010`，再继续和1相与，相与为0，说明最后一位不是1，继续右移一位得到`0000`，发现原数值为0，结束循环判断：
那么就可以根据这个思路写出遍历每个数字的二进制的1的个数的代码：

```
class Solution:
    def countBits(self, num: int) -> List[int]:
        res = []
        
        for n in range(num+1):
            res.append(self.bit(n))
            
        return res
        
        
    def bit(self, n):
        count = 0
        while n:
            if n & 1 == 1:
                count += 1
            n = n >> 1
        return count
```

但是运行时间过长，因为时间复杂度也高达`O(n*sizeof(integer))`，要怎么才能优化到`O(n)`的时间复杂度呢？


### 2.优化：考虑奇偶数二进制的特点

> `2  0010    4 0100`
> `3  0011    5 0101`

能够看出奇数总是比它前一个偶数多一个1，也就是多的相差的那个1，偶数因为对2取余是0，所以最后一位一定是0，那么比它大一个的奇数就多出来最后一位的1
那么对于偶数呢：
> `2  0010    3 0011`
> `4  0100    6 0110`
> `8  1000    12 1100`



能够看出来偶数都和它除以2的那个数的1的个数保持一致，也就是除以2，相当于右移一位，移走了最后一位的那个0，不影响1的个数

那么可以根据这个规律得到整个结果的1的个数，初始情况是0有0个1，从1开始遍历直到num+1

```
class Solution:
    def countBits(self, num: int) -> List[int]:
        res = [0]
        
        for n in range(1,num+1):
            if n % 2 == 1:
                # odd
                res.append(res[-1]+1)
            else:
                res.append(res[n//2])
                
        return res
```


### 3.反思
一定要坚持，自己没写出来的题一定要写题解，然后每天至少都得写一道题，不能断掉，断了就很容易放弃
“少就是多”
虽然来了北京，但是下一个目标还是要跳槽呀！！！