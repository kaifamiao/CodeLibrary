[这里](https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode/)参考官方题解的解法二。用同样的思路换一种写法可能更容易掌握。
因为要求时间和空间复杂度在O(n)，所以我们可以找到一种规律把前面遍历过的数存下来，遇到没走过的数只要找到前面对应的结果再加上它最高位的1即可。先来列出前8个数(decimal-->binary)：
![0.png](https://pic.leetcode-cn.com/2ddd465fc38474bc2e74384335485d451f409106548d201927c68cae3cbe9d65-0.png)

可以发现，十进制的2在十进制0的基础上，二进制多了一个最高位1，十进制6比2的二进制多了最高位1...
例如，对于数字0，2，6，14，它们二进制1的个数依次增1，而14 --> 6 --> 2 --> 0差值分别是8(2^3),4(2^2)和2(2^1)，这里关键就是找到什么时候应该减8，什么时候减4来得到上一个对应的结果。

代码和解释：
```
class Solution {
    public int[] countBits(int num){
        int[] ans = new int[num+1];
        int m=1;
        for(int i=1; i<=num; i++){
            if(i>=m*2)   m=m*2;
            ans[i] = ans[i-m] + 1;
        }
        return ans;
    }
}
```
初始化：ans数组用来存放每个数字的结果，m就是当前的数想要减去的对应差值，因为num[0]默认是0，1在0的基础上多了一个最高位1，所以m可初始化为1。
for循环：要从小的数开始往后遍历。对于m的值怎么更新，例如6-4=2，要保证当前的数6减去一个尽可能大的二次方数且差不能为负，当i遍历到6，此时的m=2，但2还不是最大的差值，所以m=2*2=4，6对应2，即num[6]=num[6-4]+1.
