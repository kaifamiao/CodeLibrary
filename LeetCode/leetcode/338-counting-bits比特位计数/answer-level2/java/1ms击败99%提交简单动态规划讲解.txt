对于一个二进制数字`n`，如果想得到他的从左到右第`n`位中的`1`的个数，可以先得到它的从左到右第`n-1`位中的`1`的个数，然后根据第`n`位是否是`1`来决定是否要加`1`。要得到整个数字中的`1`的个数，就需要知道从左到右第`31`位（从`1`开始计数）中的`1`的个数，以及最低位是否是`1`。得到前者并不难，因为如果把整个数字向右移一位就是一个前面已经计算过的数字（动态规划从小到大开始计算），这就变成了最优子结构了，递推公式变成了`res[i] = res[i>>1] + (i&1);`，有了这个公式问题就解决了。

比如如果想得到`10`也就是二进制`1010`的`1`的个数，可以先找到左边三个二进制数字`101`的`1`的个数，加上最右侧的位`0`就可以了。

```java
public int[] countBits(int num) {
    int[] res = new int[num+1];      // 不需要初始化，默认为0
    for (int i = 0; i < res.length; i++) {
        res[i] = res[i>>1] + (i&1);
    }
    return res;
}
```

更多内容请看我的[**个人博客**](http://sunshuyi.vip)
