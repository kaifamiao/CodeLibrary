一开始看到一遍扫以为要推相邻数字之间的关系，折腾了很久都没想出来
实际上有更直观的方法，把0-100全部打出来之后一眼就能看出来
时间复杂度O(n)，空间复杂度O(n)

举一个例子
> 十进制[3] = 二进制[011]
> 十进制[7] = 二进制[111]

可以发现对除了最高位之外都是完全相同的，3位于区间[2^1, 2^2)，而7位于区间[2^2, 2^3)。
所以可以写出状态转移方程

> f[2^k+i] = f[i] + 1 (0 <= i < 2^k)

为了可读性用了双重循环，但时间复杂度还是O(n)
代码:

```java
class Solution {
    public int[] countBits(int num) {
        int[] f = new int[num+1];
        f[0] = 0;
        if(num == 0) return f;
        f[1] = 1;
        for(int k=1; (1<<k) <= num; k++){
            for(int i=0; i<(1<<k) && i + (1<<k) <= num; i++){
                f[i+(1<<k)] = f[i] + 1;
            }
        }
        return f;
    }
}
```
