### 解题思路
    流程：
        ① 确定首个特殊丑数[1],由于后续丑数都可分解为2\3\5的因子,所以对首位丑数对后续因子进行相乘
        ② 本体需要判断出第n位丑数的值,所以res需要按照丑数的大小进行添加
        ③ 在循环中,每一步与各因子相乘,取最小的丑数
        ④ 某一因子使用后,对其进行进位,代表下一次使用本因子时,从后续产生的丑数上进行累乘
### 代码

```py
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        if n <= 0 :
            return 0
        res = [1]
        p2,p3,p5 = 0,0,0
        
        for i in range(1,n) :
            r2 = res[p2] * 2
            r3 = res[p3] * 3
            r5 = res[p5] * 5

            res.append(min(r2,r3,r5))

            if (res[i] == res[p2] * 2): p2+=1
            if (res[i] == res[p3] * 3): p3+=1
            if (res[i] == res[p5] * 5): p5+=1

        return res[-1]
```
### 优缺点
与传统暴力算法相比,使用本方法更有针对性:
        可以保证每次产生的数都为丑数.而使用从0到x进行遍历判断,浪费了很多计算资源.
本方法占据了更多的空间资源