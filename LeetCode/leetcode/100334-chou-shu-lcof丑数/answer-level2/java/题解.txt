思路：

1，2，3，4，5，6，8，9，10，12 ......

1.首先定义一个数组存放丑数，认为1是丑数，则初始化数组num[0] = 1;
2.然后从2,3,5这三个种子中挑选，选择num[0]*2，num[0]*3，num[0]*5中最小的数为新的丑数，
显然应该选择2，即num[1] = 2;
3.然后在从2,3,5中选择，这时应该是从num[1]*2，num[0]*3，num[0]*5中进行选择，显然选择3，即num[2] = 3;
4.然后再从num[1]*2，num[1]*3，num[0]*5中选择最小的，选择2，即num[3] = 4;
5.然后再从num[2]*2, num[1]*3, num[0]*5中选择最小的，选择5,即num[4] = 5;
6.然后再从num[2]*2, num[1]*3, num[1]*5中选择最小的，我们注意到此时num[2]*2 = 6,num[1]*3 =6,选择2或者3是一样的，选择2和3，即num[5]=6;
7.然后再从num[3]*2,num[2]*3,num[1]*5中选择最小的，我们注意到*2和*3的索引都 +1;

依次进行上述操作，得到最终的结果。

为什么索引+1?
在上一轮选择中，已经确定是最小的，在新的一轮，若不+1,有什么意义呢？

为什么有多个索引+1？
同上。


代码：

```
class Solution {
    public int nthUglyNumber(int n) {
        int[] dp = new int[n];
        int p2 = 0;
        int p3 = 0;
        int p5 = 0;
        dp[0] = 1;
        for(int i = 1; i < n; i ++) {
            dp[i] = Math.min(Math.min(dp[p2] * 2,dp[p3] * 3),dp[p5] * 5);
            if(dp[i] == dp[p2] * 2) p2 ++;
            if(dp[i] == dp[p3] * 3) p3 ++;
            if(dp[i] == dp[p5] * 5) p5 ++;
        }
        return dp[n-1];
    }
}
```
