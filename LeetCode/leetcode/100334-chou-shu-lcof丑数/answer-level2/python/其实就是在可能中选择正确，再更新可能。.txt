### 解题思路
来源于官方题解，附加上了自己的理解，
每个丑数*2或*3或*5都会且只会是某一步的新结果。因为在变大，所以想到定义三个指针，代表*2，*3，*5，且指针在不断更新
更新res结果集，res对丑数排序了
结果可能来源于某个数*2，或某个数*3，或某个数*5？
怎么选择新结果呢，取最小的那个当新结果
怎么确定某个数呢，某个数，某个数呢？
更新，如果被选成了新结果，那么就更新加一
### 代码

```python3
class Solution(object):
    def nthUglyNumber(self, n):
        cur=1       #记录当前的位置
        res=[1]*n   

        #记录结果，就是一个排序的丑数序列，res[i]表示第i个丑数是多少
        #记录在某位置的数只能在使用中只能乘以几，如res[dp2]第dp2个丑数只能乘以2来参与下一位丑数的选择的最大位置，因为丑数序列排序了。
        #意思是说dp2位置之前的数，乘以2都小于新丑数。dp3,dp5同理
        #那么新的丑数就是dp2*2，dp3*3，dp5*5这些数中最小的那个咯
        #当然，每一位都可以*2、*3、*5,且只能*2、*3、*5，从0位开始算起

        dp2,dp3,dp5=0,0,0  
        while cur<n:
            res[cur]=min(res[dp2]*2,res[dp3]*3,res[dp5]*5)  #新的丑数
            if res[cur]==res[dp2]*2:  
            #如果新的丑数是根据dp2位置的丑数来的，那么原来dp2位置的丑数再乘以2就怎么也不可能成为新丑数了，所以下一位丑数*2才有可能是某位新丑                数，同理dp3，dp5一样的更新
                dp2+=1  
            if res[cur]==res[dp3]*3:
                dp3+=1
            if res[cur]==res[dp5]*5:
                dp5+=1
            #注意细节，这里用三个if，不能用if--elif--else，因为可能新的丑数同时满足三个条件中的多个，如新丑数30，res[dp2],dp3,dp5,分别等               于15，10，6，这样三个乘以对应数之后都为30，三个都要更新
            cur+=1
        return res[cur-1]

```