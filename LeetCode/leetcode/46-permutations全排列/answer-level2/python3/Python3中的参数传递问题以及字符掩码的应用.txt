> Python3中的参数传递

“**Python 中可变对象是引用传递，因此需要将当前 path 里的值拷贝出来。**“，这句话的意思。首先必须理解的是，python中一切的传递都是引用（地址），无论是赋值还是函数调用，不存在值传递。

**可变对象和不可变对象**
python变量保存的是对象的引用，这个引用指向堆内存里的对象，在堆中分配的对象分为两类，一类是可变对象，一类是不可变对象。不可变对象的内容不可改变，保证了数据的不可修改（安全，防止出错），同时可以使得在多线程读取的时候不需要加锁。

**不可变对象（变量指向的内存的中的值不能够被改变）**
当更改该对象时，由于所指向的内存中的值不可改变，所以会把原来的值复制到新的空间，然后变量指向这个新的地址。**python中数值类型（int和float），字符串str，元组tuple都是不可变对象。**
下面以int类型为例简单介绍。

```python
a = 1
print id(a)    # 40133000L，整数1放在了地址为40133000L的内存中，a变量指向这个地址。
a += 1 
print id(a)    # 40132976L，整数int不可改变，开辟新空间存放加1后的int，a指向这个新空间。
```

**可变对象（变量指向的内存的中的值能够被改变）**
当更改该对象时，所指向的内存中的值直接改变，没有发生复制行为。**python中列表list，字典dict，集合set都是可变对象。**下面以list类型为例简单介绍。

```python
a = [1,2,3]
print id(a)    # 44186120L。

a += [4,5]     # 相当于调用了a.extend([4])
print id(a)    # 44186120L，列表list可改变，直接改变指向的内存中的值，没开辟新空间。

a = a + [7,8]  # 直接+和+=并不等价，使用+来操作list时，得到的是新的list，不指向原空间。
print id(a)    # 44210632L
```

**引用传递后的改变**

```python
a = [1,2,3]
b = a
b[0] = 2     # 由于list是可变对象，改变b时候会导致a的改变，a和b都是[2,2,3]

s = 'abc'
s2 = s
s2 += 'd'   # 由于str是不可变对象，s2是新建的对象，s2的修改不会影响s。s为'abc'，s2为'abcd'。
```

**list注意点**

```python
a = [1,2,3]
b = a
a is b             # True，因为按引用传递，a和b存的地址（引用）是一样的，改变b相当于改变a。

b = a[:]
a is b            # False，想使用list的值却不想修改原list时可以使用[:]拷贝一份到新空间。

a =[ [0]*2 ]* 2   # 以这种方式创建一个二维list，此时a为[[0,0],[0,0]]。
a[0] == a[1]      # True，这种创建方法的机制是复制list，所以2个list其实是同一个list。

a[0][0] = 1       # 改变第一个list时第二个list也改变，此时a为[[1,0],[1,0]]。
a[0] += [1]       # 改变第一个list时第二个list也改变，此时a为[[1,0,1],[1,0,1]]。
a[0] = [1,2]      # a[0]指向创建的新list[1,2]。此时a[1]不变，a为[[1,2],[1,0,1]]。
```

> 如何用字符掩码代替布尔数组？

布尔数组也可以通过一个整数的二进制来表示，在每个数位上非 0 即 1，这就可以表示一个布尔型数组。
它们的区别仅在于
1、二进制右边是低位，数组左边是索引为 0 的位置；
2、一个整数的二进制有 32 位，不过回溯搜索的问题复杂度基本上都很高，本题是 O(n!) ，n = 32 的时候已经非常大了，一般来说测试用例都达不到这个级别。
因此，完全可以用一个整数表示一个布尔型数组。
我们对布尔型数组的操作不外乎就两个：1、把某个索引位置从 true 变为 false；2、把某个索引位置从 fasle 变为 true。
异或操作，是不进位的加法，一个数位异或上 1 以后，它的功效就是使得 1 变 0 ，0 变 1。因此就可以通过对整数进行异或运算达到操作布尔型数组的效果。

```python
'''
输入：四位数据对应的真假情况，其中只有第1位为真（从0开始）。
输出：为真的那一位的下标，也就是输出1。
'''

# 哈希表形式 空间复杂度为O(n)
>>> b = {0: False, 1: True, 2: False, 3: False}
>>> for i in b:
...     if b[i]:
...             print(i)
...
1

# 布尔数组形式 空间复杂度为O(n)
>>> a = [False, True, False, False]
>>> for i,v in enumerate(a):
...     if v:
...             print(i)
1

# 字符掩码形式 空间复杂度为O(1)
>>> c = 4  # 0100
>>> c_len = 4   # 一共要判断4个位置数据对应的情况（True or False）
>>> for i in range(c_len):  
...     if (c >> i & 1) != 0:
...             print(c_len - 1 - i)
...
1
# 当i = 0 时 c >> i & 1 => 0100 >> 0 & 1 => 0100 & 0001 = 0 == 0，该位置不是True。
# 当i = 1 时 c >> i & 1 => 0100 >> 1 & 1 => 0010 & 0001 = 0 == 0，该位置不是True。
# 当i = 2 时 c >> i & 1 => 0100 >> 2 & 1 => 0001 & 0001 = 1 != 0，该位置是True。
# 布尔数组中是从左向右第 i 位的值为True，在整型变量中，是从右向左第 i 位的值为1，代表该位置为True（这里 i 从 0 开始）。这两者是相反的，所以最后输出的位置是c_len - 1 - i

# 将c的第x位从1变成0
>>> x = 1
>>> c = 4  # 0100
>>> c_len = 4   # 一共要判断4个位置数据对应的情况（True or False）
>>> c ^= 1 << (c_len - 1 - x)  # 1 << c_len - 1 - x = 0100 / c = 0100 / 二者异或为 0000
>>> c
0  # 0000 第1位从1变成了0 0100->0000

# 将c的第x位从0变成1
>>> c = 4
>>> x = 2
>>> c_len = 4
>>> c ^= 1 << (c_len - 1 - x)
>>> c
6  # 0110 第2位从0变成了1 0100->0110
```

> 本题解法

**算法步骤**
- 声明 `res`、`length`、`used`等全局变量，其中`used` 用于保存每个数字的使用情况。
- 开始回溯
  - 终止条件判断，终止条件是寻找深度达到目标深度
    - 将 `path` 添加到 `res` 中，注意，由于list是可变对象，因此，这里要用[:]取到具体的值，再append进res中。 `res.append(path[:])` 
    - `return`
  - 遍历所有待添加数，开始选择。
    - 如果当前数字没有使用
      - 做选择：将当前数字添加到 `path` 中，并更新 `used` 为 `True`。
      - 继续深度优先遍历 `backtrack(path, depth + 1)`
      - 撤销选择：更新 `used` 为 `False`， `path` 弹栈，弹出刚刚加进去的那个数字。


字符掩码版本
```python
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        def backtrack(path=[], depth=0, used=0):  # 整个回溯函数只包含两个参数，一个是path（记录选择结果），depth（记录还剩多少没有选择）。也可以不用depth，只传递path。通过比较len(path)和len(nums)，判断是否完成寻找。
            if depth == length:  # 终止条件是寻找深度达到目标深度
                res.append(path[:])  # 由于list是可变对象，因此，这里要用[:]取到具体的值，再append进res中。
                return

            for index in range(length):  # 遍历所有待添加数
                if (used >> index) & 1 == 0:  # 如果当前数字没有使用，即该位置的二进制值为0
                    used ^= (1 << index)  # 将该位置的二进制值从0改成1
                    path.append(nums[index])  # 添加到path
                    backtrack(path, depth+1, used)
                    used ^= (1 << index)  # 将该位置的二进制值从0改成1
                    path.pop()

        res = []
        length = len(nums)
        backtrack()
        return res
```
执行用时 :32 ms, 在所有 Python3 提交中击败了98.16%的用户
内存消耗 :13.7 MB, 在所有 Python3 提交中击败了24.67%的用户

[参考了这位大佬的题解](https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/)