### 解题思路
最明显的思路，就是我们在课堂上学习到的2进制转10进制的算法，以二进制101举例，二进制转换成10进制的方法为2^2 * 1 + 2^1 * 0 + 2^0 * 1 = 5，那么结果就是5。

按照这个思路，需要直到二进制的位数到底有多少，但是链表需要从左开始遍历，只有遍历完了之后才能计算出对应的十进制是多少。这种算法请详见“代码1”

还有一种思路，利用位运算的方式，在进行位运算的时候一定要有这个概念，就是位运算运算出来的结果是10进制，但是考虑问题的思路是2进制。

还是拿101来举例，为了要1次循环就能计算出结果，我们这么来考虑，二进制中的每一位和0进行或运算，还是其本身，那么左边第一位1和0进行或运算，还是1，为了让其保持其最左边的位置，我们需要将其左移2位，其他位的数字的操作和它一样。那么问题就来了，还是需要知道移动的位数我们才能进行，但是别忘了，1 | 0 << 1 变成了10，10再和 0 | 0进行或运算，变成了10，10 << 1 | 1就变成了101，但是结果却变成了10进制，也就是说，我们进行的都是2进制的位运算，但是结果却变成了10进制。这种算法请详见“代码2”；当然，如果把位运算的写法换成加减乘除，左移就变成了*2，或就变成了+，代码可能就会变成sum = sum * 2 + p->val;

### 边界条件 & 特殊点说明
1. 第一种算法只需要注意从0开始计算就可以
2. 第二种算法可以有两种写法，一种是位运算，一种将位运算换成正常的加减乘除。

### 代码

代码1
```
int getDecimalValue(ListNode* head) {
    int sum = 0;
    int num = 0;
    ListNode *p = head;
    while (p != NULL) {
        num++;
        p = p->next;
    }

    ListNode *q = head;
    while (q != NULL) {
        sum += (int)pow(2, --num) * q->val;
        q = q->next;
    }

    return sum;
}
```

代码2
```
int getDecimalValue(ListNode* head) {
    int sum = 0;
    ListNode *p = head;
    while (p != NULL) {
        sum = sum << 1 | (p->val);
        p = p->next;
    }

    return sum;
}
```