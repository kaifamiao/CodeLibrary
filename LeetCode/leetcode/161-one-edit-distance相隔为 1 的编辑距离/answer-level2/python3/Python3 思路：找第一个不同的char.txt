解体思路（参考了官方解题思路）：
1. 我们很容易能想到：这两个字符串的长度一定有固定的关系：s和t的长度相差值最多为1。
2. 根据题目的提示，只有插入、删除和替换3种可能，所以我们遍历一次s就可以做出判断了。也就是说时间复杂度为O(N)。
3. s和t其实没有谁前谁后的区分，所以我们也可以交换它们的位置，让长度较短（也可能相等）的string为s，长度较长的string为t。这样就可以对较短的string s进行遍历了。
4. 接下来的一个思路很关键，既然长度最多相差为1，那么这两个字符串一定最多只有一个不同的元素。那我们的思路可以转换为找那个不同的元素。
5. 找不同的元素就需要我们遍历s，如果发现s和t有一个元素不同时，这时候考虑两种情况：
    1）s和t长度相等，那么必须要当前元素后面的元素全都相等，这两个元素的编辑距离才为1
    2）s的长度比t小，假设当前不相等的元素的index为i，那么必须s[i:] = t[t+1]才能保证这两个元素的编辑距离为1
6. 如果我们遍历完s发现s和t的对应位置的元素都相等，这时能不能说明s和t的编辑距离一定为1呢？答案是不一定。我们想想，这时候是不是必须得t的长度比s的长度大1，它们的编辑距离才为1呢？比如：当s的长度和t的长度相等时，s = t，它们的编辑距离实际上为0（注意：这种情况很容易被忽视）；当t的长度比s的长度大2以上时，编辑距离肯定>1。所以如果我们遍历完s发现s和t的对应位置的元素都相等时，只有当t的长度比s的长度大1时，它们的编辑距离才为1。

Python3相关的代码如下：
```
class Solution:
    def isOneEditDistance(self, s: str, t: str) -> bool:
        if len(s) > len(t):
            s, t = t, s
        for i in range(len(s)):
            if s[i] != t[i]:
                if len(t) > len(s):
                    return True if s[i:] == t[i+1:] else False
                else:
                    return True if s[i+1:] == t[i+1:] else False
        return True if len(s) == len(t) - 1 else False
```

