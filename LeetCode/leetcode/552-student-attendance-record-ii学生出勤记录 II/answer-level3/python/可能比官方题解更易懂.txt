官方题解得出推导方程真是。。。没头没脑：f[n]=2f[n−1]−f[n−4] 怎么就到了n - 4 。。。不过官方题解的整体思路还是可以的，将问题分解成只考虑PL，之后再考虑A。

只考虑PL，其实有这个转移方程：
```
f[n] = f[n−1] + f[n-2] + f[n-3]
```
其中：
f[n-1] 对应最后一位是P，那么前面照单全收
f[n-2] 对应最后两位是PL，同样的可以照单全收前面的
f[n-3] 对应最后三位是PLL，同样的可以照单全收前面的

DP的思路是，我们相信前面的结果是可信的，推倒后面的结果。前面结果是可信的，但是可能以L结尾，为了保证前面结果完全可用，我们必须用P去接前面的子串，所以有了这个推导。

A的考虑与官方题解一样，依次看A可能在哪个位置。这里可以节省点时间，比如，A在第一位和在最后一位，对应的运算是一样的。最后的代码：
```
        dp = [0] * max((n + 1), 3)
        mod = 10 ** 9 + 7
        dp[0] = 1
        dp[1] = 2
        dp[2] = 4
        for i in range(3, n + 1):
            dp[i] = (dp[i - 1] + dp[i - 2] + dp[i - 3]) % mod
       
        result = 0
        for i in range(1, n / 2 + 1):
            result += (dp[i - 1] * dp[n - i]) % mod

        result *= 2
        if n % 2 == 1:
            result += dp[n / 2] * dp[n / 2]

        return (result + dp[n]) % mod
```
