# 动态规划思路：
个人觉得，把一个资源（题目可能描述成一个数，一根绳子，一堆钱也可能是背包空间等）按照某种要求分配到一定程度，可以看作同一种类型的问题来思考。

这种题目我觉得思考的关键在于如何建立dp的模型。

一般这种求最值的问题，我们可以设定子问题为[i...j]这个子区间的一个问题。

比如此题，可以设定dp[i] 为在能组成整数 i 的最少完全平方数的个数。

状态转移，所以每次的子问题求解都是最小值，我们可以设定状态转移方程为 dp[i] = min(dp[i],dp[j])
此时 dp[j] 还是个猜想的不明确的状态。

既然是资源分配问题，那么需要按照题设要求分配资源，由题设可以，我们分配的方式是用完全平方数来进行分配。

那么，这个分配方式就可以知道：1,4,9...n <=target.

而且对于分配资源，我们总会面临，分配了一本分，剩下一部分的问题，如果说 总量是 sum ， 分配了 p ，那么剩余的就是 sum - p

带到dp模型中就是: dp[sum] = dp[sum-p] + dp[p] （每一个dp[i]都是最小值）

再思考一下，由分配方式可知两点，一：用完全平方数进行分配；二：p <= target

所以，当计算dp[sum] 时，sum的情况唯一，但是p的情况会变 ，变化范围为 ： 1，4，9....n <= sum,即每次计算的dp[sum]都会更新

综合上述所有，可以得到状态转移方程为：
dp[i] = min(dp[i],dp[i-p]+dp[p])   1<p<=sum 且 为完全平方数。

代码如下：go语言实现
```
func numSquares(n int) int {
    //边界
    if n <=3 {
        return n
    }
    if n == 4 {
        return 1
    }


    dp := make([]int,n+1)
    //初始化，因为是取最小值，把下标为完全平方数的值设定为1，其余的设定为i
    for i:=1;i<=n;i++ {
        if i*i <= n{
            dp[i*i] = 1
        }
        if dp[i] == 0 {
            dp[i] = i
        }
    }

    //跳过边界值
    for i:=5;i<=n;i++ {
        //这就是从1....p < sum 的分配方式
        //因为存在重复解，类似于 dp[5] = dp[5-1] + dp[1] 和 dp[5] = dp[5-4] + dp[1],优化时间，但是时间复杂度还是O(n2) 
        for j:=1;j*j<=i/2;j++ {
            dp[i] = Min(dp[i],dp[i-j*j]+dp[j*j])
        }
    }

    return dp[n]
}

func Min(a,b int) int {
    if a<b {
        return a
    }
    return b
}
```
目前这个解排名是 72.54% 
转换成熟悉的问题比较好思考和理解

