这题乍一看很陌生，但是仔细分析会发现这就是一道完全背包问题，如果还察觉不到，那我把题目换一种说法。
给你n块钱，现在需要你找零，但是在balabala国，找零的硬笔面额都是是完全平方数（1,4,9,16），寻求那种找零方式给的钱最少，且每种面额硬笔有无穷多个。

这么一看，题目就很熟悉了。
首先找一下可以用的硬币，那必然是i^2<=n,由此就有一个硬币数组，遍历也在这里面选。
按照完全背包问题列状态转移方程：
dp[i][j]=min(dp[i][j],dp[i-1][j-k*i^2]+k) #对j块钱找零时，要么用第i种硬笔面额，要么不用，用的话可以用k个。
简化后
dp[i][j]=min(dp[i][j],dp[i][j-i^2]+1) #这个过程很难想，建议去看《背包九讲》，上面有详细的过程，需要注意下状态初始化

我照葫芦画瓢的代码是
```
class Solution(object):
    def numSquares(self, n):
        """
        :type n: int
        :rtype: int
        """
        # 寻找最短路径的最优解 广度优先算法 或者动态规划思路 欲求n的完全平方和 和找零的概念很相似用完全平方数对其找零 完全背包问题
        size=0
        while size*size<=n:
            size+=1
        #统计找的硬笔种类和个数
        # 完全背包的变种问题
        # 压缩空间 调整程序
        dp=[float('inf') for i in range(n+1)]  # dp[i][0]=1
        #初始化
        dp[0]=0
        #print(dp)
        for i in range(1,size):
            for j in range(i*i,n+1):
                dp[j]=min(dp[j],dp[j-i*i]+1) #完全背包的变种问题
        return dp[-1]
```