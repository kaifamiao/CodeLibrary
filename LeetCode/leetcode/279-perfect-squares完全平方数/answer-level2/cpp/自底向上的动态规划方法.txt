# 完全平方数

## 源码

```cpp
class Solution {
public:
    int numSquares(int n) {
        int f[n+1]; //会使用f[n],故数组开大一个单元
        //初始状态，0所需的完全平方数为0
        f[0] = 0;
        //自底向上，递推f[1] -> f[n] 之间的所有状态
        for(int i = 1; i <= n; ++i){
            //为找f[i]的最小值，出于比较目的，将f[i]初始化为最大值
            f[i] = i;
            //边界状态 j*j <= i
            for(int j = 1; j*j <= i; ++j){
                //如果有更优解,更新f[i]的值
                if(f[i-j*j] + 1 < f[i]){
                    f[i] = f[i-j*j] + 1;
                }
            }
        }
        return f[n];    //返回数组f保存的状态值
    }
};
//时间复杂度O(n*log(n))
```

## 思路

### 数据准备

首先定义长度为 n+1 的数组 f 保存状态

### 确认状态(初始和边界状态)

**初始状态**: `f[0] = 0;`   i = 0时，完全平方数所需0
**边界状态**: `j*j > i;`   当完全平方数j*j > i 时，不再成立

### 状态转移方程

**问题**: n 最少被划分成几个完全平方数之和
**最后一步**: 最后一个完全平方数为 j,加上最后一个元素 j*j 得到n
**子问题**: n-j*j 最少被划分成几个完全平方数之和
**最后一步的状态转移过程**: `f[i] = f[i-j*j] + 1;`
**状态转移方程**: `f[i] = min(f[i-j^2] + 1 | 1 <= j^2 <= i);`

### 递推过程

依据自底向上的动态规划思想，基于初始状态**f[0] = 0**和边界情况，根据**状态转移方程**向上递推,对每一次循环的f[i],根据最优策略更新f[i]为当前情况下的最优解

> 遍历过程：
> 对数组进行遍历，下标为i,每次都将当前数字先更新为最大的结果
> 即dp[i] = i，比如i = 4，最坏结果为 4 = 1+1+1+1即为4个数字
