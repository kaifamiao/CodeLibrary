### 解题思路
该题一开始让我想到的是，用一个deque来作为双端队列，然后里面放的是元素本身。这一点让我的思路一开始坑了。
由于采用了这样的思：后面进来的元素，如果是比较大的元素，要挤掉它前面比它小的元素，尽量靠前放置。这样做是合适的，因为有它在，那些比它小的元素是不需要考虑的。这样在每次取窗口中最大值时，最前面的0号元素就是窗口中最大的，返回第0元素即可。

但由于队列中放置的是元素本身，结果窗口的大小无法维护：因为在滑动的过程中，假设进入的元素都只挤掉中间的元素，而第0个元素一直占着窗口靠前，这样每次都会返回它。
比如：[1000，1,2,3,4,5,6,7,8]

所以后来需要改成，进入队列的应该是index下标。这样每次遍历时，就可以用于计算窗口的左界变动是否应该排除1000.

自己的思路里还有个坑，就是原本想每次拿着即将入队的元素，去跟第一个比较，让第一个元素出队。假如窗口中是[2，1000，1]，那么遍历到3，先pop出2，成为[1000,1]，然后3入队之前要挤掉比它小的元素，它挤不掉1000，于是挤队结束，它入队，成为[1000,1,3]，可是队列里的状态，对于要实现的算法是错误的。算法依赖每次从最前面取的数字是窗口中最大的。所以需要大的数字尽量靠前，前面没有比它小的数字。现在3的前面有1，违反了这个规则，导致后来1000被pop出去，1成了第一个位置，结果取了最左边的1被认为是窗口中数字最大的，可是后面还有个3啊。。。

所以改成新元素入队之前，从右边开始往左去比较数字，然后挤出去。所谓的挤出去其实就是pop右边的。所以需要用到pop_front和pop_back，于是需要用到deque这个结构。

### 代码

```cpp
class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        deque<int> window;
        vector<int> result;

        for(int i = 0; i < nums.size(); ++ i) {
            if (i >= k && i - window.front() >= k) {
                window.pop_front();
            }
            while (window.size() > 0 && nums[window.back()] <= nums[i]) window.pop_back();
            window.push_back(i);
            if (i >= k - 1) {
                result.push_back(nums[window.front()]);
            }
        }
        return result;
    }
};
```

![微信图片_20191231145713.png](https://pic.leetcode-cn.com/917027842ae3da77c440165a7f42b19efad84c12ac15705af0961297de6e0f74-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191231145713.png)
