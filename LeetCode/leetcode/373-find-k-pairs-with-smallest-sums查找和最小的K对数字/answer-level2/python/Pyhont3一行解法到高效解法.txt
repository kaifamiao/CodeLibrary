### è§£æ³•ä¸€ï¼šæš´åŠ›
æšä¸¾æ‰€æœ‰ç»„åˆï¼ŒæŒ‰ç…§å’Œæ’åºï¼Œæœ€åè¿”å›å‰ K é¡¹ã€‚
![ç»„åˆ1.png](https://pic.leetcode-cn.com/c6e8cfde2aa085ed377abba0373124247626f6ecbec347aa80f156ac7ff4f78d-%E7%BB%84%E5%90%881.png)
```python3
def kSmallestPairs(self, nums1, nums2, k):
    return sorted(itertools.product(nums1, nums2), key=sum)[:k]
```
### è§£æ³•äºŒï¼šæš´åŠ›æ ‡å‡†è§£
è¿™ä¸ªè§£æ³•æ›´åŠ æ ‡å‡†ï¼Œå› ä¸ºä¸Šé¢çš„è§£æ³•ç”Ÿæˆçš„æ˜¯å…ƒç»„ä¸æ˜¯åˆ—è¡¨ã€‚
```python3
def kSmallestPairs(self, nums1, nums2, k):
    return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k])
```
### è§£æ³•ä¸‰ï¼šä¼˜åŒ–çš„æš´åŠ›
ä»ç„¶éå†æ‰€æœ‰å¯¹ï¼Œä½†ä»…ä½¿ç”¨ç”Ÿæˆå™¨å’Œä½¿ç”¨å¤§å°ä¸º k çš„å †`heapq.nsmallest`ã€‚ å› æ­¤ï¼Œè¿™ä»…éœ€è¦$O(k)$çš„é¢å¤–å†…å­˜å’Œ$O(mn log k)$çš„æ—¶é—´ã€‚
```
def kSmallestPairs(self, nums1, nums2, k):
    return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum))
```
### è§£æ³•å››ï¼šå †
ä¸è®¡ç®—æ•´ä¸ªçŸ©é˜µï¼Œè€Œå°†æ¯ä¸€è¡Œå˜æˆä¸‰å…ƒç»„`[u + vï¼Œuï¼Œv]`çš„ç”Ÿæˆå™¨ï¼Œä»…åœ¨è¦æ±‚è®¡ç®—ä¸‹ä¸€è¡Œæ—¶æ‰è®¡ç®—ä¸‹ä¸€è¡Œï¼Œç„¶åå°†è¿™äº›ç”Ÿæˆå™¨ä¸å †åˆå¹¶ã€‚ å ç”¨ $O(m + k * log(m))$ çš„æ—¶é—´å¤æ‚åº¦å’Œ $O(m)$ çš„ç©ºé—´å¤æ‚åº¦ã€‚
```python3
def kSmallestPairs(self, nums1, nums2, k):
    streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1)
    stream = heapq.merge(*streams)
    return [suv[1:] for suv in itertools.islice(stream, k)]
```
### è§£æ³•äº”ï¼šä¼˜å…ˆé˜Ÿåˆ—
å®ƒä»…ä»çŸ©é˜µå·¦ä¸Šè§’çš„ç¬¬ä¸€å¯¹å¼€å§‹ï¼Œç„¶åæ ¹æ®éœ€è¦ä»é‚£é‡Œå¼€å§‹æ‰©å±•ã€‚ æ¯å½“å°†ä¸€å¯¹é€‰æ‹©ä¸ºè¾“å‡ºç»“æœæ—¶ï¼Œè¯¥è¡Œä¸­çš„ä¸‹ä¸€å¯¹å°±ä¼šæ·»åŠ åˆ°å½“å‰é€‰é¡¹çš„ä¼˜å…ˆé˜Ÿåˆ—ä¸­ã€‚ åŒæ ·ï¼Œå¦‚æœæ‰€é€‰å¯¹æ˜¯è¯¥è¡Œä¸­çš„ç¬¬ä¸€å¯¹ï¼Œåˆ™å°†ä¸‹ä¸€è¡Œä¸­çš„ç¬¬ä¸€å¯¹æ·»åŠ åˆ°é˜Ÿåˆ—ä¸­ã€‚
![ç»„åˆ2.png](https://pic.leetcode-cn.com/cba00e2cb2cf8a1158aa8caff0c42259a0263bbb5e623e99c2280da21bdd875d-%E7%BB%84%E5%90%882.png)
```python3
class Solution:
    def kSmallestPairs(self, nums1, nums2, k):
        queue = []
        def push(i, j):
            if i < len(nums1) and j < len(nums2):
                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])
        push(0, 0)
        pairs = []
        while queue and len(pairs) < k:
            _, i, j = heapq.heappop(queue)
            pairs.append([nums1[i], nums2[j]])
            push(i, j + 1)
            if j == 0:
                push(i + 1, 0)
        return pairs
```

PSï¼šæƒ³è¦ä¸€èµ·åŠªåŠ›çš„ç«¥é‹ä»¬å¯ä»¥å…³æ³¨æˆ‘åˆ›åŠçš„å…¬ä¼—å·ï¼šè…çƒ‚çš„æ©˜å­ğŸŠï¼Œè‡´åŠ›äºæ‘†è„±ç®—æ³•çš„æŠ½è±¡æ€ç»´ï¼Œå½»åº•ææ‡‚ç®—æ³•ï¼ŒåŒæ—¶å…¬ä¼—å·è¿˜ä¼šå‘å¸ƒé¢è¯•ä¸­çš„é«˜é¢‘çŸ¥è¯†ç‚¹ï¼Œä¸€èµ·åŠªåŠ›å§ï¼ğŸ˜‹