### 解题思路
从N的二进制入手，N可以分为偶数位部分和奇数位部分，基变为-2，也就是奇数索引部分变成了负数；
假设k为奇数，那么我们本来需要2^k，但现在变成了(-2)^k，也就是-2^k；
这里巧妙的一点是我们可以使用(-2)^(k+1)+(-2)^k得到2^k，也就相当于进了一位，
所以产生的一个思路就类似加法进位，也就是说如果原本N的二进制序列奇数索引位置（假设k）为1，我们需要在k+1位置+1
如果k+1位置原本为0，那么直接变为1就满足要求了，如果为1，那么1+1=2，二进制这个时候就需要向上进1,也就是k+2位置需要+1，因为k+2还是奇数，所以如果k+2位置原本为0，那么k+2位置现在变成1，这就跟k位置是1一样，同样处理即可
如果k+2位置是1，那么现在变为2需要进1，也就是k+3位置+1，对于k+3位置同k+1位置处理即可

### 代码

```cpp
class Solution {
public:
    string baseNeg2(int N) {
        //思路：从N的二进制入手，N可以分为偶数位部分和奇数位部分
        //基变为-2，也就是奇数索引部分变成了负数
        //假设k为奇数，那么我们本来需要2^k，但现在变成了(-2)^k
        //这里巧妙的一点是我们可以使用(-2)^(k+1)+(-2)^k得到2^k
        //所以产生的一个思路就类似加法进位，也就是说如果原本N的二进制序列奇数索引位置（假设k）为1，我们需要在k+1位置+1
        //如果k+1位置原本为0，那么直接变为1就满足要求了，如果为1，那么1+1=2，二进制这个时候就需要向上进1,也就是k+2位置需要+1，因为k+2还是奇数，所以如果k+2位置原本为0，那么k+2位置现在变成1，这就跟k位置是1一样，同样处理即可
        //如果k+2位置是1，那么现在变为2需要进1，也就是k+3位置+1，对于k+3位置同k+1位置处理即可
        //综上，迭代求解即可

        vector<int> s;
        int tmp = N;
        while(tmp > 0)
        {
            s.push_back(tmp&1);
            tmp >>= 1;
        }

        int n = s.size();
        if((n & 1) == 0)
        {
            s.push_back(0);
        }

        //这个时候s是反序的,而我们也需要这个反序遍历
        for(int i=1;i<s.size()-1;++i)
        {
            if(i&1)
            {
                if(s[i] == 1)
                {
                    s[i+1]+=1;
                }
                else if(s[i] == 2)
                {
                    s[i+1]+=1;
                    s[i] = 0;
                }
            }
            else
            {
                if(s[i]==2)
                {
                    s[i+1]+=1;
                    s[i]=0;
                }
            }
            
        }

        if(s.back() == 2)
        {
            s.back() = 0;
            s.push_back(1);
            s.push_back(1);
        }

        string res;
        for(int i=s.size()-1;i>=0;--i)
        {
            res.append(1,s[i]+'0');
        }

        return res;
    }
};
```