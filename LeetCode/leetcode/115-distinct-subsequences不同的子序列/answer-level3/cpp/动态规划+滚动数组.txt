### 解题思路
假设字符串s的长度是s_len，字符串t的长度是t_len，我们令dp[i][j]表示字符串s的前i个字符的子串里包含字符串t前j个字符的数量！那题目所要求的不就是求dp[s_len][t_len]！
哈哈，得到这个玩意有啥用呢？还记得动态规划的核心思想吗，大问题转化成小问题，小问题推导大问题，现在我们要求dp[i][j]，那怎么求呢？我们先直接给出状态转移方程：
dp[i][j] = dp[i-1][j-1] + dp[i-1][j];

我们接下来分析一下这个递推式的思考过程：
**情形1：**
假设现在s[i]等于t[j]，那么dp[i][j]是不是就等于dp[i-1][j-1]，这个地方读者需要自己思考一下，其实很简单，想不明白就想想dp[i][j]代表的含义！
**情形2：**
假设现在字符串s的前i-1个字符的子串已经可以匹配字符串t的前j个字符，相当于把字符串s的第i个字符删了，也就是对应我们的dp[i-1][j]！
**情形3：**
那是不是还存在一个dp[i][j-1]呢？显然不存在，因为我们只能删除字符串s的字符，并不能添加字符串t的字符，dp[i][j-1]是推导不到dp[i][j]的！所以情形3不存在！

**时间复杂度分析：**
时间复杂度，两层for循环，显然是O(mn)的，m和n分别表示两个字符串的长度，空间复杂度，如果不做任何优化，也是O(mn)的，
但是在构造dp的时候可以使用滚动数组的技巧，成功把空间复杂度降低到O(n)。

### 代码

```cpp
class Solution {
public:
    int numDistinct(string s, string t) {
        int n = s.size(), m = t.size();
        if (m == 0) return 1;
        if (n == 0) return 0;
        int i, j ;
        vector <vector<long long>> dp(2,vector<long long>(t.length()+1,0));
        dp[0][0] = 1;
        for(i=1;i<=s.length();i++){
            dp[i&1][0] = 1;
            for(j=1;j<=t.length();j++){
                dp[i&1][j] = (s[i-1] == t[j-1] ? dp[(i - 1)&1][j - 1 ] : 0) + dp[(i - 1 )&1][j];
            }
        }
        return dp[s.length()&1][t.length()];
    }
};



```