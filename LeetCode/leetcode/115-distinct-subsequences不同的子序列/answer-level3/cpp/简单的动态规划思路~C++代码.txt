每次看题解的时候都在感叹……为什么用C++写的题解如此之少。。所以我来补一个吧~

字符串的题挺多都用到动态规划解，只要之前接触过动态规划，这里应该很容易想到DP的方法了。如果想不到的话，建议先练习几道简单/中等难度的DP问题。当然，其实这道题的DP也不是很难，说实话觉得有点配不上hard难度。

## **解题思路：**
**动态规划本质上就是一种“正向的递归”**，在这道题中，我们求解的问题实际上是`S`的前$n1$个字符构成的字符串有多少种表示`T`的前$n2$个字符构成的字符串的方式。其中，$n1$、$n2$分别为`S`和`T`字符串的长度。

## **动态方程：**
想到动态规划后，**解题的唯一难点就是写出动态方程**了。按照我们写的解题思路，我们定义`dp[i][j]`表示`S`的前$j$个字符有多少种表示`T`的前$i$个字符的方式。显然，我们想到需要分情况讨论：
1. 如果`S`的第$j$个字符和`T`的第$i$个字符**相同**，即`S[j] == T[i]`。这时如果想让`S`的前$j$个字符中的某$i$个字符和`T`的前$i$个字符匹配，有两种方式：
- 匹配时**包含**`S`的第$j$个字符，这时`dp[i][j] = dp[i-1][j-1]`。
- 匹配时**不包含**`S`的第$j$个字符，这时`dp[i][j] = dp[i][j-1]`。
因此，这种情况下的动态方程为`dp[i][j] = dp[i-1][j-1] + dp[i][j-1]`。
2. 如果`S`的第$j$个字符和`T`的第$i$个字符**不相同**，即`S[j] != T[i]`。这时如果想让`S`的前$j$个字符中的某$i$个字符和`T`的前$i$个字符匹配，**相当于**让`S`的前$j-1$个字符中的某$i$个字符和`T`的前$i$个字符匹配，即`dp[i][j] = dp[i][j-1]`。

## **代码实现：**
完成动态方程之后，代码就很容易实现了，唯一需要注意的就是一些边界条件的预设定。这部分就不具体讲解了，希望读者自行验算~

```
class Solution {
public:
    int numDistinct(string s, string t) {
        // 特殊情况处理
        if (s.size() == 0)
            return 0;
        
        // 构建dp数组
        vector<vector<long long int>> dp(t.size(), vector<long long int>(s.size()));
        
        // 初始边界条件预设
        for (int i = 0; i < (int)t.size(); i++) {
            dp[i][0] = 0;
        }
        dp[0][0] = (s[0] == t[0]);
        for (int i = 1; i < (int)s.size(); i++) {
            dp[0][i] = dp[0][i-1] + (s[i] == t[0]);
        }

        // dp
        for (int i = 1; i < (int)t.size(); i++) {
            for (int j = 1; j < (int)s.size(); j++) {
                if (s[j] == t[i])
                    dp[i][j] = dp[i-1][j-1] + dp[i][j-1];
                else
                    dp[i][j] = dp[i][j-1];
            }
        }
        return dp.back().back();
    }
};
```
另外，我们也可以选择把dp数组设成$(n1 + 1) * (n2 + 1)$维，这样初始化时可以预设一些边界条件。这些都是些处理动态规划的常用小细节，在此不再赘述。

## **复杂度分析：**
时间复杂度：$O(M * N)$，$M$和$N$分别为两个字符串的长度，来源于两层循环。
空间复杂度：$O(M * N)$，$M$和$N$分别为两个字符串的长度，来源于dp数组占用的空间。