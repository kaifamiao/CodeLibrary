# 题解

## 动态规划
![在这里插入图片描述](https://pic.leetcode-cn.com/6fe439e14047f8f578cb0226643517802a88ef626f7d98390ec0cce74ec76a2d.png)
我们使用$dp[i][j]$表示$S$的前$j$个字符有几种方式构成$T$的前$i$个字符。在$S$和$T$前插入空字符，便于计算。
易知，初始化$dp$数组第一行全为$1$，第一列除首位全为$0$。$dp[0][j]$表示$S$的前$j$位可以构成空序列的方法数。$dp[i][0]$表示$T$的前$i$位可以由空字符构成的方法数。
 1. 初始化$S,T$的长度分别为$len1,len2$
 2. 初始化$dp$为$(len2+1)*(len1+1)$的全零数组，将第一行置为全置为$1$
 3. 遍历$dp$数组，每一行$i$，遍历区间$[1,len2+1)$：
 	+ 每一列$j$，遍历区间$[1,len1+1)$：
 		+ 若$T[i-1]==S[j-1]]$，此时：$dp[i][j]=dp[i-1][j-1]+dp[i][j-1]$。解释：如图中绿色单元格所示，$dp[1][5]$，表示序列$T[0]$可以由序列$S[0,1,2,3,4]$构成的方法数。$T[0]==S[4]$，此时$dp[1][5]$等于黄色单元格（$dp[0][4]$，$dp[1][4]$）之和。$dp[0][4]$表示空字符可以由$S[0,1,2,3]$（"babg"）有一种构成方法，$dp[1][4]$表示$T[0]$（"b"）可以由$S[0,1,2,3]$（"babg"）有两种构成方法。那么$T[0]$（"b"）可以由空字符+$S[4]$或者"b"不加，所以方法数为二者之和。即$dp[i][j]=dp[i-1][j-1]+dp[i][j-1]$
 		+ 否则，$dp[i][j]=dp[i][j-1]$。如蓝色单元格所示，因为"a"$!=$"b"，所以"ba"由"bab"构成的方式依旧等于由"ba"构成的方法数。
 4. 返回$dp[-1][-1]$
                                                                                                                                               
### 复杂度分析
 - 时间复杂度：$O(m*n)$，$m$为$T$的长度，$n$为$S$的长度。
 - 空间复杂度：$O(m*n)$

### Python
```python
class Solution:
    def numDistinct(self, s: str, t: str) -> int:
        len1=len(s)
        len2=len(t)
        dp=[[1]*(len1+1)]+[[0]*(len1+1) for _ in range(len2)]
        for i in range(1,len2+1):
            for j in range(1,len1+1):
                if(t[i-1]==s[j-1]):
                    dp[i][j]=dp[i-1][j-1]+dp[i][j-1]
                else:
                    dp[i][j]=dp[i][j-1]
        return dp[-1][-1]
```