### 思路
就是给定序列 $A$ 和 $B$，问 $B$ 在 $A$ 中出现多少次，可以不连续。相当于 $A$ 和 $B$ 的 $LCS$ 是B，但这的侧重点是 $B$。 从最后一步出发，就是 $B$ 的最后一个字符，设 $A$ 的长度为 $n$ ，$B$ 的长度为 $m$，有两种情况：
- $B[m-1] != A[n-1]$，也就是 $B$ 的最后一个和 $A$ 的最后一个不等，那 $A$ 的最后一个字符就废了，考虑 $A[0..n-2]$ 与 $B[0..m-1]$
- $B[m-1] = A[n-1]$，相等的情况，只需考虑 $A[0..n-2]$ 与 $B[0..m-2]$

**注意：问次数，就是考虑加法，无重复无遗漏**

### 转移方程
就是把我们上面两种情况加起来即可，$dp[i][j]$ 就代表 $A$ 的前 $i$ 个和 $B$ 的前 $j$ 个

$dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\  \&\& \ A[i-1]=B[i-1]$

### 初始条件
需要考虑空串的情况
- 若 $A$ 是空串，$B$ 不是空串，$B$ 在 $A$ 中出现次数为 $0$，$dp[0][j] = 0$
- 若 $B$ 是空串，$B$ 在 $A$ 中出现次数是 $1$（因为 $A$ 可以是空串），就是把 $A$ 中的字符都删掉dp[i][0] = 1

### 计算顺序
$f[0] [0], f[0] [1], …, f[0] [m]$
$f[1] [0], f[1] [1], …, f[1] [m]$
$……$
$f[n] [0], f[n] [1], …, f[n] [m]$


时间复杂度 $O(n*m)$，空间复杂度 $O(n*m)$，可以用滚动数组优化成 $O(n)$

### 代码

```java
class Solution {
    public int numDistinct(String S, String T) {
        int n = S.length();
        int m = T.length();
        int[][] dp = new int[n + 1][m + 1];
        
        //初始化，如果S是空串，但是T不是空串，那么出现次数为0
        for (int j = 0; j <= m; j++) {
            dp[0][j] = 0;
        }
        //初始化，如果S不是空串，但是T是空串，出现次数为1
        for (int i = 0; i <= n; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                //初始值就是不想等的情况
                dp[i][j] = dp[i - 1][j];
                if (S.charAt(i - 1) == T.charAt(j - 1)) {
                    dp[i][j] += dp[i - 1][j - 1];
                }
            }
        }
        return dp[n][m];
    }
}
```