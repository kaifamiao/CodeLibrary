题目要求**将数组中任何位置上的 1 组合到一起**，那么肯定需要知道数组中 1 的个数。组合到一起的长度就是 1 的个数。

假设数组中 1 的个数为 5，数组中某一段的数字为 `1 0 1 0 1`，那么只需要把里面的两个 0 交换出去就能得到最小交换次数。


#### 方法一：滑动窗口

**思路**

滑动窗口是数组/字符串问题中常用的抽象概念。 窗口通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即 $[i, j)$（左闭，右开）。而滑动窗口是可以将两个边界向某一方向“滑动”的窗口。例如，我们将 $[i, j)$ 向右滑动 $1$ 个元素，则它将变为 $[i+1, j+1)$（左闭，右开）。

假设这里的 1 有 $c$ 个，序列总长度为 $n$。我们可以枚举所有长度为 $c$ 的子串，把里面的 0 全部换成 1，所以我们要找到 0 最少的长度为 $c$ 的子串。如果用暴力的方法，时间代价是 $O(n \times c)$，这显然是会超时的。

我们可以用滑动窗口来优化这个过程——我们可以先计算出总的 1 的个数，再通过滑动窗口，使用 $O(1)$ 的复杂度计算出每个窗口 1 的个数。总的减去最多的个数，就是我们要求的结果。

**算法**

1. 计算原数组 `data` 中 1 的个数 `totalOne`。
2. 维护一个长度为 `totalOne` 的窗口，计算窗口中 1 的个数。先遍历求出第一个窗口 1 的个数，并保存好这个数字，记为 `countOne`。
3. 向右移动窗口，继续计算 1 的个数。假设当前下标为 `i`，那么需要加上当前的数字，再减去移出窗口的数字，移出窗口的下标为 `i - totalOne`。所以新的窗口 1 的个数为 `countOne += data[i] - data[i-totalOne]`。
4. 求 `countOne` 的最大值，和 `totalOne` 相减就是我们要求的结果。

**代码**

```Golang [ ]
func minSwaps(data []int) int {
    n := len(data)
    totalOne := 0
    for i := 0; i < n; i++ {
        totalOne += data[i]
    }
    countOne := 0
    for i := 0; i < totalOne; i++ {
        countOne += data[i]
    }
    max := countOne
    for i := totalOne; i < len(data); i++ {
        countOne += data[i] - data[i-totalOne]
        if max < countOne {
            max = countOne
        }
    }
    return totalOne - max
}
```

**复杂度分析**

- 时间复杂度：$O(n)$。$n$ 为数组 `data` 的长度。计算 1 的个数遍历一次 `data` 数组，复杂度为$O(n)$。使用滑动窗口计算子数组 1 的个数的复杂度为 $O(n)$。

- 空间复杂度：$O(1)$。没有使用额外的空间。