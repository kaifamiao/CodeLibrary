在一个回文串中，以中心为轴对称的那些位置上必须是互为相同的字符，即它们必须成对出现。若这个回文串长度为奇数，那么对称轴位置上的字符可以任意取，即允许出现落单的字符。由此，首先遍历 `s`，统计出来有多少个成对出现的（个数记为 `p`），以及有多少个落单的（个数记为 `s`）。

为了能够构造出来 `k` 个非空回文串，我们首先考虑如何把那些落单的字符使用掉，因为这些字符在每个回文串中最多只能用一次。这就意味着，如果 `s > k`，那么必然是无解的。

否则，我们不妨把这些落单的字符先分配到 `k` 个串里面的 `s` 个。这样一来，这 `s` 个串就非空了。剩下我们唯一需要担心的问题就是，那些成对出现的共计 `2 * p` 个字符够不够组成剩下的 `s - k` 个非空串。显然，只要 `2 * p >= s - k`，就有解——因为最短的非空回文串只要有1个字符即可，而成对出现的字符是可以拆开来用的。

参考代码：

```c++
bool canConstruct(string s, int k) {
    int pairs = 0;
    int single = 0;
    
    vector<bool> seen(26, false);
    for (char c : s) {
        if (seen[c - 'a']) {
            pairs++;
            seen[c - 'a'] = false;
        } else {
            seen[c - 'a'] = true;
        }
    }
    for (bool b : seen) {
        if (b) single++;
    }
    
    if (single > k) return false;
    return (2 * pairs >= k - single);
}
```