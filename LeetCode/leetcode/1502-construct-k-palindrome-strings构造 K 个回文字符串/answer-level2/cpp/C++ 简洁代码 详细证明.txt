```
    //首先统计字符串中每个字母有几个 设字母 a 有 c 个
    //若c是偶数，则该字母可以任意搭配(即每次拿两个在头尾夹着就可以是回文)
    //若c是奇数，则若想使用完这些字母，字母a至少要成为一个独立的回文串，因为总会多出来一个 其余的可以任意搭配
    //假设有odd个奇数个数的字母 字母总数为sum个, 则若想构成k个回文 必须要有 odd<=k  -----条件1
    //然后让剩余的 sum-odd 个字母(都是可以成对的) 去构成k-odd个回文串 则只要sum-odd >= k-odd就行了 ----条件2
    //                                                          条件2化简得 sum >= k
    //   条件2证明 假设 剩余的字母个数为2*n(因为都是成对的) 需要构成k个回文
    //            则一对一对的去分配回文时可以分配 1个回文(全部都在一起) 2个回文   ...   n个回文(每个是一对)
    //            把其中某个回文分开时 则表示为    2个回文               3个回文   ...   n+1个回文
    //            继续分                           3                    4          ...   n+2
    //            ....
    //            全部分完时                       n(每个都是一对)      n+1       ...   2*n个回文(独立)
    //            结论 对于2*n个字母时 它可以构成1~2*n个回文串 故而想构成k个回文时，只需要 sum >= k 即可
    //                                                          
    //同时满足以上两个条件即可
    int a[26];//统计每个字母的个数
    bool canConstruct(string s, int k) {
        int odd = 0;
        for(auto v : s) a[v-'a']++;
        for(int i = 0; i < 26; i++) if(a[i]&1) odd++;
        return odd<=k && s.size()>=k  ? true : false; 
    }
```
