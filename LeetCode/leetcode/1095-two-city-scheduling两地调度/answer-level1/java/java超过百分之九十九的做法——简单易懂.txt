思路：这个题第一反应是复杂，甚至都想到了动态规划（最近在学dp，看到啥都想到），后来要实现了才发现没有那么难。
其实可以这么想，一个人去a和去b两种选择。肯定是要去一个地方，主要区别就是钱的差值。
打个比方：a这个人去A100，去B110.然后b这个人去A10，去B50。
我们不用考虑100,110,10,50这四个数的比较，
只要知道a去A比B便宜10.而b去A比B便宜40。肯定是选择便宜的多的，也就是a去B，b去A。这个逻辑绕明白了就能明白这道题的做法了。
我不知道我表达清楚了没有，可能我说的比较乱，因为思路也是才理出来。但是方向应该是对的。每个人只要和自身比较就行了，不要和别人比较。目前的想法是都假设去A。然后再比较去B要便宜的钱数（如果本身B比A大这个钱数就是负数。）然后找出一般的人选择便宜的钱数最多的。
下面是代码的实现：
```
class Solution {
    public int twoCitySchedCost(int[][] costs) {
        int sum = 0;
        //去a和去b的差值不会大于999，所以数组长度2000是包含正负
        int[] ar = new int[2000];
        for(int [] i :costs ){
            sum += i[0];
            //这个i[1]-i[0]是说去b比去a贵的。如果是正数要减去
            ar[i[1]-i[0]+1000] ++; 
        }
        int index = 0;
        int i = 0;
        while(i<costs.length/2){
            while(ar[index]>0&&i<costs.length/2){
                sum += (index-1000);
                ar[index]--;
                i++;
            }
            index++;
        }
        return sum;        
    }
}
```
其实这道题我做出来以后觉得稍微有点难度，所以看了题解，什么贪心算法，哈希表什么的。。。我怕不是做了个假题？我怎么都没用到或者用到了我不知道？
这里说一下我的思路：刷了leetcode几百道题,一个基本的认识：哈希表很耗性能，所以我这里用的是数组下标代替数值，数组来表示map的方法来做的。因为两个数都是1到1000之间，所以差值不会小于-1000不会大于1000.所以这里用2000的数组来表示所有差值，每个差值加1000可以保证是非负的。
然后至于别的就是按照上面的思路来写的。
说个题外话，第一版本的代码有一个测试案例没通过，这个题的参数是数组型数组，java中创建只能一个个往里填，所以我没办法用debug调试知道到底哪里错了，所以很痛苦，眼睛看数组都花了也没看出错误，所以中间试图打算将数组换成队列来做这道题，就是之前刷算法用到的一个自带排序的queue。**PriorityBlockingQueue**。不过还好改动不小，并且在改动的时候灵机一动感觉找到了不正确的点，就是我第一版本的第二个while条件只判断了ar[index]的值，忘记了判断i的值。
其实这个讲出来是为了表述另一个观点：关于我这里用数组来实现排序，取小。其实我现在也觉得用**PriorityBlockingQueue**也可以实现，同样道理用别的也可能可以实现的。方法不是只有一种。
不过因为比较懒而且题都刷完了，所以我就不用别的方法实现了。
~~~~
如果稍微帮到你了记得点个喜欢~~~~