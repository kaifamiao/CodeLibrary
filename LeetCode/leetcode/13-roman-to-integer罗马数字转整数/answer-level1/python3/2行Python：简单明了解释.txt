# 罗马数字规律对应
# 个位:1:'I',4:'IV',5:'V',9:'IX'
# 十位:10:'X',40:'XL',50:'L',90:'XC'
# 百位:100:'C',400:'CD',500:'D',900:'CM'
# 千位:1000:'M'

主要问题是，有可能有两个的组合，如何处理？那么最简单就是两个两个遍历two_literal = s[i:i+2]
因为存在两个为一个的可能，并且一定是小的在大的前面，因此我们选择向后一次取两个然后查看字典中是否存在这两个值，不存在就说明大小组合，则取大的(two_literal[0])，否则就取两者得值。
但是取两者问题在于，大小组合，下次继续遍历上一次小的，因此会导致重复，也就是这次需要跳过，那么需要进行判断是否上次事两个取值？

以1994为例
MCMXCIV:
(1)MC:?,取M=1000
(2)CM:存在,取CM=900(注意3的舍取)
(3)MX:不存在,取M?不行，需要跳过
(4)XC:存在,取XC=90(注意4的舍取)
(5)CI:不存在,取C?不行，需要跳过
(6)IV:存在,取IV=4(注意7的舍取)
(7)V:存在,取V=5?不行，需要跳过

因此，在满足两个取值条件下，将小值作为下一次循环的跳过的条件，正确吗？
CMMX:CM;MM;MX:这不是会导致MX出错啊？不可能的，因为只有小大组合，不可能出现下下位仍然是大本身，CM<M,因此小大组合一定在单独大后面，即M..CM

```
class Solution:
	def romanToInt(self, s: str) -> int:
		d = {'I': 1, 'IV': 4, 'V': 5, 'IX': 9, 'X': 10, 'XL': 40, 'L': 50, 'XC': 90, 'C': 100, 'CD': 400, 'D': 500, 'CM': 900, 'M': 1000}
		isjump = theSum = 0  # 初始化是否跳跃条件和累积值
		for i in range(len(s)):
			if isjump == s[i]:
				# 如果本次循环等于上次大小组合的大则跳过
				continue
			two_literal = s[i:i+2]  # 取两值
			if two_literal in d:
				# 小大组合，并更新isjump为大值，避免下次重复
				theSum += d[two_literal]
				isjump = two_literal[-1]
			else:
				# 非小大组合一定是第一位大
				theSum += d[two_literal[0]]
		return theSum

print(romanToInt('MCMXCIV'))
print(romanToInt('LVIII'))
print(romanToInt('IX'))
```

对上面进行优化：
以上主要问题就是，额外考虑当用两个字去字典取值的时候下次是否该跳过的问题，既然是需要跳过，那么不跳过会怎么样？
一定会重复增加大的值，因此我们需要减去就行。
则对两个字(小大组合)进行修改，将其改为负值即可，比如果CM=900,下一次M=1000，那么就把CM=-100,下次再加上1000，不就是900吗？
同理其他的，最关键的是罗马数字由 1,4,5,9这些基本数字构成。分别在5,10这里特殊很多
# 个位:1:'I',-1(4):'IV',5:'V',-1(9):'IX'
# 十位:10:'X',-10(40):'XL',50:'L',-10(90):'XC'
# 百位:100:'C',-100(400):'CD',500:'D',-100(900):'CM'
# 千位:1000:'M'

究极压缩，这么聪明的你肯定看懂了
```
class Solution:
    def romanToInt(self, s: str) -> int:
        d = {'I': 1, 'IV': -1, 'V': 5, 'IX': -1,
             'X': 10, 'XL': -10, 'L': 50, 'XC': -10,
             'C': 100, 'CD': -100, 'D': 500, 'CM': -100,
             'M': 1000}
        return sum(d.get(s[i: i + 2], d[s[i]]) for i in range(len(s)))
```
