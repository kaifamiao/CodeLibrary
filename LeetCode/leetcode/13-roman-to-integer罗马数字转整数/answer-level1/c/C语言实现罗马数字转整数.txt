### 解题思路
  通过数组的下标索引来实现罗马数字符号与阿拉伯数字的一一对应。首先，定义两个数组，一个int型存储阿拉伯数字，一个char型存储罗马数字。两个数组的值都一一对应，这样方便后面查找后累加。然后定义两个变量，一个用来保存最后的整数，一个用来记录传入的字符串参数的字符个数。用while循环进行传入字符串的移位，用for循环找出传入的字符串的每一位与前面定义的char类型数组相同的字符，并且能找出char类型数组的下标，通过下标找出int型数组对应的数值，然后进行累加，然后跳出循环。最后返回累加后的值。
  这里处理罗马数字特殊情况的方法比较硬核，我是都罗列了出来。注意将特殊情况罗列出来后，移位时要移两位。
### 代码

```c
int romanToInt(char * s){
//两个数组罗马数字数值与阿拉伯数字数值一一对应
   	int arry[7] = { 1,5,10,50,100,500,1000 };
	char a[] = "IVXLCDM";
	int b=0;
	int n = 0;
	while( s[n]!= '\0') {
		for (int i = 0;i < 7;i++) {   //用for进行查找
			if (s[n] == a[i]) {
				if (s[n] == 'I'&&s[n+1] == 'V') {
					b = b + 4;
					n++;
					break;
				}
				if (s[n] == 'I'&&s[n+1] == 'X') {
					b = b + 9;
					n++;
					break;
				}
				if (s[n] == 'X'&&s[n + 1] == 'L') {
					b = b + 40;
					n++;
					break;
				}
				if (s[n] == 'X'&&s[n+ 1] == 'C') {
					b = b + 90;
					n++;
					break;
				}
				if (s[n] == 'C'&&s[n + 1] == 'D') {
					b = b + 400;
					n++;
					break;
				}
				if (s[n] == 'C'&&s[n+ 1] == 'M') {
					b = b + 900;
					n++;
					break;
				}
				b = b + arry[i];  //累加
				break;
			}
		}
	n++;
	}
	return b;
}
```