## 由高到底逐位转换

### 方案

由高到低位，逐位累加转换。

转换时由于每个罗马字符对应一个特定的数值，因此基本的操作累加即可，出现哪个字符，就累加对应的值即可。因此我们需要一个将字符和值映射起来的结构，例如 map。

```go
map[int32]int{
		'I': 1,
		'V': 5,
		'X': 10,
		'L': 50,
		'C': 100,
		'D': 500,
		'M': 1000,
	}
```

除了累加外，其实我们仅仅需要处理两种特殊情况，就是 4 或 9。例如：

- 4，9：IV, IX
- 40，90：XL, XC
- 400，900：CD, CM

观察可发现，这类特殊的值一个通用的情况是前面字符对应的值比后边的字符小，例如 I 比 V 和 X 小，X 比 L 和 C 小。因此，我们仅仅需要记住前面的字符，若发现比当前的小，则将对应的值减去即可，但要减去两倍。

该实现仅仅需要一轮遍历，在限行时间内即可完成，也就是 O(n) 的时间复杂度。

### Go 实现

LeetCode 上：

执行结果：通过

执行用时 :0 ms, 在所有 golang 提交中击败了100.00%的用户

内存消耗 :3 MB, 在所有 golang 提交中击败了53.24%的用户

```go
func romanToInt(s string) int {
	// 结果
	// 全部可能的字符对应的值
	r, vals := 0, map[int32]int{
		'I': 1,
		'V': 5,
		'X': 10,
		'L': 50,
		'C': 100,
		'D': 500,
		'M': 1000,
	}
	// 前一个字符，用于处理 4, 9 这样的情况
	prevC := 1000
	//遍历全部的字符
	for _, c := range s {
		// 将字符对应的值累加
		r += vals[c]
		// 若发现存在比上一个字符大的字符值，说明应该是 4 IV, 9IX 这类的（40XL, 90XC, 400CD, 500CM）
		// 将之前累加的结果减去即可，但是要减去2倍
		if vals[c] > prevC {
			r -= 2*prevC
		}
		//记录上一个字符
		prevC = vals[c]
	}
	return r
}
```

[红牛慕课更多编程题](http://www.hellokang.net/problem/)