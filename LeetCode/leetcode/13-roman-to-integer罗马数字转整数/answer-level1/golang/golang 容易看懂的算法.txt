执行用时 12 ms
内存消耗 5 MB

看了几个大佬写的，效率内存都是刚刚的，但是对新人来说可能不大容易看懂，所以把我自己的发上来供新人借鉴。
**强调一下我这个不是最优算法**

原理： 由于罗马数字的大数（高位）在前面，所以我们从前往后遍历字符串，如果在字典中查到关键词，那么就累加其对应的值。因为只用遍历一次，所以该算法复杂度是o(n)


``` golang
func romanToInt(s string) int {
    // 用字典保存关键词和数值的映射
    m := map[string]int{"M":1000, "CM":900, "D":500, "CD":400, "C":100, "XC": 90, "L":50, "XL":40, "X":10, "IX":9, "V":5, "IV":4, "I":1}
    // 字符指针
    i := 0
    n := len(s)
    // 返回的结果
    ret := 0
    // 当前关键字，写在循环外面是为了减少:=产生的cpu开销
    key := ""
    for {
        // 如果有两个以上的字符没有检测
        if i < n - 1 {
            // 那么先检测是否存在两个字符的key，从当前字符指针中截取2个字符
            key = string(s[i : i + 2])
            if _, ok := m[key];ok{
                // 如果在字典中找到两个字符对应的key，那么直接取值进行累加
                ret += m[key]
                // 移动指针到两个字符以后的位置
                i += 2
            } else {
                // 如果没有两个字符对应的key，说明当前字符必是M D C L X V I中的一个，那么直接取单字符key的值
                key = string(s[i])
                ret += m[key]
                // 移动指针第二个字符的位置
                i += 1
            }        
        // 如果只剩下一个字符没检测了，那么直接从字典里取值累加就行了
        } else if i == n - 1 {
            key = string(s[i])
            ret += m[key]
            i += 1
        // 字符串遍历完毕后跳出循环
        } else {
            break
        }
    }
    return ret
}
```

一些优化思路：
1. rune和string互转有相当大的损耗，把字典拆成单字和双字两个字典，这样遍历单字字典时就可以设定为map[rune]int提高性能
2. 因为双字检测失败后会导致第二个字符下次循环中再次检测，用动态规划思路应该可以规避重复检测提高性能
3. string(s[i : i + 2])存在性能和内存开销，可以考虑其他方法代替字符串截取