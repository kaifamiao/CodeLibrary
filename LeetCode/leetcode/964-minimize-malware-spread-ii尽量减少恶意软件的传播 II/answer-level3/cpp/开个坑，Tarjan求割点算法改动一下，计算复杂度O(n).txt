大学数据结构课上讲了这道题，虽然要求的是n^2的方法（读图就n^2了很无奈），但是其实计算答案线性复杂度的解法不难想。
当时写了一篇题解，在这里贴上，本人刚刚来力扣还不太习惯这种函数式提交，之后改下代码；若有大佬代码常数较小可以试一下。
（这题一看就知道和割点有关系的，可以先去了解一下tarjan求割点，这里不赘述）
题面解析
给定一张n个点的无向图，其中给出m个点被感染，选择一个被感染的点将之与之相连点所有边去除，问如何选择，使得最后和感染的点连通的点最少？

暴力方法
最简单直接的想法是，如果问删除哪个点使得答案最优，那么不妨枚举删除哪一个点。

于是，现在问题转变成了，已知某一个点被删除了，问被感染的点有多少？暴力的想法是，一个点如果被感染，那么那个点必定和某个被感染的点相连。所以，我们可以从每个点都开始深搜一遍，搜到感染点就退出。但是这样太慢了，复杂度大约为O(mn^2)。继而考虑到，只有被感染的点才能感染其他点，所以不妨从每一个被感染点开始遍历，每次碰到一个新的节点就加一个新的点，最终统计一下被感染点的个数，这样的复杂度是O(m*n)的，这也是这题的标准解法。此处不贴代码。

改进思路？

1. 割点和本题的联系

是否必然呢？

事实上，我们要割掉的点，并不一定是割点才有效。我们考虑以下一种情况：
![1.png](https://pic.leetcode-cn.com/43639d6d9d4636fe7cd7f402ef1bafac87995c7d0b7f388e3590b559574ed460-1.png)


非割点情况 截图

蓝色为感染点 白色为健康点

可以看出，割掉上图蓝点后，原先被感染的所有点都不会被感染了，但是蓝色的点不是一个割点。

因此，本题真正的关键点不在割点。上述情况可以通过分类讨论去特判，但是特判条件太复杂，代码不可打。但是割点算法确可以改编运用。

正确解法

一般来说割去感染点p后，如果p不是孤立的，必定剩下来n块，其中n>=1，如果p不是根，则有一块是父亲块。 我们考虑剩下来的每一块：
![2.png](https://pic.leetcode-cn.com/aa1a6ac7485803335fe076fb76f5cf613b21defe996b03e45151abc316b2dd95-2.png)

正解 截图

显然，这张图上的每一个点都能被p感染。

对于独立子块1:

这块里面有三个点，而且本身有一个点被感染了。割掉p以后，这三个点都会被这一块里面的原来那个蓝点感染。所以割不割p对独立子块1无效。

对于独立子块2:

这块里面只有两个点，而且本身没有蓝点。本来都会被p感染，割掉p以后，这两个点相当于被p救了。

从而归纳出以下结论：

设割掉p以后的独立子块含有k个点，fk个感染点，那么：

如果fk=0，k个点在割掉p以后免于受感染，被k拯救

如果fk>0，k个点在割掉p以后仍然要被块内的蓝点感染，割不割p与之无关。

因此我们得出解法：用Tarjan的算法主流程，在p点，计算出一个独立子块后，同时计算出独立子块的点数k和其内部的感染点fk，如果fk=0，那么save[p]+=k;否则不计算。之后统计一下每一个点的save值，最大的点就是我们的答案。

这里派生出两个问题：

怎么计算独立子块的k与fk？
割点算法是基于时间戳的，也就是每到一个新的点就会记录一下当前访问的点是第几个访问到的。
DFS有一个很好的性质。我们在DFS之前保存一下当前的时间戳tind=ind，dfs完以后，全局变量ind的值改变了。可以看出ind-tind=k。什么意思呢，我们dfs之前，已经一共访问了tind个点，dfs之后，我们一共访问了ind点，既然我们dfs了一棵独立子树，那么前后时间戳ind的差值就是这次dfs带来的增量。

简单说，进去前时间为a，出来后时间为b，那么这次dfs的耗时就是b-a，这个耗时是每访问了一个新的节点就加1的，所以b-a=k。

fk同理，不同的是，处理k的时候的时间戳是每访问了一个新的节点就自增的，处理fk的时候只有在访问感染点的时候才自增。

父亲块怎么处理？

这个问题是笔者一开始几次Wrong Answer的原因。父亲块的k和fk是不能简单从正面求出的。正难则反，采用补集思想，我们做完这一块一整块的dfs以后，也能得出这一整块的k和fk。用它减去p点和其所有子块的k和fk以后，剩下来的就是p的父亲块的k和fk。

处理完所有的k和fk以后计算save[p],找到最大的序号最小的就是答案。如果save都为0，输出-1。

这个算法的总复杂度就是遍历的复杂度o(n+e),e是边数。

贴一下完整代码（大学交oj作业用的，笔者暂时不知道力扣怎么用）
```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#define MAX_EDGE_NUM 1510
using namespace std;
int index1 = 0, index2 = 0, dfsTime[MAX_EDGE_NUM], lowestTime[MAX_EDGE_NUM], n, maxans = 0, maxid = -1, tmp, upIndex1, upIndex2, root;
int save[MAX_EDGE_NUM], father[MAX_EDGE_NUM], kid[MAX_EDGE_NUM], infectedKid[MAX_EDGE_NUM];
//dfsTime[i] i号点dfs的时间序号
//index1 计时器1 dfs每遇到一个新的点就+1
//index2 计时器2 dfs每遇到一个新的感染点才+1
//lowestTime[i] i号点沿dfs搜索树能够到的最早的点的dfs时间序号
//kid[i] i号点为根的搜索树里一共有多少个点
//infectedKid[i] i号点为根点搜索树里有多少个被感染点
//save[i] 割掉i号点以后可以拯救多少个节点 不算自己
//father[i] i号点的搜索树根
struct Edge
{
	int endPoint;
	int nextEdge;
};

struct Graph
{
	// 图的大小
	int edgeNum, verticeNum, infectNum;

	// 使用静态邻接表存储图。firstedge是每个点连接的第一条边。
	int firstEdge[MAX_EDGE_NUM];

	// 边数组
	Edge edges[MAX_EDGE_NUM * 200];

	// 感染信息
	int tag[MAX_EDGE_NUM];

	Graph()
	{
		edgeNum = 0;
		verticeNum = 0;
		memset(tag, 0, sizeof(tag));
	}

	/**
	 * @brief 增加一条边
	 * @param startPoint: 边的起点
	 * @param endPoint: 边的终点
	 */
	void addEdge(int from, int to)
	{
		edgeNum++;
		edges[edgeNum].endPoint = to;
		edges[edgeNum].nextEdge = firstEdge[from];
		firstEdge[from] = edgeNum;
	}

	/**
	 * @brief 输入图
	 */
	void input()
	{
		scanf("%d", &verticeNum);
		getchar();
		for (int i = 0; i < verticeNum; i++)
		{
			char inputStr[MAX_EDGE_NUM * 2];
			char *scanPos = inputStr;

			fgets(inputStr, MAX_EDGE_NUM * 2, stdin);
			for (int j = 0; j < verticeNum; j++)
			{
				if (*scanPos == '1' && i != j)
					addEdge(i, j);
				scanPos += 2;
			}
		} //输入
	}

	void input_infect(void)
	{
		scanf("%d", &infectNum);
		for (int i = 0; i < infectNum; i++)
		{
			int infectedPoint;
			scanf("%d", &infectedPoint);
			tag[infectedPoint] = 1;
		} //tag[i]=1 表示i号点感染
	}
} G;

void tarjan(int p, Graph &G)
{
	int v, tempIndex1, tempIndex2; //用来暂存
	father[p] = root;			   //记录根节点
	kid[p] = 1;
	infectedKid[p] = G.tag[p];
	dfsTime[p] = lowestTime[p] = ++index1;
	index2 += G.tag[p];
	for (int i = G.firstEdge[p]; i; i = G.edges[i].nextEdge)
	{
		v = G.edges[i].endPoint; //遍历p点连出去的边
		if (!dfsTime[v])
		{
			tempIndex1 = index1;
			tempIndex2 = index2;
			tarjan(v, G);
			if (lowestTime[v] < lowestTime[p])
				lowestTime[p] = lowestTime[v];
			if (lowestTime[v] >= dfsTime[p])
			{ //说明v在的这一块是独立的

				if (tempIndex2 == index2)
					save[p] += index1 - tempIndex1;
				//如果搜索完这一块以后没有增加被感染的点 那么这一块会被p拯救
				kid[p] += index1 - tempIndex1;
				infectedKid[p] += index2 - tempIndex2;
				//统计p点的两个kid数量 留待后面算父块
			}
		}
		else if (dfsTime[v] < lowestTime[p])
			lowestTime[p] = dfsTime[v];
	}
}
int main()
{
	G.input();
	G.input_infect();

	for (int i = 0; i < G.verticeNum; i++)
		if (!dfsTime[i])
		{
			root = i;
			upIndex1 = index1;
			upIndex2 = index2; //用于暂存 计算搜索树根节点的两个kid数量
			tarjan(i, G);
			kid[i] = index1 - upIndex1;
			infectedKid[i] = index2 - upIndex2;
		}
	for (int i = 0; i < G.verticeNum; i++)
	{
		if (infectedKid[father[i]] == infectedKid[i])
			save[i] += kid[father[i]] - kid[i]; //计算父块的拯救节点数
		if (G.tag[i] && save[i])
		{
			if (save[i] > maxans)
				maxans = save[i], maxid = i;
			else if (save[i] == maxans && i < maxid)
				maxid = i;
		} //更新答案
	}
	printf("%d\n", maxid);
	return 0;
}
```
