### 解题思路
参照题解dfs做的，写一下自己的理解
最重要的思路：找到只有被唯一一个感染源感染的个数最大的集群，删除这个感染源。因为被两个以上感染的集群，删除一个没用

1 用dfs将每一个初始感染源可以感染的节点都找到，假设找到是infect数组。
2 infect中每个被感染节点i记录下它被感染的感染源，因为可能有多个，所以用数组存储infectedBy[i]。
3 从infectedBy[i]的size为1的节点, size==1代表就是只被一个初始感染源感染。统计初始感染节点在这种情况下出现的次数contri。
4 遍历初始感染源的出现次数，最大且索引小的就是答案


### 代码

```cpp
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        vector<int> clean = vector<int>(graph.size(), 1);
        for (auto u : initial) {
            clean[u] = 0;
        }

        vector<vector<int>> infectedBy = vector<vector<int>>(graph.size(), vector<int>());
        for (auto u : initial) {
            set<int> infect;
            dfs(graph, u, clean, infect);
            for (auto i : infect) {
                infectedBy[i].emplace_back(u);
            }
        }

        map<int, int> contri;
        for (auto u : initial) {
            contri[u] = 0;
        }
        for (int i=0; i<graph.size(); i++) {
            if (infectedBy[i].size() == 1) {
                contri[infectedBy[i][0]]++;
            }
        }

        int count = -1, res = initial[0];
        for (auto u : initial) {
            int score = contri[u];
            if (score > count || (score == count && u < res)) {
                res = u;
                count = score;
            }
        }
        return res;
    }


    void dfs(vector<vector<int>>& graph, int u, vector<int> clean, set<int>& infected) {
        for (int i=0; i<graph.size(); i++) {
            if (graph[u][i] == 1 && clean[i] == 1 && infected.count(i) == 0) {
                infected.emplace(i);
                dfs(graph, i, clean, infected);
            }
        }
    }
};
```