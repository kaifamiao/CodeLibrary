![无标题.png](https://pic.leetcode-cn.com/993747a0100aceb8888e8284231db162f0fa05273bec8df275eb2aa9515f15b8-%E6%97%A0%E6%A0%87%E9%A2%98.png)


对于`initial`中的每个点，可以抽象为图中的几种情况（不是全部情况），具体来说，这样的点总是像图中一样的关键节点，删除它会导致整个集团变成新的几个集团，这样才有删除的必要，因为如果它连出去的某一个集团是纯净的，也就是说，它里面没有其他的病毒，那么删除中间的节点，就能拯救右上角的集团中的点。

具体到代码中来说，我们对每一个已经受感染的节点，对它的每一个相连的集团进行广度或者深度优先搜索，查看这个集团是不是纯净的，如果是就把它加到中间的点能够拯救的点去。在搜索的过程中如果遇到除中间点的其他病毒，表示这不是一个纯净的集团，`visited`数组表示一个节点是否已经访问过，如果只是单纯的设置为`true`或`false`，遇到左边的两种情况会出错，比如先访问了左上角的点，并将它设置为已访问，在遍历左下角的点时候遇到左上角的点不会进入访问，遍历结束，左下角的集团被认为是纯净的并加入到中间的点能拯救的点中去，但实际上左下角的点会被左上角的集团感染，具体做法是对每一个集合进行广度优先搜索的时候用不同的颜色进行标记，既不用每次初始化`visited`数组又解决了这个问题。

详细代码如下
```
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        vector<vector<int>>edge(n);
        sort(initial.begin(),initial.end());//这里先排个序因为要按索引最小返回，不排的话后面判断相等也可以
        for (int i = 0; i < n; i++)
            for (int j = 0; j < i; j++)//它是邻接矩阵储存的图，所以只用看一半（左下半部分或右上半部分都可以）
                if (graph[i][j])
                {
                    edge[i].push_back(j);
                    edge[j].push_back(i);
                }
        set<int>Infected={initial.begin(),initial.end()};//标记一下被感染的点
        int max_ = 0,ret = initial[0];//max_表示最多能拯救的点
        for (auto& it : initial)//对每个已经受感染的节点，对它的边连出去的集团进行广搜，检查这个集团是否纯净
        {
            vector<int>visited(n);
            int color = 1,total = 0;//记录删除这个点能拯救多少个点
            for (auto& point:edge[it])
            {
                color++;//每一条边用不同的颜色染色
                queue<int>que;
                que.push(point);
                int cnt = 0;
                for(;que.size();que.pop())
                {
                    auto top = que.front();
                    cnt++;
                    if (Infected.find(top) != Infected.end())
                    {
                        cnt = 0;//这个集团里面有其他的已经感染的点，那么即使删除一个也还是会被感染
                        break;
                    }
                    for (int i = 0; i < edge[top].size(); i++)
                        if (visited[edge[top][i]] != color&& edge[top][i]!=it)
                        {
                            visited[edge[top][i]] = color;
                            que.push(edge[top][i]);
                        }
                }
                total += cnt;
            }
            if (total > max_)
            {
                max_ = total;
                ret = it;
            }
        }
        return ret;
    }
};
```


