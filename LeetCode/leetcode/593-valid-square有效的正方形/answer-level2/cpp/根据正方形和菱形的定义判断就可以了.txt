题目要求判断正方形，由于给的点的顺序不确定，第一反应就是考虑哪个点位于哪个位置，这是常规的判断，也能做出来，复杂度也不高，但是代码量会很大，我们可以换个思路，不讨论点的位置，而是直接计算每两个点之间的距离，4个点中选2个，根据排列组合公式，情况总共有6种，那么这六种情况究竟是怎么样的呢？显然，不是边长就是对角线长，这是第一个已知条件。下面我们考虑怎么通过边长判断是不是正方形，显然正方形的边长是相等的，但是边长相等的还有菱形，它俩的区别在于对角线，对角线相等菱形就是正方形，那么我们就可以通过对角线是否相等来剔除菱形了，这是第二个条件。结合一、二条件，我们只要判断出来哪四个是边长、哪两个是对角线，就能判断是否是正方形了。正方形的对角线一定比边长长，
而菱形就比较特殊了，它较长的对角线一定比边长长，而另外一个较短的对角线，①有可能大于边长，②也有可能小于边长，③也有可能等于边长。我们来分别讨论：
  ①、该情况下，无论正方形还是菱形，六个距离中，两个对角线都是是最大的，因此直接排序，判断最后两个对角线是否相等、前四个边长是否相等即可。
  ②、该情况下，若是菱形，六个距离中，一个对角线最小，另外一个最大，排序后，一个位于最开始，一个位于结束部分，若是正方形，两个对角线均位于最后，因此排序后判断最后两个数是否相等，可以分辨出是不是正方形。
  ③、该情况下，若是菱形，六个距离中，有五个相等，另外一个是最长的对角线，若是正方形，仍然是两个对角线位于最后，因此排序后判断最后两个数是否相等，可以分辨出是不是正方形。
综上，无论哪种情况，只需要对六个距离进行排序，前四个相等、后两个相等，就可以断定其是正方形，当然要剔除边长为0的情况。代码将会非常简洁明了，计算距离时没有进行开方，为的是加快计算速度和防止开方后出现小数点影响判断。
```
double dis(vector<int>& p1, vector<int>& p2)
{
	return (p2[1] - p1[1])*(p2[1] - p1[1]) + (p2[0] - p1[0])*(p2[0] - p1[0]);
}
bool validSquare1(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4)
{
	vector<double>d;
	d.push_back(dis(p1, p2));			//相邻的和不相邻的均进行计算  相邻的是边，不相邻的是对角线
	d.push_back(dis(p2, p3));
	d.push_back(dis(p3, p4));
	d.push_back(dis(p4, p1));
	d.push_back(dis(p1, p3));
	d.push_back(dis(p2, p4));
	sort(d.begin(), d.end());
	if (d[0] == 0)
		return false;
	else if (d[0] == d[1] && d[1] == d[2] && d[2] == d[3] && d[4] == d[5])
		return true;
	return false;
}
```