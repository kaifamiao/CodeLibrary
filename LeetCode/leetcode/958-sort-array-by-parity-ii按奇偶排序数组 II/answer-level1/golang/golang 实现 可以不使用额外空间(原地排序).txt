### 本题思路：

    * 遍历整个切片，如果有以下情况：（原地排序）
        1. 某偶数位存了奇数；
            那么就向后找奇数位上存了偶数的，并且实现交换来有序。注意这里可能有同学会认为会越界，但是本题是答案一定存在，所以不可能存在越界情况
        2. 某奇数位存了偶数
            那么就向后找偶数位上存了奇数的，并且实现交换来有序。同上原理
        返回原切片。

        时间复杂度： O(n^2) ？不是很确定，最坏情况下，每次都走内循环，每次要走 n/2 ，应该消去系数，乘以外边循环的 n，是 n^2.
        空间复杂度： O(1) 无疑问，原地排序。


    * 两个辅助切片。
        遍历整个原切片，把奇数放到一个切片内，偶数放到另一个切片内。
        然后设置 index = 0; step=2; 遍历第一个偶数切片，放回原切片；
        设置 index = 1; step=2; 遍历奇数切片，放回原切片；
        返回原切片。

        时间复杂度： O(n)
        空间复杂度： O(n)

    

### 第一种办法的 运行结果：

    * 执行用时 :20 ms, 在所有 golang 提交中击败了100.00%的用户
    * 内存消耗 :6.3 MB, 在所有 golang 提交中击败了100.00%的用户


```
func sortArrayByParityII(A []int) []int {
    
    for i := 0; i < len(A)-1; i++ {
        if i & 1 == 1 && A[i] & 1 == 0 {
            j := i+1
            for A[j] & 1 == 0 && j < len(A) {
                j += 2
            }
            A[i], A[j] = A[j], A[i]

        } else if i & 1 == 0 && A[i] & 1 == 1 {
            j := i+1
            for A[j] & 1 == 1 && j < len(A) {
                j += 2
            }
            A[i], A[j] = A[j], A[i]
        }
    }
    return A
}
```
