### è§£é¢˜æ€è·¯
è¿™é“é¢˜ä¸€å¼€å§‹æˆ‘ä»¬å¯ä»¥ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³æƒ³è¿™é“é¢˜ï¼Œå‡å¦‚æˆ‘ä»¬è€ƒè™‘ç¬¬Nå¤©å–æ‰è‚¡ç¥¨ï¼Œåªæ˜¯è€ƒè™‘ï¼Œä½†æ‰‹é‡Œä¸ä¸€å®šæœ‰ï¼Œé‚£ä¹ˆåŠ¨æ€è½¬ç§»æ–¹ç¨‹å°±åº”è¯¥æ˜¯ f(n) = max(prices[n] - prices[n - 1] + f(n - 1), f(n - 1)),æ„æ€å°±æ˜¯è¯´å¦‚æœæˆ‘ç¬¬Nå¤©å–æ‰çš„è¯ï¼Œé‚£ä¹ˆæˆ‘éœ€è¦è®¡ç®—ç¬¬Nå¤©çš„æ”¶ç›Š+æ˜¨å¤©æœ€å¤§çš„æ”¶ç›Šï¼Œä¸ç¬¬Nå¤©æ‰‹é‡Œæ²¡æœ‰è‚¡ç¥¨å–æœ€å¤§å€¼ï¼Œé‚£ä¹ˆä»£ç å¦‚ä¸‹ï¼š

### ä»£ç 

```swift
class Solution {
    func maxProfit(_ prices: [Int]) -> Int {
         guard prices.count > 0 else {return 0}
        guard prices.count > 1 else {return 0}
        var dp = [Int](repeating: 0, count: prices.count)
        for i in 1 ..< prices.count {
            dp[i] = max(prices[i] - prices[i - 1] + dp[i - 1], dp[i - 1])
        }
        return dp[prices.count - 1]
    }
}
```
### è§£é¢˜æ€è·¯
ä½†æ˜¯æˆ‘ä»¬è§‚å¯Ÿè¿™ä¸ªè½¬ç§»æ–¹ç¨‹ï¼Œåªè¦ä¿è¯prices[n] - prices[n - 1] > 0 å°±æ˜¯f(N)æœ€å¤§çš„æ”¶ç›Šã€‚ä»£ç å˜ä¸ºï¼š
### ä»£ç 

```swift
class Solution {
    func maxProfit(_ prices: [Int]) -> Int {
        guard prices.count > 0 else {return 0}
        guard prices.count > 1 else {return 0}
        var preProfit = 0
        var maxP = 0
        for i in 1 ..< prices.count {
            maxP = max(prices[i] - prices[i - 1] + preProfit, preProfit)
            preProfit = maxP
        }
        return maxP
    }
}
```

### è§£é¢˜æ€è·¯
ç»§ç»­ä¼˜åŒ–
### ä»£ç 

```swift
class Solution {
    func maxProfit(_ prices: [Int]) -> Int {
        guard prices.count > 0 else {return 0}
        guard prices.count > 1 else {return 0}
        var maxP = 0
        for i in 1 ..< prices.count {
            var todayP = prices[i] - prices[i - 1]
            if todayP > 0 {
                maxP +=  todayP
            }
        }
        return maxP
    }
}
```
### è§£é¢˜æ€è·¯
è¿™æ ·å°±å˜æˆäº†è´ªå¿ƒç®—æ³•ï¼Œå“ˆå“ˆå“ˆå“ˆğŸ˜€
### 