### 解题思路
买股票的最佳时机2
可以多次买入卖出 但不能同时操作 也就是说卖出前先买入 买入后必须先卖出才能再次买入

    "****.****"
如果在某一天买入 然后在某一天卖出 必然当天不会再买入 不然是等价结果罢了 

所以同一天只有一次操作
连续的卖出和下一次买入之间至少是前后两天的关系
下面寻找这些若干的组合的 合最大利润

在一个非严格递增的数列中 同一天不能继卖出又买入 
最大利润==尾部减去头部
1 2 2 2 3 3 3 4    最大利润就是3
无论怎么买入卖出
尾-头>=允许同一天买入买出的合利润>=卖出卖出至少是前后两天关系的合利润
因为买入后再卖出 一般都会损失者两天差价的利润 除非两天差价0 非严格递增
就算是这样 那还是不会超过尾-头的差值 这是数列必定的约束

    "**** . ****"
若"."前是非严格递增数列 "."小于前值 
"."处有三种操作 买入 卖出 不管
卖出 必亏 因为 "."小于前值 必定不是在前值买入而是某个前前值买入 那前值卖出利润最大
买入 如果"."后存在比前值大 等于前值 小于前值大于"."都可以扩大利润（此处就不加证明了 很繁琐的情况讨论，但是想到非严格递增数列的你直觉一定会知道这是正确的）
不管 假设后续维持了非严格递增 找到了更大的 那最大利润仅仅是这个非严格递增的首尾差

这个证明太严格就会很繁琐
但是我笃定 这个非严格递增就是用来证明的工具 

### 代码

```python3
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if prices==[]:
            return 0
        in_value = prices[0]
        max_profit = 0
        for i in range(1,len(prices),1):
            if prices[i]>=prices[i-1]:
                if i ==(len(prices)-1):
                    max_profit += prices[i]-in_value
            else:
                max_profit += prices[i-1]-in_value
                in_value = prices[i]
        return max_profit
```