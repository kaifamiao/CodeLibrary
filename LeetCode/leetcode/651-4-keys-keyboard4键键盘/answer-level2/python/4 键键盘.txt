#### 方法框架

**解释**

要么按 'A'，要么按 'CTRL+A'，'CTRL+C' 或 'CTRL+V'。按键 `N` 次写出 `M` 个 `A`，只能有两种按键方式：

* 加法（按 `1` 次）：`M` 加 `1`。
* 乘法（按 `k+1` 次）：`M` 乘 `k`，其中 `k >= 2`。

在下面的方法中，使用这两种按键方式。


#### 方法一：动态规划【通过】

**思路和算法**

假设 `best[k]` 是按键 `k` 次得到 'A' 的最多数量。

假设 `k` 次按键后得到了最多数量的 'A'。如果它的最后一步使用加法，则 `best[k] = best[k-1] + 1`。

如果最后一步使用乘法，且乘 `x`，`x` 满足 `x < k-1`，则 `best[k-(x+1)] = best[k-(x+1)] * x`。

当 `j < k` 时，根据 `best[0], best[1], ..., best[k-1]` 找出计算出最大的 `best[k]`。

```python [solution1-Python]
class Solution(object):
    def maxA(self, N):
        best = [0, 1]
        for k in xrange(2, N+1):
            best.append(max(best[x] * (k-x-1) for x in xrange(k-1)))
            best[-1] = max(best[-1], best[-2] + 1) #addition
        return best[N]
```

```java [solution1-Java]
class Solution {
    public int maxA(int N) {
        int[] best = new int[N+1];
        for (int k = 1; k <= N; ++k) {
            best[k] = best[k-1] + 1;
            for (int x = 0; x < k-1; ++x)
                best[k] = Math.max(best[k], best[x] * (k-x-1));
        }
        return best[N];
    }
}
```

**复杂度分析**

* 时间复杂度：$O(N^2)$，两层嵌套的 for 循环，每层 for 循环的执行时间都为 $O(N)$。

* 空间复杂度：$O(N)$，`best` 数组的大小。

#### 方法二：优化的动态规划【通过】

**思路**

做 `2N` 次乘法，需要 `2N+1` 次操作。如果先乘 `N` 次，再对此时结果乘 `2`，则一共需要 `N+4` 次操作。当 `N >= 3` 时，第二种方式的操作步骤更少。

同样的，做 `2N+1` 次乘法，需要 `2N+2` 次操作。可以改为先乘 `N+1` 次，再对此时结果乘 `2`，则一共需要 `N+5` 次操作。当 `N>=3` 时，第二种方式的操作步骤更少。

结合以上情况，连乘不会超过 `5` 次。

**算法**

本方法与 *方法一* 相同，只是在内部循环中不考虑连乘次数大于 `5` 的情况。为简便起见，省略本方法代码。

**复杂度分析**

* 时间复杂度：$O(N)$。共两层循环，但内部循环时间为 $O(1)$。

* 空间复杂度：$O(N)$，数组 `best` 的大小。


#### 方法三：数学方法 【通过】

**解释**

在 *方法二* 中，连乘次数不超过 5。

当 `N` 任意大时，连乘 `k` 次是为了达到 $k^{\frac{N}{k+1}}$。函数 $k^{\frac{1}{k+1}}$ 在 $k = 2, 3, 4, 5$ 时，当 $k = 4$ 取得最大值。因此 `best[K]` 的最大值应该为 `best[K] = best[K-5] * 4`。

现在做一些推理。

* 做完乘法后不做加法：如果先做 `k` 次乘法再做 `c` 次加法，一定不如做 `k+c` 次乘法得到的 'A' 多。

* 'A' 的数量超过 5 时不做加法：如果先做 `1` 次加法再做 `k` 次乘法，'A' 的数量为 `(x+1) * k = xk + k`。如果直接做 `k+1` 次乘法，'A' 的数量为 `xk + x`。因为 `k <= 5`，所以只有当 `x <= 5` 时第一种做法才有可能得到更多 'A'。

* 连续做 2，3 或 5 次乘法的结果是有界的。
  * 做 2 遍 -- 连乘 2 次，可以改为直接连乘 4 次。这样需要的操作次数更少。（4^1 的操作次数是 5，2^2 的操作次数数 6）
  * 做 5 遍 -- 连乘 3 次，可以改为做 4 遍连乘 4 次。操作次数相同，但结果更大。（操作次数都是 20，但 4^4 > 3^5）
  * 做 5 遍 -- 连乘 5 次，可以改为做 6 遍连乘 4 次。操作次数相同，但结果更大。（操作次数都是 30，但 6^4 > 5^5）

综上所述，当 'A' 的数量不等于 4 时，最多可以连续做 5 次加法和 9 次乘法。

我们可以手动写出前 14 次操作的最大值：`1, 2, 3, 4, 5, 6, 9, 12, 16, 20, 27, 36, 48, 64, 81`。之后每次操作的最大值都通过做 4 次乘法得到，即 `best[K] = best[K-5] * 4`。

```python [solution2-Python]
class Solution(object):
    def maxA(self, N):
        best = [0, 1, 2, 3, 4, 5, 6, 9, 12,
                16, 20, 27, 36, 48, 64, 81]
        q = (N - 11) / 5 if N > 15 else 0
        return best[N - 5*q] * 4**q
```

```java [solution2-Java]
class Solution {
    public int maxA(int N) {
        int[] best = new int[]{0, 1, 2, 3, 4, 5, 6, 9, 12,
                               16, 20, 27, 36, 48, 64, 81};
        int q = N > 15 ? (N - 11) / 5 : 0;
        return best[N - 5*q] << 2 * q;
    }
}
```

**复杂度分析**

* 时间和空间复杂度：$O(1)$。