### 解题思路

#### 最后一步
从最后一步开始分析，第 N 次按键分别可以是key1, key2, key3, key4。如果按了 key1，它的总次数 = 「N - 1次按键的最大次数」，即发现了子问题。
比较麻烦的是 key2,key3,key4，来看下第 n 次的选择，以及可能的第 n - 1 次选择.

操作上: 
|第 n - 1 次 |  第 n 次 |
|---|---|
|key1, key2, key3, key4 | key1 可以接在任意按键后面 | 
|key1, key2, key3, key4 | key2 可以接在任意按键后面 | 
|key1, key2, key3, key4 | key3 可以接在任意按键后面 | 
|key1, key2, key3, key4 | key4 可以接在任意按键后面 | 

#### 消除状态

对于第 N 次按键，增加 A 会有两种方式：
    1. A(key1) 
    2. 复制(key4)。

1 不必多说，对于 2 我们需要知道 “第 N - 1 次缓冲区为 k 时，已经得到 A 的最大数量为 C”，那么第 N 次 A 个数 = C + k.
由此我们可以想到dp 状态转移方程: f[i][k] ，表示第 i 次按键缓冲区为 k 时，已经得到 A 的最大数量。

但这里有两个问题:
    1. key2 和 key3 决定了 k 的数值，我们还需要增加一个状态f[i][k][s]，表示已经选中了 s 个 A 么？
    2. k 的值会非常大，当做一个状态几乎是不可能的。

对于1，假如增加s后，状态方程是什么样子: f[i][k][s] 表示第 i 次按键缓冲区为 k ，选中 A 为 s 时，得到 A 的最大数量。

**尝试优化状态，减少状态**
直觉上，key2/key3/key4 要连着按，接下来证明下：
    假如 ...key2 + key1 + key3 + key4 ，那么一定可以换成 ...key1 + key2 + key3 + key4，并且局面更优，最后得到A数量更多
    假如 ...key2 + key3 + key1 + key4 ，那么一定可以换成 ...key1 + key2 + key3 + key4，并且局面更优，最后得到A数量更多

因为要求 N 次按键得到 A 的最大数量，所以我们可以把 key2/key3/key4 看成连着按。
这样的话，f[i][k][s] 里的 s，选中多少个A 就没有存在的必要了，因为选中后立刻放入缓冲区，即变为 f[i][k].

但还存在问题2，k 值非常大，该如何解决？
s 之所以存在，是因为放入缓冲区后，还可以 key4 + key1... + key4 这样的按。假如按完key3 后，立刻按key4 几次是最优情况，而不是夹杂 key1，我们就能消除 s 这个状态。

可以证明，假如 key4 得到至少一个key1，那么可以用连按 key4 替换 key1 key4 交替按，局面是更优的，至少不会更差。

所以 f[i][s] => f[i]: 表示前 i 次按键最大 A 的数量。

现在确定的只是从哪个点**开始**进行 **复制(key4)** 这个操作，可以从前面第三个点开始遍历，更新f[i]值（从3开始是因为前面有两次key2,key3）。

#### 状态转移方程

State: f[n] = max {f[n - 1] + 1, f[j-3] * (i - j + 2)}  j>=3 & j <=i 
init: f[0] = 0
answer: f[N]
顺序: 递增

    例如 A A A key2 key3 key4 key 4 , f[j-3] * (i - j + 2) 表示对前 3 个 A * 3


### 代码

```java
class Solution {
    public int maxA(int N) {
        int[] f = new int[N + 1];
        f[0] = 0;
        int i, j;
        
        for(i = 1; i <= N; i++) {
            f[i] = f[i - 1] + 1;
            for(j = 3; j <= i; j++) { // j 表示 copy 点
                f[i] = Math.max(f[i], f[j - 3] * (i - j + 2));
            }
        }
        
        return f[N];
    }
}
```