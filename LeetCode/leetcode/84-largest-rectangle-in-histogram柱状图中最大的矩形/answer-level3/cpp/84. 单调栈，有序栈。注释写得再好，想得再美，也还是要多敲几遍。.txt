### 解题思路
解题思路不写了，想的太美反而会导致写不出代码来。


记录几个代码细节，可能会在别的单调栈题目中用到：
- 在出栈的时候（出栈之后）计算一个结果。
- 想让所有的数据都入栈再出栈。
- 外循环入栈，内循环出栈，各司其职。
- 出栈的原因是由于某一次我想入栈
- 结尾添加一个元素，使得当我想将这个元素入栈的时候，会导致全部出栈
- 入栈的不是元素本身，而是元素的引用，本题是下标
- 给栈初始化一个-1，使得第一个元素的入栈，和其他元素的入栈没什么区别，我们可以想象heights前面还有一个巨tm小的元素。那么第一个元素放进去也还是满足单调增的。左边界计算还是一致的。
- 不能用栈顶元素本身的下标来计算宽度，而必须要用左边界，因为中间可能出现过更大的数，被pop出去了，更小的数肯定没有，有的话能看到。pop的顺序是从大到小pop的，我这个大的还没pop，你小的等一会。
- 这么多细节，你让我怎么想明白。我放弃了。考到原题我就写，让我举一反三，就这形势只能看运气。
### 代码

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        if(heights.size() == 0) return 0;
        stack<int> st;
        st.push(-1);// 给一个原始左边界。
        heights.push_back(-1); // 确保所有柱子的序号都能够出栈，因为-1总会比任何柱子矮，尝试入栈的时候，会导致所有的柱子都出栈。
        int res = 0;
        for(int i=0; i<heights.size(); i++){// 尝试将所有的柱子入栈。最后-1入栈的时候，一定会导致所有的柱子出栈
            int topIndex = st.top();
            // 想出栈，因为外循环是入栈，内循环就出栈，把入栈的工作交给外循环。
            while(topIndex!=-1 && heights[i]<heights[topIndex]){
                int h = heights[topIndex];
                st.pop();//出栈
                int left = st.top();
                int area = h * (i - left - 1);
                res = max(res , area);
                topIndex = left;// 更新topIndex，观察是否需要继续出栈
            }
            // 尝试出栈完成，不管实际是否出栈，最终我都会将我希望入栈的下标给她入栈
            st.push(i); // 如果这次入栈的是-1，那么就是最后一个元素了，i++之后，循环也就结束了。
        }
        return res;
    }
};
```