这个题意最开始理解起来有点困难，以为是要匹配数字的数值大小，比如1-1,2-11,3-21,4-1211，但是到5的时候就发现完全不是5的总和，然后就想，那肯定是看个数，想到用字典保存key-value，但是依然到5的时候发现跟以为的3112不一样，发现是只要数值变化，个数就变化，只记录相同数字的个数，并且是记录上一次报数结果的新个数
如n=4时，为1211
n=5时，'1211'发现为1个1,1个2,2个1，所以报数结果为'111221'
同理，当n=6时，上一次结果为'111221'，是3个1,2个2,1个1，那么报数结果为'312211'
以此类推

那么可以用循环的方式解决，遍历上一次报数字符串，然后累加相同数字的count，一旦发现不相同，那么更新报数字符串，当n改变时，报数字符串需要置为空，并且每一次更新都要保存上一次的报数字符串


```
class Solution:
    def countAndSay(self, n: int) -> str:

        if n == 1:
            return '1'
        if n == 2:
            return '11'

        # 记录上一次的报数字符串
        pre = '11'

        # 从n=3开始遍历每一层的报数
        for i in range(3, n + 1):
            # 每一次的报数都要将结果先置为空
            res = ''
            # count初始化为1
            count = 1
            for j in range(1, len(pre)):
                # 只要元素连续相同，count++
                if pre[j] == pre[j - 1]:
                    count += 1
                else:
                    '''一旦不相同，就更新报数字符串，保存当前部分结果，并且count需要置为1'''
                    res += str(count) + pre[j - 1]
                    count = 1
            '''将末尾的元素添加到报数字符串的结果中'''
            res += str(count) + pre[-1]
            # 每一次都保存上次的报数字符串结果
            pre = res

        return res

```
