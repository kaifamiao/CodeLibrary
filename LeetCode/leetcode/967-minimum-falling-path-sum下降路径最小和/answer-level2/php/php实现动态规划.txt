解题思路：
1. 动态规划
- 到达当前坐标的长度设为f(x,y)，当前坐标的值为a[x,y]，则f(x,y) = min(f(x-1,y-1), f(x-1,y), f(x-1,y+1)) + a[x,y];
- 那么子问题就是「查找上一步坐标的最小长度」
2. 规则：
-  上一步的可能方向为：左前方：(x-1,y-1)、前方：(x-1,y)、右前方(x-1,y+1)；
-  若x=0，从第一行进来，到达当前坐标的最短长度必定是当前坐标的值，即，f(x,y)=a[x,y];
-  若y=0,第一列，则只能从前方或右前方过来，f(x,y) = min(f(x-1,y), f(x-1,y+1)) + a[x,y];
-  若y=(总行数-1),最后一列，则只能从左前方或前方进来，f(x,y) = min(f(x-1,y-1), f(x-1,y)) + a[x,y];
-  若y为其他情况，则处于中间列，则 f(x,y) = min(f(x-1,y-1), f(x-1,y), f(x-1,y+1)) + a[x,y];
3. 实现
- 计算到达每个坐标点的最短长度；
- 计算最后一行数组的最短长度，即为所求；

但是PHP可以直接用isset()判断数组键值对是否存在，可以省掉对坐标位置的判断，当然你也可以用坐标位置判断来实现；
```
function minFallingPathSum($A) {
        $col_len = count($A[0]);
        $row_len = count($A);
        $dp[] = [];
        for($i=0; $i<$row_len; $i++) {
            for($j=0; $j<$col_len; $j++) {
                if($i==0) { # 首行，入口
                    $dp[$i][$j] = $A[$i][$j];
                } else {
                    $pre_arr = [$dp[$i-1][$j]];
                    if(isset($dp[$i-1][$j-1])) { # 不是首列
                        $pre_arr[] = $dp[$i-1][$j-1];
                    }
                    if(isset($dp[$i-1][$j+1])) {
                        $pre_arr[] = $dp[$i-1][$j+1];
                    }
                    $dp[$i][$j] = min($pre_arr) + $A[$i][$j];
                }
            }
        }
        
        return min($dp[$row_len-1]);
    }
```
