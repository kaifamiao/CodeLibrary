### 解题思路
    这个解法是由jack这名用户上传，巧妙的使用了哈希表来缩短执行时间，非常值得学习，但是原作者并没有将原理和亮点讲的很清楚，所以我重新将它梳理了一遍发了出来。

思路：
    这个解法是以常规的滑动思想为基础，字符串左右各一个指针（left和right），左边的指针标记的是最近的重复字符（初始值为0.表示暂无重复字符），然后right指针进行遍历，若遍历字符与目前两指针中间的字符串重复，则将left指针移向该字符，right指针继续向前遍历，知道遍历结束为止，其中没遍历一个字符，都进行一次目前字符串长度与最长字符串长度的比较。
    然后根据字符是由ASCII码表示的特点，创建一个256个元素的数组，作为哈希表，用于储存每一个字符最近出现位置，若未出现过，则为0，若出现了，则将其位置信息存入（即right的值），若第二次出现，则通过找到对应ASCII码值，就可知该字符最近一次出现位置，从而完成left指针的移动。

### 代码

```c
int lengthOfLongestSubstring(char * s){
    //用于储存目前最长字串
    int prior = 0;
    //用于定位目前不重复字符串的起始字符左边一个字符（即最近一个出现重复的字符）
    int left = 0;
    //用数组构建一个哈希表，存储该字符最近出现位置，若为0，则表示没有出现过，并且为256而不为128是因为此处是ASCII扩展字符集
    int dict[256] = {0};
    //目前所遍历的字符串的位置
    int right = 1;
    //存储目前字符的ASCII值
    int i;

    while (* s != '\0')
    {
        //获得目前字符的ASCII值
        i = * s - 0;

        //判断目前所遍历字符是否出现过
        if (dict[i] > left)
            //若出现过，则将目前不重复字符串起始位置之前的一位定位到该字符
            left = dict[i];

        //不论是否出现过，都更新该字母对应哈希表的值
        dict[i] = right;

        //判断目前不重复字符串长度是否比出现过的最长不重复字符串长
        prior = (prior>right-left)? prior : right-left;

        //将指针指向下一个字符
        s++;

        //更新为接下来要遍历的字符的位置
        right++;
    }

    return prior;
}
```