解题思路：

其实问题可以认为是有一个盒子队列，每个盒子装有一个小球，每个小球上都有一个字符。我们需要依次去拿出来，然后计算字符连续不重复的小球的最大个数。

我们能做的就是取球，取到了以后，记录这个球的次序（索引），比如这个球上的字符是a（A球），那么我们就在A球上写上这个球的次序，记录为1。然后我们再取，假如取到B球，由于B球我们还没取到，说明没有重复，此时B球上我们记录为2，第三个球为C（3）。如果我们取完所有的球，都没有，那么不重复就等于球的总数。

但是如果我们取到第4个球，这个球是a球，哈，就和我们第一次取的球相同了，我们该怎么处理呢。首先我们记录下当前所得到的的最大不重复球的个数是3。然后需要继续往后找，在找之前，由于有重复的球，那么我们就需要把原来的A球踢掉（将A球的索引改成4），同时，我们修改不重复的起始位置为原来A球的后一个位置（2）。然后继续往后找。。。

但是如果我们取到的第4个球，是C球，那么我们记录下最大的不重复球个数为3，然后更新起始位置为4。但是下一个球为b，那我们已经有了B球（2），但是由于我们的起始位置已经修改为4，则说明之前的B球已经不属于我们的计算范围，不属于重复球，因为我们只是更新B球的次数为为5。（也就是说，我们的比较，必须是在我们起始位置之后的，这才是有效的计算，之前的已经计算完成了，这是个滑窗的概念？）。

通过这样，我们记录每次获取到最大不重复的球的个数，并比较每次获取到的和前一次获取到的最大值进行比较，不断滚动更新最大值。

而实现我们快速去更新球的次序，我们就需要用一个专门的盒子来存储了。所以我们就建立一个数组，球上各个字符的值作为索引，初始值都为-1。每获取到一个球，对应数值设置为对应的索引。具体解法如下：

int lengthOfLongestSubstring(char * s){
    int len = strlen(s);
    int start = 0;
    int max = 0;
    int array[128];
    int temp;
    memset(array, -1, sizeof(array));
    
    for (int i = 0; i < len; i++) {
        temp = s[i];
        if (array[temp] == -1) {
            array[temp] = i;
        } else if (array[temp] < start) {
            array[temp] = i;
        } else {
            if (i - start > max) {
                max = i - start;
            }
            start = array[temp] + 1;
            array[temp] = i;
        }
    }

    if (max == 0) {
        max = len;
    } else {
        if (max < (len - start)) {
            max = len - start;
        }
    }

    return max;
}