我的想法是，设定一个窗口，维持当前未出现重复的字符串
1、每增加一个字符时，与窗口中的字符判断。
2、若都不重复，则将当前字符加入窗口中，比较最大长度。
3、若重复，比较最大长度，并将窗口前端放到重复字符的下一位。
即每增加一个字符时必定会比较一次最大长度，保证不会遗漏。
遍历一遍字符串就能得出结果，但由于要循环比较，时间复杂度稍大，应该比O(n)大，比O(n^2)小。
提交了四遍并修改，最终提交成功。执行用时:8 ms, 在所有 C 提交中击败了70.20%的用户。内存消耗 :7.1 MB, 在所有 C 提交中击败了68.80%的用户。自己想出来的代码，还是比较满意的吧。


```
int lengthOfLongestSubstring(char * s){
    if(s[0] == '\0')
    return 0;
    if(s[1] == '\0')
    return 1;
    int max=0, i=0, j;//i为滑动窗口前端，j为后端
    bool flag;//用来判断当前字符是否在窗口内
    for(j=1; s[j]!='\0'; j++){
        flag = false; //每增加一个字符时都假设为“不在”
        for(int k=i; k<j; k++){ //判断新的字符在不在已有窗口内
            if(s[k] == s[j]){ //如果在的话
                max = max>(j-i) ? max:(j-i); //比较当前最大长度
                i = k+1; //将i放到窗口内的重复字符的下一位
                flag = true; //标记存在
                break;
            }
        }
        if(!flag){ //如果当前字符不在已有窗口内，修改最长长度
            max = max>(j-i+1) ? max:(j-i+1);
        }
    }
    return max;
}
```
