### 解题思路
总体思路是空间换时间。定义左右指针来控制。右指针一直往前走，左指针只在字符出现重复时跳转。

（1）因为有128个字符，所以开辟一个tag[128]的数组，用来标记字符是否出现过。
     为了加快检索速度，我决定采用字符对应的ASCII码做数组下标。
     比如，a的ASCII码是97，那么就把tag[97]进行标记。
（2）原本我的想法是出现标记1，但是后来我发现一个问题，请看（3）。
（3）就是字符出现重复后，left指针跳转的位置很难确定。
     因为left指针必须要跳到该重复字符前一次出现的下一个位置。
     那么就必须再次从头遍历，找到前一次出现的位置，效率显然太低了！！！
     既然我们需要知道位置，那我们就把位置记录下来。
     操作很简单，只需要当前字符位置+1就行了。
（4）那么记录下来的位置信息保存在哪里呢？还要再开个数组吗？不不不！
     我们tag[]数组的作用是标记，既然是标记，里面填1和填5，没有任何区别。
     既然如此我们就填位置信息就好了，反正只要tag[]数组里的值不是0，就代表字符出现过。
（5）碰到重复字符时，就去tag[]数组取左指针的跳转位置就好了，由于数组下标是ASCII码，
     所以，瞬间就可以找到。
（6）另外，需要注意一点，左指针不能回退，左指针是指向重复字符的下一个位置的，如果
      它回退了，一定是重复的。所以，取出位置后要判断，只有比当前left大，才要跳转。
      举个例子就懂了。比如 abdfehhsdubw 这个字符串。在6位置h重复时，left会跳到前一个h
      的下一个位置，就是6。然后right继续往前走，碰到了d，d出现过，而前一个d的位置是2，
     如果跳转，left会跳到3，此时重复的h就又被包进去！所以，left不能后退。


### 代码

```c
//  有必要说明，该程序只会找到第一个满足条件的子串输出。
//  假如字符串中存在两个长度相等的最长不重复子串，该程序输出前一个

int lengthOfLongestSubstring(char * s)
{
    int tag[128] = {0};     //开辟一个数组，用来标记字符是否出现过
    int tag_index = 0;         
    int max = 0, sublen = 0;   

    for (int left = 0, right = 0; s[right] != '\0'; right++)
    { 
        tag_index = (int) (s[right]);    //用对应字符ASCII码做标记数组的下标
        if (tag[tag_index] > left)     //这个判断是为了保证left指针不能回退，
        {                              //同时，如果tag数组值大于left，也说明字符出现过了
            left = tag[tag_index];
        }
        tag[tag_index] = right + 1; 
        
        sublen = right - left + 1;
        if (max < sublen)
        {
            max = sublen;
//            start = left;         //这两句是用来记录最终结果的子串起始位置和结束位置
//            end = right;
        }
    }
    return max;
}
```