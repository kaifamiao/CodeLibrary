# 题目描述
给定一个字符串，请你找出其中不含有重复字符的**最长子串**的长度。

**示例 1:**

```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```
这里说明一下这道题的解题思路。
实际上，这道题的答案很明显——如果我们设置两个指针，一个指向当前的字符串的头部，即`front`，另一个指向下一个要判断的位置，即`rear`，则每次进行判断的时候，从`front`到`rear - 1`进行遍历即可。
1. 如果有相等的，则说明该字符串不合法，则执行`front += 1`,接着判断；
2. 否则的话，执行`rear += 1`，然后接着进行判断。

但是，实际上，这种的算法的复杂度过高，那么我们可以进行一定的优化——用空间换取时间。我们可以使用标识符`char status[256]`来判断某个字符是否已经在该字符串中，如果对应的标志为0，则表明没有相等的，则执行第二种情况即可；如果标志为1，则表明有，则执行第一种情况即可。

在此基础上，我们可以进行进一步的优化——实际上，根据要求，我们要找的是最长的字串，而非子序列。那么如果有相等的话，实际上从`front`到字符串中相等的字符的下标这些都在没有必要进行判断了，因为以其作为`front`的字符串的最大无重复长度必定小于一开始的待判断的字符串，因此直接跳过就可以了。

下面是整体代码。
```
int lengthOfLongestSubstring(char * s){
    char status[128] = {0}, *front = s, *rear = s;
    int max_length = 0, length = 0;

    while(*rear){
        if(!status[*rear]){
            status[*rear] = 1;
            length++;
        }else{
            max_length = max_length > length ? max_length : length;
            while(*front != *rear){
                status[*(front++)] = 0;
                length--;
            }
            front++;
        }
        rear++;
    }
    max_length = max_length > length ? max_length : length;
    return max_length;
}
```
