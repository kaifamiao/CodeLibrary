思路：在读取新字符时，需要判断新字符是否在已有的子序列中出现过。不管该新字符是否出现过，其都是要添加到子序列中的，而区别就在于，如果之前出现过的话，子序列的开始值要更新，否则不需要。

判断新字符是否出现过（且知道其出现的位置），很明显用哈希的思想。那么，map，set，数组，都可以使用。显然，数组是最快的了。

```
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int ans(0);
        int lookup[128] = {0};
        for (int i=1,j=1;j<=s.size();j++){//i表示子序列的起始索引，j表示当前（末尾）索引
            int hashIdx = int(s[j-1]);
            if(lookup[hashIdx]>=i)//如果新字符在当前子序列中出现过
                i = lookup[hashIdx] + 1;//更新子序列的开始值
            lookup[hashIdx] = j;
            ans = max(ans,j-i+1);
        }
        return ans;
    }
};
```
用数组做哈希表，速度和内存直接起飞，分别为98.81%和100%
但是由于初始化128维数组全为-1很麻烦，故把它们初始化为0，此时只需要简单改一下字符串索引就行了，即认为字符串索引是从1开始的。

最开始的时候犯了一个非常愚蠢的错误，测试样例的输出结果一会正确，一会是个几十万的巨大的数。查了半天，发现是因为ans没有初始化。。。

我觉得比较难想到的一点是，需要有一个变量来记录子序列的开始值。能想到这一点，问题其实就迎刃而解了。

我在思考一个问题，如何在开始写算法之前，就能把算法中需要用到的变量都想出来呢？害，这好像是个鸡生蛋蛋生鸡的问题。