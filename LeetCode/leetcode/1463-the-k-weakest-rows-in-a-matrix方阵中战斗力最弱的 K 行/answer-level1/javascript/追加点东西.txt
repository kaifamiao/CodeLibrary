### 解题思路

注意:
    如果第 i 行的军人数量少于第 j 行，

    或者 两行军人数量相同但 i 小于 j，那么我们认为第 i 行的战斗力比第 j 行弱

   也就是说 如果两行的军人数量相同, 行数大的那个就大

``` js
// 例如 mat =
            [[1,1,0,0,0],
            [1,1,1,1,0],
            [1,0,0,0,0],
            [1,1,0,0,0],
            [1,1,1,1,1]],
            k = 3
// 循环 mat 把每项累加 后 再加上 索引 * 0.001 , 题目限制了2 <= n, m <= 100

 list = ["20.000","40.001","10.002","20.003","50.004"]

// 再循环 list 把 其的每项 和索引 放到一个新数组

arr = [[0,"20.000"],[1,"40.001"],[2,"10.002"],[3,"20.003"],[4,"50.004"]]

// 再用 sort 拿后面的元素 排序 再取其前面的元素 生成个新数组

arr = [2, 0, 3, 1, 4]

// 再按k 来截取

arr = [2, 0, 3]
```

### 代码

```javascript
/**
 * @param {number[][]} mat
 * @param {number} k
 * @return {number[]}
 */
  var kWeakestRows = function(mat, k) {
    let list = mat.map((t,i) => t.reduce((t,a) => t + a) + (i * 0.001))
    let arr = []
    list.forEach((t,i) =>{
      arr.push([i,t])
    })
    return arr.sort((a,b) => a[1] - b[1]).map(t => t[0]).slice(0,k)
};
```