![image.png](https://pic.leetcode-cn.com/a7b9b25acde9da598211e62899aeee7a85d6f9aac80d87ab1f2bd92aef42ea80-image.png)

1、直接法
·思路：首先通过n = (n / 5) * 5找到离n最近的一个5的倍数，之后该数n循环除以5得到其因子之中有多少个5，为5的因子个数直接加到最终结果上，之后n -= 5，类似上面的过程……以此类推，最终直到n==0为止，此时的结果就是所求。
·复杂度分析：这个过程对每一个5的倍数都要进行n/5次运算，一共要对n/5个数进行这种运算，因此一共要进行n^2/25次运算 时间复杂度O(n^2)显然题目要求时间复杂度O(logn) 

```
int trailingZeroes(int n){
    int numoffive = 0,temp;
    for(n = (n / 5) * 5;n > 0;n -= 5){
        temp = n;
        while(temp % 5 == 0){
            temp /= 5;
            numoffive++;
        }
    }
    return numoffive;
}
```
运行结果：在计算大数字时超出时间限制

2、筛选法
·思路：我们注意到1 * 2 * 3 * … * k * … * n之中的数k只要是5的倍数就会为结尾贡献一个0，同时如果k又是25的倍数会为结尾再多贡献一个0(25 = 5^2 此时因子中有2个5，相当于为结尾贡献2个0)，同时如果k同时又是125的倍数又会在25的倍数基础上再多为结尾贡献一个0(125 = 5^3)，以此类推同时n！中有n/5个5的倍数，有n/25个25的倍数，有n/125个125的倍数……，被除数为5的次方数并且幂次一直增大直到此次方数>n为止，将前面的n/5+n/25+n/125+……全部相加就是所求结果
·复杂度分析：算法只会在5^1、5^2、5^3、……这些5的次方数处做运算，直到5^(k+1) >= n为止，此时运算次数k <= log(5)(n)，因此此算法的时间复杂度为O(logn)

```
int trailingZeroes(int n){
    int numoffive = 0;
    long temp;
    for(temp = 5;temp <= n;temp*=5) numoffive += n/temp;
    return numoffive;
}
```
运行结果 0ms 100% 5.1MB 100%
