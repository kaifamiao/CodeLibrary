若要结尾产生0，则需要2*5，4*5，6*5，8*5…………，都是一个偶数乘以一个5或者5的倍数，且因为5和5的倍数要少于偶数，所以5为主要的限制因素，接下来主要考虑5的因素。
直接用n除以5，可以得出大概的数目，但是如果有25=5*5，125=5*5*5，725 = 5*5*5*5等这种，一个数相当于含有1个5，2个5，3个5…………，所以要再加上取。我用递归解决：
class Solution {
    public int trailingZeroes(int n) {
        if (n < 5) return 0;
        else return (n/5) + trailingZeroes(n/5);
    }
}
这个方法也有一个bug，就是n很大的情况下，一个数可能等于很多个5相乘，当5过多并且用完前面剩余的偶数时，偶数就成了主要限制因素。但是考虑到这样的数会很大，可能超出int的范围，所以就懒得想了。