1. 看到题目后的第一个想法，咦，好像数据结构学过有关于链表的基本操作，那我这个菜鸡来试试看。
3. 看着测试用例里面6的位置太孤单，那来试试前66，中66，后66该咋办
4. 准备遍历链表并查看值，找到跟val相同的我就不要叻，
                 1. 前面为66的话，我就要筛选了，直到找到第一个不是6的
                 2. 中间是6的话，好办，next直接略过6，直指下一个
                 3.  后面是6的话，咦，有点难办，因为这里运行出错总是提示有空指针的使用，原来我没有
5. 行，我自己填的测试用例都通过了，我要提交了
6. 咦，有错诶，说是输入[] 1，有空指针
7. 行，我改，原来一开始没有判断传过来的链表到底怎么样，以为是个正经链表，啧啧，好，我再次提交
8.  咦，还有错诶，说是输入[1] 1，有空指针
9. 行，我接着改，原来我没有判断p->next会不为NULL，以为是个正经节点，啧啧，好，我再次次提交
10. OK，执行用时 :20 ms， 在所有 C 提交中击败了71.22%的用户 内存消耗 :9 MB, 在所有 C 提交中击败了100.00%的用户

下为代码

```
struct ListNode* removeElements(struct ListNode* head, int val){
    struct ListNode* p = head;
    if(p){
         //val在头部
        while (p->val == val){
            if(p->next==NULL){
                return NULL;
            }
            p = p->next;
        }
        head = p;
        //val在中间和尾部
        while(p!=NULL){
            if(p->val == val){
                p = head;
            }
            if(p->next!=NULL&&p->next->val == val){
                p->next = p->next->next;
            }
            p = p->next;
        }
    }
        return head;
}

```
有些疑问请高手解答：
1. 那些和val相等的节点要释放吗？会造成内存泄露吗？

总结：
1. 注意NULL的判断，每一步不能理所当然
2. 以后要走一步看几步才行