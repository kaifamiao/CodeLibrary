## è§£æ³•ä¸€ï¼šåŒåŒå‘é“¾è¡¨
åœ¨æ‡‚å¾—LRUçš„O(1)æ—¶é—´å¤æ‚åº¦å®ç°åï¼Œæœ¬é¢˜å¹¶ä¸éš¾ï¼Œå› æ­¤ä¸å†èµ˜è¿°LRUçš„å®ç°ã€‚


é¦–å…ˆæ˜¯é¢‘æ¬¡åŒå‘é“¾è¡¨ï¼Œæ¯ä¸ªé¢‘æ¬¡é“¾è¡¨èŠ‚ç‚¹ä¸­ä¸²ä¸€ä¸ªLRUåŒå‘é“¾è¡¨ã€‚å…¶å®è¿™ç§å®ç°ä¸‹æ²¡æœ‰ç¬¬äºŒä¸ªé™„å¸¦å“ˆå¸Œçš„è§£æ³•ç®€å•ï¼Œä¸è¿‡æŒºé”»ç‚¼ä»£ç å®ç°èƒ½åŠ›çš„ã€‚ğŸ˜€
ä¸»è¦çš„éš¾ç‚¹åœ¨äºåŒå‘é“¾è¡¨çš„ä¿®æ”¹ï¼Œç»†èŠ‚å¾ˆå¤šï¼Œä¸€ä¸å°å¿ƒå®¹æ˜“å†™é”™ã€‚é™„ä»£ç ï¼š



```
class Node:
    def __init__(self, val):
        self.val = val
        self.next = None
        self.prev = None

    def remove_from_origin_list(self):
        """
        å°†å½“å‰èŠ‚ç‚¹ä»åŸé“¾è¡¨æŠ½å‡ºï¼Œè‡ªèº«ä»ä¿ç•™å‰åæŒ‡å‘å…³ç³»
        """
        if self.prev is None:
            raise Exception('Delete Error. No prev Node')
        self.prev.next = self.next
        if self.next:
            self.next.prev = self.prev

    def insert_next(self, node):
        if node is None:
            raise Exception('Insert Error. node is None')

        nxt = self.next
        node.next = nxt
        node.prev = self
        self.next = node
        if nxt:
            nxt.prev = node
        
    def __str__(self):
        s = ''
        s += str(self.val) + '->'
        if self.next:
            s += str(self.next)
        return s


class CountNode(Node):
    def __init__(self, *args, **kwags):
        super().__init__(*args, **kwags)
        self.lru_head = Node(0)  # ç©ºå¤´ç»“ç‚¹, lru å¤´ä¸ºæœ€æ–°è®¿é—®è¿‡çš„èŠ‚ç‚¹
        self.lru_tail = None  # æŒ‡å‘å°¾èŠ‚ç‚¹, æœ€è¿‘æœ€å°‘ä½¿ç”¨çš„èŠ‚ç‚¹
        self.nodes = 0


    def insert_lru(self, lru_node):
        if self.nodes == 0:
            self.lru_tail = lru_node

        self.nodes += 1
        self.lru_head.insert_next(lru_node)
        
    
    def remove_lru(self, lru_node):
        if self.nodes <= 0:
            raise Exception('Count Node Error. Nodes count must > 0')
     
        self.nodes -= 1
        lru_node.remove_from_origin_list()

        if lru_node == self.lru_tail:
            if lru_node.prev != self.lru_head:
                self.lru_tail = lru_node.prev
            else:
                self.lru_tail = None
    

    def pop_lru(self):
        """
        popå°¾èŠ‚ç‚¹ï¼Œè¿”å›å‰©ä½™lruèŠ‚ç‚¹ä¸ªæ•°ï¼Œå¦‚æœä¸ªæ•°ä¸º0ï¼Œå½“å‰countèŠ‚ç‚¹éœ€è¦è¢«å›æ”¶
        :return: popçš„lruèŠ‚ç‚¹
        """
        lru_node = self.lru_tail
        self.remove_lru(lru_node)
        
        return lru_node
            

    
    def add_count(self, lru_node):
        """
        lru_nodeå¿…é¡»æ˜¯count_nodeä¸­çš„lruèŠ‚ç‚¹, ç”±LFUCacheæ§åˆ¶
        :return: lru_nodeå¤„äºçš„æ–°count_node
        """
        # ç›´æ¥å°†lruèŠ‚ç‚¹è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªcountèŠ‚ç‚¹
        if self.next and self.next.val == self.val + 1: 
            self.remove_lru(lru_node)
            self.next.insert_lru(lru_node)
            if self.nodes == 0:
                self.remove_from_origin_list()
            return self.next
      
        # è‡ªå·±å‡çº§ä¸ºä¸‹ä¸€ä¸ªèŠ‚ç‚¹
        if self.nodes == 1:
            self.val += 1
            return self
        # åˆ†è£‚å‡ºä¸€ä¸ªæ–°èŠ‚ç‚¹
        else:
            # åˆ†ç¦»lruèŠ‚ç‚¹
            self.remove_lru(lru_node)
            if self.nodes == 0:
                self.remove_from_origin_list()
            # lruèŠ‚ç‚¹æ’å…¥æ–°é¢‘æ¬¡èŠ‚ç‚¹
            new_node = CountNode(self.val + 1)
            new_node.insert_lru(lru_node)
            # å°†æ–°èŠ‚ç‚¹æ’å…¥é¢‘æ¬¡é“¾ä¸­
            self.insert_next(new_node)
            return new_node

    def __str__(self):
        s = ''
        s += str(self.lru_head) + '->\n'
        s += str(self.lru_tail) + '  nodes:' + str(self.nodes) + ' val: '+str(self.val) + '\n'
        if self.next:
            s += str(self.next)
        return s
        


def debug(func):
    def wrapper(*args, **kwags):
        print('<', func.__name__, '>', str(args), str(kwags))
        res =  func(*args, **kwags)
        print('result:', res)
        return res
    return wrapper


class LFUCache:

    def __init__(self, capacity: int):
        # é¢‘æ¬¡åŒå‘é“¾ + å†…éƒ¨lruåŒå‘é“¾
        self.cache = {}
        self.node_map = {} # å­˜å‚¨keyå¯¹åº”çš„lruèŠ‚ç‚¹å’Œé¢‘æ¬¡èŠ‚ç‚¹
        self.count_nodes = CountNode(0)  # é¢‘æ¬¡åŒå‘é“¾è¡¨
        self.size = 0
        self.cap = capacity
        # leetcode æµ‹è¯•ç”¨ä¾‹ä¸­ä¼šæœ‰cap=0çš„æƒ…å†µï¼Œä¸èƒ½ç›´æ¥æŠ›å¼‚å¸¸ï¼Œä½†ç”Ÿäº§ç¯å¢ƒä¸­åº”ç›´æ¥æŠ›å¼‚å¸¸
        # if self.cap <= 0:
        #     raise Exception('Capacity must greater than 0')

    
    # @debug
    def get(self, key: int) -> int:
        if key in self.cache:
            lru_node, count_node = self.node_map[key]
            new_count_node = count_node.add_count(lru_node)
            self.node_map[lru_node.val] = [lru_node, new_count_node]
            # print(self.count_nodes.next)

            return self.cache[key]
        else:
            return -1

    # @debug
    def put(self, key: int, value: int) -> None:
        # é”®å·²å­˜åœ¨åˆ™æ›¿æ¢å¹¶æ·»åŠ è®¿é—®é¢‘æ¬¡
        if key in self.cache:
            self.get(key)
            self.cache[key] = value
            return

        if self.size == self.cap:
            if self.cap == 0:
                return

            self.size -= 1
            pop_node = self.count_nodes.next.pop_lru()
            # print('pop, ', pop_node.val)
            self.node_map.pop(pop_node.val)
            self.cache.pop(pop_node.val)
            if self.count_nodes.next.nodes == 0:
                self.count_nodes.next.remove_from_origin_list()
            
        self.size += 1
        self.cache[key] = value
        
        lru_node = Node(key)   

        if self.count_nodes.next and self.count_nodes.next.val == 1:
            self.count_nodes.next.insert_lru(lru_node)
            self.node_map[key] = [lru_node, self.count_nodes.next]
        else:
            new_node = CountNode(1)
            new_node.insert_lru(lru_node)
            self.count_nodes.insert_next(new_node)
            self.node_map[key] = [lru_node, new_node]

        # print('cache', self.cache)
        # print(self.count_nodes.next)
```



## è§£æ³•äºŒï¼šå“ˆå¸Œå­˜å‚¨é¢‘æ¬¡ï¼Œæ¯ä¸ªé¢‘æ¬¡èŠ‚ç‚¹åŒ…å«lruåŒå‘é“¾è¡¨
ç›¸å¯¹ç®€å•ï¼Œåªéœ€å­˜å‚¨æœ€å°é¢‘æ¬¡ï¼Œå³å¯æ‰¾åˆ°åœ¨å“ˆå¸Œä¸­æ‰¾åˆ°æœ€å°é¢‘æ¬¡çš„lruåŒå‘é“¾è¡¨å¹¶popèŠ‚ç‚¹ã€‚