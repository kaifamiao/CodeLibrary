## ç»“æ„è®¾è®¡
cache åŸºäºä¸¤å±‚listå®ç°ã€‚ç¬¬ä¸€å±‚ä¸ºå‡ºç°çš„æ¬¡æ•°ï¼Œç¬¬äºŒå±‚ä¸ºå…·ä½“çš„å…ƒç´ ã€‚
router æ˜¯ä¸€ä¸ª unordered_mapã€‚è®°å½•æ¯ä¸ª key åœ¨ cache ä¸­çš„ä½ç½®ã€‚ 
å…·ä½“ç»“æ„å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š
![LFU.png](https://pic.leetcode-cn.com/c5f758cb360e8d6bf6ecf9b06672bc26b99fabf892a376c8e9cfd3a2d9023482-LFU.png)

## åŠŸèƒ½è®¾è®¡
### GET
**æ—¶é—´å¤æ‚åº¦ï¼šO(1)**

ç›´æ¥è®¿é—® routerï¼Œåˆ¤æ–­ key æ˜¯å¦å­˜åœ¨ï¼š
* ä¸å­˜åœ¨ï¼Œè¿”å› -1ã€‚
* å­˜åœ¨ï¼Œé€šè¿‡routerä¸­ç¼“å­˜çš„ä½ç½®ï¼Œç›´æ¥è®¿é—®å¯¹åº”çš„æ•°æ®é“¾è¡¨ç»“ç‚¹ï¼Œè¿”å›æ•°æ®ã€‚

### PUT
**æ—¶é—´å¤æ‚åº¦ï¼šO(1)**
é¦–å…ˆåˆ¤æ–­ key æ˜¯å¦åœ¨ router ä¸­ï¼š
* å¦‚æœåœ¨ï¼Œç›´æ¥æ›´æ–°å¯¹åº”æ•°æ®é“¾è¡¨ç»“ç‚¹çš„å€¼ï¼Œå¹¶è°ƒç”¨ updateFreq æ›´æ–°è®¿é—®æ¬¡æ•°ã€‚PUTç»“æŸã€‚
* å¦‚æœä¸å­˜åœ¨ã€‚åˆ™åˆ¤æ–­æ˜¯å¦å·²æ»¡ï¼šè‹¥å·²æ»¡å…ˆè°ƒç”¨ swapOut (è¯¥å‡½æ•°ä¼šæŒ‰LFUè§„åˆ™æ·˜æ±°ä¸€ä¸ªå…ƒç´ ï¼Œåé¢ä¼šè®¨è®º)ã€‚
* åˆ¤æ–­æ¬¡æ•°ä¸º1çš„é¢‘æ¬¡é“¾è¡¨ç»“ç‚¹æ˜¯å¦å­˜åœ¨ï¼Œä¸å­˜åœ¨åˆ™åˆ›å»ºã€‚
* å°†æ•°æ®æ’å…¥åˆ°æ¬¡æ•°ä¸º 1 çš„æ•°æ®é“¾è¡¨ã€‚å¹¶æ›´æ–° routerã€‚PUT ç»“æŸã€‚

ä»¥æ’å…¥(key = 5, val = 5) ä¸ºä¾‹ï¼Œå›¾ç¤ºå¦‚ä¸‹ï¼š
![LFUæ’å…¥.png](https://pic.leetcode-cn.com/46287cb09c76bd0ed7243c70a6bc2a24237e5ad3545dd130f4f8a811aa50e1cd-LFU%E6%8F%92%E5%85%A5.png)
### updateFreq
**æ—¶é—´å¤æ‚åº¦ï¼šO(1)**
æ¯æ¬¡æ›´æ–°æˆ–æŸ¥è¯¢ï¼Œå¯¹åº”å…ƒç´ çš„é¢‘æ¬¡åªä¼šå¢åŠ ä¸€ï¼Œä¹Ÿå°±æ˜¯è¯´å¯¹åº”çš„æ•°æ®ç»“ç‚¹**åº”ä»å½“å‰çš„æ•°æ®é“¾è¡¨ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªæ•°æ®é“¾è¡¨**ï¼Œå¦‚æœä¸‹ä¸€ä¸ªæ•°æ®é“¾è¡¨**ä¸å­˜åœ¨æˆ–è€…å¯¹åº”çš„é¢‘æ¬¡ä¸ç¬¦**ï¼Œåˆ™åº”åˆ›å»ºæ–°çš„æ•°æ®é“¾è¡¨ã€‚
ä»¥æ›´æ–°(key=5, val = 5)ä¸ºä¾‹ï¼Œè¿‡ç¨‹å¦‚ä¸‹å›¾ç¤ºï¼š

<![](https://pic.leetcode-cn.com/d41d72efe878cb6965a3a4371ae7341a3c781d41f0d9f71511472b7c5b2410a2-1.png),![](https://pic.leetcode-cn.com/6a3b1ddd96e07276cc901096737db7a14dca7787b74a9031fdd29e2248a48086-2.png)>

### swapOut
**æ—¶é—´å¤æ‚åº¦ï¼šO(1)**
å¼¹å‡ºé¢‘æ¬¡æœ€å°çš„æ•°æ®é“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œå¹¶åˆ é™¤routerã€‚
![LFU-swapout.png](https://pic.leetcode-cn.com/b8844ce65cdc4dac9b029bbf0a4453caf34e72066d7562e54afad6214072b925-LFU-swapout.png)

## ä»£ç å®ç°

```cpp
//ä¸º list è‡ªå®šä¹‰ä¸€ä¸ªå†…å­˜ç®¡ç†ç±»æ¨¡æ¿
template<typename T>
class SingleAlloctor {
	enum {
		MAXN = 5000,
	};
	static T *data;    //å†…å­˜æ± ä¸ºå…¨å±€å˜é‡ï¼Œé˜²æ­¢é‡å¤ç”³è¯·ã€‚
	static int current;
	static int pool[MAXN]; //poolæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªé“¾è¡¨ï¼›current ä¸ºå¤´ç»“ç‚¹ï¼Œæ ‡è®°äº†å“ªäº›dataå¯ç”¨ã€‚
	public:
		typedef T value_type;
		T * allocate(int num) {
			int cur = current;
			current = pool[current];
			return data + cur;
		}
		void deallocate(T *p, std::size_t) {
			ptrdiff_t offset = p-data;
			pool[offset] = current;
			current = offset;
		}
		SingleAlloctor() {
            if(data != nullptr) { //åº”è¯¥è¿˜æœ‰å¯¹åº”çš„deleteï¼Œå“ˆå“ˆå·æ‡’äº†ã€‚
                return;
            }
			data = static_cast<T*>(::operator new (MAXN * sizeof(T)));
			for(int i = 0; i < MAXN; i++) {
				pool[i] = i-1;
			}
			current = MAXN-1;
		}
};

template<typename T>
int SingleAlloctor<T>::current;

template<typename T>
int SingleAlloctor<T>::pool[SingleAlloctor<T>::MAXN];

template<typename T>
T *SingleAlloctor<T>::data = nullptr;

class LFUCache {
    struct FreqNode;
	typedef list<FreqNode, SingleAlloctor<FreqNode>> FreqList;

	struct DataNode {
		int key;     //ç´¢å¼•
		int value;   //æ•°æ®
		FreqList::iterator fit; //å¯¹åº”çš„é¢‘æ¬¡é“¾è¡¨çš„ç»“ç‚¹
		DataNode(int k = 0, int v = 0, FreqList::iterator f = FreqList::iterator())
			: key(k), value(v), fit(f) {}
	};
	typedef list<DataNode, SingleAlloctor<DataNode>> DataList;

    struct FreqNode {
        int cnt;      //é¢‘æ¬¡
        DataList dataList;  //å¯¹åº”çš„æ•°æ®ç»“ç‚¹åˆ—è¡¨
		FreqNode(int c = 0) : cnt(c) {}
    };
	FreqList cache;
	unordered_map<int, DataList::iterator> router;

	size_t capacity;

	void updateCache(int key) {
		auto rit = router.find(key);
		auto it = rit->second;
		if(it->fit == cache.begin()) {
			cache.push_front(FreqNode(it->fit->cnt+1)); //æ›´é«˜é¢‘æ¬¡çš„ç»“ç‚¹ä¸å­˜åœ¨ï¼Œåˆ›å»ºå®ƒï¼
		} else {
			FreqList::iterator pre = it->fit; --pre;    
			if(pre->cnt != it->fit->cnt+1) {       // æ›´é«˜é¢‘æ¬¡çš„ç»“ç‚¹é¢‘æ¬¡ä¸åŒ¹é…ï¼Œæ’å…¥ä¸€ä¸ªæ–°çš„ã€‚
				cache.insert(it->fit, FreqNode(it->fit->cnt+1));
			}
		}
		auto curIt = it->fit;          //ä»å½“å‰æ•°æ®é“¾è¡¨æ–­å¼€ï¼Œæ’å…¥åˆ°æ›´é«˜é¢‘æ¬¡çš„æ•°æ®é“¾è¡¨ã€‚
		auto preIt = it->fit; --preIt;
		preIt->dataList.push_front(DataNode(key, it->value, preIt));
		curIt->dataList.erase(it);
		rit->second = preIt->dataList.begin(); //æ›´æ–° router
	}

	void swapOut() {
		for(auto it = --cache.end(); ;) {
			if(it->dataList.size()) { //åˆ é™¤æœ€åä¸€ä¸ª
				auto out = it->dataList.back();
				router.erase(out.key);
				it->dataList.pop_back();
				break;
			} else {       //å¯èƒ½å­˜åœ¨è‹¥å¹²ä¸ªç©ºçš„æ•°æ®é“¾è¡¨ï¼Œæ¸…æ¥šå®ƒã€‚å‡æ‘Š O(1)ã€‚
				cache.erase(it--);
			}
		}
	}
    
public:
    LFUCache(int capacity) : capacity(capacity) {}
    
    int get(int key) {
		auto it = router.find(key);
		if(it == router.end()) {
			return -1;
		}
		int val = it->second->value;
		updateCache(key);
		return val;
    }

    void put(int key, int value) {
		if(capacity == 0) {
			return;
		}
		auto rit = router.find(key);
		if(rit != router.end()) {
			rit->second->value = value; //keyå·²å­˜åœ¨ï¼Œæ›´æ–°valueã€‚
			updateCache(key);
		} else {
			if(router.size() == capacity) {
				swapOut();
			}
			if(cache.empty() || cache.back().cnt != 1) {
				cache.push_back(FreqNode(1)); //ä¸å­˜åœ¨é¢‘æ¬¡ä¸º 1 çš„æ•°æ®é“¾è¡¨ï¼Œåˆ›å»ºä¸€ä¸ªã€‚
			}
			auto it = --cache.end();
			it->dataList.push_front(DataNode(key, value, it)); //æ’å…¥åˆ°æ•°æ®é“¾è¡¨ã€‚
			router.insert(make_pair(key, it->dataList.begin())); //æ›´æ–°router
		}
    }
};
```

**å¯¹STLä¸ç†Ÿæ‚‰çš„å°ä¼™ä¼´ï¼Œå¯ä»¥å…³æ³¨å…¬ä¼—å·å›å¤ "CPPæ ‡å‡†åº“" è·å–ç›¸å…³PDFå“¦ã€‚**
# å¦‚æœæ„Ÿè§‰æœ‰ç‚¹æ„æ€ï¼Œå¯ä»¥å…³æ³¨ğŸ‘HelloNebulağŸ‘
* **åˆ†äº«å‘¨èµ›é¢˜è§£**
* **åˆ†äº«è®¡ç®—æœºä¸“ä¸šè¯¾çŸ¥è¯†**
* **åˆ†äº«C++ç›¸å…³å²—ä½é¢è¯•é¢˜**
* **åˆ†äº«ä¸“ä¸šä¹¦ç±PDF**

![qrcode_for_gh_6e5f8557b1f8_258.jpg](https://pic.leetcode-cn.com/05e5a3b25cb51d114880f718c50446c6a6e9d3f242c7418e6b6e52fb2db48994-qrcode_for_gh_6e5f8557b1f8_258.jpg)


