### 解法简介
将原问题分解，先求解包含$K$个不同整数的子数组的最大窗口长度。这个就是常见的滑动窗口模版题了，如果不熟悉可以先去看看力扣的滑动窗口专题。每次加进新的元素，如果发现不满足不同个数$\gt K$了，就移动左边的指针。这样可以保证每次$l$指针都是使得窗口满足$\le K$的最小指针。
同样的，可以求得包含$K-1$个不同整数的子数组的最大窗口。只需要将判断条件改成$\gt K-1$就可以了。在不同个数为$K$子数组存在的情况下，只要将左端点指针向左移动一步，必然可以得到一个不同个数为$K$子数组，即求得这种情况下的右边界。两者做差即可得到中间的子数组个数。
其实这里蕴含了滑窗函数的单调性和连续性：
用$f(l,r)$表示从$s[l,r]$子数组中的不同元素个数，则有$0 \le f(l,r+1) - f(l,r)\le 1$，以及$0 \le  f(l,r) - f(l+1,r) \le 1$，凡是满足类似性质的问题，都可以采用滑窗（双指针）进行求解。

### Tips
由于数据范围为$[1,n]$，可以直接用`vector<int>`或者数组代替$hash$表，这样可以加快运算速度。

### 代码
```
class Solution {
public:
    int subarraysWithKDistinct(vector<int>& A, int K) {
        int n = A.size();
        vector<int> h1(n+1,0),h2(n+1,0);
        int cnt1=0,cnt2=0;
        
        int ans = 0;
        
        int l = 0, r = 0;
        for(int j = 0 ; j < n ; j++) {
            if(h1[A[j]]++ == 0) cnt1++;
            if(h2[A[j]]++ == 0) cnt2++;
            while(cnt1 > K) if(--h1[A[l++]] == 0) cnt1--;
            while(cnt2 > K-1) if(--h2[A[r++]] == 0) cnt2--;
            if(cnt1 == K) ans += r-l;
        }
        return ans;
    }
};
```