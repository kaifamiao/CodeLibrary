学习自[五分钟学算法](https://mp.weixin.qq.com/s/6YeZUCYj5ft-OGa85sQegw)

# 思考

数组类型

题目中的subarray 已经明确了这个题可以考虑用滑动窗口，这题比较 trick 的一个地方在于，

这里不是求最大值最小值，而是要求计数。

但是如果每次仅仅加1的话又不太对，例如 `A = [1, 2, 1, 2, 3], K = 2` 这个例子，

假如右指针移到 index 为3的位置，如果按之前的思路左指针根据 count 来移动，

当前窗口是 `[1, 2, 1, 2]` ，但是怎么把 `[2, 1]` 给考虑进去呢？

可以从数组和子数组的关系来思考！

假如 `[1, 2, 1, 2]` 是符合条件的数组，

如果要计数的话， `[1, 2, 1, 2]` 要求的结果是否和 `[1, 2, 1]` 的结果存在联系？

这两个数组的区别在于多了一个新进来的元素，之前子数组计数没考虑到这个元素， 

假设把这个元素放到之前符合条件的子数组中组成的新数组也是符合条件的，

下面看看这个例子中所有满足条件的窗口以及对应的满足条件的子数组情况：

```
[1,2,1,2,3]  // 窗口满足条件
 l r         // 满足条件的子数组 [1,2]

[1,2,1,2,3]  // 窗口满足条件
 l   r       // 满足条件的子数组 [1,2],[2,1],[1,2,1]

[1,2,1,2,3]  // 窗口满足条件
 l     r     // 满足条件的子数组 [1,2],[2,1],[1,2,1],[1,2],[2,1,2],[1,2,1,2]

[1,2,1,2,3]  // 窗口不满足条件，移动左指针至满足条件
 l       r   

[1,2,1,2,3]  // 窗口满足条件
       l r   // 满足条件的子数组 [1,2],[2,1],[1,2,1],[1,2],[2,1,2],[1,2,1,2],[2,3]
```

可以看到对于一段连续的数组，新的元素进来，窗口增加1，每次的增量都会在前一次增量的基础上加1。

当新的元素进来打破当前条件会使这个增量从新回到1，

这样我们左指针移动条件就是只要是移动不会改变条件，就移动，不然就停止。

```go
func subarraysWithKDistinct(A []int, K int) int {
    if A == nil || len(A) < K {
    	return 0
    }
    
    hash := make([]int, len(A)+1)
    l, count, result, results := 0, 0, 1, 0 
    for r:=0 ; r < len(A); r++ {
    	hash[A[r]]++
    	
    	if hash[A[r]] == 1 {
    		count++
    	}
    	
    	for hash[A[l]] > 1 || count > K {
    		if count > K {
    			result = 1
    			count--
    		} else {
    			result++
    		}
    		hash[A[l]]--
    		l++
    	}
    	
    	if count == K {
    		results += result
    	}
    }
    
    return results
}
```