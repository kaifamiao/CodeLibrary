### 解题思路
这道题采用双滑动窗口，但这里巧妙的隐藏了一个滑动窗口。
下面这个文章的解释比较清楚。
https://www.cnblogs.com/godweiyang/p/12203881.html

现在考虑右边界为 j 的情况，左边界 i 有什么规律呢？ 我们可以证明，满足 [i, j] 正好包含 K 个不同整数的 i 的取值是一段连续的区间。 假设 [i, j]包含 K 个不同整数，同时 [i', j] 也包含 K 个不同整数（i < i'），因为从 i 移动到 i' 每个数的数量是非增的，所以这过程中没有增加新的数，也没有任何一个数的数量降到了0。

有了这个性质之后，对于任意的 j ，我们只需要求出左边界 i 的取值范围就行了。同样这里还是不能暴力求，不然就和一开始没区别了嘛。 既然这样，想想如果 j 的左边界 i 的范围得到了，这时候我们继续求 j + 1 的左边界范围，能不能利用一下之前得到的结果？而不用重新计算。 很容易发现，如果 j 右移了， i 的取值范围也会右移，因为 j 右移有两种结果：一是引入了新的数，二是某个存在的数的数量加 1 。 第一种情况对左边界没有任何影响，因为不同整数数量没有变化，还是 K 。第二种情况不同整数数量变成 K + 1 了，这时候左边界一定要右移，删掉点数，才可能使区间符合题意。

有了上述的性质之后就好做了，因为左边界的取值范围也是不断右移的，所以我们只需要维护两个指针 l 和 r 就行了，一个保存取值范围的最小值，一个保存最大值。然后每次对于一个 j ，符合题意的子区间数量就是 r - l + 1 。而 j 右移一个数之后， l 需要右移，直到 [l, j] 中正好有 K 个不同整数， r 也继续右移，直到[r + 1, j] 中正好有 K - 1 个不同整数。

因为 l 和 r 最多只会移动 n 次，而 j 也只移动了 n 次，所以总体时间复杂度降到了 O(n) 。

### 代码

```golang
func subarraysWithKDistinct(A []int, K int) int {
	if len(A) == 0 || K > len(A) {
		return 0
	}

    // hashMap := make(map[int]int, len(A)+1)
    // 用切片性能高很多
	hashMap := make([]int, len(A)+1)

	step, l, r, ans := 0, 0, 0, 0
    count := 0

	for ; r < len(A); r++ {
		hashMap[A[r]]++

        if hashMap[A[r]] == 1 {
            count++
        }

		// 在左下标的数非唯一，或者超过K时，移动左下标
		for hashMap[A[l]] > 1 || count > K {
			if count > K {
				hashMap[A[l]]--
                count--
				l++
                //有新数进来，之前的步数清0
				step = 0


			} else {
				hashMap[A[l]]--
				l++
                //step在这里用的很巧妙，累计了之前移动的步数
				step++
			}
		}

		if count == K {
			ans += step + 1
		}
	}


	return ans
}
```