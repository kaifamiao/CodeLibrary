#### 方法一：排序

**分析**

我们想象一个直方图，其中 $x$ 轴表示文章，$y$ 轴表示每篇文章的引用次数。如果将这些文章按照引用次数*降序*排序并在直方图上进行表示，那么直方图上的最大的正方形的边长 $h$ 就是我们所要求的 $h$。

![h-index](https://pic.leetcode-cn.com/Figures/274_H_index.svg){:width="400"}
{:align="center"}

**算法**

首先我们将引用次数降序排序，在排完序的数组 $\mathrm{citations}$ 中，如果 $\mathrm{citations}[i] \gt i$，那么说明第 0 到 $i$ 篇论文都有至少 $i+1$ 次引用。因此我们只要找到最大的 $i$ 满足 $\mathrm{citations}[i] \gt i$，那么 $h$ 指数即为 $i+1$。例如：

| $i$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|:------------------------------------:|:-----:|:-----:|:-----:|:----:|:----:|:----:|:----:|
| 引用次数 | 10 | 9 | 5 | 3 | 3 | 2 | 1 |
| $\mathrm{citations}[i] \gt i$ | true | true | true | false | false | false | false |

其中最大的满足 $\mathrm{citations}[i] \gt i$ 的 $i$ 值为 2，因此 $h = i + 1 = 3$。

找到最大的 $i$ 的方法有很多，可以对数组进行线性扫描，也可以使用二分查找。由于排序的时间复杂度已经为 $O(n \log n)$，因此无论是线性扫描 $O(n)$ 还是二分查找 $O(\log n)$，都不会改变算法的总复杂度。

```Java []
public class Solution {
    public int hIndex(int[] citations) {
        // 排序（注意这里是升序排序，因此下面需要倒序扫描）
        Arrays.sort(citations);
        // 线性扫描找出最大的 i
        int i = 0;
        while (i < citations.length && citations[citations.length - 1 - i] > i) {
            i++;
        }
        return i;
    }
}
```

**复杂度分析**

* 时间复杂度：$O(n\log n)$，即为排序的时间复杂度。
* 空间复杂度：$O(1)$。大部分语言的内置 `sort` 函数使用堆排序，它只需要 $O(1)$ 的额外空间。

#### 方法二：计数

**分析**

基于比较的排序算法存在时间复杂度下界 $O(n\log n)$，如果要得到时间复杂度更低的算法，就必须考虑不基于比较的排序。

**算法**

方法一中，我们通过降序排序得到了 $h$ 指数，然而，所有基于比较的排序算法，例如堆排序，合并排序和快速排序，都存在时间复杂度下界 $O(n\log n)$。要得到时间复杂度更低的算法. 可以考虑最常用的不基于比较的排序，[计数排序](https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)。

然而，论文的引用次数可能会非常多，这个数值很可能会超过论文的总数 $n$，因此使用计数排序是非常不合算的（会超出空间限制）。在这道题中，我们可以通过一个不难发现的结论来让计数排序变得有用，即：

> 如果一篇文章的引用次数超过论文的总数 $n$，那么将它的引用次数降低为 $n$ 也不会改变 $h$ 指数的值。

由于 $h$ 指数一定小于等于 $n$，因此这样做是正确的。在直方图中，将所有超过 $y$ 轴值大于 $n$ 的变为 $n$ 等价于去掉 $y>n$ 的整个区域。

![h-index cut off](https://pic.leetcode-cn.com/Figures/274_H_index_2.svg){:width="400px"}
{:align="center"}

从直方图中可以更明显地看出结论的正确性，将 $y>n$ 的区域去除，并不会影响到最大的正方形，也就不会影响到 $h$ 指数。

我们用一个例子来说明如何使用计数排序得到 $h$ 指数。首先，引用次数如下所示：

$$
\mathrm{citations} = [1, 3, 2, 3, 100]
$$

将所有大于 $n=5$ 的引用次数变为 $n$，得到：

$$
\mathrm{citations} = [1, 3, 2, 3, 5]
$$

计数排序得到的结果如下：

|$k$   |  0   | 1   |   2 |   3 |   4 |   5 |
|:------:|:----:|:---:|:---:|:---:|:---:|:---:|
|count   |  0   | 1   |   1 |   2 |   0 |   1 |
|$s_k$ |  5   | 5   |   4 |   3 |   1 |   1 |

其中 $s_k$ 表示至少有 $k$ 次引用的论文数量，在表中即为在它之后的列（包括本身）的 $\mathrm{count}$ 一行的和。根据定义，最大的满足 $k \leq s_k$ 的 $k$ 即为所求的 $h$。在表中，这个 $k$ 为 3，因此 $h$ 指数为 3。

```Java []
public class Solution {
    public int hIndex(int[] citations) {
        int n = citations.length;
        int[] papers = new int[n + 1];
        // 计数
        for (int c: citations)
            papers[Math.min(n, c)]++;
        // 找出最大的 k
        int k = n;
        for (int s = papers[n]; k > s; s += papers[k])
            k--;
        return k;
    }
}
```

**复杂度分析**

* 时间复杂度：$O(n)$。在计数时，我们仅需要遍历 $\mathrm{citations}$ 数组一次，因此时间复杂度为 $O(n)$。在找出最大的 k 时，我们最多需要遍历计数的数组一次，而计数的数组的长度为 $O(n)$，因此这一步的时间复杂度为 $O(n)$，即总的时间复杂度为 $O(n)$。
* 空间复杂度：$O(n)$。我们需要使用 $O(n)$ 的空间来存放计数的结果。

## 思考

> 可能会出现多个不同的 $h$ 指数吗？

答案是 **否**。从直方图中可以看出，由于 $y$ 轴已经降序排序，因此直线 $y=x$ 有且仅有穿过直方图一次。同时，也可以直接通过 $h$ 指数的定义证明出 $h$ 指数的唯一性。