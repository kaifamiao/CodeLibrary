# 1. 思路
这道题一开始也是没有明确的思路，只能举几个简单的正例和反例，观察后序遍历的规律。
我的发现是，正确的后序遍历序列从右向左都可以分成三个部分：
**[左子树][右子树][中间节点]**
当然左子树或者右子树都是可以没有的，另外根据搜索树的性质，可以知道左子树必定都小于右子树的节点。
所以我的策略是，从第一个数起，所有小于中间节点的数假设属于左子树，那么剩下部分(除中间节点)应该都属于右子树，那么这些剩下的部分都应该大于中间节点，如果存在小于中间节点的数，那么这个后序遍历序列一定是错误的。
# 2. 代码
1. i是开始位置，j是结束位置，如果i和j相等(长度为1)或者间隔为1(长度为2)，一定是一个正确的序列
2. 确定左子树、右子树的开始和结束位置
3. 判断右子树的值是否都大于中间节点
4. 递归判断左子树序列和右子树序列
```c++ []
class Solution {
public:

    bool verifyPostorder(vector<int>& postorder) {
        return ok(postorder, 0, postorder.size()-1);
    }
    bool ok(vector<int>& p, int i, int j){
        if(j-i <= 1) return true;
        int ri=j-1,rj=ri,li=i,lj=li-1;

        while(p[lj+1]<p[j]&&lj<j){lj++;}
        
        ri=lj+1;
        for(int k=ri; k<=rj; k++){
            if(p[k]<p[j]) return false;
        }
        
        return ok(p, li, lj) && ok(p, ri, rj);
    }
1. };
```
# 3. 总结
这道题看着又像是一道找规律的题目，只不过还要结合递归的思想，另外再定位左子树和右子树起始终止位置时要小心。