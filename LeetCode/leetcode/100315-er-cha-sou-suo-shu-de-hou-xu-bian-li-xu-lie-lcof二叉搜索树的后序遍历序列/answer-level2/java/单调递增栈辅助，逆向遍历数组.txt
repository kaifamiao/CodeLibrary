### 解题思路
看到蛮多大佬都用了递归来解决，这里提一个不一样的思路，**单调栈**。

二叉搜索树是left < root < right的，后序遍历的顺序是left->right->root，乍一看，好像没有办法保证单调性，不过我们可以做一个变化，**后序遍历的逆序**是什么呢？

**root->right->left**

发现什么了吗？是的，这是**换了一个方向的先序遍历**，从root开始，先遍历右子树，再遍历左子树。怎么做到先root，然后right，最后left呢，只要我们**反向遍历数组**，这样我们就可以利用单调栈了。

下面说说单调递增栈的思路和用法。

**翻转先序遍历**又是root->right->left的，基于这样的性质和遍历方式，我们知道越往右越大，这样，就可以构造一个单调递增的栈，来记录遍历的元素。

为什么要用单调栈呢，因为往右子树遍历的过程，value是越来越大的，一旦出现了value小于栈顶元素value的时候，就表示要开始进入左子树了（如果不是，就应该继续进入右子树，否则不满足二叉搜索树的定义，不理解的请看下二叉搜索树的定义），但是这个左子树是从哪个节点开始的呢？

单调栈帮我们记录了这些节点，只要栈顶元素还比当前节点大，就表示还是右子树，要移除，因为我们要找到这个左孩子节点直接连接的父节点，也就是找到这个子树的根，只要栈顶元素还大于当前节点，就要一直弹出，直到栈顶元素小于节点，或者栈为空。栈顶的上一个元素就是子树节点的根。

接下来，数组继续往前遍历，之后的左子树的每个节点，都要比子树的根要小，才能满足二叉搜索树，否则就不是二叉搜索树。

那么，这个思路的时间复杂度是多少呢？O(N)。

因为每个节点都只会进栈一次和出栈一次，虽然看上去有两个循环，其实是O(2*N)的复杂度，去掉常数就是O(N)了。空间复杂很好看出来，一样O(N)。

### 代码

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        // 单调栈使用，单调递增的单调栈
        Deque<Integer> stack = new LinkedList<>();
        // 表示上一个根节点的元素，这里可以把postorder的最后一个元素root看成无穷大节点的左孩子
        int pervElem = Integer.MAX_VALUE;
        // 逆向遍历，就是翻转的先序遍历
        for (int i = postorder.length - 1;i>=0;i--){
            // 左子树元素必须要小于递增栈被peek访问的元素，否则就不是二叉搜索树
            if (postorder[i] > pervElem){
                return false;
            }
            while (!stack.isEmpty() && postorder[i] < stack.peek()){
                // 数组元素小于单调栈的元素了，表示往左子树走了，记录下上个根节点
                // 找到这个左子树对应的根节点，之前右子树全部弹出，不再记录，因为不可能在往根节点的右子树走了
                pervElem = stack.pop();
            }
            // 这个新元素入栈
            stack.push(postorder[i]);
        }
        return true;
    }
}
```