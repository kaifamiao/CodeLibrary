显然，在任何一个状态下，所剩石子堆必然是 `values` 的一个后缀。不妨以此后缀的首个元素的下标 $i$ 作为此状态的编码。

在任何状态下，当前轮次的玩家最多只有三种决策：
- S1：取剩下石子中的的前 1 堆
- S2：取剩下石子中的的前 2 堆
- S3：取剩下石子中的的前 3 堆

由于两人轮流玩，我们需要用两个递推式来记录任何一个状态下，两个玩家的最优得分。记 $f_1(i), f_2(i)$ 分别表示在状态 $i$ 时，本轮次玩家和下一轮次玩家的最优得分。在此状态下，可以计算出来三种决策对应的分数：
- $s_1 = W[i] + f_2(i + 1)$
- $s_2 = W[i] + W[i + 1] + f_2(i + 2)$
- $s_3 = W[i] + W[i + 1] + W[i + 2] + f_2(i + 3)$

这里直接用 $W$ 代替 `values`。其计算思路为：这一轮取出的石子对应的分数 加上 下一轮次玩家决策后，“我”（下一轮次玩家的下一轮次玩家，故用 $f_2$）的最优得分。记 $k = \argmax_{i \in \{1,2,3\}} \{s_i\}$ 为最佳策略。

按照“理性人假设”（即两方都采用对自己有利的策略）：
- $f_1(i) = s_k$（“我”当然取对自己最有利的策略，得到“我”的分数）
- $f_2(i) = f_1(i + k)$（“我”取了对自己最有利的策略后，对方要在对应的新状态下取得对他最有利的策略）

注意到当 $|W| < 3$ 时，上述三种决策有些是不可能的（石子堆数量不够）。但是，我们不妨总是假设有 $|W| + 3$ 堆石子，且新加的三堆都是空的（值等于0）。这样我们就可以统一按照上述递归式迭代计算，并令初始条件：$f_1(|W| + j) = f_2(|W| + j) = 0$ 对于 $j < 3$。

代码实现如下：

```c++
string stoneGameIII(vector<int>& w) {
    const int n = w.size();
    w.push_back(0);
    w.push_back(0);
    w.push_back(0);
    vector<vector<int>> dp(n + 3, vector<int>(2, 0));
    
    for (int i = n - 1; i >= 0; i--) {
        int s1 = w[i] + dp[i + 1][1];
        int s2 = w[i] + w[i + 1] + dp[i + 2][1];
        int s3 = w[i] + w[i + 1] + w[i + 2] + dp[i + 3][1];
        dp[i][0] = max(s1, max(s2, s3));
        
        if (s1 >= max(s2, s3)) {
            dp[i][1] = dp[i + 1][0];
        } else if (s2 >= max(s1, s3)) {
            dp[i][1] = dp[i + 2][0];
        } else {
            dp[i][1] = dp[i + 3][0];
        }
    }
    
    if (dp[0][0] == dp[0][1]) return "Tie";
    if (dp[0][0] > dp[0][1]) return "Alice";
    return "Bob";
}
```

吐槽：开始计算了 $4|W|$ 个状态（分别考虑了当前轮次为 A/B 时，A/B 的最优得分），但是超时了！只有降到 $2|W|$ 个状态时，才能AC！