## 解法一：(动态规划)

这是一道典型的动态规划题。我们设置状态为**当前从第i个石子堆开始，先手赢后手多少值**(赢多少值就是先手的值减去后手拿的值)。

我们分别来看下面的几种情况：

- 如果只有一个石子堆，那么先手直接拿这一个。
- 如果有两个石子堆，那么先手可以拿一个或者两个，那么先手一定拿最大的情况(不一定是全拿完，因为有负数)。
- 三个石子堆，先手拿三种情况的最优。
- 四个呢？前三种情况都是先手有值，后手完全看先手拿了多少。如果都拿光那么后手就没有值了。那么四个石子还是三种情况这没问题，只是假设你拿了三个，还剩下一个，剩下的这一个就是你之前算过的先手的状态，由于先手拿了，所以后手变成了先手。那么拿三堆石子的先手的值应该是你当前`i, i + 1, i + 2`这三堆的和减去之前算过的`i + 3`状态下先手的最优值。另外两种状态同理。

那么我们现在来总结一下，**首先**我们要从后往前找状态，因为你需要的子问题都在当前问题的后面，就比如你要算`i`你就需要`i + 1`的状态。不过要注意上面的前三种情况如果你全拿完了是不需要减的，因为石子堆拿完了，后手没得拿了。**其次**，每种状态都有三种选择，就是你**拿第`i`堆**，**拿`i, i + 1`**,**拿`i, i + 1, i + 2`**这三种情况，而这三种情况的最优情况(就是前面说的先手赢后手多少值)要记得减去后手可以拿的最优情况，因为后手此时相当于你之前算出来的先手，所以可以直接使用之前算出来的状态。我们取三种选择中最优的那个选择存入当前位置。**最后**，我们只要看第一个位置的先手是否大于0就知道`Alice`是否可以赢了，因为`Alice`就相当于是第一个位置先手的情况。

```cpp
class Solution {
public:
    string stoneGameIII(vector<int>& stoneValue) {
        int size = stoneValue.size();
        int dp[size + 1];
        dp[size] = 0;
        for (int i = size - 1; i >= 0; i--) {
            dp[i] = -1e9;
            int stone = 0;
            for (int j = i; j < i + 3 && j < size; j++) {
                stone += stoneValue[j];
                dp[i] = max(dp[i], stone - dp[j + 1]);
            }
        }
        
        return dp[0] > 0 ? "Alice" : dp[0] < 0 ? "Bob" : "Tie";
    }
};
```