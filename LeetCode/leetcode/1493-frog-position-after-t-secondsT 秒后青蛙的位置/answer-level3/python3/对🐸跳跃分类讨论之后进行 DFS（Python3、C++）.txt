### è§£é¢˜æ€è·¯
ğŸ¸è·³è·ƒçš„ç»ˆæ­¢æ¡ä»¶ä¸ºä»¥ä¸‹ä¸¤ç§ï¼š
1. æ—¶é—´èŠ±å…‰æ—¶ï¼Œå¦‚æœå½“å‰ç»“ç‚¹ $u$ æ°å¥½ä¸º $target$ï¼Œæ¦‚ç‡ä¸º $p$ï¼Œå¦åˆ™ä¸º $0$;
2. æ—¶é—´æ²¡ç”¨å®Œï¼Œä½†æ˜¯è·³åˆ°äº†å¶å­ç»“ç‚¹ï¼Œå¦‚æœå½“å‰å¶å­ç»“ç‚¹ $u$ æ°å¥½ä¸º $target$ï¼Œæ¦‚ç‡ä¸º $p$ï¼Œå¦åˆ™ä¸º $0$ã€‚

$$ t=0\left\{
\begin{aligned}
u = target & , & p &      \\
u  â‰  target & , & 0 \\
\end{aligned}
\right.
$$

$$ t>0\left\{
\begin{aligned}
u = target & , & p  \\
u  â‰  target & , & 0 \\
\end{aligned}
\right.
$$

å› æ­¤æˆ‘ä»¬åªéœ€æ·±åº¦ä¼˜å…ˆéå†è¿™æ£µæ ‘ï¼Œåˆ†æ¡ä»¶è®¨è®ºæ¦‚ç‡å³å¯ã€‚

æœ¬é¢˜å’Œä¸Šä¸€é¢˜æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œå³è¾“å…¥å¹¶ä¸æ˜¯ä¸€æ£µæ ‘ï¼Œå› æ­¤æˆ‘ä»¬éœ€è¦å¤„ç†è¾“å…¥è¿›è¡Œå¤„ç†ã€‚ä¸€èˆ¬ä¸éœ€è¦é‡æ–°å»ºæ ‘ï¼Œå­˜å‚¨æ ‘å½¢å…³ç³»å¯ä»¥æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼ï¼š
- ä½¿ç”¨é‚»æ¥çŸ©é˜µ
- ä½¿ç”¨äºŒç»´æ•°ç»„

æˆ‘ä»¬ä½¿ç”¨äºŒç»´æ•°ç»„ä¿å­˜ç»“ç‚¹ï¼ˆè¿™æ˜¯ä¿å­˜æ ‘å½¢å…³ç³»çš„ä¸€ä¸ªå¸¸ç”¨æ–¹æ³•ï¼‰ï¼Œæ³¨æ„æ·±åº¦ä¼˜å…ˆæœç´¢æ—¶ï¼Œå¦‚æœç¢°åˆ°çˆ¶ç»“ç‚¹å°±é¿å¼€ã€‚

### ä»£ç 

```cpp []
class Solution {
public:
    vector<vector<int>> e;
    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {
        e = vector<vector<int>> (n + 1); // ä¸‹æ ‡ä» 1 å¼€å§‹
        for (auto edge : edges){
            int a = edge[0], b = edge[1];
            e[a].push_back(b);
            e[b].push_back(a);
        }

        return dfs(1, -1, t, target, 1);
    }

    double dfs(int u, int father, int t, int target, double p){
        /*
        u: å½“å‰ç»“ç‚¹ï¼› fatherï¼šé¿å…éå†åˆ°çˆ¶èŠ‚ç‚¹ï¼›tï¼šå‰©ä½™æ—¶é—´ï¼›p:å½“å‰æ¦‚ç‡
        */
        if (t == 0){
            if (u == target) return p;
            return 0;
        }

        int k = e[u].size(); // å½“å‰ç»“ç‚¹uçš„å­©å­ä¸ªæ•°
        if (u != 1) k --; // é™¤äº†æ ¹èŠ‚ç‚¹1ï¼Œå­©å­ä¸ªæ•°éœ€è¦å‡å»çˆ¶èŠ‚ç‚¹çš„é‚£æ¡è¾¹

        if (k == 0){ // åˆ°è¾¾å¶å­ç»“ç‚¹
            if (u == target) return p;
            return 0;
        }

        double res = 0;
        for (auto s: e[u]){
            if (s != father)
                res = max(res, dfs(s, u, t - 1, target, p * 1.0 / k));
        }
        return res;

    }
};
```
```python []
class Solution:
    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:
        self.e = [[]for _ in range(n + 1)] # ä¸‹æ ‡ä» 1 å¼€å§‹
        for edge in edges: # å­˜ç»“ç‚¹
            a = edge[0]
            b = edge[1]
            self.e[a].append(b)
            self.e[b].append(a)
        return self.dfs (1, -1, t, target, 1)

    def dfs(self, u, father, t, target, p):
        """u: å½“å‰ç»“ç‚¹ï¼› fatherï¼šé¿å…éå†åˆ°çˆ¶èŠ‚ç‚¹ï¼›tï¼šå‰©ä½™æ—¶é—´ï¼›p:å½“å‰æ¦‚ç‡"""
        if t == 0:
            if u == target: return p
            return 0
        k = len(self.e[u]) # å½“å‰ç»“ç‚¹uçš„å­©å­ä¸ªæ•°
        if u != 1: k -= 1  # é™¤äº†æ ¹èŠ‚ç‚¹1ï¼Œå­©å­ä¸ªæ•°éœ€è¦å‡å»çˆ¶èŠ‚ç‚¹çš„é‚£æ¡è¾¹
        if k == 0:  # åˆ°è¾¾å¶å­ç»“ç‚¹
            if u == target: return p
            return 0
        
        res = 0
        for s in self.e[u]:
            if s != father:
                res = max(res, self.dfs(s, u, t - 1, target, p * 1.0 / k))
        return res
```
### å¤æ‚åº¦åˆ†æ
- æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œéå†äº†æ¯ä¸€ä¸ªç»“ç‚¹ã€‚
- ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œä½¿ç”¨äº†æ•°ç»„å­˜å‚¨æ¯ä¸€ä¸ªç»“ç‚¹ã€‚