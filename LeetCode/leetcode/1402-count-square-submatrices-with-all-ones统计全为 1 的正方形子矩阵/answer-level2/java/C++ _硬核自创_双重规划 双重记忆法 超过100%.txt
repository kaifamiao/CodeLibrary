### 战绩
![image.png](https://pic.leetcode-cn.com/d10b8c8716d44a84a8fb85bb3e25c7a8f122a9abf97c968fd553f7ea85389afd-image.png)
### 代码
```cpp []
class Solution {
public:
    int countSquares(vector<vector<int>>& m) {
        int n{}; 
        for (int i{}, up[300][300]{}; i < m.size(); i++) {
            for (int j{}, cnt[302]{}; j < m[0].size(); j++) {
                if (m[i][j]) { // 这是统计方n的第一个必要条件
                    n++; // 只要当前单元格为1 那么便计数++ 1代表边长1的正方形
                    up[i][j] = !i ? 1 : up[i-1][j] + 1; // 防止越界 第一次初始化为1
                    int c{2}; // 定义种子 代表方n的边长 从2开始进入循环并++
                    while (c <= up[i][j]) { // 先看上面的累加值 能否满足至少大于等于边长2 这是第二个必要条件
                        if (++cnt[c] >= c) n++; // 左边1个数信息统计 ++cnt[c] 进来即加 因为此时说明前两个必要条件满足. key c代表边长 先加再判断 这是第三个必要条件 达成即说明可以++方n个数 这是左边的规划
                        c++; // 种子累加
                    }
                    while (cnt[c]) cnt[c++] = 0; // 只要当前上格数目不满足 立马重置cnt[c]个数 比如先前有2个 这次上个只有1了 那么连续计数中断清0
                }else for (int i{2}; cnt[i]; cnt[i++] = 0); // 如果当前格为0 那么必然这一行所有记录的cnt全部清0直到个数为0为止 那么后面的方n也不会再有计数了 前面的方n都不满足 后面对左边计数要求更高 更不能满足了
            }
        }
        return n; 
    }
};
```
```java []
class Solution {
    public int countSquares(int[][] m) {
        int[][] up = new int[300][300];
        int n = 0;
        for (int i = 0; i < m.length; i++) {
            int[] cnt = new int[302];
            for (int j = 0; j < m[0].length; j++) {
                if (m[i][j] == 1) { // 这是统计方n的第一个必要条件
                    n++; // 只要当前单元格为1 那么便计数++ 1代表边长1的正方形
                    up[i][j] = i == 0 ? 1 : up[i-1][j] + 1; // 防止越界 第一次初始化为1
                    int c = 2; // 定义种子 代表方n的边长 从2开始进入循环并++
                    while (c <= up[i][j]) { // 先看上面的累加值 能否满足至少大于等于边长2 这是第二个必要条件
                        if (++cnt[c] >= c) n++; // 左边1个数信息统计 ++cnt[c] 进来即加 因为此时说明前两个必要条件满足. key c代表边长 先加再判断 这是第三个必要条件 达成即说明可以++方n个数 这是左边的规划
                        c++; // 种子累加
                    }
                    while (cnt[c] != 0) cnt[c++] = 0; // 只要当前上格数目不满足 立马重置cnt[c]个数 比如先前有2个 这次上个只有1了 那么连续计数中断清0
                }else for (int k = 2; cnt[k] != 0; cnt[k++] = 0);  // 如果当前格为0 那么必然这一行所有记录的cnt全部清0直到个数为0为止 那 么后面的方n也不会再有计数了 前面的方n都不满足 后面对左边计数要求更高 更不能满足了
            }
        }
        return n;
    }
}
```
```python []
class Solution:
    def countSquares(self, m: List[List[int]]) -> int:
        n, up = 0, [[0 for i in range(300)] for i in range(300)]
        for i in range(len(m)):
            cnt = [0 for i in range(302)]
            for j in range(len(m[0])):
                if m[i][j]:
                    n += 1
                    up[i][j] = 1 if i == 0 else up[i-1][j] + 1
                    c = 2 
                    while c <= up[i][j]:
                        cnt[c] += 1
                        if cnt[c] >= c: n += 1
                        c += 1 
                    while cnt[c]: 
                        cnt[c] = 0
                        c += 1
                else:
                    k = 2
                    while cnt[k]: 
                        cnt[k] = 0
                        k += 1
        return n;
```
### 思路
我的目的是让没有头绪的人至少能明白我这个思路 那我的目的就达到了 因为我也经历过艰难的摸索过程 希望你们有所启发
> 语言可能会比较啰嗦 请放空心情先

这题首先肯定有动态规划 这没跑了吧 标签都贴出来了
其次如何用? 这是个难点 首先分析问题 元素全1的正方形 意味着边长为`1` 边长为`2` 边长为`n`才满足需求(以下边长2正方形称为`方2`, 边长3正方形称为`方3`, 以此类推) 但问题是大正方形中必有小正方形 这个该如何统计呢?
分类讨论 **按照单元格为个体** 红色代表当前考虑元素 (边长1的正方形不做讨论 直接遇1 cnt++即可):

`int cnt = 0;`

- 如果某行号r已经有连续2个1了, 那么上面对应连续2个1算一个 `cnt = 1` 即
$$ \color{black}{1}\quad\color{black}{1} $$
$$ \color{black}{1}\quad\color{red}{1} $$

- 连续3个1 新增了一列1 相当于新增了右半边的方2 此时`cnt = 1 + 1 = 2`
$$ \color{black}{1}\quad\color{black}{1}\quad\color{black}{1} $$
$$ \color{black}{1}\quad\color{black}{1}\quad\color{red}{1} $$

- 我们发现 上面 $2\times3$ 矩阵 列数是满足方3的一条边了 另一条还得有3才算一个方3 比如
$$ \color{black}{1}\quad\color{black}{1}\quad\color{black}{1} $$
$$ \color{black}{1}\quad\color{black}{1}\quad\color{black}{1} $$
$$ \color{black}{1}\quad\color{black}{1}\quad\color{red}{1} $$

有人会发现 那这个 $3\times3$ 矩阵只有一个方3 那有多少个方2呢 上面有2个 下面有2个 总共4个 这样又如何算呢? 这就是我们这个算法一个的巧妙之处 我称之为 **"让渡给计算机"** **"在正确的时间点 做正确的事"** 那么整体便都会正确了 一个大正确不是由所有的小正确组成的不是么. 要知道一个函数能运行正确 只要2个条件 **正确的参数 正确的法则** $f$
也就是说 你只要代码给正确了 自然结果也就不会错了 而关键就在于是一个单元格一个单元格扫描的 当处于第二行时 **方2的个数已经被正确计算了 到了第三行时 上面方2的个数已经不用考虑了** 而程序需要判断的只是在当前时间点可能的情况 那么复杂情况变简单化了 
> 此时解决了第一个 多重方n个数的技术问题

详见伪代码(红色为当前单元格元素):
$$ \color{blue}{1}\quad\color{black}{1} $$
$$ \color{blue}{1}\quad\color{red}{1} $$
```
if 当前元素为1:
    if 上面元素也为1 and 左边2个竖1: # 竖1为蓝色
        cnt++
```
这只是考虑方2的 方3呢:
$$ \color{blue}{1}\quad\color{blue}{1}\quad\color{black}{1} $$
$$ \color{blue}{1}\quad\color{blue}{1}\quad\color{black}{1} $$
$$ \color{blue}{1}\quad\color{blue}{1}\quad\color{red}{1} $$
```
if 当前元素为1:
    if 上面有2个竖1 and 左边有6个竖1:
        cnt++
```
剩下的方4..方n以此类推

所以你会发现 我们只要处于方n的最后一格 周围的1满足条件 那么这个便是合法的方n 而对于大方n中蕴含小方n的办法 上面已经提到了 **即在满足小方n条件的第一时间就进行了统计 所以不用担心漏掉上面的方n或前面的**

好了 下面要解决第二个问题就是 **如何动态规划这个合法的左边1个数 上面1个数 让我们在第一时间知道前边是否符合条件?** 其实不难 有个通用的思考办法:

我准确记录信息的多个必要条件从而构成了一个充分条件是什么?

---
- 对于当前元素上边的1 你只需要知道**上边连续1**有多少个 比如方2 上面只需要有1个1 方3则需要2个
- 而左边的1 作为一个整体 我采用二次计数的方法 即再开一个memo 记录下前边满足**竖1**的个数 而左边1**按列计算** 同时**依赖于上边1的信息** 在方2时 如果上边1为1时 那么这列满足 cnt[2]++ 在方3时 如果上边1为2时 那么这列满足 cnt[3]++ 以此类推 左边信息个数对于方2时需要1个 代表左边1列 方3时需要2个 代表左边2列满足 等等

那么便满足上面提到的两个必要信息了 这样就能记录下来了 (但准确记录还需要解决一些问题)

**记录上面1**的伪代码:
```
for i in row:
    for j in col:
        if 当前格为1:
            m[i][j] = m[i-1][j] + 1
```
没错就是简单的 下面格累加上一个数值 这样一层层累加下来 保证某个单元格上面的1个数能被正确记录下来 关键点是`if 当前格为1:` 这样当前格上面为0时 就不用记录了 那么上格数值就为默认的0 那么你在 **"向上看时"** 保证是正确的 0就代表上边没有1 如果是竖直连续的1 才会被累加下来 比如1 -> 2 -> 3...一直到上一格

记录左边1满足条件的列数这个信息 需要参考当前格上边的计数 如果满足当前格为1 同时上边技术为对应值 那么cnt[c]直接++以计数方c左边满足条件的列数
伪码如下:
```
 if 当前格为1:
    while 种子(从2开始) <= 上面竖1个数 + 1:
        对应方n左边信息计数 + 1         
```
这里看到了while 因为可能上面竖1个数是2 那么满足方3 是3 那么满足方4 直到不能满足为止则跳出 保证所有方n左边列数完整记录下来

以为到这里就完了么 不 还有两个需要重置的操作:
一个是当当前格为0时 左边所有方n的计数需要全步清0 同时因为只有当0才进入上面1累加计数 所以当前格计数也为默认值0:
```
if 当前格为0:
    所有对应方n左边计数信息清0, 直到某个方n计数已经为0时跳出 # 因为前面更低计数都不满足 后面必定也不满足了 以此来避免无意义运行
```

第二个是 当上方格不满足某个种子数时 从这个方n其以及后面的左边计数信息全部清0 直到某个方n计数为0时跳出:
```
if 上方行累加计数不满足:
    从这个方n开始后面所有左边个数清0, 直到某个计数已经是0为止
```

最后注意 我描述的是 "上看和左看" 实际上我代码里写的是 **上看时先累计了当前格** 还有**左看时也累加了当前格** 让上边与左边计数刚好与方n相等 方便对应 然后再与种子判断 减少不必要的偏差 所以要注意

好了 到现在为止 所有小问题才算解决 整个代码流程才算完 能想出来和实现它是非常不容易的 但我相信对我提升很大 所以 接着折腾吧 也希望大家能理解 收获

类似 **动态规划题解:** [750. 角矩形的数量](https://leetcode-cn.com/problems/number-of-corner-rectangles/solution/cpython3-shuang-100you-hua-qu-chu-rong-yu-suan-fa-/)

