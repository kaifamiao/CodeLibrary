我本来想着先按起点的大小来排序，排完序后计算上车时的人数就容易一些，后来又发现那么下车怎么算了，然后就爆炸了。
最后我灵机一闪想到了方法，这道题关键是只要人数不超出座位数就行，然后我们就用一个数组来存储每个点的人数就是了，我真是个小机灵鬼^_^。
这道题有限制终点不会大于1000，我们就搞一个数组a[1001]，用来存储每一个点的人数就行了。
我举个栗子：(2,3,6)
由于终点都是先下后上的所以需要终点人就下车，起点和终点前一个点都在车上，在a[3]到a[6-1]都需要+2，全部行程加完后，然后判断数组有没有出现超过座位的数字就行，
时间复杂度O(n)，是不是简单到爆又容易理解！！！
```
 public boolean carPooling(int[][] trips, int capacity) {

	        int n=trips.length;
	        int[] a = new int[1001];
	        for(int i=0;i<1001;i++) {
	        	a[i]=0;
	        }
	        for(int i=0;i<n;i++) {
	        	for(int j=trips[i][1];j<trips[i][2];j++) {
	        		a[j]+=trips[i][0];
	        	}
	        }
	        for(int i=0;i<1001;i++) {
	        	if(a[i]>capacity) 
	        		return false;
	        }
	        return true;
	    }
```

