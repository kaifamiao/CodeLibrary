第一眼看到这个题，立刻产生了遍历的冲动，但是这样好像没有什么意义，于是打算用二分查找来优化一下。主要应该有一下几个步骤：
0.特判数组长度是否为0
**1.找出分割点
2.判断在哪一侧
3.二分查找**
第一步很简单，只要从左往右遍历，判断是否会出现左边的元素大于右边的元素，如果是，那么直接分开，退出循环。用一个变量divP(division point)存储起来。之所以是大于，是因为可能有重复的元素。有两种情况需要特判：
**1.所有元素相等的情况
2.数组已经有序，没有经历旋转**
（两种情况有重叠）

先来看第一种情况：这种情况只需要判断divP的值是否发生改变，所以只需要在最开始的时候给divP初始化的时候赋值为-1，从循环中退出来的时候如果值还是-1，那么return target == nums[0]

第二种情况，解决方法非常暴力，只要在最开始遍历的时候，顺便判断与目标值一不一样就可以了。一样直接返回，这么方便的办法不香吗？而且这样还有一个好处，就是我们可以确定目标只有可能存在于分割点之后，因为分割点之前的都已经判断了。只需要对分割点之后的部分二分查找，也就是说目标值在前面的话复杂度和暴力一样。如果在后面找，那么时间就是
divP+O(log(n-divP))，如果是单纯的暴力就是O(n)。所以我说的是二分优化，算法可以互补一下吧。
下面是代码：
```
func search(a []int, tg int) bool {
	if len(a) == 0 {return false}
	divP := -1
	for i := 0; i < len(a)-1 ;i ++{
		if a[i] == tg {return true
		}else if a[i] > a[i+1] {
			divP = i
			break
		}
	}
	if a[len(a)-1] == tg {return true}
	if divP == -1 {return a[0] == tg}
	return find(&a,divP+1,len(a)-1,tg)
}

func find(a *[]int, i, j, tg int) bool {
	if j - i < 2 {
		return (*a)[i] == tg ||
			(*a)[j] == tg
	}
	if tg > (*a)[(j+i)/2] {
		return find(a,(j+i)/2,j,tg)
	}
	return find(a,i,(j+i)/2,tg)
}

```
