介绍一种基于「分治」的算法来统计"1"的个数。

## 思路

假设现在我们要统计`1001 1011 0101 0010 1001 1111 0001 0010`中“1”的个数。

![](https://pic.leetcode-cn.com/b3a968d3cc9cdbf31fc0ead16bc095d592a8795c3111770f52384c256b95aad4.png)

基于分治的思想，我们先统计出每`2`位有多少个1，如图中第①层所示。

将每`2`位的结果合并，统计出每`4`位有多少个1，如图中第②层所示。

再将每`4`位的结果合并，统计出每`8`位有多少个1，如图中第③层所示。

接着将每`8`位的结果合并，统计出每`16`位有多少个1，如图中第④层所示。

最后将每`16`位的结果合并，统计出每`32`位有多少个1，如图中第⑤层所示，即可得到答案。

------

好了，有了一个直观的感受后，现在考虑如何实现合并的过程。

初始的$n$为： `1001 1011 0101 0010 1001 1111 0001 0010`，

第①层的结果为：`0101 0110 0101 0001 0101 1010 0001 0001`，这该怎么得到呢?

一条语句即可搞定！

`n = (n & (0x55555555)) + ((n >> 1) & (0x55555555));`

很神奇有木有，让我们来分析一下这条语句干了什么！

------

首先，十六进制的常数`0x55555555`转化为二进制是`0101 0101 0101 0101 0101 0101 0101 0101 0101`。

那么，`n & 0x55555555`就可以提取$n$偶数位上的1：

![](https://pic.leetcode-cn.com/24090196012810fac7a05c4182c89be0acd88644a347ccae05f71a40b714c704.png)

`(n >> 1) & 0x55555555`就可以提取$n$奇数位上的1：

![](https://pic.leetcode-cn.com/47ef5cc8e2be3bae6b08eb59a7aa6c06ee41ebc7c0b70ecf8970d6e16626e138.png)

最后，`n = (n & (0x55555555)) + ((n >> 1) & (0x55555555))`把这两个结果相加，即可得到每两位上“1”的个数。

![](https://pic.leetcode-cn.com/b556c6d02f76e42b4ccef0327c9a50c9bfa547b6ae98953a6baf0fb4cab8d48c.png)

这就得到第①层的结果啦。

![](https://pic.leetcode-cn.com/53a29f449682d2b548e6b79911f1aecc4c52e0651a2def3d6308a488b10df18c.png)

------

现在考虑怎么得到第②层的结果。

既然得到每2位的结果是通过常数`0101 0101 0101 0101 0101 0101 0101 0101`，即`0x55555555`得到的。

那么类比一下，每4位就应该是通过常数`0011 0011 0011 0011 0011 0011 0011 0011`，即`0x3333333`得到。

经过第一层，此时$n$更新为`0101 0110 0101 0001 0101 1010 0001 0001`。

那么，`n & 0x33333333`就等于：

![](https://pic.leetcode-cn.com/f4dc49f0113fe6f325b5a19d07754c00ad2c81934cbb4b3ea6b9d07548068bfb.png)

`(n >> 2) & 0x33333333` （注意，现在要右移两位）就等于：

![](https://pic.leetcode-cn.com/74514142e810e0faa2cd44e765626441e79c3e938c7a2f772f78030f20ae1877.png)

最后，`n = (n & (0x33333333)) + ((n >> 2) & (0x33333333));`相加即可得到每四位上“1”的个数。

![](https://pic.leetcode-cn.com/6a63c243e942b0640baf78ca85e2d9e645dfa21aac3275b4a8bf056367b66e73.png)

这就得到第②层的结果啦。

![](https://pic.leetcode-cn.com/e6571009d4d806bccbad256ab589f09acd880df49d100da4be2a1a848573a314.png)

------

以此类推...

合并每4位，得到每8位的结果。常数为：`0000 1111 0000 1111 0000 1111 0000 1111`，即`0x0F0F0F0F`。

因此有`n = (n & (0x0F0F0F0F)) + ((n >> 4) & (0x0F0F0F0F));`

![](https://pic.leetcode-cn.com/5f2b21e69f248e1a146382d68e5c3fe4ffc322ce30b50629d398163a1efd517a.png)

------

合并每8位，得到每16位的结果。常数为：`0000 0000 1111 1111 0000 0000 1111 1111`，即`0x00FF00FF`。

因此有`n = (n & (0x00FF00FF)) + ((n >> 8) & (0x00FF00FF));`

![](https://pic.leetcode-cn.com/6ecfac54a27ed34a88e4ea1d971fcae1b65d6529aaedbefec9a8be61fed7e48d.png)

------

合并每16位，得到每32位的结果。常数为：`0000 0000 0000 0000 1111 1111 1111 1111`，即`0x0000FFFF`。

因此有`n = (n & (0x0x0000FFFF)) + ((n >> 16) & (0x0x0000FFFF));`

![](https://pic.leetcode-cn.com/4dcc8bb8979f4cdefae4ac654ac28c8c14005ceb1b5d5183ac2b0f150e20d0a3.png)

最后得到 `n = 16`，即最开始所求的32位数`1001 1011 0101 0010 1001 1111 0001 0010`中有16个“1”。


## 代码

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        n = (n & (0x55555555)) + ((n >> 1) & (0x55555555));
        n = (n & (0x33333333)) + ((n >> 2) & (0x33333333));
        n = (n & (0x0F0F0F0F)) + ((n >> 4) & (0x0F0F0F0F));
        n = (n & (0x00FF00FF)) + ((n >> 8) & (0x00FF00FF));
        n = (n & (0x0000FFFF)) + ((n >> 16) & (0x0000FFFF));
        return n;
    }
};
```