### 解题思路
对于n大于0的情况下，直接用取模运算看结果是否为1，为1就计数器加1，否则计数器不加1。
难点在于java中的负数处理。
负数的处理如下：
对于-1，其二进制码的由来是（二进制补码）：（这里用八位来举例）
1:首先是1的二进制码：0000 0001
2:然后将对应的位的数字取反：1111 1110
3:然后在取反之后的结果加1: 1111 1111.
观察-1的二进制码：现在我们把-1的二进制码想成是正数的，那么对应的码值就是255.

由以上规律得：
其实对应的负数的码值：就是pow（2，表示的位数）+负数本身。
比如这里的-1就是：pow（2，8）= 256 ，加上负数本身就是255。


由以上思考得：
负数=Integer.MAX_VALUE * 2 + 2 + 负数本身

这里要加2是因为：n位数表示的最大数位pow(2,n-1)-1。比如八位表示的有符号整数位127=pow(2,8)-1

考虑到这里，我们只需要将负数转化为对应的整数。转过来之后必然超过对应的最大值。那么我们只需要就数据的类型上调即可。
将这里的int转为long即可。接下来的操作就和整数一致了。 

### 代码

```java
public class Solution {
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
       int count = 0 ;
       long s;
       if(n < 0){
            //这里必须要有long，不然转不过去
            s = (long)n + 2 + Integer.MAX_VALUE + Integer.MAX_VALUE ;
       }else{
           s = n ;
       }
        while(s != 0){
            if(s % 2 == 1 ){
               count++;
            }
            s = s / 2 ;
        }

           return count;
       

        
        
    }
}
```