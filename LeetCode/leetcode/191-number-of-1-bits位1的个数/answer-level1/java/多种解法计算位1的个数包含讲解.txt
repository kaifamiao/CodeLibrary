这道题最简单暴力的做法就是直接移位，在Java里面直接用无符号的右移，每次判断最低位是不是`1`，把判断为`1`的所有的次数记录起来就可以了。

```java
public int hammingWeight(int n) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        count += n&1;  // 累加1
        n>>>=1;        // 循环右移1位
    }
    return count;
}
```

但是这道题有一个更加有意思的解法，首先对于一个二进制数字比如`10100`，在减一操作之后得到`10011`，比较这两个数字，发现原数字最低位的`1`的右边的数字没有变，而右边的`0`都变成了`1`，而这个`1`变成了`0`，如果对原来的数字和减一的数字进行按位与，就会把最低位的`1`置零。

所以就有了一个神奇的想法，如果我们想把数字`a`最低位的`1`变成`0`而不改变其他位，直接通过`a&(a-1)`就可以得到了，而把所有的`1`都变成了`0`的次数不就是位`1`的个数了吗？

比如对于数字`101`，在经过`a&(a-1) = 101&100 = 100`，再操作一次就是`100&011 = 0`，一共两次操作，最后的结果就变成了`0`。

简单代码如下：

```java
public int hammingWeight(int n) {
    int count = 0;    // 统计置0的次数
    while (n!=0) {
        count ++;
        n = n&(n-1);  // 最低位的1置0
    }
    return count;
}
```

看起来上面两个算法都可以达到我们想要的目的，但是不知道效率怎么样，那就来测试比较一下（添加的java的内置计算`1`个数的方法）

```java
private void test() {
    int t = 10000000;                        // 比较一千万次
    long s = System.currentTimeMillis();
    for (int i = 0; i < t; i++) {
        hammingWeight1(-3);
    }
    System.out.println("Java builtin:\t" + (System.currentTimeMillis()-s));
    s = System.currentTimeMillis();
    for (int i = 0; i < t; i++) {
        hammingWeight2(-3);
    }
    System.out.println("最低位1置0:   \t" + (System.currentTimeMillis()-s));
    s = System.currentTimeMillis();
    for (int i = 0; i < t; i++) {
        hammingWeight3(-3);
    }
    System.out.println("向右移位比较:\t" + (System.currentTimeMillis()-s));
}

// java内置方法
public int hammingWeight1(int n) {
    return Integer.bitCount(n);
}

// 最低位1置0
public int hammingWeight2(int n) {
    int count = 0;
    while (n!=0) {
        count ++;
        n = n&(n-1);
    }
    return count;
}

// 向右移位比较
public int hammingWeight3(int n) {
    int count = 0;
    for (int i = 0; i < 32; i++) {
        count += n&1;  // 累加1
        n>>>=1;        // 循环右移1位
    }
    return count;
}
```

输出的结果如下：

```sh
Java builtin:   10
最低位1置0:     150
向右移位比较:    10
```

虽然上面只是一次测试的结果（每次运行测试的时候结果都不一样），但是可以看出最低位置`0`这个方法效率要比普通的移位操作或者内置的方法慢一个数量级，猜测原因应该是`n=n&(n-1)`这个操作耗时比较高（`n=n&(n-1)`其实是两步，第一步`int a = n-1`，第二步`n=n&a`），而`n&1`或者`n>>>=1`这两个操作都要快很多。

回到测试，多测几次发现java内置的方法有的时候要比向右移位快很多，这就有意思了，得看看它到底是怎么实现的：

```java
public static int bitCount(int i) {
    // HD, Figure 5-2
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```

看完之后一句**卧槽**涌上心头，这写的是什么玩意儿？！这是什么神仙算法！那就来仔细看看这个算法，对每一步进行分解，假设我们的输入是`-1`

```java
public static int bitCount(int i) {                  // i = 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11 11  -1的二进制
    // HD, Figure 5-2                                //     01 01 01 01 01 01 01 01 01 01 01 01 01 01 01 01  
    i = i - ((i >>> 1) & 0x55555555);                // i = 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10  (1)每2位的计算
                                                     //     00 11 00 11 00 11 00 11 00 11 00 11 00 11 00 11  
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333); // i = 0100 0100 0100 0100 0100 0100 0100 0100          (2)每4位求和
                                                     //     0000 1111 0000 1111 0000 1111 0000 1111
    i = (i + (i >>> 4)) & 0x0f0f0f0f;                // i = 00001000 00001000 00001000 00001000          (3)每8位求和

    i = i + (i >>> 8);                               // i = 0000100000010000 0001000000010000            (4)每16位求和

    i = i + (i >>> 16);                              // i = 00001000000100000001100000100000             (5)每32位求和

    return i & 0x3f;                                 // i = 00000000000000000000000000 100000            (6)取最低的6位
}
```

这个过程一共有6步，主要思想就是**分治法**，计算每2、4、8、16、32位中`1`的个数：

1. 第一步也是最重要的一步，统计每2位里面的`1`的个数，比如二进制`11`有两个`1`应该变成统计结果`10`（`11-((11>>>1)&01) = 10`），`10`或者`01`应该变成`01`（`10-((10>>>1)&01) = 01`，`01-((01>>>1)&01) = 01`）
2. 统计每4位里面的`1`的个数，也就是把上面计算得到的两位`1`的个数和相加，比如`01 00`，通过移位并且和掩码`0011`按位与，变成`0000`和`0001`然后求和得到`0001`
3. 统计每8位二进制里面`1`的个数，这一步跟上面又不一样了，不是先用掩码再相加，而是先相加再用掩码，主要不同地方是在上一步两个二位的二进制数字相加可能会溢出，使用掩码之后就会得到错误的结果，比如`10 10`，相加得到`01 00`然后用`00 11`按位与得到`00 00`不是我们想要的结果。当计算8位的个数的时候就不会溢出，因为4位里面`1`的个数最多是4个，也就是`0100`，两个相加最大是`1000`，不会进位到第二个4位，使用掩码能够得到正确的结果，并且可以清除多余的`1`
4. 统计每16位二进制里面`1`的个数，这个时候直接移位相加并没有用掩码，原因很简单，在上一步的每8位里面的的结果的是保存在最后4位里面，并且一定是准确的，直接相加肯定不会溢出8位，结果也一定保存在最右边的8位里面，至于16位里面的左边的8位是什么值我们根本就不关心，所以没有必要用掩码，也不会影响后面的计算
5. 这一步得到32位的和，直接移位相加，因为左右16位的1的个数一定保存在他们各自的右侧8位，相加的结果也不会溢出，一定还在最右的8位里面，左边的24位是什么也没有影响
6. 结果一定在最后的6位里面，因为一共最多只有32个`1`，只需要6位来保存这个值。

这样就通过一个精细的二进制的运算利用分治法得到了最后`1`的个数，不得不感叹这样的做法实在是太妙了！

Java中还有很多精妙的整型数字的位操作方法比如下面的几种，虽然很想介绍一下，不过因为篇幅原因就跳过，因为后面还有更加重要的内容

* `highestOneBit`
* `lowestOneBit`
* `numberOfLeadingZeros`
* `numberOfTrailingZeros`
* `reverse`
* `rotateLeft`
* `rotateRight`


更多内容请看我的[**个人博客**](http://sunshuyi.vip)