### 解题思路
要知道对于一个回文串来说，其**字符数量**满足以下条件之一即可：

- 字符个数为偶数的情况，此时对于每个字符都能找到对子；
- 字符个数为奇数的情况，对于每个字符都能找到对子，但还有一个字符在回文串的中间，它是落单的。

我们每次“贪”的时候，每次“贪”两个相同的字符，从中间开始构建回文串，一个放在最前面，另一个放在最后面。在“贪”完的最后，会出现以下两种情况：

- 如果还剩下 1 个字符的话，则可以将该字符插入到回文串的中间位置，但只能插入 1 次；
- 如果还剩下**任意**个字符的话，并且这些字符只出现过 1 次的话，则可以随便取 1 个字符放在回文串的中间，也只能插入 1 次。

### 分析
1. 以`abccccdd`为例，一开始的时候，需要统计每个字符所出现的次数，如下所示：

```
               abccccdd
+----------------------------------------+
|     回文串     |  a  |  b  |  c  |  d  |
------------------------------------------
|                |  1  |  1  |  4  |  2  |
+----------------------------------------+
```

2. 由于`c`和`d`都出现了两次以上，所以我们先“贪”哪个字符都是可以的。假如从`c`开始，选出两个`c`组成回文串，则`c`的数量就从`4`变成了`2`，如下所示：

```
               abccccdd
+----------------------------------------+
|     回文串     |  a  |  b  |  c  |  d  |
------------------------------------------
|                |  1  |  1  |  4  |  2  |
------------------------------------------
|       cc       |  1  |  1  |  2  |  2  |
+----------------------------------------+
```
3. 此时，还可以继续“贪”字符`c`，则`c`的数量就变成了`0`，如下所示：

```
               abccccdd
+----------------------------------------+
|     回文串     |  a  |  b  |  c  |  d  |
------------------------------------------
|                |  1  |  1  |  4  |  2  |
------------------------------------------
|       cc       |  1  |  1  |  2  |  2  |
------------------------------------------
|      cccc      |  1  |  1  |  0  |  2  |
+----------------------------------------+
```
4. 此时的字符`c`已经“贪”完了，接下来就来到了字符`d`，如下所示：

```
               abccccdd
+----------------------------------------+
|     回文串     |  a  |  b  |  c  |  d  |
------------------------------------------
|                |  1  |  1  |  4  |  2  |
------------------------------------------
|       cc       |  1  |  1  |  2  |  2  |
------------------------------------------
|      cccc      |  1  |  1  |  0  |  2  |
------------------------------------------
|     dccccd     |  1  |  1  |  0  |  0  |
+----------------------------------------+
```

5. 通过上面可以看到，字符`d`也被“贪”完了。此时字符`a`和`b`落单了，那么我们可以随便选一个字符将其插入到回文串的中间位置，使其构成最终的回文串即可。这里我选择了字符`a`，如下所示：

```
               abccccdd
+----------------------------------------+
|     回文串     |  a  |  b  |  c  |  d  |
------------------------------------------
|                |  1  |  1  |  4  |  2  |
------------------------------------------
|       cc       |  1  |  1  |  2  |  2  |
------------------------------------------
|      cccc      |  1  |  1  |  0  |  2  |
------------------------------------------
|     dccccd     |  1  |  1  |  0  |  0  |
------------------------------------------
|     dccaccd    |  0  |  1  |  0  |  0  |
+----------------------------------------+
```

好了，此时已经是最终的结果了，已经不能再继续“贪”了，因为每个字符出现的次数都已经等于 0 了。也不能将字符`b`进行插入了，因为如果将`b`插入回文串的话，就构不成所谓的回文串了。

> 这里将英文字母对应的 ASCII 值给出，便于查看：
> a~z 对应 97~122
> A~Z 对应 65~90

### 代码（含注释）
```
class Solution {
    public int longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        // 小技巧：如果题目给出的只是英文字母的话，最好开一个数组而不是哈希表，
        // 因为数组比哈希表更加单纯、简单。
        // 这一小部分代码就是先将字符串 s 转换成字符，然后统计每个字符所出现的次数
        int[] freqs = new int[128];
        for (int i : s.toCharArray()) {
            freqs[i]++;
        }
        
        // 用于保存最后的结果，进行返回
        int res = 0;
        // 用于统计最后落单的那个字符，对应上述步骤 5
        int odd = 0;
        for (int freq : freqs) {
            // 如果某个字符出现的次数为偶数次，则回文串的长度就是该字符出现的次数，
            // 例如 cccccc 出现了 6 次，则可以构成一个长度为 6 的回文串；
            // 如果某个字符出现的次数为奇数次，则回文串的长度就是该字符出现的次数再减一，
            // 例如 aaaaa 出现了 5 次，则可以构成一个长度为 4 的回文串。
            res += (freq % 2 == 0) ? freq : (freq - 1);
            // 如果某个字符最后还剩下 1 次，则将这个字符插入到回文串的中间位置
            if (freq % 2 == 1) {
                odd = 1;
            }
        }
        res += odd;
        return res;
    }
}
```

### 代码（不含注释）
```
class Solution {
    public int longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }

        int[] freqs = new int[128];
        for (int i : s.toCharArray()) {
            freqs[i]++;
        }
        
        int res = 0;
        int odd = 0;
        for (int freq : freqs) {
            // 下面一行代码等价于：res += freq / 2 * 2;
            // 下面一行代码也等价于：res += ((freq >> 1) << 1);
            res += (freq % 2 == 0) ? freq : (freq - 1);
            if (freq % 2 == 1) {
                odd = 1;
            }
        }
        res += odd;
        return res;
    }
}
```

### 全部题解
《剑指Offer》的全部题解与 LeetCode 的部分题解在此下方，其中还包含**基础算法**与**进阶算法**，欢迎查看~
[LeetCode、SwordToOffer and other algorithms in Java.](https://github.com/dyfloveslife/LeetCodeAndSwordToOffer)