### 思路
1. 首先，使用collections.Counter完成字符的计数。

2. 然后分析：在字符串中，每个字符的数量要么是偶数，要么是奇数，那么：
    - 若是偶数x，可以在回文串的两边各放一半的字符，答案加x。
    - 若是奇数y，可以先不管多余的一个字符，把剩下的偶数个字符平均分成两半放在回文串的两边，答案加y-1。
    > **注**：对于这个操作，可以通过if判断奇偶实现；也可以通过减去其二进制最低位实现；这里用的是另一种方法：由于-2的二进制除了最低位为0，其余位均为1，因此将x和y与-2进行二进制与运算，即可实现偶数不变，奇数减一。

3. 最后，如果所有字符的数量都是偶数，那么回文串的长度和原字符串相同，否则比原字符串短，需要把奇数个字符中的其中一个多余的字符放在回文串中间，而剩余的字符由于无法配对而舍弃，答案加1。

### 代码：
```python
class Solution:
    def longestPalindrome(self, s: str) -> int:
        count = collections.Counter(s)
        ans = sum(cnt & -2 for cnt in count.values())
        return ans + 1 if ans < len(s) else ans
```