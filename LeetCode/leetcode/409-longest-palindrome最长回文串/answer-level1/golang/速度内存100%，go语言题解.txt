速度内存均100% 刷leetcode来写的第一个题解

```go
func longestPalindrome(s string) int {
	var dict [123]int
	for _, v := range s {
		dict[v] += 1
	}
	count := 0
	for _, v := range dict {
		count += v / 2 * 2
	}

	if count == len(s) {
		return count
	} else {
		return count + 1
	}
}
```
首先说明，开的数组比较大，其实只需要开长度为26*2的数组的，这里开长度为123的数组的原因在后面说明，直接在字符的ascii值的索引位置改变计数的值。

可以把这里的回文串分为两种，长度为奇数和长度为偶数的，比如`abba`和`abcba`

思路较为简单，计算每个字符出现的次数，如果这个字符`出现的次数>=2`，就可以形成出形如`a*a`的回文串，这个字符可以构成不大于他出现次数的最大偶数长度的回文串，比如 `a`出现了`5`次，那么可以构成`aa*aa`，注意中间的`*`的位置要留给其他的回文串

那么我们开个字典计算出现的次数，key就是这个字符，value就是出现的次数。但是go里面写字典比较麻烦（我比较菜），可以开一个数组，把前面的key简化成这个字符的`ascii`码，只需要开长度为`26*2`的数组就可以了，但是这样每次计算次数的时候都需要做个减法，消耗时间，所以可以直接开一个ascii码最大的字符的长度的数组。空间换时间。  不过我没有去计算，多开了的数组和多消耗的时间具体是多少。

遍历给出的字符串之后，统计的到了每个字符出现的次数。如果次数是奇数，那么回文串的长度加上次数再减一，如果次数是偶数，那么直接加到回文串的长度里面，可以`if`判断，也可以`x/2*2`计算。