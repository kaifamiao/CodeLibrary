### 解题思路
回文串的特点是沿中心轴对称，因此除了正中心落单的字符，所有其他的字符都能在对称轴的另一边找到配对。

比如我们构建的回文串acdbdca,只有正中心的字母b没有配对，

因此在这个回文串中，只有正中心的那个字符的个数是奇数个，其他的字符一定是偶数个。

于是我们可以统计原字符串中，哪些字符是奇数个。

比如有奇数个的字符有两个，odd=2,我们只关心a和b的个数是奇数，具体是多少并不关心，

因为无论这个奇数是多少，最后落单的字符都只有1个，比如a有13个，其中12个都能两两配对，放到回文串中，

只剩下一个落单的，但回文串中只能放一个落单的字符，就是把它放在正中心。

因此有2n个字符，他们的个数都是奇数个，那其中有2n-1个是用不上，要舍弃的。unUsed=odd-1,

如果所有的字符都是偶数个，那所有的字符都能拿来做为回文串，没有一个是无用的。

于是unUsed=max(0, odd-1),现在只需要知道有多少字符是用不上的，用原始字符串的长度减去用不上的字符个数。

得到的就是最长回文串的长度。这种方法需要遍历一遍字符串，统计每个字符出现的次数。

因此时间复杂度是O(n)。n是字符串长度，需要使用一个数组来记录每个字符出现的次数，

假设字符集大小是m，那么空间复杂度是O(m)

### 代码

```go
// Time: O(n), Space: O(m) n是字符串长度，m是字符集大小
func longestPalindrome(s string) int {
	// 初始用于计数的数组,因为只有大小写英文字符
	d := make([]int, 256) // 所以把数组设置成ASCII字符集的大小
	oddNum := 0           // 定义数量是奇数的个数
	// 遍历字符串，统计每个字符出现的次数
	for _, c := range s {
		d[c]++
	}
	// 接下来统计字符出现的次数
	for _, count := range d {
		if count%2 == 1 {
			oddNum++
		}
	}
	// 不能使用的字符，在0和odd中取较大值
	unUsed := 0
	if oddNum > 0 {
		unUsed = oddNum - 1
	}
	// 最后用字符串的长度减去无用字符串的个数
	return len(s) - unUsed
}
```