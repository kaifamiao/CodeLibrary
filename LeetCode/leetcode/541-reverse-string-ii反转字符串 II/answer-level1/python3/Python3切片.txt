#### 题目
给定一个字符串和一个整数 $k$，你需要对从字符串开头算起的每个 $2k$ 个字符的前$k$个字符进行反转。如果剩余少于 $k$ 个字符，则将剩余的所有全部反转。如果有小于 $2k$ 但大于或等于 $k$ 个字符，则反转前 $k$ 个字符，并将剩余的字符保持原样。
输入: `s = "abcdefg", k = 2`
输出: `"bacdfeg"`
#### 思路
按示例，$2k=4$，字符串`"abcdefg"`可分为两部分`"abcd"`和`"efg"`，第一部分反转前$2$个字符`"ab"`，第二部分只反转前$2$个字符`"ef"`，剩余部分不变。于是结果为`"ba"+"cd"+"fe"+"g"`。
一句话翻译过来就是：每间隔$k$个反转$k$个字符。

剩余字符长度$0\le lengh < 2k$，将其再分为两部分：
- 若$0\le lengh < k$，还不够满足“前$k$个字符”，因此剩余字符全部反转；
- 若$k\le lengh < 2k$，“前$k$个字符”是“**完整**”的，直接反转即可。

利用Python切片其实不需要考虑“剩余字符”的长度这一问题，比如`s="abcdefg"`反转前$k$个字符：若$k=5$，反转部分直接写`s[4::-1]`；若$k=10$，也可直接写`s[9::-1]`（此时$9>len(s)$）。
#### 代码
因为`[0,k]`反转了，`[k,2k]`不需反转，因此还应加上$k \rightarrow 2k$这一段。代码如下：
```python
def reverseStr(s, k):
    result=''
    for i in range(0,len(s),2*k):
        tmp=s[i:i+k]
        tmp=tmp[::-1]+s[i+k:i+2*k]
        re+=tmp
    return result
```

#### 结果
貌似每次内存都是12.9MB?
![QQ截图20191230165900.png](https://pic.leetcode-cn.com/a3c996a525f8a2be08a9481be2f6d8bfe2434adf408d9140e8be4facf528ebcb-QQ%E6%88%AA%E5%9B%BE20191230165900.png)
