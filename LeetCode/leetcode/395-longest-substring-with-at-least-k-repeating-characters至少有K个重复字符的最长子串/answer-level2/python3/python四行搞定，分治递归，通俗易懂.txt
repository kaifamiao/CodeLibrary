# 简单分析

假设给定字符串为s，首先我们将s分割为以下两种类型的子字符串：
类型1：假设为s1，当前字符串只包含一种字符，即`set(s1) == 1`，且`len(s1) < k`
类型2：假设为s2，当前字符串包含至少一种字符，即`set(s2) >= 1`，且每种字符出现的次数均不小于k

我们暂不考虑特殊情况。
那么，我们的问题其实可以理解为：从s中找出所有的s2，获取每个s2的长度，返回最大值。

## 进一步做问题分解
大问题：给定的字符串s
分割条件：出现了s1
分解后的小问题：含有s2的子字符串
更新结果：从小字符串到更长的字符串，获取当前符合条件最长的s2的长度，然后更新

## 递归的两个条件
### 基线条件
1. 当前处理的**字符串**每个字母重复的次数均不小于k时，返回当前字符串的长度
2. 当前字符串长度小于k，返回0       

### 递归条件
当前处理的**字符**出现的次数小于k，以当前字符为分隔符切割当前字符串，对切割好的子字符串依次调用函数本身

## 更新条件
递归会把字符串s一次次的切分，直到出现`s.count(c) >= k`或`len(s) < k`的情况，而每次由大到小的切分，都可能出现满足类型2的s2字符串出现。
那么动态规划部分要做的就是，与历史最长的s2长度比较，然后更新，直到迭代完整个字符串

结果：`max([len(s2) for s2 in s2_list])`

# 代码实现

## 初步实现

```
def longestSubstring(self, s, k):
    if len(s) < k:
        return 0
    # 获取出现次数最少的字符
    c = min(set(s), key=s.count)
    if s.count(c) >= k:
        return len(s)
    return max(self.longestSubstring(t, k) for t in s.split(c))
```

## 进一步简化

主要优化点在于取消了`c = min(set(s), key=s.count)`这一步以及对`len(s) < k`的初始检查，】。
当s仅存在一个字符串时，例如`s='a'`，`s.split(c)`返回`['', '']`，然后再下一次调用时`s==''`，空字符串会直接跳过循环`for c in set(s)`，直接返回`len(s)`即`0`
```
def longestSubstring(self, s, k):
    for c in set(s):
        if s.count(c) < k:
            # 满足分割条件，进行分割
            return max(self.longestSubstring(t, k) for t in s.split(c))
    # 如果每个字符出现的次数均不小于k，则返回当前字符串的长度
    return len(s)
```
