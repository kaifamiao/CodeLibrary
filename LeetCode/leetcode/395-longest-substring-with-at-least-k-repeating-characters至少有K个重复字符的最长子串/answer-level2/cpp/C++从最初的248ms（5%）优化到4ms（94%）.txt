# 基本思路
思路的话主要就是分治，相信大家都很容易理解。
先遍历一遍统计字符串S中每个字母出现的次数,然后再遍历一遍找到出现次数小于k的一个字母对应的位置（假设S[mid]对应的字母出现次数小于k）。那么包含S[mid]的子串显然不可能符合题目要求。

所以原问题求S[start,end]字符串对应的答案就等价于求S[start,mid-1]和S[mid+1,end]对应的2个答案的最大值。也即longestSubstring(S[start,end])=max(longestSubstring(S[start,mid-1]) , longestSubstring(S[mid+1,end]))

(如果mid不存在，则说明原字符串S完全符合要求，所以答案即为S.size())

# 最初跑248ms的3个原因
我一开始就是完全按照那个基本思路直接递归求解，但是这样的话会非常慢。可能原因如下：
(以下列举的字符串中，‘数字’ 对应数量小于k的字符)
- **......1234......**   若字符串如左边所示，我们不做处理直接递归求解时，找到的第一个数量小于k的字符为**1**，以此为基准点分割出来的左右两个子串分别为
**......** 和 **234......**，在右子串中，前3个字符均为数量小于k的字符，那么在右子串继续递归计算的时候，又不得不重复计算多三次每个字符出现的次数。

所以在第一次递归时，如果能直接把**1234**这个整体作为一个分隔点(而不是只把**1**作为分隔点)，将原字符串分隔成为 **......** 和 **......** 再递归，则能节省时间，尤其是这个整体的长度越长时，节省的时间越多。


- **......1......2......3......4......**  若字符串如左边所示，如果我们不做任何处理直接递归求解时，找到的第一个数量小于k的字符为**1**，以此为分隔点分隔出来的左右两个子串分别为 **......** 和 **......2......3......4......** 
这样的话右子串在继续递归计算时，则不得不重复计算多几次每个字符出现的次数，然后找到下一个字符 **2**作为分隔点继续递归，而这些实际在第一次递归时，已经求出来了。

所以在第一次递归时，如果能以1 2 3 4作为分隔点分割出5个子串，再分5次去递归，则能节约不少时间。

- **......1......** 若字符串如左边所示，假设以1作为分隔点，左子串递归求解得到的答案是left_ans，如果此时右子串的长度right_length<=ans，那么显然这个时候右子串得到的答案right_ans显然<=right_length，那么这时候递归右子串没有意义。

所以如果能提前判断是否有必要递归计算这个子串，不必要时不递归计算该子串则能节省一些时间。

# 优化
我优化的方法就是针对上面提到的三个原因。
具体思路如下
用一个pre记录下一个可能的子串的起始位置，cur记录当前位置,ans记录递归对应子串得到的答案的最大值（都初始化为0）
1. S[cur]对应的字符出现次数超过k，则令cur=cur+1
2. 若S[cur]对应的字符出现次数小于k，说明当前cur即为一个分隔点 
2.1 若当前子串S[pre,cur-1]的长度小于等于ans，则不递归；否则递归计算该子串得到对应的结果a，然后令ans=max(ans，a)
2.2从cur位置开始一直往后找，直到找到第一个位置end，满足S[end]对应的字符出现次数不小于k。所以下一个子串的开始位置pre=end，cur也从下一个可能的子串开始，所以cur=end；
3. 若不存在S[cur]满足S[cur]出现的次数小于k，则说明当前的字符串就符合要求，所以直接返回当前字符串的长度。


# 代码
```C++ []
class Solution {
public:
	int longestSubstring(string s, int k) {
		//特殊情况
		if (s.size() == 0)
			return 0;

		//count记录s中26个字母出现的次数
		//count[0]-->a的次数  count[1]-->b的次数...以此类推
		vector<int>count(26, 0);

		
		//numOfLessThanK记录有多少种字母的数量大于0小于k
		int numOfLessThanK = 0;
		for (char &x : s) {
			//增加了一个新的字母，则可能的小于k的字母种类+1
			if (count[x - 'a'] == 0)
				numOfLessThanK++;

			count[x - 'a']++;
			
			//有一种字母达到了数量k,则小于k的字母种类-1
			if (count[x - 'a'] == k)
				numOfLessThanK--;
		}
		//不存在小于数量k的字母，则说明s已经符合要求
		if (numOfLessThanK == 0)
			return s.size();

		//pre记录上s中上一个出现次数>=k的索引位置
		//cur用来记录当前遍历到的位置
		//ans用来存最大长度
		int pre = 0, cur = 0;
		int ans = 0;
		while (cur < s.size()) {
			//当前cur位置上对应的字母数量小于k
			if (count[s[cur] - 'a'] < k) {
				//递归计算[pre,cur-1]区间上的子串ss对应的答案
				string ss = s.substr(pre, cur - pre);
				// 如果子串长度小于等于当前的候补答案ans
				// 则没必要计算这个子串
				if (ss.size() > ans) {
					ans = max(ans, longestSubstring(ss, k));
				}

				int end = cur;
				//end为从cur位置开始下一个出现字母次数大于k的位置
				while (end < s.size() && count[s[end] - 'a'] < k)
					end++;
				//[cur,end-1]这个区间的字母出现次数全部小于k
				//所以下一个可能的子串开始位置pre=end
				pre = end;
				cur = end;
			}
			else
				cur++;
		}
		//前面while循环退出是cur=s.size()
		//因为循环是每到一个cur位置上对应的字母数量小于k
		//时就计算前一个子串。。
		//所以有可能最后一个子串[pre,cur-1]没计算过
		if (pre < s.size()) {
			string ss = s.substr(pre, cur - pre);
			//同样，如果子串长度小于等于当前的候补答案ans
			//则没必要递归计算
			if (ss.size() > ans) {
				ans = max(ans, longestSubstring(ss, k));
			}
		}

		return ans;
	}
};
```

