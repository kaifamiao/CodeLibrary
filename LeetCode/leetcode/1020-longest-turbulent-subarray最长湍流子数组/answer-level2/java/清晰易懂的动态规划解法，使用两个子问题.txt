首先我们要看懂题目的意思。我们可以把数组中 `A[i+1] > A[i]` 称为“上升段”，把 `A[i+1] < A[i]` 称为“下降段”，`A[i+1] == A[i]` 的称为“水平段”。那么，我们要找的是一段交替上升下降的子数组。例如示例输入 `[9,4,2,10,7,8,8,1,9]`：

![波形子数组示意图](https://pic.leetcode-cn.com/85bd024ca1de1c4a6953b552b3868085c9243a8ba8fddab344d4064ce905f368.jpg)

我们要找的就是这种上升和下降交替的波形子数组，也也是题目叫“湍流”（turbulent）子数组的原因。

我们发现，波形数组有一个很明显的递推关系：我们在已有的波形子数组上，再加一段上升或者下降段，就可以得到更长的波形子数组。这样一个递推关系提示我们可以用动态规划的方法来解这道题。

我们可以这样定义子问题：定义 $f(k)$ 为数组 `A[0..k)` 中，以 `A[k-1]` 结尾的最长波形子数组。注意这里的附加条件**以 `A[k-1]` 结尾**，这是因为只有最右侧的波形子数组才可以和新加入的上升/下降段连接起来。这是子数组类动态规划题目中常见的定义子问题方法，例如 [53. 最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/) 中的子问题也是有这种方法定义的。

需要注意的是，波形数组的连接是有条件的。如果波形数组的最后一段是“上升”，就需要连上一段“下降”才是合法的波形数组；如果波形数组的最后一段是“下降”，就需要连上一段“上升”才是合法的波形数组。我们在写子问题递推关系的时候需要注意这一点。

那么，我们需要分类讨论子问题的递推关系。对于子问题 $f(k)$：

+ 如果 $f(k-1)$ 波形数组的最后一段是“上升”，且 `A[k-1]` 和 `A[k-2]` 之间是“上升”，那么 $f(k) = 2$；
+ 如果 $f(k-1)$ 波形数组的最后一段是“上升”，且 `A[k-1]` 和 `A[k-2]` 之间是“下降”，那么 $f(k) = f(k-1) + 1$；
+ 如果 $f(k-1)$ 波形数组的最后一段是“下降”，且 `A[k-1]` 和 `A[k-2]` 之间是“上升”，那么 $f(k) = f(k-1) + 1$；
+ 如果 $f(k-1)$ 波形数组的最后一段是“下降”，且 `A[k-1]` 和 `A[k-2]` 之间是“下降”，那么 $f(k) = 2$；
+ 如果 `A[k-1]` 和 `A[k-2]` 之间是“水平”，那么 $f(k) = 1$；

什么？一个看似简单的问题竟然要分这么多情况考虑，是不是看得头都大了？

通常来说，如果你发现子问题的递推关系过于复杂，那可能是子问题定义得不是很好。既然我们总是要判断波形数组的最后一段是上升还是下降，那我们为何不在子问题定义时就把它们区分开来呢？

是的，我们可以定义两个子问题，分别对应最后一段上升和下降的波形子数组：

+ 子问题 $f(k)$ 为数组 `A[0..k)` 中，以 `A[k-1]` 结尾，且最后一段为“上升”的最长波形子数组；
+ 子问题 $g(k)$ 为数组 `A[0..k)` 中，以 `A[k-1]` 结尾，且最后一段为“下降”的最长波形子数组。

那么我们的子问题递推关系就变得清晰了起来：

+ 如果 `A[k-1]` 和 `A[k-2]` 之间是“上升”，那么 $f(k) = g(k-1) + 1$，$g(k) = 1$；
+ 如果 `A[k-1]` 和 `A[k-2]` 之间是“下降”，那么 $f(k) = 1$，$g(k) = f(k-1) + 1$；
+ 如果 `A[k-1]` 和 `A[k-2]` 之间是“水平”，那么 $f(k) = 1$，$g(k) = 1$。

我们可以以此写出题解代码：

```Java []
public int maxTurbulenceSize(int[] A) {
    if (A.length <= 1) {
        return A.length;
    }
    
    int N = A.length;
    int[] f = new int[N+1];
    int[] g = new int[N+1];
    f[1] = 1;
    g[1] = 1;
    
    int res = 1;
    for (int k = 2; k <= N; k++) {
        if (A[k-1] > A[k-2]) {
            f[k] = g[k-1] + 1;
        } else {
            f[k] = 1;
        }
        if (A[k-1] < A[k-2]) {
            g[k] = f[k-1] + 1;
        } else {
            g[k] = 1;
        }
        res = Math.max(res, f[k]);
        res = Math.max(res, g[k]);
    }
    return res;
}
```

这段代码还可以进行空间优化。我们发现 $f(k)$、$g(k)$ 只和 $f(k-1)$、$g(k-1)$ 有关，我们完全可以只用一个变量保存中间结果：

```Java []
public int maxTurbulenceSize(int[] A) {
    if (A.length <= 1) {
        return A.length;
    }
    
    int f = 1;
    int g = 1;
    int res = 1;
    for (int k = 1; k < A.length; k++) {
        int f2;
        if (A[k] > A[k-1]) {
            f2 = g + 1;
        } else {
            f2 = 1;
        }
        int g2;
        if (A[k] < A[k-1]) {
            g2 = f + 1;
        } else {
            g2 = 1;
        }
        f = f2;
        g = g2;
        res = Math.max(res, f);
        res = Math.max(res, g);
    }
    return res;
}
```

---

如果你觉得本文对你有帮助，欢迎关注我的公众号《面向大象编程》，其中的《LeetCode 例题精讲》系列文章正在写作，不仅有题解，更能让你学会解题的通用思路，举一反三！

![](https://pic.leetcode-cn.com/686f04878b7b483ba9ca0679fba44fce69f4fb4cc9d1d9b9b0327b3f18ca99a6.jpg)