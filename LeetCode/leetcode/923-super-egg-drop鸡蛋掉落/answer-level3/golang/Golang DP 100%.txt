### 解题思路
本题的关键点有三个：K(给的鸡蛋个数)，N(楼层数)，m（扔鸡蛋的次数）
在记忆递归+二分搜索的方法中，虽然可以实现但效率真的很差（5%），因为我们穷举的方法（顺序）不对，也体现在了这种方法实现迭代dp的复杂性上。
于是换个思路，用K,m推N，也就是找给K个鸡蛋，扔m次最多可以测验的楼层。
递推关系：我们使用之前的状态得到当前的状态，对dp[K][m]的上一状态来说有两种情况：
> 存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。

1.N层楼，我们知道了F+1一定会碎，于是我们试到了F层，它没有碎。此时正好用了K个鸡蛋，m-1步。
2.N层楼，我们知道了F-1一定不会碎，于是我们试了F层，它碎了，此时正好用了K-1个鸡蛋，m-1步

第一种情况，转移到当前状态就是多了一步尝试，应当是我们知道F+2一定会碎，于是我们试到F层之后鸡蛋没碎，再用一次，没碎，但多试了一次（m步）
第二种情况，转移到当前状态不仅多了一步尝试，而且还多浪费了一个鸡蛋。同理，应该是我们知道F-2一定不会碎，于是我们试到F层之后鸡蛋还是碎了，但我们还有一个鸡蛋和一次机会，这次还是碎了（K个鸡蛋，m步）

于是我们就知道了，当前状态可以表示两个子状态：
![image.png](https://pic.leetcode-cn.com/4ad4ec30ad1393d0a99ab19e2074618f99c702ae587b691eaa62b3e4138f0275-image.png)

**m增加的过程中N不是线性增加，所以只要N大于参数N，那么就可以返回**



### 代码

```golang
func superEggDrop(K int, N int) int {
    if K == 1 {
        return N
    }
    if N == 0 {
        return 0
    }
    var (
        dp = make([][]int,K+1)
        m = 0
    )
    for i := 0; i < K+1; i ++ {
        dp[i] = make([]int,N+1)
    }
    for dp[K][m] != N {
        m ++
        for k := 1; k < K+1; k ++ {
            dp[k][m] = dp[k][m-1] + dp[k-1][m-1] + 1
            if dp[k][m] > N {
                return m
            }
        }
    }
    return m
}
```