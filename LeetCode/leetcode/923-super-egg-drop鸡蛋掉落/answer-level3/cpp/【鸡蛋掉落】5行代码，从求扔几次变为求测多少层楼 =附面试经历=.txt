### 思路
1. 先将问题从 N 个楼层，有 K 个蛋，求最少要扔 T 次，转变为有 K 个蛋，扔 T 次，可以测试出多少个区间。

2. 我们只能站在楼层上扔蛋测试，楼层相当于点，区间是点与点之间的线段。是从 0 - N ，所以区间比楼层多一。
	> 比如： 1 层楼， 1 层碎了（F <= 1），1 层没碎 （1 < F）。
	> 比如： 2 层楼，有 1 层碎了（F <= 1）， 1 层没碎但 2 层碎了（1 < F <= 2）， 2 层没碎（2 < F）。

3. 如果只有 1 个蛋了，蛋不能碎，只能从低到高一层一层的判断，所以有 T 次机会，就只可以判断出 T + 1 个区间。

4. 当只有 1 次机会时，无论有多少个蛋，你能测试出的楼层都只有 2 层。

5. 其他情况时，递归。【可以测试的区间】 == 【蛋碎了减 1 个，机会减 1 次】 + 【蛋没碎，机会减 1 次】

### 图解
<![图片.png](https://pic.leetcode-cn.com/28747cba6c6a6323a95e188877d133d11c890d6e768fca04af929243bbe751a0-%E5%9B%BE%E7%89%87.png),![图片.png](https://pic.leetcode-cn.com/5a309b9b458c14d45731be8a59fd8b2c04c8d3b7232a9cd8c2b31aa91e2cbcbe-%E5%9B%BE%E7%89%87.png),![图片.png](https://pic.leetcode-cn.com/64cf4b31b9ad8fa34c77b102c2bdeb0979081c9bb6c938e5fbef8c566d64f61a-%E5%9B%BE%E7%89%87.png),![图片.png](https://pic.leetcode-cn.com/e74124755b518722988ba696157161c65e7f50b83a80fcf300ce26e9c5637219-%E5%9B%BE%E7%89%87.png)>


### 答题
```C++
int fun(int K, int T)	// 计算 K 个鸡蛋，扔 T 次，可以覆盖多少个区间
{
	//if (T == 1) return 2;
	//if (K == 1) return T + 1;
	if (T == 1 || K == 1) return T + 1;	// 上面两句可以合并成这一句

	return fun(K - 1, T - 1) + fun(K, T - 1);
}

int superEggDrop(int K, int N) 
{
	int T = 1;	// 测试机会
	while (fun(K, T) < N + 1) T++;
	return T;
}
```

### 面试中遇到的子问题
一次面试中，面试官问了这道题的子问题。

```
有 2 个蛋，用一座 100 层的楼，要使用最少次数测试出蛋几层会碎（F）。
问第一次应该从几层扔。
```

分析题意，其实本质上是和本题是一样的。
相当于`int ans = superEggDrop(2, 100);`，得到 14 次。
因为最少需要 14 次，所以第 1 次扔在 14 层，如果蛋碎了，接下来 1~13 这个区间就只能一次一次尝试了。
> 接下来第二次扔蛋，因为扔过 1 次了，接下来的区间大小只有 12 ，只能够 15~26 ，所以扔到 27 层。


但是现场没有纸笔，不考代码，脑容量不够递归。
考虑到上面分析，推到最后一次，即区间大小是 0 ，再往前一次，区间大小是 1 。
所以在蛋的数量固定为 2 的情况下，次数和楼层的关系应该是：
扔 1 次，覆盖 1 层。
扔 2 次，覆盖 3 层。
扔 3 次，覆盖 6 层。
即：1 + 2 + 3 + ... + 14 > 100
所以答案是 14 次。


### 其它思考
> 这个问题简化后，其实和`猜数字`（猜一个数字，返回大了小了还是对了）是一个类型的，可以对比着思考。


### 致谢
感谢您的观看，希望对您有帮助，欢迎热烈的交流！  

[我的leetcode](https://github.com/AhJo53589/leetcode-cn)