LeetCode新手的第一篇题解，看到很多题解也就是上来就说要逆序查找，但是直接这样说有点反直观，字典序难道不是顺序看的嘛？实际上我本身也是从顺序开始思考，逆序本身只是思考后的结果而已。
（以下分析如果有不严谨的地方欢迎评论指出）

提交时C++用时24ms超过99.5%的同类提交。

本身想这题也不是一遍就想出来正确算法，最开始有点感觉，后来分析了一下才逐步明晰。

首先看看这道题的要求：1. 比原序列字典序小  2. 是所有满足条件1中最大的那个

+ 一次交换后字典序就变小，交换的两个数，肯定原先是大数在前，小数在后。交换后，小数换到前面来，大数换到后面去。
+ 怎么保证maximal呢？我们知道无论答案是什么，一定是比原序列小的。再加上原序列和交换后序列本身只有两位不同，其他的位数都一样，那么被改变的那两位中，较高的一位肯定在序列中的位数越低越好（因为一旦位数更高，变小的就更多了）。至此可以知道，我们要先找到变化的两位中较高的那一位，再找较低的那一位；且找较高的那一位时，只能从后往前找（因为找到了就可以得到答案了呀，这个答案自然就是所有满足条件的答案中，较高位最低的一个），由条件1，为了最大，较低位一定是这个较高位身后比它更小且位数最高的那一位（也就是精选题解中说的，比它小的最左边的那个数），为什么强调最左呢？这是因为当有几个更小的数相同时，应该选择最左边的数。（参考样例 [3, 1, 1, 3] 的结果）
+ 当然，如果找不到这样搭配的较高位和较低位，说明这个序列本身已经是字典序最小的了。

最后贴上代码：
```
class Solution {
public:
    vector<int> prevPermOpt1(vector<int>& A) {
        int alen = A.size();
        for(int i = alen - 1; i >= 0; i--) {
            int maxId = -1, maxi = -1;
            for(int j = i + 1; j < alen; j++) {
                if(A[i] > A[j]) {
                    if(maxi < A[j]) {
                        maxId = j;
                        maxi = A[j];
                    }               
                }
            }
            if(maxId == -1)  continue;
            else {
                swap(A[i], A[maxId]);
                break;
            }
        }
        return A;
    }
};
```

