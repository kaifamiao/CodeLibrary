关键字：按字典序排列小于 A 的最大可能排列。其实就是找到当前排列的上一个排列。
具体看注释
```
func prevPermOpt1(A []int) []int {
    // 从后往前找
    for i := len(A) - 2; i >= 0; i-- {
        // 首先找到第一个乱序的地方。如果直接和最后一个数字交换。最后一个数字 > 需要交换的，那么排列更小了。
        // 所以我们应该从后往前找到第一个小于当前数字，并交换。
        if A[i] > A[i+1] {
            for j := len(A) - 1; j > i; j-- {
                if A[j] < A[i] {
                    A[i], A[j] = A[j], A[i]
                    return A
                }
            }
        }
    }
    return A
}
```