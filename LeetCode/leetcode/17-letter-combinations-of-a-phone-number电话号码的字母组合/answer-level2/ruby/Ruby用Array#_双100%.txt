### 解题思路
执行用时 :36 ms, 在所有 Ruby 提交中击败了100.00%的用户
内存消耗 :9.5 MB, 在所有 Ruby 提交中击败了100.00%的用户

先建立参考数组@l储存各数字对应字母

将将数字字符串digits处理为ASCII码的数组存入d
'0'~'9'的ASCII码是48~57，'2'的ASCII码正好是50
用d的第一个元素的对应字母来初始化数组a
之后，循环下标i从1开始

为什么这里的a直接取自参考数组@l，而不需要进行复制？
每次循环中，都会先调用a的*=，
也就是a = a*3或者4，
这个过程调用Array#*，产生了一个新的数组赋值给a
所以不会影响到参考列表@l

参考列表里的字符串不会受影响也是因为
a[j] += @l[k][j / m]实际上是a[j] = a[j] + @l[k][j / m]
a[j] + @l[k][j / m]产生了一个新的字符串赋值给a[j]，
所以不会影响到参考列表里的字符串

我们事先保存了数组a在倍增前的size也就是m
只要用循环下标j除以m，就能知道它在新数组a的第几部分
接下来就在第一部分连接第一个字母，第二部分连接第二个字母，依此类推


### 代码

```ruby
def letter_combinations(digits)
	return [] if digits.empty?
	@l ||= [
		['a', 'b', 'c'], ['d', 'e', 'f'],
		['g', 'h', 'i'], ['j', 'k', 'l'],
		['m', 'n', 'o'], ['p', 'q', 'r', 's'],
		['t', 'u', 'v'], ['w', 'x', 'y', 'z']
	]
	d = digits.chars.map{|c| c.ord}
	n = digits.size
	a = @l[d[0] - 50]
	i = 1
	while i < n
		j = 0
		m = a.size
		k = d[i] - 50
		a *= (k == 5 || k == 7 ? 4 : 3)
		while j < a.size
			a[j] += @l[k][j / m]
			j += 1
		end
		i += 1
	end
	a
end
```