# 规范string的使用

本题遇到了一个开发工程师经常遇到的问题：字符串延长。
本题解主要注重于如何减少字符串延长的时间空间占用，以及提供一种多叉树遍历表生成的思想。

## 第一部分：如何规范化使用string的+=
通常来说，字符串的+=运算符提供了一个非常简便的延长方法，但是这一运算符会在字符串无法在当前位置延长时，申请另一足够长的连续空间以满足字符串的需求，在频繁延长的场合产生了很高的内存浪费和memory alloc耗时，我的解法优化了这一问题，目前内存占用超越了100%的解法。
**1、StringBuilder类**
StringBuilder类是C++以及各类高级语言提供的字符串辅助类，用于在初始化时提供一个较大的内存空间以便进行append操作，并在append完成后产生一个恰好能够容纳目标字符串的空间，并回收之前所使用的空间。这种方法在对单个字符串进行append操作时消除了反复拷贝和申请释放内存而产生的时间空间耗费，但是仍然不是本题的最优解。
**2、预设Capacity（容量）**
虽然很基础，但是却是很多程序员没有注意到的问题。String在初始化的时候可以通过构造函数而预先定义capacity，借此提前申请目标大小的空间，相比StringBuilder，这种做法不需要添加额外代码，只需要在初始化时提供一个特定的capacity即可，对于本题，目标的capacity就是digits的长度。


同样的，本题答案vector的capacity也可以轻易得到：
![Formula.png](https://pic.leetcode-cn.com/2a37e4932f0f40246078692c1d0698a2fd74fadbae0b03b15091bb7dc2eb7861-Formula.png)
其中characterPerDigit就是每个digit所能代表的字符的数量。
该stringLength可以通过一次O(n)的扫描连乘得到，对于整个题目所占用的时间复杂度，几乎可以忽略。
```
int stringCount = 1;
        for(int i = 0 ; i < digitSize ; i++){
            char digit = digits[i];
            switch(digit){
                case '7':
                case '9':{
                    stringCount *= 4;
                    break;
                }
                default:{
                    stringCount *= 3;
                    break;
                }
            }
        }

```
了解了这一规范，能够为一些字符串操作的题目带来内存和时间占用上的显著提升（也许），毕竟如果放到C#或者Java环境下，频繁使用+=会给垃圾回收机制带来不必要的巨大压力。

## 第二部分：通过底层的索引值计算该路径上每一层的sibling-index
如果你已经对Trie字典树有所了解，可以跳过这部分内容。

本题是一个多叉树问题，其中每一层的结点，其拥有的孩子数量相同，并且所有叶子节点都位于同一层且填满该层，而所有从根节点到叶子节点的路径就是我们所求的答案。
这种情况下我们已经得出叶子节点的数量，得知每一层的结点孩子的数量，并且会希望通过一次对叶子节点的遍历就得到所有的路径，甚至这样子得到的所有路径字典序还能保持有序。
我们首先看一道简单的例子："234"
从树的角度考虑，根节点"2"能够表示三个字符，因此该层拥有三个孩子，每个子树—————由于它们结构上完全一致，应当保有主树三分之一的叶节点，唯一不同的是每个子树的根节点被分别标记为"a","b","c"，也就是"2"所代表的三个字符。
随后是第二层，同样该层各个子树的根节点"3"能够表示三个字符，因此该层每个结点也拥有三个孩子，每个结点的每个子树在结构上同样完全一致，拥有其父三分之一的叶节点数量，该层每个子树，根据其在兄弟中的索引值（sibling-index，从左到右是012012012）而分配到了"d","e","f"三个不同的字符。
第三层也一样，此时各个子树（实际上只有根结点）的sibling-index是012012012012012012012012012，共27个（3×3×3）。
我们很快发现每层的划分方式仅和该层的数字所表示的字符数量有关，而且字符的分配方式在子树中形成了循环。
这就让我们想到，是否有一表达式可以直接从leaf-index（叶子结点的索引）得到某一层的sibling-index呢？
答案是肯定的：

第一层每个结点的子树占据27个叶子，因此packSize初始值为27。
随后第一层的每个pack向下分为三个子pack，每个pack占用9个叶子，因此packSize为9.
最后一层每个pack为3。
……
与此相同的是第一位、第二位、第三位的字符的循环规律：
第一位（最左端）27位一循环。
第二位9位一循环。
第三位3位一循环。
……
借此，只需要对每一个digit进行遍历，然后在每一次遍历中对answer中的字符串进行赋值，就可以完成整个路径表的生成。
```
vector<string> answer;
//这里是answer的初始化以及其他运算。
int packSize = stringCount;
for(int i = 0 ; i < digitSize ; i++){
    char digit = digits[i] - '0';
    string appendString = characterMap[digit];
    int appendSize = appendString.size();
    for(int j = 0 ; j < stringCount ; j++){
        answer[j][i] = appendString[j % packSize) / (packSize / appendSize];
    }
    packSize /= appendSize;
}
```

第一次写题解，排版究极肮脏，还请谅解。




