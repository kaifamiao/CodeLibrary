打家劫舍这一类问题分别在No198，No213和No337，本题是这一类问题最简单的一种状态，第一直觉就应该是动态规划，如官方题解，设f(x)为打劫前x家房子所能得到的最大的资金，很容易想到动态规划的边界条件，即：

f(1)=nums[1]

f(2)=max(nums[1],nums[2])

然后是最关键的动态转移方程，如果要打劫第n家，就必然不能打劫第n-1家，所以打劫第n家得到的钱一共是第n家的钱加上前n-2家获得的最多的钱，即：f(n-2)+nums(n)，如果不打劫第n家，获得的最大收益就是f(n-1)，两者我们要去较大的那个，所以动态转移方程是：

f(n)=max(nums[n]+f(n-2),f(n-1))

到这里，这道题就能顺利通过了

以下是JAVA版本：

    public int rob(int[] nums) {
        if (nums.length == 0) {
            return 0;
        } else if (nums.length == 1) {
            return nums[0];
        }
        int[] ans = new int[nums.length];
        ans[0] = nums[0];
        ans[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < nums.length; i++) {
            ans[i] = Math.max(nums[i] + ans[i - 2], ans[i - 1]);
        }
        return ans[ans.length - 1];
    }

再看第213题，打家劫舍II，本质上还是这个动态转移方程，只不过把房子首尾相连，如果打劫了第一家就不能打劫最后一家，那么我们还是可以按照这题的方法，先假设第一家一定去打劫，最后一家一定不打劫（f(1)=f(2)=nums(1)，只计算到第n-1位），然后假设第一家一定不打劫，而最后一家一定要去打劫（f(1)=0 , f(2)=nums(2)，计算到最后），取两者中的最大值就行了。

第337题打家劫舍III又做了一点变化，把社区规划成了树形，但仍然用这个动态转移方程去做，在打家劫舍II中我们计算了打劫第一家和不打劫第一家两种情况，而在这题中就更复杂一些，我们需要使用递归，为每一个树的分支计算出一个解，在解的集合中取最大值作为最终的解