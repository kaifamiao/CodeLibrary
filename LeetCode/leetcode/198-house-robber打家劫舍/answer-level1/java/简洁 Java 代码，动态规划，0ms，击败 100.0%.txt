#### 1、代码

由于当前状态只与前一状态有关，则只保存前一状态的值即可，优化空间复杂度.

```java
class Solution {
    public int rob(int[] nums) {
        int dp_yes = 0;
        int dp_no = 0;

        for (int n: nums) {
            int tmp = dp_yes;
            dp_yes = dp_no + n;
            dp_no = Integer.max(dp_no, tmp);
        }

        return Integer.max(dp_yes, dp_no);
    }
}
```

#### 2、问题分析

##### 问题定义

定义 $DP(i, j)$ 为偷到第 $i$ 个（包含第 $i$ 个）房屋为止的可获得的最大金额数：

当 $j = 1$ 时，偷窃第 $i$ 个房屋；

当 $j = 0$ 时，不偷窃第 $i$ 个房屋.

##### 状态转移方程

1）如果偷窃当前第 $i$ 个房屋，此时第 $i - 1$ 个房屋必是未被偷窃的，则目前可获得的最大收益为不偷第 $i - 1$ 个房屋时的收益，加上当前第 $i$ 个房屋的收益：

$$
DP(i,1) = DP(i-1,0) + nums[i]
$$

2）如果不偷窃当前第 $i$ 个房屋，则此时可获得得最大收益，为第 $i - 1$ 个房屋在两种情况下（偷与不偷）的收益中较大的那个：

$$
DP(i,0) = max(DP(i-1,0), DP(i-1,1))
$$

#### 3、算法分析

时间复杂度：$n$个房屋，每个考虑一次且仅一次，则时间复杂度为 $O(n)$.

空间复杂度：$O(1)$.

#### 4、执行结果

![截屏2020-03-0717.46.55.png](https://pic.leetcode-cn.com/d87a18f18d3adc7639e9fbb49cc05eb152752c141965a29cdf7f06d9412e40dc-%E6%88%AA%E5%B1%8F2020-03-0717.46.55.png)

