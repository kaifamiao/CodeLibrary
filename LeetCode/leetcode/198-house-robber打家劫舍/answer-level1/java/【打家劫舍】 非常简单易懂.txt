### 题目描述
>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

### 示例
>示例 1:
输入: `[1,2,3,1]`
输出: `4`
解释: 偷窃 `1` 号房屋 (金额 = `1`) ，然后偷窃 `3` 号房屋 (金额 = `3`)。
     偷窃到的最高金额 = `1 + 3` = `4` 。

>示例 2:
输入: `[2,7,9,3,1]`
输出: `12`
解释: 偷窃 `1` 号房屋 (金额 = `2`), 偷窃 `3` 号房屋 (金额 = `9`)，接着偷窃 `5` 号房屋 (金额 = `1`)。
     偷窃到的最高金额 = `2 + 9 + 1` = `12` 。

### 思路
现在假设我就是那个小偷，我每到一户人家我会先纠结一下，到底偷不偷呢？
- 如果选择偷，那么上一户人家必须是没偷过的，因为连续偷两户人家就被发现了；
- 如果选择不偷，那么上一户人家可以选择偷，也可以选择不偷。

通过上面的描述，我们只需要用一个数组来记录到第`i`户人家`偷`与`不偷`时获得的收益：
记`dp[i][0]`为到第`i`户人家选择`不偷`能获得的最大收益，`dp[i][1]`为到第`i`户人家选择`偷`能获得的最大收益，则有如下递推式：
`dp[i][0] = max(dp[i - 1][1], dp[i - 1][0]) // 前面一户人家可以偷也可以不偷`
`dp[i][1] = dp[i - 1][0] + nums[i] // 前面一户人家必须不偷，当前户人家才能偷`

那么相应的代码也就不难得出了：
```java
class Solution {
    public int rob(int[] nums) {
		if (nums == null || nums.length == 0) {
			return 0;
		}
		int[][] dp = new int[nums.length][2];
		dp[0][0] = 0;
		dp[0][1] = nums[0];
		int ans = Math.max(dp[0][0], dp[0][1]);
		for (int i = 1; i < nums.length; i++) {
			dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
			dp[i][1] = dp[i - 1][0] + nums[i];
			ans = Math.max(Math.max(dp[i][0], dp[i][1]), ans);
		}
		return ans;
	}
}
```

