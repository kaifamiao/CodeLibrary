## 题目
根据这道题的条件特点：

__如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警__（即相邻的数字不能同时作为最终求和的有效数字）。


## 分析
这个条件如果精简掉其他内容，很容易让人联想到奇偶数。这个解法就是从这点出发。  
  
- 设置两个变量，`sumOdd` 和 `sumEven` 分别对数组的奇数和偶数元素求和。  
- 最后比较这两个和谁更大，谁就是最优解。  

至少在下面这个例子里，这么做是成功的了。  

|  Index  |  [0] | [1]  | [2]  | [3]  |
|---------|---|---|---|---|
| nums    | 1 | 2 | 3 | 4 |
| sumEven | 1 | 1 | 4 | 4 |
| sumOdd  | 0 | 2 | 2 | 6 |

接下来要解决的就是最优解不是纯奇数和或者偶数和的情况。  
这种情况下，最优解可能前半段出现在这边，后半段出现在另一边。  
那么只要找到一个时机，当这一段的最优解没有另一边好时，就复制对面的最优解过来。  

举个例子：  
|  Index  |  [0] | [1] | [2] | [3] | [4] |
|---------|---|---|---|---|-----|
| nums    | 1 | 3 | 1 | 3 | 100 |
| sumEven | 1 | 1 | 2 | 2 => 3 |     |
| sumOdd  | 0 | 3 | 3 |   |     |

当偶数和（奇偶指的数组下标）加到第二个 1 之后，发现还不如奇数和一个 3 大，就应该将对面的3复制过来替换掉自己的 2。  

|  Index  |  [0] | [1] | [2] | [3] | [4] |
|---------|---|---|---|---|-----|
| nums    | 1 | 3 | 1 | 3 | 100 |
| sumEven | 1 | 1 | 2 | 3 | 103 |
| sumOdd  | 0 | 3 | 3 | 6 | 6   |

继续计算后得到最优解。  


## 思路
1. 设置两个变量，`sumOdd` 和 `sumEven` 分别对数组的奇数和偶数元素求和。
2. 遍历数组，索引为奇数时，将元素加到奇数和，并与偶数和比较更新成max。
3. 偶数和同理。
4. 返回时进行最后一次更新max。


## 答题 
```C++
int rob(vector<int>& nums) 
{
	int sumOdd = 0;
	int sumEven = 0;

	for (int i = 0; i < nums.size(); i++)
	{
		if (i % 2 == 0)
		{
			sumEven += nums[i];
			sumEven = max(sumOdd, sumEven);
		}
		else
		{
			sumOdd += nums[i];
			sumOdd = max(sumOdd, sumEven);
		}
	}
	return max(sumOdd, sumEven);
}
```

完成。  



## 更新：  
看到了更新了官方题解，感觉我和他思路的本质是一样的，但官方题解将公式分析的更纯粹了，好厉害！  

不过我这个相比较而言拙劣的思路，可能是稍微更好理解一点吧（请不要戳破，谢谢）  

如果感兴趣的话，可以看下后续。  

[【打家劫舍 II】代码简洁易懂 II](https://leetcode-cn.com/problems/house-robber-ii/solution/da-jia-jie-she-ii-dai-ma-jian-ji-yi-dong-ii-by-ika/)