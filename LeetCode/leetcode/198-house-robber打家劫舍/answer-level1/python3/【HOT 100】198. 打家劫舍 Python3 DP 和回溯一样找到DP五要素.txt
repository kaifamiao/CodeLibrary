### 2020/02/02
记录一下特别的今天，今年的假期是一个黑色笼罩的假期，最终也奔赴了工作的战场，但是更坚定了自己的想法，在自然面前，我渺小至极，一定要在有条件的时候追求一些更值得的东西，而不是荒废，徒留一身疲惫。
2020年的目标：实现租房自由，以及更成熟的爱家人


### 解题思路
- **相似题型**
- **DP五要素**
- **代码**


### 相似题型
我最终还是先这样编一个DP五要素，类似于回溯三要素，这样我能够让自己系统的去考虑同一种类型的题目，但这是我第一个DP的题这样考虑了，之后还需要多实践是否可行，毕竟回溯题我能够按照回溯三要素法能够做下去
所以，这里先占坑~


### DP五要素
- **状态**
- **状态的选择**
- **状态的转移**
- **base case（初始化）**
- **是否能优化空间复杂度**

所有人都会说DP最重要的是状态和状态转移方程，什么是状态呢，以这道题为例，那就是**房子就是一个状态**，为什么它是一个状态，因为它有可以变化的选择，也就是我这个小偷可以偷第一个房子，第二个房子，一直到第n个房子，也就是它可以进行状态转移，对我而言，维度可以进行变化（遍历）的我都会把它当做一个状态，然后考虑它的选择范围，也就是**第二要素：状态的选择**，对于这道题而言，就是从第一个房子到第n个房子，于是就用`for i in range(len(nums))`来代表选择范围。

考虑DP的时候我们一般都是用记录**网格**，或者**table**来保存状态，而且一般常用的是自下而上，这样能够避免多次重复计算。

那么对于这道题的这个房子状态来说，它的状态转移是什么，根据题目，我们知道首先小偷是可以偷这个房子的，如果没有其他条件，小偷当然是每个房子都偷，这样总价格是最多的，但是这里有一个`限制条件：小偷不能偷相邻的房子`，那么对于每一个房子来说，就有偷或者不偷的考虑，因为只有`i-1`这个房子没有被偷，才可以偷`i`这个房子，并且`i+1`这个房子也不能偷了，那么对于i这个房子，就有两种情况：
- 1.偷：那么i-1不能被偷，总价值就是i-2这个房子+当前这个i房子，
- 2.不偷：那么i-1这个房子可以被偷

（我们当然希望偷的越多越好，所以如果`i`不偷，我们希望小偷偷到了`i-1`这里来）
又由于我们希望总价值最大，所以我们需要在两者之间取`max`，也就是：
`dp[i] = max(dp[i-1], dp[i-2]+nums[i])`

我其实这道题不太能画出网格来，感觉是`n*n`网格，但是只有一半可取，灵魂画手不太好施展开来，于是最终还是考虑用状态转移的思维来写状态转移方程【其他题能画网格的可以根据网格知道状态转移方程该如何写，**比如“最长公共子串”，“最长公共子序列”等**】

考虑完了**状态转移方程**，我们需要考虑`base case`，这里由于用到了`i-`2，那么我们必须要保证`i=1`和`i=2`的时候被初始化了：
当`i=1`的时候，只有一个房子，那当然就是偷偷偷，即为：`dp[0]=nums[0]`，（index从0开始）
当`i=2`的时候，有两个房子，这里一定要注意注意注意！！！不是理所当然的偷第二个房子，当有选择的时候，我们一定要选择最优对吧！那么一定要选钱最多的房子，我就是这里理所当然了一下，导致我变成一个愚蠢的小偷。。。
那么应该是：`dp[0]=max(nums[0], nums[1])`

于是我们能写出第一版的代码：

### 代码

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        if n == 1:
            return nums[0]
        if n == 2:
            return max(nums[0], nums[1])

        dp = [0 for i in range(n)]
        
        
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        
        for i in range(2, n):
            dp[i] = max(dp[i-1], dp[i-2]+nums[i])
        
        return dp[-1]
```

一般在写完第一版这样的传统的用dp数组来保存数据的代码之后，我们可以思考一下是否有优化的空间，比如优化空间（怎么这么绕。。。）
也就是我们能不不用额外的数组空间来完成，减小空间复杂度
小trick来也：
**如果当前状态如果只和相邻状态相关，可以考虑用变量保存节约空间**

因为状态i的转移只考虑了同一维度的第`i-2`个房间和第`i-1`个房间，也就是当前状态只跟这两个相邻的状态有关，而且第`i-1`个房间和第`i-2`个房间的状态也只跟它们对应的第`i-1`和第`i-2`房间有关，所以我们可以每次只记录和更新这两个状态的值，最终选择更大的那个值


### 代码

```
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums:
            return 0
        n = len(nums)
        if n == 1:
            return nums[0]
        if n == 2:
            return max(nums[0], nums[1])

        # dp = [0 for i in range(n)]
        
        
        # dp[0] = nums[0]
        # dp[1] = max(nums[0], nums[1])
        
        dp_0 = nums[0]
        dp_1 = max(nums[0], nums[1])
        
        for i in range(2, n):
            # dp[i] = max(dp[i-1], dp[i-2]+nums[i])
            dp_0, dp_1 = dp_1, max(dp_1, dp_0+nums[i])
        
        return dp_1
```

![image.png](https://pic.leetcode-cn.com/47154fb8e5392839dbc04b02311540c6395e456621a01cebfe9369ff80c80f10-image.png)


### 后记
太久没写题解了，最近被疫情折磨，希望生活快点好起来，疫情快点消失。
另：还是不够乖巧啊。