结果：
执行用时 :48 ms, 在所有 Python3 提交中击败了87.66%的用户
内存消耗 :12.8 MB, 在所有 Python3 提交中击败了99.28%的用户

分析：
     这题就是很明显的动态规划类的题目，而在解决这道题目的时候，我们需要注意题目中的隐藏条件：①只有相邻的房屋同时被偷时才报警；②你一次隔多少间房子不受限制（相邻房子算没有间隔），唯一目标就是得到最高的金币。
基于以上的条件，再看看题目中给的例子，我们会发现题目中的例子都是基于隔一间房子偷一次的规律来的（虽然对于所给的例子，这种偷法就够了），那有没有其他的例子需要你一次隔两间房子偷呢？ 答案是肯定的！且看下面例子：
[1,1,100,1,1,100,1,1,200,1,1] ，对于这样一个例子，为了获取最大的金币，我们很容易看出来，必须得把其中最高金币的房间都偷到（数组中的100和200我们都得拿到，因为其并没有相邻）。再仔细一看，我们可以发现，若要获得最高，从第一个100跳到第二个100，再跳到200，我们都需要连隔两间房子，最大的金币应该是402，具体的跳法如下图所示：
![01.png](https://pic.leetcode-cn.com/f4bd1f9e9e90aac9b0691c15121301ebf4edb222d33eb0845c40b960fc3cfb0c-01.png)
    所以，当数组的长度大于4的时候，我们可以列出状态方程：dp[n]=max(dp[n-2]+nums[n]，dp[n-3]+nums[n])，dp[n]代表当走到第n个位置时所能获得的最大金币，dp就是用来存储到达每个位置所能获得的最大金币，最后在计算偷完所有房屋时获得的最大金币时，我们相当于只用比较dp[len(nums)-1]  和dp[len(nums)-2]就行了（数组的最大索引是len(nums)-1）。
    为什么在计算dp[n]时，用的是dp[n-2]和 dp[n-3]呢？ 还有没有可能是dp[n-4] 或dp[n-5]？   答：不可能，因为在n-4或 n-5的位置 完全可以再跳两步（隔一间房子）到达n-2或n-3的位置。
    这里要也别强调！！数组长度为0，也就是空数组时，我们返回0。因为如果不加这一条（也就是去掉if len(nums）=0 return 0），提交的时候，代码会报错！！ 可能是题目内置测测试用例里面包含了空数组。
    最后弄清楚数组长度≤2，数组长度＝3  的表达式，数组长度大于4时，就按照动态规划的求法来写。


代码：
class Solution:
    def rob(self, nums: List[int]) -> int:
        if len(nums)==0:
            return 0
        if len(nums)<=2:
            return max(nums)
        elif len(nums)==3:
            return max(nums[0]+nums[2],nums[1])
        else:
            dp=[0]*len(nums)
            dp[0]=nums[0]
            dp[1]=nums[1]
            dp[2]=nums[0]+nums[2]
            for i in range(3,len(nums)):
                dp[i]=max(dp[i-2]+nums[i],dp[i-3]+nums[i])
            return max(dp[len(nums)-1],dp[len(nums)-2])