**官方是从当前房子偷不偷角度来写动态规划，我第一反应是当前房子怎么加上之前偷的最优解=。=**

对于当前的房子其实只有两种情况：
1. 加上它隔一个的房子，累积最优解 如 **99** 2 **1**
2. 加上它隔两个的房子，累积最优解 如 **99** 1 1 **1**
不用隔三间及以上了，因为前面会包含。

那么子问题 lst[i] += max(lst[i-2], lst[i-3]) 更新就行了。
```
def dp(lst):
    if not lst: return 0
    if len(lst) <= 2: return max(lst)
    lst[2] += lst[0] 
    #因为分析过是看隔一个和隔两个那个数最大  所有从第四个数开始算方便
    #所以要把第三个数先算一下
        
    for i in range(3,len(lst)):
    #从第四个数开始算  不用判断lst长度是否大于4 这里就自动跳过了
        lst[i] += max(lst[i-2],lst[i-3]) #当前点 和 隔一家 隔两家 最优解
    
    return max(lst[-1], lst[-2])

```


