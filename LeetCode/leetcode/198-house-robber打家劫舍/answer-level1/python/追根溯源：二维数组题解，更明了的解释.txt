如果一开始就给大家一维 dp 的解答，对于对动态规划不太熟悉的朋友来说是难以理解如何推导出来的  
>dp[n] = MAX( dp[n-1], dp[n-2] + num )  
  
其实此题和买卖股票是一样的，几乎没多大差别，废话不多说，先贴出代码，看了未精简的代码，说不定你一下就懂了  

某一天 i 存在两种状态
  1. 抢劫了
  2. 未抢劫  

所以我们定义二维数组 dp[i][0] 表示第 i 天没抢劫，dp[i][1] 表示第 i 天抢劫了

如果第 i 天抢劫了，那么前一天必然未抢劫，所以第 i 天抢劫了的收益为
>dp[i][1] = dp[i-1][0] + nums[i]

如果第 i 天没抢劫，那么就会有个择优。我第 i 天没抢，则可以第 i-1 天也没有抢，也可以是 i-1 天抢了，所以
>dp[i][0] = max(dp[i-1][0], dp[i-1][1])
```
class Solution(object):
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums: # 空时直接返回 0
            return 0
        if len(nums) <= 2: # 元素个数小于 2 时的最基本情况
            return max(nums)
        dp = [[None]*2 for _ in nums] # 初始化数组
        dp[0][0] = 0 # 第 1 天未抢
        dp[0][1] = nums[0] # 第 1 天抢劫了
        for i in range(1, len(nums)): # 从第二天开始择优
            dp[i][0] = max(dp[i-1][0], dp[i-1][1])
            dp[i][1] = dp[i-1][0] + nums[i]
        n = len(nums) - 1
        return max(dp[n][0], dp[n][1]) # 从最后一天选择出 抢了最后一天 和 没抢最后一天 最大的
```

是不是比一维 dp 好理解了许多，如果你细心的话是可以发现，二维 dp 精简下就可以转换为 一维 dp。  

有的同学会说，我二维 dp 也难以想到。
别担心，才开始刷题的我亦是如此，此时你需要的只是仔细想想，先写个最笨的解法，然后从中提炼出更好的解法。
让我们看看暴力破解，假设我们有 4 间房 1， 2， 3， 4，咋们列出树状图表示抢劫的过程
![打家结社.001.png](https://pic.leetcode-cn.com/03775e777f81ca980050f2414c70fdd5a755d9e26ad7084401250416a4e011f8-%E6%89%93%E5%AE%B6%E7%BB%93%E7%A4%BE.001.png)
  
任意一条路径代表一个解，由于每个点存在一个值（金钱数），所以不同路径获得的金钱数不同，我们需要找出获得金钱数最大的路径。  

仔细想想，因为限制条件是相邻的两间不能抢而已，所以一开时就抢3或者4，放弃许多不抢，显然不明智，所以这些不是最优解的路径直接丢掉。  

动态规划为啥叫动态规划？那是因为它在暴力破解的基础上从某个点开始不停地择优，同时会保留一些之前的状态。  

当你使用动态规划解此题时，在这颗暴力破解树上最直观的体现就是不停地在各个路径上跳来跳去，并且在局部范围保持最优解，实现这一效果的手段就是保存了状态，**从而随时可以从存储的状态中通过常见的 max min 等函数择优**，当然不一定就是 max min 函数，只是举个例子哈

>好了今天就讲到这里，更加深入的内容需要大家自己去积累
>搜索订阅号 Apelife
>关注后回复 图解，分享给你leetcode动态图解解题集
>定期为大家分享题解，学习经验，解题思路等

