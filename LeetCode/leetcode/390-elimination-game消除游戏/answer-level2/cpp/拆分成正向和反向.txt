一开始想到用 DP来解决，分成正向过程和反向过程，但是空间超出了。
在看了一些题解后，用自己容易理解的方式实现出来了，感觉还比较简洁，分享给大家。
主要思想还是递归，但是拆分成了正向和反向两个函数，交替进行，并通过简单的奇偶变换来向下转化，直到递归终止条件，也就是只剩下1的时候。

```c++
class Solution {
public:
    int lastRemaining(int n) {
        if (n < 2) return 1;
        return f(n);
    }

    int f(int n) {
        if (n == 1) return 1; // 1是终止条件
        if (n % 2 == 1) return f(n-1); //当 n 是奇数时，正向消除等同于从1到 n-1正向消除，即可以转化成下面的情况。
        return 2 * b(n / 2); //当 n是偶数时，正向消除过后，剩下就是2,4,6,8...n-1,并且这个时候需要反向消除。不难发现，把所有数除以2后，数列转化成
                            //1，2，3，...，n/2，那么只需要求出反向消除 n/2的结果，再乘回2，就是最终结果。
    }
    int b(int n) {
        if (n == 1) return 1; //1是终止条件
        if (n % 2 == 1) return 2 * f((n-1)/2); //当 n 是奇数时，从后往前消除后剩下的就是2,4,6,8,...,n-1,接下来需要正向消除，类似于 n 是奇数时正向的分析。
        return 2 * f((n+1)/2) - 1; //当 n 是偶数时，反向消除后剩下1,3,5,7,...,n-1，仔细观察后，也可以发现将数列+1再/2，可以转化成1,2,3,4,...,(n+1)/2的情况，接下来再正向消除，得到正向的结果后，再*2并-1,就是最终结果。
    }
};
```