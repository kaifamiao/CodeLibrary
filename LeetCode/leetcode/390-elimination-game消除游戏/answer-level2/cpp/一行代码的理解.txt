如果正正经经的模拟整个流程，然后2倍的跨步删除数字，最后再输出最后一个数字，很可能会倒在最后几个例子里。\
即便优化到了o(n)的复杂度，最后执行几个上亿的值**也可能会弄超时**。\
评论区那位大佬的一行递归实在太秀了，虽然给出了正确性的证明，但是怎么想到的还是个迷，所以这里尝试归纳一下这个题目的规律然后解释下大佬的数学原理。

首先来看这些例子：
```
1   -> 1        1   ->  1       1   ->  1
3   -> 2        2   ->  2       5   ->  2
6   -> 4        4   ->  2       10  ->  8
12  -> 6        8   ->  6       20  ->  6
24  -> 12       16  ->  6       40  ->  30
48  -> 22       32  ->  22      80  ->  22
96  -> 54       64  ->  22      160 ->  118
182 -> 86       128 ->  86      320 ->  86
```

左边的是输入，箭头右边是输出。\
这里有个**神奇的规律**，
```
如果输入是 a 而输出是 b ，那么输入是 2a 时的输出就是 2*(a-b+1) 。
```
比如说输入 160 输出是 118 ，那么输入 320 就会得到 2*(160-118+1) = 86。

(。・∀・)ノ真的会有这么巧的事情啊。具体的证明我也不清楚，这是我用“**死盯法**”归纳出来的。

非要说怎么看出来的话：\
1 2 3 4 5 6 7 8 9 10，一轮下来就剩下 2 4 6 8 10 一共五个数，正好是一半。\
而 1 2 3 4 5 6 7 8 9， 一轮下来剩下 2 4 6 8 就四个，也是 9/2 取整得到的值。\
而 2 4 6 8 10， 其实可以对应到 5 4 3 2 1。在 5 的解中输出 2 , 对应到 8 的位置， 所以 10 输出 8。

如果说 1 **2** 3 4 5 中 2 在 1号位( 1 在 0号位)，在 5 4 3 **2** 1 中就是 4(size) - 1 = 3 号位。\
```
             3号位
  1   2   3   4   5
1 2 3 4 5 6 7 8 9 10
```
所以有 a - b。
但是3号位毕竟是指针，要得出 1 2 3 4 5 中的值就需要 +1 ，所以有 a - b + 1。
然后得到值后对应到两倍上的输入，也就是 x2 了，于是就是  2*(a - b + 1)。
\
\
\
这样的话就方便了，如果要找 2048 的解，就将他二分倒底，比如说输入2048：\
2048 / 1024 / 512 / 256 / 128 / 64 / 32 / 16 / 8 / 4 / 2 / 1\
1 的输出就是 1，带入2*(a-b+1)的公式中迭代或递归个11次就得到2048的输出了。\
同样，如果输入是 2000，找 2000 / 1000 / 500 / 250 / 125，从 125 开始迭代递归个 4 次就能找出 2000 的值了。

1000000000 是超时的，但是找出 390625 的解却是绰绰有余。

但如果是 99999999 呢？一次也无法二分，只能老老实实的计算然后超时了。
\
\
\
现在我们再来看看下面例子：
```
100 ->  54
101 ->  54
102 ->  56
103 ->  56
104 ->  62
105 ->  62
106 ->  64
107 ->  64
```
这里显示出
```
输入为偶数 e 时，其输出的结果和 e+1 相同。
```
也就是说如果输入是奇数，只要找比它小1的偶数当作输入就好了。

这个倒是比较好证明：\
1 2 3 4 5 6 的情况下，第一轮下来会吃掉 1 3 5 的奇数，然后倒回来又吃掉 6 2。\
而 1 2 3 4 5 6 7的情况， 第一轮吃掉 1 3 5 7 的奇数，7正好在最后一下吃掉，而倒回来又吃掉 6 2，6因为在最右是无可避免的被吃掉了。\
所以偶数 e 和奇数 e+1 的输出是一样的。

这样一来，求奇数值时就可以毫无顾虑的求下去了。再来看看2000的值。\
2000 / 1000 / 500 / 250 / 125 / 62^ / 31 / 15^ / 7 / 3^ /1^\
求 2000 的值时，只要从 1 开始迭代递归11次就能拿到。

值得注意的是打出^号的地方。（如果你已经开始用递归逆下去写了的话就不用注意了）\
在 1 套公式后得出的其实是 2 的值，而 2 再下去是 4 的值，这样就和 7 的值不一样了。\
这样下去，1 迭代 11 次其实是 2048 的值而不是 2000 的值。\
所以在按顺序迭代时，要记录二分时 a%2 == 1 的情况，在乘2之后对应+1。
\
\
\
(~￣3￣)╭现在咱们来看看这个**不需要**注意这个问题的递归。
```
//C++
int lastRemaining(int n) {
    if(n == 1) return 1;
    return 2*(n/2 - lastRemaining(n/2) + 1);
}
```
输入 n 的时候，先找到 n/2 的值，然后套入 2*(a-b+1) 的公式中。
这个时候就不用管 +1 了，因为 +1 是a往上寻找时出现的问题，这个是向下寻找，自己就是 n 所以不用管。
当递归到 1 时返回 1 就好，然后一路往上的回来就得到解了。

现在套用这个“X = Y 吗？ 是 ： 否” 这个格式，写成：
```
//C++
int lastRemaining(int n) {
    return n == 1 ? 1 : 2*(n/2 - lastRemaining(n/2) + 1);
}
```
就变成一行了~

ヾ(≧▽≦*)o阅读到这里真是幸苦了，十分感谢您的耐心，也希望您有所收获。