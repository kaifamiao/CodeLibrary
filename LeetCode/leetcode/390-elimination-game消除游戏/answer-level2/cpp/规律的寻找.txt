# 本题的困难之处主要就是在于规律的寻找
本算法不追求简洁，如何循序渐进的找到规律才是根本目的。下述所说的第几个数，没有明确指出的，均为从左开始。
#### 分析
1. **直观条件：从1到n的排序整数序列**
题目开头给出这是一个从1到n排序的整数序列，暂时好像没什么用，用处似乎只在于规范n的范围，即n必须大于等于1.我们先暂时放置。
2. **直观条件：每隔一个数字就删除一个数字**
这个条件我们经验告诉我们，每次数列的长度都会减半，有点像二分法，其终极目标就是将整个数列缩短到剩一个，此时第一个数就是我们要求的目标，那么如果我们能够**找到第一个数的变化规律**，我们就能得到答案。显然找一个数的规律要比找整个序列的规律简单，问题规模得到了缩减。
3. **直观条件：交替左起右起**
该条件一看明显知道会影响整个算法，但是不知道怎么分析，我们还是一步一步来，我们观察左起右起究竟有什么影响，前边说到，问题转换为**求第一个数变化规律**：
    *  先分析左起，那么无论如何，第一个数都要被删除，即**删除后数列的第一个数是删除前数列的第二个数**；
    * 再分析右起，右起时，左侧第一个数是从右数起的最后一个，假设数列为12345，长度为奇数，右起开始删除，则剩下24；假设数列为1234，长度为偶数，右起删除，剩下13；显然我们可以得到，**第一个数是否会被删除完全依赖于数列的长度**，若长度为偶数，删除后数列的第一个数不变，否则，删除后的第一个数是原数列的第二个数。
    * **综上，当左起或者右起长度为奇数时，删除后数列的第一个数是原数列的第二个数，其他情况，删除后数列的第一个数不变。**
4. **隐藏条件：等差数列**
上述说到，第一个数的变化规律，它不变化还好，一旦变化就变成了原来的第二个，那么怎么计算第二个呢？显然需要找到其递推公式，我们联系条件1，其说明了，该**数列是个首项为1，公差为1的等差数列**，但这只是没有删除的时候的规律，我们再联系条件2，其隔一个删一个，简单来说就是隔一个数采样一次，再组成新数列，由于第一次删除的数列就是等差数列，那么隔一个采样一次相当于**等距采样**，显然删除后的数列也是等差数列，那么公差呢？我们把数列两个相邻项之间的距离称为**一个单位**，那么隔一个抽样一次，相当于隔了**两个单位抽样一次**，也就是新数列相邻两项间的距离是原数列的二倍，而这个所谓的**一个单位**，就是**公差**，我们可以得到，**新数列的公差是原数列的2倍**，这样一来，我们知道第一轮的公差和首项，就可以推算出每一轮的公差和首项，也就可以算出每一轮的第二个数究竟是多少了。*不要忘记了我们的目标，求第一个数的变化规律，**而第一个数的变化规律仅与数列的第一项和第二项有关。***

#### 算法
至此我们分析完毕，我们将求解整个数列的规律变为了求解第一个数的变化规律，而第一个数的变化规律，仅与删除前数列的第一项和第二项有关，而删除前后的数列都是等差数列，公差每次删除后都会翻倍，那么算法就显而易见了，先判断删除后第一个数会不会变化，记录新的第一项，然后公差翻倍、改变方向、判断数列长度、缩短数列长度。**由于这里边涉及的运算均和2相关，要不就是求一半，要不就是翻倍，要不就是判断奇偶，因此均可以使用位运算加速**。

```
int lastRemaining(int n)
{
	if (n == 0)
	{
		return 0;
	}
	int first = 1;							//第一个数
	int factor = 1;							//公差
	bool isLeft = true;						//方向
	bool isEven = ((n & 1) == 0);			//长度是否为偶数
	while (n != 1)
	{

		if (isLeft || !isEven)				//若从左向右或者从右向左时为奇数，第一个数变为原来的第二个
		{
			first += factor;
		}
		isLeft = !isLeft;					//改变方向
		n >>= 1;							//长度减半
		factor <<= 1;						//公差翻倍
		isEven = ((n & 1) == 0);			//判断奇偶
	}
	return first;
}
```
