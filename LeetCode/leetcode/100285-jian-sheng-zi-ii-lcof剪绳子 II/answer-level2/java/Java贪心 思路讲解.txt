# 思路

## DP的缺陷
这个题和剪绳子I一样的描述，就是数据范围变大了。`剪绳子`可以用动态规划或者贪心做，这道题对于使用DP难度就增大了一些，因为数据范围变得比较大时，long已经不足以去存储中间结果的状态，但是由于DP做法是枚举各种剪的情况然后取最大值，因此只能通过使用`BigInteger`的方法去做，这点评论区已经有人给出了[解答](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/solution/java-dong-tai-gui-hua-ji-bai-100-he-jian-sheng-zi-/)。

那么这个题范围变大的本意是想让我们使用贪心算法能更好的求解(毕竟`BigInteger`使用起来麻烦，贪心没有数据溢出的问题，它是找当下的最优解，不需要比较，**中间结果可以直接取模**)。

## 贪心
我们首先考虑对于一段长n的绳子，我们可以切出的结果包含什么？

`1`会包含吗？ 不会，因为`1 * (k - 1) < k`, 只要把1和任何一个其他的片段组合在一起就有个更大的值
`2`可以
`3`可以
`4`可以吗？ 它拆成两个2的效果和本身一样，因此也不考虑
`5`以上可以吗？ 不可以，这些绳子必须拆，因为总有一种拆法比不拆更优，比如拆成 `k / 2` 和 `k - k / 2`

综上, 最后的结果只包含2和3(当然当总长度为2和3时单独处理), 那么很显然`n >= 5时， 3*(n - 3) >= 2 * (n - 2) `，因此我们优先拆成3，最后剩余的拆成2。最后的结果一定是由*若干个*`3`和*1或2个*`2`组成.
 
# 代码
```
class Solution {
    public int cuttingRope(int n) {
        if(n == 2) {
            return 1;
        }
        if(n == 3){
            return 2;
        }
        int mod = (int)1e9 + 7;
        long res = 1;
        while(n > 4) {
            res *= 3;
            res %= mod;
            n -= 3;
        }
        return (int)(res * n % mod);
    }
}
```