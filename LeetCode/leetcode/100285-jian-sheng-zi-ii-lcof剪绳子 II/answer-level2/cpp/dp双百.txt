### 解题思路
dp思想我就不说了，具体到这个题我们发现4可以拆成2*2，5可以拆成2*3,也就是说后面的数都可以用2或者3表示且比原数大，计算发现尽可能多的3才会带来最大值。那么递归过程就很好写了。但是还有个问题因为必须保证最少两段，所以前期分出来了一部分副作用的1，直到6才能完成最佳的取值，所以初始化工作较长。通常分配dp的空间为n，但是本题初始化较长，可能已经超过了N，所以直接分配1001的空间。不过问题不大，没什么影响。

### 代码

```cpp
class Solution {
public:
    int cuttingRope(int n) {
        vector<long> dp(1001,0);
        dp[1]=1;
        dp[2]=1;
        dp[3]=2;
        dp[4]=4;
        dp[5]=6;
        dp[6]=9;
        for(int i=7;i<=n;i++){
            dp[i]=(dp[i-3]*3)%1000000007;
        }
        return dp[n];
    }
};
```