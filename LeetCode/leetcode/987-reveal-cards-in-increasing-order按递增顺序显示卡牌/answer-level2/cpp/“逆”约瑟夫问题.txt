> 执行用时 :**16 ms**, 在所有 C++ 提交中击败了90.33%的用户
> 内存消耗 :**9.2 MB**, 在所有 C++ 提交中击败了62.15%的用户

- 先排序，数据保证了严格递增。
- **我们的策略只与N有关，与具体的数字没有关系。**
- 把[0, 1, 2, ..., N-1]搞定后，"映射"到原数据排序后的数组即可。



约瑟夫问题：
N个数字围成一圈。从0开始出圈，往后每次跳一个出一个。已知原序列按顺序0到N-1，求出圈序列。
**核心：跳过数字找下一个数字**

本题：
N个数字围城一圈。从0开始出圈，往后每次跳一个出一个。已知出圈序列是顺序0到N-1，求原序列。
**核心：跳过空位找空位**


**我们要做的是：从0到N-1，依次填坑**
**我们要做的是：从0到N-1，依次填坑**
**我们要做的是：从0到N-1，依次填坑**


两个例子：

**N = 7**
R0: _ _ _ _ _ _ _  初始7个坑，坑是首尾相连的
R1: 0 _ 1 _ 2 _ 3  第一轮从初始坑开始，填一个坑跳过一个坑
R2: 0 **a** 1 4 2 **b** 3  填数字3后跳过了一个坑**a**，填数字4后跳过坑**b**
R3: 0 5 1 4 2 _ 3  填数字5后只剩下一个坑
R4: 0 5 1 4 2 6 3  果断填完

**N = 8**
R0: _ _ _ _ _ _ _ _  首尾相连的8个坑
R1: 0 _ 1 _ 2 _ 3 _  第一轮从初始坑开始，填一个坑跳过一个坑
R2: 0 4 1 **b** 2 _ 3 **a**  填数字3后跳过了一个坑**a**，填数字4后跳过坑**b**
R3: 0 4 1 _ 2 5 3 _ 填数字5后只剩下两个坑
R4: 0 4 1 6 2 5 3 7 果断填完



```C++
class Solution {
public:
    int len;
    vector<bool> b;
    
    // 循环找到从下标为x开始的下一个空位
    int next (int x) {
        for (int i = x; i < len; i++) {
            if (!b[i]) {
                return i;
            }
        }
         for (int i = 0; i < x; i++) {
            if (!b[i]) {
                return i;
            }
        }
        return -1;      // 找不到空位了，即全部填满
    }

    vector<int> deckRevealedIncreasing(vector<int>& deck) {
        
        vector<int> ro(deck);
        sort(ro.begin(), ro.end());
        
        len = ro.size();
        b = vector<bool>(len, false);
        
        int  i = 0, k = 0;
        vector<int> ans(len);
        
        while (1) {
            ans[i] = ro[k++];
            b[i] = true;
            
            i = next(next(i + 1) + 1);      // 从后一位开始，跳过一个空位找下一个空位
            if (-1 == i) {
                break;
            }
        }
        
        return ans;
    }
};
```
