```javascript

class SegmentTree {
    constructor(options) {
        if (!options.array || typeof options.merger !== 'function') {
            throw new Error('options error!')
        }
        this.array = options.array || []  // ç”¨æˆ·ä¼ é€’æ¥çš„æ•°ç»„
        this.merger = options.merger

        // åˆå§‹åŒ– treeçš„æœ€å¤§å®¹ç§¯
        this.tree = new Array(4 * this.array.length)

        // æ„å»ºçº¿æ®µæ ‘
        this.buildSegmentTree(0, 0, this.array.length - 1)
    }

    /**
     * åœ¨treeIndexçš„ä½ç½®åˆ›å»ºæ ‡ç¤ºåŒºé—´[l, ..., r]çš„çº¿æ®µæ ‘
     * @param treeIndex
     * @param l
     * @param r
     */
    buildSegmentTree(treeIndex, l, r) {
        if (r < 0) {
            return
        }

        // è¿˜å‰©ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™, é€’å½’ç»“æŸ
        if (l === r) {
            this.tree[treeIndex] = this.array[l]
            return
        }

        const leftTreeIndex = SegmentTree.leftChild(treeIndex)
        const rightTreeIndex = SegmentTree.rightChild(treeIndex)
        const mid = Math.floor(l + (r - l) / 2)

        // åœ¨å·¦å­æ ‘ leftTreeIndexä½ç½®åˆ›å»ºåŒºé—´[l, mid]çš„çº¿æ®µæ ‘
        this.buildSegmentTree(leftTreeIndex, l, mid)

        // åœ¨å³å­æ ‘ rightTreeIndexä½ç½®åˆ›å»ºåŒºé—´[mid + 1, r]çš„çº¿æ®µæ ‘
        this.buildSegmentTree(rightTreeIndex, mid + 1, r)

        this.tree[treeIndex] = this.merger(this.tree[leftTreeIndex], this.tree[rightTreeIndex])
    }

    /**
     * æŸ¥è¯¢åŒºé—´ [queryL, queryR]çš„å€¼
     * @param queryL
     * @param queryR
     * @return {number}
     */
    query(queryL, queryR) {
        // 0 1
        if (
            queryL < 0
            || queryL > this.array.length
            || queryR < 0
            || queryR > this.array.length
            || queryL > queryR
        ) {
            return []
        }

        return this._query(0, 0, this.array.length - 1, queryL, queryR)
    }

    /**
     * åœ¨ä»¥ treeIndex ä¸ºæ ¹çš„çº¿æ®µæ ‘ä¸­ [l...r]çš„èŒƒå›´é‡Œ, æœç´¢åŒºé—´[queryL, queryR]çš„å€¼
     * @param treeIndex
     * @param l
     * @param r
     * @param queryL
     * @param queryR
     * @return {*}
     * @private
     */
    _query(treeIndex, l, r, queryL, queryR) {
        // é€’å½’å‡½æ•°çš„ç»“æŸæ¡ä»¶
        if (l === queryL && r === queryR) {
            return this.tree[treeIndex]
        }
        const mid = Math.floor(l + (r - l) / 2)
        const leftTreeIndex = SegmentTree.leftChild(treeIndex)
        const rightTreeIndex = SegmentTree.rightChild(treeIndex)

        // å¦‚æœæŸ¥è¯¢åŒºé—´åœ¨å³å­æ ‘
        if (queryL >= mid + 1) {
            return this._query(rightTreeIndex, mid + 1, r, queryL, queryR)
        }
        // å¦‚æœæŸ¥è¯¢åŒºé—´åœ¨å·¦å­æ•°
        else if (queryR <= mid) {
            return this._query(leftTreeIndex, l, mid, queryL, queryR)
        }
        // æŸ¥è¯¢åŒºé—´ queryL .. queryRçš„å†…å®¹å³åœ¨å·¦å­æ ‘,åˆåœ¨ğŸˆ¶å³å­æ ‘
        else {
            const leftResult = this._query(leftTreeIndex, l, mid, queryL, mid)
            const rightResult = this._query(rightTreeIndex, mid + 1, r, mid + 1, queryR)
            return this.merger(leftResult, rightResult)
        }
    }

    /**
     * çº¿æ®µæ ‘åŒºé—´æ›´æ–°
     * @param index
     * @param e
     */
    set(index, e) {
        if (index < 0 || index > this.array.length) {
            throw new Error('index error!')
        }

        // æ•°ç»„å¯¹åº”çš„ä¸‹æ ‡æ›´æ–°
        this.array[index] = e

        // å†…éƒ¨ç»´æŠ¤çš„ä¸€ä»½ treeæ•°æ®æ›´æ–°, ä¸”æ›´æ–°ç»“æœå½±å“å½“å‰æ›´æ–°èŠ‚ç‚¹çš„æ‰€æœ‰çˆ¶çº§,é‡æ–° merger
        this._set(0, 0, this.array.length, index, e)
    }

    _set(treeIndex, l, r, index, e) {
        // å·²æ‰¾åˆ°æ›´æ–°çš„èŠ‚ç‚¹
        if (l === r) {
            this.tree[treeIndex] = e
            return
        }

        const mid = Math.floor(l + (r - l) / 2)
        const leftTreeIndex = SegmentTree.leftChild(treeIndex)
        const rightTreeIndex = SegmentTree.rightChild(treeIndex)
        /**
         *  l >= mid + 1
         *  r <= mid
         *  [1,2,3,4,5]
         *  mid = 2
         *  index 2
         */
        if (index >= mid + 1) {
            this._set(rightTreeIndex, mid + 1, r, index, e)
        }
        else if (index <= mid) {
            this._set(leftTreeIndex, l, mid, index, e)
        }

        this.tree[treeIndex] = this.merger(this.tree[leftTreeIndex], this.tree[rightTreeIndex])
    }

    getSizie() {
        return this.array.length
    }

    /**
     * æ ¹æ®ä¸‹æ ‡è·å– arrayçš„æ•°æ®
     * @param {number} index
     */
    get(index) {
        if (index < 0 || index > this.array.length) {
            throw new Error(`${index} min&&max`)
        }
        return this.array[index]
    }

    /**
     * ä¸€ä¸ªç´¢å¼•æ‰€è¡¨ç¤ºçš„å…ƒç´ å·¦å­©å­èŠ‚ç‚¹çš„ç´¢å¼•
     * @param index
     * @return {number}
     */
    static leftChild(index) {
        return index * 2 + 1
    }

    /**
     * ä¸€ä¸ªç´¢å¼•æ‰€è¡¨ç¤ºçš„å…ƒç´ å³å­©å­èŠ‚ç‚¹çš„ç´¢å¼•
     * @param index
     * @return {number}
     */
    static rightChild(index) {
        return index * 2 + 2
    }
}
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    const options = {
        array: nums,
        merger: function (n, m) {
            return n + m
        }
    }

    this.seg = new SegmentTree(options)
};

/**
 * @param {number} i
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
    return this.seg.query(i, j)
};

/** 
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(i,j)
 */
```