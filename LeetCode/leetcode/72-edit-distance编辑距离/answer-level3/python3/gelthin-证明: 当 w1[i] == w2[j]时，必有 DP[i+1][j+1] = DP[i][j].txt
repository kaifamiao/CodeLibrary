### 解题思路
教科书标准 DP 题.
这题就是要注意 DP 数组初始化不要出错了。DP[0][j] = j, DP[i][0] = i, DP[0][0] = 0

liweiwei 大神给了细致的分析，并且提到了: 重叠子问题，最优子结构，**无后效性**

这里留了一道难题：如何证明 或者 证否下面命题?
+ 当 w1[i] == w2[j]时， DP[i+1][j+1] = DP[i][j] （这里虽然有多种方式得到 DP[i+1][j+1], 但数值上必然有这个式子成立）
+ 例如对于实例， w1 = "abcc", w2 = "abc". 最后既可以删除 w1 中最后一个 c, 也可以考虑匹配 "abc" 和 "ab", 删去倒数第二个 "c"
+ 官方题解没有对此进行分析。

#### 我试着来证明，当 w1[i] == w2[j]时，必有 DP[i+1][j+1] = DP[i][j]
证明如下:

注意到 DP[i+1][j+1] 还可能更新为 min([DP[i][j] + 1, DP[i+1][j] + 1, DP[i][j+1] + 1])，故需要证明 DP[i][j] <= min([DP[i][j] + 1, DP[i+1][j] + 1, DP[i][j+1] + 1])，进一步只需证明：DP[i][j] <= min(DP[i+1][j] + 1, DP[i][j+1] + 1)。

下面先来证明 DP[i][j] <= DP[i+1][j] + 1。DP[i+1][j] 对应了求解 (w1[:i+1], w2[:j]) 的最优操作序列的编辑距离， 考虑最优操作序列中对 w1[i] 的操作： 

+ 1. w1[i] 被删除。考虑 DP[i+1][j] 对应的最优操作序列，从中删去 "删除 w1[i]" 这一操作，则剩下的操作序列构成了求解 (w1[:i], w2[:j]) 的一个可行操作序列，这一序列编辑距离为 DP[i+1][j]-1。 而 DP[i][j] 代表求解 (w1[:i], w2[:j]) 的最优操作序列的编辑距离， 故 DP[i][j] <= DP[i+1][j]-1。

+ 2. w1[i] 被替换。此时必然是 w1[i] 替换为 w2[:j] 中某一个元素，设为 w2[k]。考虑 DP[i+1][j] 的最优操作序列中 w1[i] 替换为 w2[k] 的这个动作，则在此动作前一个位置再补充一个操作，"插入字符 w1[i]", 则这一修改的操作序列构成了求解 (w1[:i], w2[:j]) 一个可行的操作序列（不一定是最优操作序列）。由此推出，DP[i][j] <= DP[i+1][j] + 1。

+ 3. w1[i] 没有被删除，也没有被替换，那么 w1[i] 必然对应到了 w2[:j] 中一个字符，设为 w2[k]。 同样地，考虑 DP[i+1][j] 的最优操作序列，在操作序列的恰当位置插入一个操作，"插入字符 w1[i]"，则这一修改的操作序列构成了求解 (w1[:i], w2[:j]) 一个可行的操作序列，故 DP[i][j] <= DP[i+1][j] + 1

对于 DP[i]][j] <= DP[i][j+1] + 1, 也可以类似证明。
证毕。

这一证明过程有点奇怪，居然没有用到条件 w1[i] == w2[j], 而是天然地就有 DP[i][j] <= min(DP[i+1][j] + 1, DP[i][j+1] + 1)。 不知道我是否漏考虑了情形。在相似题 [712. 两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/solution/gelthin-dpguo-cheng-tan-xin-by-gelthin/) 类似结论的证明中，是必须要用到这一条件的。


#### 其实跳出来想，DP[i][j] <= min(DP[i+1][j] + 1, DP[i][j+1] + 1) 这一结果似乎是显然的
(w1[:i], w2[:j]) 比起 (w1[:i+1], w2[:j]) 或者 (w1[:i], w2[:j+1]) 只是少了一个字符而已，那么多加一次操作，补上一个字符，总可以把(w1[:i], w2[:j]) 规约到(w1[:i+1], w2[:j]) 或者 (w1[:i], w2[:j+1])， 因此，必然有：DP[i][j] <= min(DP[i+1][j] + 1, DP[i][j+1] + 1) 。

证明过程不需要用到条件 w1[i] == w2[j]，也即当这一条件不成立时，也有 DP[i][j] <= min(DP[i+1][j] + 1, DP[i][j+1] + 1)。

+ 当 w1[i] == w2[j] 时，DP[i][j] 对应的操作序列直接构成了 (w1[:i+1], w2[:j+1]) 的可行解， DP[i+1][j+1] <= DP[i][j]。
+ 当 w1[i] != w2[j], DP[i][j] 对应的操作序列需要再加上 "替换 w1[i] 为 w2[j]" 才构成 DP[i+1][j+1] 的可行解, DP[i+1][j+1] <= DP[i][j]+1。 但仅仅到这里，仍无法说明，DP[i+1][j+1] > DP[i][j]

上面分析，似乎都是给出了上界，怎么给出 DP[i+1][j+1] 的下界似乎没有想得特别清楚，这里也许需要考虑最后一次操作动作，然后分治递归。由于最后一次操作至多改动一个字符，DP[i+1][j+1] 必然依赖于 DP[i][j], DP[i+1][j], DP[i][j+1]。

#### 为何 DP 能够给出正确的解答：

DP 需要按照从左到右顺序逐个字符处理，也即最后一次操作必然是处理 w1[i] 或者 w2[j]对应的字符，但是按照题意，理论上操作序列是可以无序跳着字符处理(例如， 先处理最后一个字符，再处理第一个字符，再处理中间的字符）。这里 DP 能够正确，应该是任何一种合法的操作序列，都可以等价重排为 按照顺序从字符串左边到右边依次处理的序列，然后这个序列被 DP 过程考虑了进来，因此 DP 能给出正确答案。

### 代码

```python3
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        ## DP 方法
        # DP[i][j] 代表 A[:i] 和 B[:j] 经过处理以后对应所需的处理次数（也即编辑距离）
        # if A[i] = B[j], 
        #    可以有： DP[i][j] = DP[i-1][j-1] 但也不一定是这个，需要证明
        #  if A[i] != B[j] 
        #        替换 A[i] 为 B[j]： DP[i][j] = DP[i-1][j-1] + 1
        #        在 A 中插入 B[j]：  DP[i][j] = DP[i][j-1] + 1
        #        删除 A[i]：         DP[i][j] = DP[i-1][j] + 1

        m, n = len(word1), len(word2)
        DP = [[0 for j in range(n+1)] for i in range(m+1)]
        # 初始化：DP[0][0] 为 0
        for j in range(n+1):
            DP[0][j] = j
        for i in range(m+1):
            DP[i][0] = i
    
        for i in range(m):
            for j in range(n):
                DP[i+1][j+1] = min([DP[i][j] + 1,DP[i+1][j] + 1, DP[i][j+1] + 1]) # 最初初始化 DP[i+1][j+1] 为 0
                if word1[i] == word2[j]:  # 多一种选择，但也不一定
                    DP[i+1][j+1] = min(DP[i+1][j+1], DP[i][j])
        return DP[m][n]
```