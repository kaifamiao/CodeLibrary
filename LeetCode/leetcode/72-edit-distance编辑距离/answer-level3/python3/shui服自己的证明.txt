### 解题思路
所谓动态规划
D[i][j]表示单词1前i个变到单词2前j个的最短距离  增删改操作时可以还原的 所以也是单词2前j个变到单词1前i个的最短距离（这个不用纠结）

    若已知D[i][j-1] D[i-1][j] D[i-1][j-1]
    首先相比于D[i-1][j-1] 
    D[i][j-1]最大是D[i-1][j-1]+1
    D[i-1][j]最大是D[i-1][j-1]+1
    D[i][j] 最大是D[i-1][j-1]+1

D[i][j]表示单词1 2 前i j个之间互换的最短距离
考察D[i][j]和D[i+1][j]

    ?????? + a
    !!!!!!
    D[i+1][j]<=D[i][j]+1
    万般无奈我也可以只加一步罢了

    xbb + c
    bba
    D[i+1][j]=D[i][j]

    xbb +a
    bba
    D[i+1][j]=D[i][j]-1

    ?????? + a
    !!!!!!
    如果的D[i+1]][j]=D[i][j]-2
    那么对新添加的a有3种操作
        1 如果对a做了删除 有一步分出来对a删除 那么必然有D[i][j]-3步就可以使得i,j的转换实现 矛盾
        2 如果对a做了修改 将修改 变为删除、增加两步 D[i+1]][j]+1=D[i][j]-2+1=D[i][j]-1 就是删除a 增加新的值 实现转换的步数  那么D[i][j]-2 是能实现i,j转换的步数 矛盾
        3 如果对a什么都没做 D[i+1]][j]+2=D[i][j]-2+2=D[i][j] 就是删除a后 再插入a后的步数 那么在原本没有a的时候 直接插入a D[i][j]-1 就能实现i,j转换 矛盾 

同理 
最后可得

    D[i+1][j]=D[i][j]-1或D[i][j]或D[i][j]+1


对一个字符串的增删改操作 
是可以颠倒顺序的
在一个地方删除 在一个地方增加 在一个地方修改
首先需要避免重复操作 如果在某个位置插入了 元素 不会再去删除这个元素 或者修改这个元素
如果删除了某个位置的元素 不会再在这个元素的位置上插入 修改
如果修改了某个位置的元素 不会再进行该位置的插入删除

那么将复杂的顺序 可以排序成前执行所有插入操作 在执行所有删除操作 在执行所有修改操作

一个操作可以由此进行解释 根据其关联的一个元素 先有操作 关联元素时认为指定的

当元素在字符串非某尾时  一个操作可以是删除该元素 修改该元素 在该元素前一格插入
当元素在字符串末尾时 一个操作可以删除该元素 修改该元素 在该元素前一格插入 在该元素后一格子插入

考察D[i][j]变到D[i+1][j+1]

    让word1变成word2 
    如果w1[i+1]=w2[j+1]  
        D[i+1][j+1]<=D[i][j+1]+1  删除w1[i+1] 然后变到新w2
        D[i+1][j+1]<=D[i+1][j]+1  在w1[i+1]后新加w2[j+1] 然后前面部分变到原w2
        D[i+1][j+1]<=D[i][j]      原w1变到原w2 
    如果w1[i+1]!=w2[j+1] 
        D[i+1][j+1]<=D[i][j+1]+1  删除w1[i+1] 然后变到新w2
        D[i+1][j+1]<=D[i+1][j]+1  在w1[i+1]后新加w2[j+1] 然后前面部分变到原w2
        D[i+1][j+1]<=D[i][j]+1    原w1变到原w2 然后w1[i+1]修改为w2[j+1]

下面需要验证的是 D[i+1][j+1]  的解 是否在以上三种方法的集合中  

这样子想 想让w1[0到i+1]变为w2[0到j+1]
那么设最短步数为D[i+1][j+1] 对应的一个解法过程为s s由若干步骤描述组成
那么 可以先将s整理排序 即先 做删除 插入 再做修改

    有三种可能的情况
    a w1[i+1]可以被删除 那么就是其他位置对应w2的最后一位w2[j+1] 既然有删除操作了 那么可以将删除操作放到最后一步  _D[i+1][j+1] = D[i][j+1]+1
    b 如果 w1[i+1]没有被删除 （可以被修改但是不重要）且对应的位置不是w2的末位w2[j+1] 而是w2[0到j+1]的到数第x+1位那么 s中必然有在w1[i+1]末尾插入x个元素的操作  x>=1 而插入的最后一个元素必然是w2[j+1]  独立出这一步 那么_D[i+1][j+1] = D[i+1][j]+1
    c 如果 w1[i+1]没有被删除 对应位置恰好是w2的末尾w2[j+1] 那么s中的所有操作中，和w1[i+1]相关的，如果存在的话，也只有修改操作，不然就会改变w1[i+1]对应位置或者多余重复。（删除再加回来是重复的）
        如果w1[i+1]==w2[j+1] s中必定没有对w1[i+1]的修改操作，否则无法使新w1变为新w2。所以不操作w1[i+1] 那么使w1[0到i]变为w2[0到j]即可  _D[i+1][j+1] = D[i][j]
        如果w1[i+1]!=w2[j+1] s中必定有对w1[i+1]的修改操作，使w1[i+1]=w2[i+1]。那么将该修改操作挪到最后，那么前面的操作便是 使w1[0到i]变为w2[0到j]即可  _D[i+1][j+1] = D[i][j]+1
    三种情况下的 D[i+1][j+1]的考察值_D[i+1][j+1]，都是三种情况下的最短操作步骤。因为有且只有这三种情况，每种情况下都已经证明了必然存在可以被独立到最后处理的一步或者零步，使得剩下的操作完成了某种任务 而要是每种情况下的考察值步数最少 就是独立后剩下的任务的步数最少 所以剩下任务就可以用前面的迭代值表示。

于是 w1[i+1]==w2[j+1]时 D[i+1][j+1] 可能取值就是三种 即 D[i][j+1]+1 D[i+1][j]+1 D[i][j] 必然取最小值 min(D[i][j+1]+1,D[i+1][j]+1,D[i][j])
同理 w1[i+1]!=w2[j+1]时 D[i+1][j+1]=min(D[i][j+1]+1,D[i+1][j]+1,D[i][j]+1)
同时根据前文的证明 D[i][j+1]+1>=D[i][j]-1+1=D[i][j] D[i+1][j]+1>=D[i][j]-1+1=D[i][j] 
所以 w1[i+1]==w2[j+1]时 D[i+1][j+1]=D[i][j]必定成立
所以最后的公式为 

    D[i+1][j+1]=min(D[i][j+1]+1,D[i+1][j]+1,D[i][j]+1),w1[i+1]!=w2[j+1]
    D[i+1][j+1]=D[i][j],w1[i+1]==w2[j+1]

### 代码

```python3
class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        l_w1 = list(word1)
        l_w2 = list(word2)
        l_w1.insert(0,'')
        l_w2.insert(0,'')
        l1 = len(l_w1)
        l2 = len(l_w2)
        buf = [[0 for j in range(l2)] for i in range(l1)]
        for i in range(l1):
            buf[i][0]=i
        for j in range(l2):
            buf[0][j]=j
        for i in range(1,l1):
            for j in range(1,l2):
                if l_w1[i]==l_w2[j]:
                    buf[i][j]=buf[i-1][j-1]
                else:
                    buf[i][j]=1+ min(buf[i-1][j-1],buf[i][j-1],buf[i-1][j])
        return buf[l1-1][l2-1]
```