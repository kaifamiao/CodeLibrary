### 解题思路
1. 定义数组元素的含义：你要求什么
我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]。

2. 找出数组元素之间的关系式：往后退一步
接下来我们就要找 dp[i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp[i] [j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。

这里先把题目的条件拉过来：

插入一个字符
删除一个字符
替换一个字符
还有第一步我们分析的结果：

当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]。

也就是说：

如果是在字符串word1末尾插入一个与 word2[j] 相等的字符就能使它符合条件,(注意这里的word1是字符串,word2[j]是字符),那么在这个操作之前，word1后面肯定是少一个字母的，所以将 word1 转化为 word2 所使用的最少操作次数应该是将 后面少一个字母的word1 转化为 word2 所使用的最少操作次数再加上本次操作，也就是加1，翻译成代码就是：dp[i] [j] = dp[i-1] [j] + 1；因为i-1代表的是长度嘛；
如果是在字符串word1末尾删除一个字符就能使它符合条件,那么在这个操作之前，word1后面肯定是多一个字母的，所以将 word1 转化为 word2 所使用的最少操作次数应该是将 后面多一个字母的word1 转化为 word2 所使用的最少操作次数再加上本次操作，也就是加1，翻译成代码就是：dp[i] [j] = dp[i] [j-1] + 1；
如果把字符 word1[i] 替换成与 word2[j] 相等，意思就是将这两个字符串的最后一个字符交换一下就可以了，那交换之前呢？交换之前的最少操作此时肯定是dp[i-1][j-1]，因为我们忽略了最后一个元素了，所以翻译成代码就是：dp[i] [j] = dp[i-1] [j-1] + 1;
我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有：

dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;

于是，我们的关系式就推出来了。

3. 找出初始值：公式求不出的值
看看哪个是公式求不出的，i和j两个都不能等于0,所以求不出的就是他俩有一个等于零的时候，也就是所有的dp[0] [0….n] 和所有的 dp[0….m] [0]；

这里的0….m-1可以换算成1...m，也就是1到i，这里分析出来的dp[0….m-1] [0]就是你代码中要代入公式初始化写在左边的。

### 代码

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int m = word1.length();
        int n = word2.length();
        int[][] dp = new int[m+1][n+1];

        if (m*n==0) return m+n;

        for (int i=0; i<=m; i++) dp[i][0]=i;
        for (int j=0; j<=n; j++) dp[0][j]=j;


        for (int i=1; i<=m; i++) {
            for (int j=1; j<=n; j++) {
                if (word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j-1], dp[i-1][j]), dp[i][j-1]) + 1;
                }
            }
        }
        return dp[m][n];
    }
}
```