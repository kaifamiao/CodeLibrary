1. 首先想到使用递归加备忘录的方式解决，但是发现备忘录中存的不一定是最优的子结果，因此无法得到最优的结果。
2. 因此还是需要直接使用动态规划的思想，通过转移方程解决。转移方程比较简单dp[i][j] = min(dp[i-1][j], dp[i][j-1],dp[i-1][j-1]) + 1,当指定元素不同时。
3. 通过压缩空间，可以使用一行dp数组存储，但是需要两个存储变量辅助解决。