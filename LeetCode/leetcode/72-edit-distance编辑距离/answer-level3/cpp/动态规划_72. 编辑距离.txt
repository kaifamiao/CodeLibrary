### 解题思路 动态规划
    /*
     * 动态规划
     *
     * 对单词A,B进行三种操作：插入一个字符、删除一个字符、替换一个字符，使得A,B相同。
     * 因为对单词A的删除和对单词B的插入操作等价，对单词B的删除和对单词A的插入操作等价，
     * 对单词A替换和对单词B的替换等价，所以将A，B转换为相等本质的操作只有三种：
     * 1. 在单词A中插入一个字符，如果知道horse到ro的编辑距离为a，则horse到ros的编辑距离不会超过a+1；
     * 2. 在单词B中插入一个字符，如果知道hros到ros的编辑距离为b，则horse到ros的编辑距离不会超过b+1；
     * 3. 修改单词A的一个字符，如果知道hors到ro的编辑距离为c，则horse到ros的编辑距离不会超过c+1。
     *
     * 这样就能将原问题转化为规模较小的子问题，符合动态规划的思想。
     * 定义二维数组D[i][j]表示单词A的前i个字符和B的前j个字符之间的编辑距离。例如：
     * hor(i)se --> word1[1...i]   ro(j)s --> word2[1...j]    D[i][j] = hor与ro之间的编辑距离
     *
     * 根据上面的推论，当获得D[i][j-1]，D[i-1][j]和D[i-1][j-1]的值之后可以计算出D[i][j]。
     * 1. D[i][j-1]对应A的前i个字符和B的前j-1个字符编辑距离的子问题，D[i][j]最小为D[i][j-1]+1;
     * 2. D[i-1][j]对应A的前i-1个字符和B的前j个字符编辑距离的子问题，D[i][j]最小为D[i-1][j]+1;
     * 3. D[i-1][j-1]对应A前i-1个字符和B前j-1个字符编辑距离的子问题，D[i][j]最小为D[i-1][j-1]+1，
     *    特别的，如果A的第i个字符和B的第j个字符原本相同，则D[i][j]最小可为D[i-1][j-1]。
     *
     * 由上可得，动态规划的状态转移方程为：
     * 1. 如果A和B的最后一个字符相同：D[i][j] = 1+ min(D[i][j-1], D[i-1][j], D[i-1][j-1] - 1)
     * 2. 如果A和B的最后一个字符不同：D[i][j] = 1+ min(D[i][j-1], D[i-1][j], D[i-1][j-1])
     *
     * 边界情况：
     * 一个空字符串和一个非空字符串的编辑距离为D[i][0] = i和D[0][j] = j，
     * D[i][0]相当于word1执行i次删除操作，D[0][j]相当于word1执行j次插入操作。
     * */
### 代码

```cpp
int minDistance(std::string word1, std::string word2) {
    int n = word1.length();
    int m = word2.length();

    // 如果有一个字符串为空
    if (n * m == 0) {
        // 则返回不为空字符串的长度
        return n + m;
    }

    // 设置状态数组
    int dp[n + 1][m + 1];

    // 初始化单词A的边界值
    for (int i = 0; i < n + 1; i++) {
        dp[i][0] = i;
    }

    // 初始化单词B的边界值
    for (int j = 0; j < m + 1; j++) {
        dp[0][j] = j;
    }

    // 动态转移方程求每个状态的值
    for (int i = 1; i < n + 1; i++) {
        for (int j = 1; j < m + 1; j++) {
            // D[i][j-1]
            int a = dp[i][j - 1] + 1;
            // D[i-1][j]
            int b = dp[i - 1][j] + 1;
            // D[i-1][j-1]
            // 在A的第i个字符等于B的第j个字符时
            int c = dp[i - 1][j - 1];
            // A的第i个字符不等于B的第j个字符时
            if (word1[i - 1] != word2[j - 1]) {
                // D[i-1][j-1]
                c += 1;
            }
            // 状态转移方程
            dp[i][j] = std::min(a, std::min(b, c));
        }
    }

    // 返回A的第n个字符B的第m个字符的值
    return dp[n][m];
}
```