### 解题思路

> 自从某次死磕爬楼梯和硬币兑换II的题目后，见[一次由爬楼梯和零钱兑换II引起的DP子问题定义思考](https://www.jianshu.com/p/42fe8e5192af), 就不再害怕动态递归了。

动态规划最大难点在于定义状态，定义状态最重要的是找到子问题需要多少变量进行描述。

我们可以通过寻找问题中的自变量个数来确定变量数目。我们问题的自变量就两个，字符串A和字符串B，对应的因变量是两者的编辑距离。

于是我们的状态数组为，DP[i][j], 对于s1的前i个字符和s2的前j个字符，两者的编辑距离

接下来是状态转移方程，

如果s1[i-1] == s2[i-1],  DP[i][j] = DP[i-1][i-1], 即如果两者前一个字符串相同，那么不需要操作

否则, DP[i][j] = min(dp[i-1][j]  + 1, //删除i
                    dp[[i][j-1]  + 1, //删除j
                    dp[i-1][j-1] + 1  //替换，
                ])

代码实现如下:

```cpp
class Solution {
public:
    int minDistance(string s1, string s2) {
        int m = s1.size();
        int n = s2.size();
        int dp[m+1][n+1];
        for (int i = 0; i < m+1; i++) dp[i][0] = i;
        for (int i = 0; i < n+1; i++) dp[0][i] = i;

        for (int i = 1; i < m+1; i++){
            for (int j = 1; j < n+1; j++){
                if (s1[i-1] == s2[j-1]){
                    dp[i][j] = dp[i-1][j-1];
                } else{
                    dp[i][j] = min(min(dp[i-1][j] + 1, dp[i][j-1] + 1), dp[i-1][j-1] + 1);
                }
            }
        }

        return dp[m][n];
    }
};
```

代码的注意点

- 我们的数组大小为 m+1 x n+1 , 因为我们考虑字符串为空的情况，也就是对于abc, 我们分别考察 ' ', 'a', 'b', 'c'
- 初始化. 对于' ', 变化成另外字符串，他的操作肯定是随着字符串长度增加而增加
- 为什么没有增加操作？ 因为一方的删除等价于另一方的增加。例如abc 和 ac,  我们可以删除abc的b, 也可以在ac中增加b。 无论是哪种，他的编辑距离都只会增加1.

此外，在状态转移方程中，对于`s1[i-1] == s2[j-1])`, 我们其实也可以考虑三种情况

DP[i][j] = min(dp[i-1][j]  + 1, //删除i
                dp[[i][j-1]  + 1, //删除j
                dp[i-1][j-1] //不操作
                ])

从直觉上，不操作是最佳选择，因此我就不考虑另外的情况，最后发现结果也是对的，最终就只用了一种情况。