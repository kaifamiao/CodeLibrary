
#### 思路

要找到比当前数字大的下一个数。我们只能从数字的个位数开始从小往大找。当数字的排序是降序的, 也就是987这样的排序时, 是不存在下一个更大的数的。所以要有下一个更大的数, 数字的排序必然会存在打断降序排序的情况。

如6987, 千位数上的6与后面三位9、8、7交换都能形成更大的数字, 想要获取下一个更大的数字, 那就得找到9、8、7这3个数中最小且大于6的那个数字了。

因为我们前面遍历的时候, 数字都是降序排序的, 所以数字也同样从个位开始是从小到大排列的, 我们只需要再从个位数开始遍历, 找到第一个大于6的元素, 将他们交换即可。

交换之后还需要将6之后的数字重新排序, 因为6987这个数字我们可以观察得到下一个更大的数是7689。在前面我们已经将6与7的位置互换了, 得到了7986, 但7986并不是真正的结果, 所以需要将7之后的数字重新排序。

最后需要判断一下得到是数字是否大于32位。

数字交换和排序, 我们可以使用数组来处理, 将每一位的数字写入数组中, 数组头对应个位数, 就能很方便的处理数字交换和排序了



#### code

```
var max = 1 << 31
func nextGreaterElement(n int) int {
    if n < 10 || n+1 > max {
        return -1
    }
    m := []int{}
    for n > 0 {
        m = append(m, n%10)
        n /= 10
    }
    n1 := -1
    for i := 1; i < len(m); i++ {
        if m[i] < m[i-1] {
            n1 = i
            break
        }
    }
    if n1 == -1 {
        return -1
    }
    n2 := -1
    for i := 0; i < n1; i++ {
        if m[i] > m[n1] {
            n2 = i
            break
        }
    }
    m[n1], m[n2] = m[n2], m[n1]
    sort.Sort(sort.Reverse(sort.IntSlice(m[:n1])))
    n, n1 = 0, 1
    for _, v := range(m) {
        n += n1*v
        n1 *= 10
    }
    if n > max || n < 0 {
        return -1
    }
    return n
}
```





    