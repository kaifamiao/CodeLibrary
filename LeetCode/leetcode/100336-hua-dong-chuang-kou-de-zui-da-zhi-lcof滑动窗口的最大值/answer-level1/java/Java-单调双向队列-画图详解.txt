## 解题思路
这分明就是一道 [LeetCode-239](https://leetcode-cn.com/problems/sliding-window-maximum/) 的`hard`级别的题目啊。

我们先看什么是`单调的双向队列`，`双向队列`大家都知道，既能在头部进行插入、删除操作，也能在尾部进行插入删除操作，而所谓的`单调`，就是我们人为规定从队列的头部到尾部，所存储的元素是依次递减（变小）的。如下所示：

```
头部                      尾部
 --------------------------
|  5   3   2   1   0  -1   |
 --------------------------
  由大     →       到小
```

也就是说，我们维护一个`单调的双向队列`，窗口在每次滑动的时候，我就从队列`头部`取当前窗口中的`最大值`，每次窗口新进来一个元素的时候，我就将它与队列中的元素进行大小比较：

- 如果刚刚进来的元素比队列的尾部元素`大`，那么先将队列尾部的元素弹出，然后把刚刚进来的元素添到队列的尾部；
- 如果刚刚进来的元素比队列的尾部元素`小`，那么把刚刚进来的元素直接添到队列的尾部即可。

下面通过图示进行说明。

## 分析
### 添加元素

**在不规定窗口大小的前提下**，我们先看看如何将新元素添加到`单调的双向队列`中。假如有`5、4、1、2、6`要进入`单调的双向队列`，首先让索引为`0`的元素`5`进入，由于之前队列是空的，所以`5`直接进去即可，如下所示：

```
头部                    尾部
 --------------------------
|  5                      |
|  ↑                     |
|  0                      |
 --------------------------
  大                  小
```

此时，索引`1`位置上的`4`要进队列，则需要比较队列尾部与`4`的大小关系。由于`5`是大于`4`的，并且`4`从尾部进去以后能够满足从头到尾、从大到小的规定，所以我们让`4`进去即可，如下所示：

```
头部                    尾部
 --------------------------
|  5    4                 |
|  ↑   ↑                |
|  0    1                 |
 --------------------------
  大                  小
```
然后，索引`2`位置上的元素`1`也想要进去，根据我们的规定，让它直接进入就好了，如下所示：

```
头部                    尾部
 --------------------------
|  5    4    1            |
|  ↑   ↑   ↑           |
|  0    1    2            |
 --------------------------
  大                  小
```

然后，索引`3`位置上的元素`2`想要进去，**此时，由于尾部的元素`1`是小于元素`2`的，`2`进去以后不满足从大到小的规定，所以让`1`从尾部出来，直接丢掉它，然后再让元素`2`从尾部进入**，如下所示：

```
头部                    尾部
 --------------------------
|  5    4    2            |
|  ↑   ↑   ↑           |
|  0    1    3            |
 --------------------------
  大                  小
```

你可以看到，对于上面的这些过程，每次在元素进来之前，我们都可以通过`LinkedList.peekFirst()`操作来获取队列的头部，也就是整个队列的最大值，同时也是当前窗口的最大值。

每进入一个元素我就可以取最大值，每进入一个元素我就可以取最大值，每进入一个元素我就可以取最大值。（这句话说了三遍~）

因此，我就是通过这种既能从头部进出，又能从尾部进出的结构，来维持窗口的最大值的。

好了，现在还剩下索引为`4`的元素`6`想要进入队列，我们发现`6`比队列中任何一个元素都要大，所以我们将队列中的所有元素都弹出，然后只让`6`进入，如下所示：

```
头部                    尾部
 --------------------------
|  6                      |
|  ↑                     |
|  4                      |
 --------------------------
  大                  小
```
此时，窗口中的最大值就是`6`了。**要注意一点的是：如果此时又来了一个索引为`5`的元素`6`想要进入队列中，则我们需要将之前的索引为`4`的元素`6`进行弹出，让新来的`6`进入**，此时就变成了如下所示：

```
头部                    尾部
 --------------------------
|  6                      |
|  ↑                     |
|  5                      |
 --------------------------
  大                  小
```

为什么在元素相等的情况下，也要更新元素呢？

这时因为窗口是每次向右进行滑动的，每次进入到窗口中的值都有可能是当前窗口中最大的值，我们将相同的值进行更换，其实是为了更新它的索引。这样在窗口进行滑动的时候，每次的最大值都是新的，就能保持最大。

### 删除元素
不妨假设以下场景，窗口大小是 2，之前窗口中包含`5`和`4`，**但是此时已经来到了`4`、`1`元素**，队列中的情况也如下所示： 

```
元素： 5  [4  1]  2
索引： 0   1  2   3

头部                    尾部
 --------------------------
|  5   4   1              |
|  ↑  ↑  ↑             |
|  0   1   2              |
 --------------------------
  大                  小
```
由于元素`5`已经被滑动窗口略过了，所以我们应将队列中的最大值，也就是`5`弹出，让`4`成为当前窗口新的最大值，如下所示：

```
头部                    尾部
 --------------------------
|     4   1               |
|     ↑  ↑              |
|     1   2               |
 --------------------------
  大                  小
```

### 总结
总之，整个流程看起来比较繁琐，不过你可以用一个具体的例子，按照下面的代码走一遍，就能知道整个流程是怎么样运行的。


## 代码
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums == null || k < 1 || nums.length < k) {
            return new int[0];
        }

        int index = 0;
        int[] res = new int[nums.length - k + 1];
        LinkedList<Integer> qMax = new LinkedList<>();

        for (int i = 0; i < nums.length; i++) {
            // 在队列不为空的情况下，如果队列尾部的元素要比当前的元素小，或等于当前的元素
            // 那么为了维持从大到小的原则，我必须让尾部元素弹出
            while (!qMax.isEmpty() && nums[qMax.peekLast()] <= nums[i]) {
                qMax.pollLast();
            }
            // 不走 while 的话，说明我们正常在队列尾部添加元素
            qMax.addLast(i);
            // 如果滑动窗口已经略过了队列中头部的元素，则将头部元素弹出
            if (qMax.peekFirst() == (i - k)) {
                qMax.pollFirst();
            }
            // 看看窗口有没有形成，只有形成了大小为 k 的窗口，我才能收集窗口内的最大值
            if (i >= (k - 1)) {
                res[index++] = nums[qMax.peekFirst()];
            }
        }
        return res;
    }
}
```
## 全部题解
《剑指Offer》的全部题解与 LeetCode 的部分题解在此下方，其中还包含**基础算法**与**进阶算法**，欢迎查看~
[LeetCode、SwordToOffer and other algorithms in Java.](https://github.com/dyfloveslife/LeetCodeAndSwordToOffer)