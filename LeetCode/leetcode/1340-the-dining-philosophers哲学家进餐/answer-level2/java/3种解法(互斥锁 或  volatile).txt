这道题本质上其实是想考察**如何避免死锁**。
易知：当 $5$ 个哲学家都拿着其左边(或右边)的叉子时，会进入死锁。

PS：死锁的 $4$ 个必要条件：
1. 互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
2. 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
3. 不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
4. 循环等待条件: 若干进程间形成首尾相接循环等待资源的关系。

故**最多**只允许 $4$ 个哲学家去持有叉子，可保证至少有 $1$ 个哲学家能吃上意大利面（即获得到 $2$ 个叉子）。
因为最差情况下是：$4$ 个哲学家都各自持有1个叉子，此时还 **剩余 $1$ 个叉子** 可供使用，这 $4$ 个哲学家中必然有1人能获取到这个 **剩余的 $1$ 个叉子**，从而手持 $2$ 个叉子，可以吃意大利面。
即：$4$ 个人中，$1$ 个人有 $2$ 个叉子，$3$ 个人各持 $1$ 个叉子，共计 $5$ 个叉子。

既然**最多**只允许4个哲学家去持有叉子，那么如果只允许3个哲学家去持有叉子是否可行呢？

当然可行，$3$个哲学家可以先都各自持有$1$把叉子，此时还剩余$2$把叉子；

当这$3$个哲学家刚好都相邻(比如：编号为图中的`0, 1, 2`)，可能会造成只有$1$个哲学家能吃到意面的情况，具体而言即`0`号哲学家拿到了其左侧的叉子(编号为`1`)，`1`号哲学家也拿到了其左侧的叉子(编号为`2`)，`2`号哲学家也拿到了其左侧的叉子(编号为`3`)，此时只有`0`号哲学家能拿到其右侧的叉子(编号为`0`)，因此只有`0`号哲学家能吃到意面。
而其余情况下，`3`个哲学家中都能有`2`人吃到意面。
即：$3$ 个人中，$2$ 个人各自持有 $2$ 个叉子，$1$ 个人持有 $1$ 个叉子，共计 $5$ 个叉子。

并且仔细想想，叉子的数目是**固定**的(个数为`5`)，直觉上来讲`3`个人去抢`5`个叉子 比 `4`个人去抢`5`个叉子效率高。

用`Semaphore`去实现上述的限制：`Semaphore eatLimit = new Semaphore(4);`
一共有5个叉子，视为5个`ReentrantLock`，并将它们全放入1个数组中。

给叉子编号 $0, 1, 2, 3, 4$（对应数组下标）。
具体编号我是如下图这般设计的：

![哲学家问题图.png](https://pic.leetcode-cn.com/30159b01ce754904bbc76bb81e52cfb5751b074f811ba88919bb3a0b861e02d8-%E5%93%B2%E5%AD%A6%E5%AE%B6%E9%97%AE%E9%A2%98%E5%9B%BE.png){:width=300}


有了这些思路，代码实现就变得清晰起来。

代码具体实现：
```java [-方法1]
class DiningPhilosophers {
    //1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中
	private ReentrantLock[] lockList = {new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock()};
    
    //限制 最多只有4个哲学家去持有叉子
	private Semaphore eatLimit = new Semaphore(4);

	public DiningPhilosophers() {

	}

	// call the run() method of any runnable to execute its code
	public void wantsToEat(int philosopher,
		Runnable pickLeftFork,
		Runnable pickRightFork,
		Runnable eat,
		Runnable putLeftFork,
		Runnable putRightFork) throws InterruptedException {
        
		int leftFork = (philosopher + 1) % 5;	//左边的叉子 的编号
		int rightFork = philosopher;	//右边的叉子 的编号

		eatLimit.acquire();	//限制的人数 -1

		lockList[leftFork].lock();	//拿起左边的叉子
		lockList[rightFork].lock();	//拿起右边的叉子

		pickLeftFork.run();	//拿起左边的叉子 的具体执行
		pickRightFork.run();	//拿起右边的叉子 的具体执行

		eat.run();	//吃意大利面 的具体执行

		putLeftFork.run();	//放下左边的叉子 的具体执行
		putRightFork.run();	//放下右边的叉子 的具体执行

		lockList[leftFork].unlock();	//放下左边的叉子
		lockList[rightFork].unlock();	//放下右边的叉子

		eatLimit.release();//限制的人数 +1
	}
}
```



接下来的2个方法转自：
作者：mike-meng
链接：[https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng/](https://leetcode-cn.com/problems/the-dining-philosophers/solution/zhe-xue-jia-jiu-can-wen-ti-by-mike-meng/)

他是用C++实现的，将其转为Java代码如下：

**方法 $2$：**
设置 $1$ 个临界区以实现 $1$ 个哲学家 “**同时**”拿起左右  **$2$ 把叉子**的效果。
即进入临界区之后，保证**成功获取**到左右 **$2$ 把叉子** 并 执行相关代码后，才退出临界区。

评论区看到有题友说方法2就是“只让1个哲学家就餐”的思路，无需将叉子视为`ReentrantLock`。

下面我也给出了“只允许1个哲学家就餐”的代码。

但是2者之间还是有**细微**的**差别**：
方法2是在成功**拿起左右叉子之后**就退出临界区，而“只让1个哲学家就餐”是在**拿起左右叉子 + 吃意面 + 放下左右叉子** 一套流程走完之后才退出临界区。

前者的情况可大概分为2种，举具体例子说明(可参照上面给出的图片)：
1. `1`号哲学家拿起左右叉子(`1`号叉子 + `2`号叉子)后就退出临界区，此时`4`号哲学家成功挤进临界区，他也成功拿起了左右叉子(`0`号叉子和`4`号叉子)，然后就退出临界区。
2. `1`号哲学家拿起左右叉子(`1`号叉子 + `2`号叉子)后就退出临界区，此时`2`号哲学家成功挤进临界区，他需要拿起`2`号叉子和`3`号叉子，但`2`号叉子有一定的概率还被`1`号哲学家持有(`1`号哲学家意面还没吃完)，因此`2`号哲学家进入临界区后还需要等待`2`号叉子。至于`3`号叉子，根本没其他人跟`2`号哲学家争夺，因此可以将该种情况视为“`2`号哲学家只拿起了1只叉子，在等待另1只叉子”的情况。

总之，第1种情况即**先后进入临界区**的**2位哲学家**的左右叉子不存在竞争情况，因此先后进入临界区的2位哲学家进入临界区后都不用等待叉子，直接就餐。此时可视为2个哲学家在同时就餐(当然前1个哲学家有可能已经吃完了，但姑且当作是2个人同时就餐)。

第2种情况即先后进入临界区的2位哲学家的左右叉子存在竞争情况(说明这2位哲学家的**编号相邻**)，因此**后进入临界区**的哲学家还需要等待1只叉子，才能就餐。此时可视为只有1个哲学家在就餐。

至于“只允许1个哲学家就餐”的代码，很好理解，每次严格地只让1个哲学家就餐，由于过于严格，以至于都不需要将叉子视为`ReentrantLock`。

方法`2`有一定的概率是“并行”，“只允许1个哲学家就餐”是严格的“串行”。

代码如下：
```java [-方法2]
class DiningPhilosophers {
    //1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中
	private ReentrantLock[] lockList = {new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock()};
    
    //让 1个哲学家可以 “同时”拿起2个叉子(搞个临界区)
	private ReentrantLock pickBothForks = new ReentrantLock();

	public DiningPhilosophers() {

	}

	// call the run() method of any runnable to execute its code
	public void wantsToEat(int philosopher,
		Runnable pickLeftFork,
		Runnable pickRightFork,
		Runnable eat,
		Runnable putLeftFork,
		Runnable putRightFork) throws InterruptedException {
        
		int leftFork = (philosopher + 1) % 5;	//左边的叉子 的编号
		int rightFork = philosopher;	//右边的叉子 的编号

		pickBothForks.lock();	//进入临界区

		lockList[leftFork].lock();	//拿起左边的叉子
		lockList[rightFork].lock();	//拿起右边的叉子

		pickLeftFork.run();	//拿起左边的叉子 的具体执行
		pickRightFork.run();	//拿起右边的叉子 的具体执行
        
		pickBothForks.unlock();	//退出临界区

		eat.run();	//吃意大利面 的具体执行

		putLeftFork.run();	//放下左边的叉子 的具体执行
		putRightFork.run();	//放下右边的叉子 的具体执行

		lockList[leftFork].unlock();	//放下左边的叉子
		lockList[rightFork].unlock();	//放下右边的叉子
	}
}
```
```java [-只允许1个哲学家就餐]
class DiningPhilosophers {
    //只允许1个哲学家就餐
    private ReentrantLock pickBothForks = new ReentrantLock();

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号

        pickBothForks.lock();    //进入临界区

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        pickBothForks.unlock();    //退出临界区
    }
}
```


**方法 $3$：**
前面说过，该题的本质是考察 **如何避免死锁**。
而当5个哲学家都**左手持有**其**左边的叉子** 或 当5个哲学家都**右手持有**其**右边的叉子**时，会发生**死锁**。
故只需设计1个避免发生上述情况发生的策略即可。

即可以让**一部分哲学家**优先去获取其左边的叉子，再去获取其右边的叉子；再让**剩余哲学家**优先去获取其右边的叉子，再去获取其左边的叉子。

代码如下：
```java [-方法3]
class DiningPhilosophers {
	//1个Fork视为1个ReentrantLock，5个叉子即5个ReentrantLock，将其都放入数组中
	private ReentrantLock[] lockList = {new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock(),
		new ReentrantLock()};

	public DiningPhilosophers() {

	}

	// call the run() method of any runnable to execute its code
	public void wantsToEat(int philosopher,
		Runnable pickLeftFork,
		Runnable pickRightFork,
		Runnable eat,
		Runnable putLeftFork,
		Runnable putRightFork) throws InterruptedException {

		int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
		int rightFork = philosopher;    //右边的叉子 的编号

        //编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子
		if (philosopher % 2 == 0) {
			lockList[leftFork].lock();    //拿起左边的叉子
			lockList[rightFork].lock();    //拿起右边的叉子
		}
        //编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子
		else {
			lockList[rightFork].lock();    //拿起右边的叉子
			lockList[leftFork].lock();    //拿起左边的叉子
		}

		pickLeftFork.run();    //拿起左边的叉子 的具体执行
		pickRightFork.run();    //拿起右边的叉子 的具体执行

		eat.run();    //吃意大利面 的具体执行

		putLeftFork.run();    //放下左边的叉子 的具体执行
		putRightFork.run();    //放下右边的叉子 的具体执行

		lockList[leftFork].unlock();    //放下左边的叉子
		lockList[rightFork].unlock();    //放下右边的叉子
	}
}
```

# 小改进
`ReentrantLock`和`synchronize`关键字都是使用**互斥量**的**重量级锁**，而`volatile`关键字相较于它们就比较“轻量”。
因此把`ReentrantLock`数组改为使用`volatile`修饰的`boolean`数组。

PS: `volatile`要和**原子操作**搭配使用才能保证同步。
而对`volatile`变量赋 **常量值** 可看为是原子操作。

```java [-改进的方法1]
class DiningPhilosophers {
    //1个Fork视为1个boolean变量，false则无人使用，true则有人使用
    private volatile boolean[] forkList = new boolean[5];
    //限制 最多只有4个哲学家去持有叉子
    private Semaphore eatLimit = new Semaphore(4);

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号

        eatLimit.acquire();    //限制的人数 -1

        while (forkList[leftFork]) Thread.sleep(1);
        forkList[leftFork] = true;  //拿起左边的叉子

        while (forkList[rightFork]) Thread.sleep(1);
        forkList[rightFork] = true; //拿起右边的叉子

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        forkList[leftFork] = false; //放下左边的叉子
        forkList[rightFork] = false;    //放下右边的叉子

        eatLimit.release(); //限制的人数 +1
    }
}
```
```java [-改进的方法2]
class DiningPhilosophers {
    //1个Fork视为1个boolean变量，false则无人使用，true则有人使用
    private volatile boolean[] forkList = new boolean[5];
    //false则无人正在拿起2个叉子，true则有人正在拿起2个叉子
    private volatile boolean pickUpBoth = false;

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号

        while (pickUpBoth) Thread.sleep(1);
        pickUpBoth = true;	//进入临界区

        while (forkList[leftFork]) Thread.sleep(1);
        forkList[leftFork] = true;	//拿起左边的叉子

        while (forkList[rightFork]) Thread.sleep(1);
        forkList[rightFork] = true;	//拿起右边的叉子

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        pickUpBoth = false;	//退出临界区

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        forkList[leftFork] = false; //放下左边的叉子
        forkList[rightFork] = false;    //放下右边的叉子
    }
}
```
```java [-改进的方法3]
class DiningPhilosophers {
    //1个Fork视为1个boolean变量，false则无人使用，true则有人使用
    private volatile boolean[] forkList = new boolean[5];

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号

        //编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子
        if (philosopher % 2 == 0) {
            while (forkList[leftFork]) Thread.sleep(1);
            forkList[leftFork] = true;  //拿起左边的叉子
            while (forkList[rightFork]) Thread.sleep(1);
            forkList[rightFork] = true; //拿起右边的叉子
        }
        //编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子
        else {
            while (forkList[rightFork]) Thread.sleep(1);
            forkList[rightFork] = true; //拿起右边的叉子
            while (forkList[leftFork]) Thread.sleep(1);
            forkList[leftFork] = true;  //拿起左边的叉子
        }

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        forkList[leftFork] = false;    //放下左边的叉子
        forkList[rightFork] = false;    //放下右边的叉子
    }
}
```

# 再改进:
受到题友启发，发现**位运算**就可以表示`5`个叉子的**使用状态**，无需使用`volatile`修饰的`boolean[]`数组来表示5个叉子，只需用1个`volatile`修饰的`int`变量即可。

```java [-再改进的方法1]
class DiningPhilosophers {
    //初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用
    private volatile int fork = 0;
    //限制 最多只有4个哲学家去持有叉子
    private Semaphore eatLimit = new Semaphore(4);

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号
        int leftMask = 1 << leftFork, rightMask = 1 << rightFork;

        eatLimit.acquire();    //限制的人数 -1

        while ((fork & leftMask) != 0) Thread.sleep(1);
        fork ^= leftMask;  //拿起左边的叉子

        while ((fork & rightMask) != 0) Thread.sleep(1);
        fork ^= rightMask; //拿起右边的叉子

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        fork ^= leftMask; //放下左边的叉子
        fork ^= rightMask;    //放下右边的叉子

        eatLimit.release(); //限制的人数 +1
    }
}
```
```java [-再改进的方法2]
class DiningPhilosophers {
    //初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用
    private volatile int fork = 0;
    //false则无人正在拿起2个叉子，true则有人正在拿起2个叉子
    private volatile boolean pickUpBoth = false;

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号
        int leftMask = 1 << leftFork, rightMask = 1 << rightFork;

        while (pickUpBoth) Thread.sleep(1);
        pickUpBoth = true;    //进入临界区

        while ((fork & leftMask) != 0) Thread.sleep(1);
        fork ^= leftMask;  //拿起左边的叉子

        while ((fork & rightMask) != 0) Thread.sleep(1);
        fork ^= rightMask; //拿起右边的叉子

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        pickUpBoth = false;    //退出临界区

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        fork ^= leftMask; //放下左边的叉子
        fork ^= rightMask;    //放下右边的叉子
    }
}
```
```java [-再改进的方法3]
class DiningPhilosophers {
    //初始化为0, 二进制表示则为00000, 说明当前所有叉子都未被使用
    private volatile int fork = 0;

    public DiningPhilosophers() {

    }

    // call the run() method of any runnable to execute its code
    public void wantsToEat(int philosopher,
                           Runnable pickLeftFork,
                           Runnable pickRightFork,
                           Runnable eat,
                           Runnable putLeftFork,
                           Runnable putRightFork) throws InterruptedException {

        int leftFork = (philosopher + 1) % 5;    //左边的叉子 的编号
        int rightFork = philosopher;    //右边的叉子 的编号
        int leftMask = 1 << leftFork, rightMask = 1 << rightFork;

        //编号为偶数的哲学家，优先拿起左边的叉子，再拿起右边的叉子
        if (philosopher % 2 == 0) {
            while ((fork & leftMask) != 0) Thread.sleep(1);
            fork ^= leftMask;  //拿起左边的叉子

            while ((fork & rightMask) != 0) Thread.sleep(1);
            fork ^= rightMask; //拿起右边的叉子
        }//编号为奇数的哲学家，优先拿起右边的叉子，再拿起左边的叉子
        else {
            while ((fork & rightMask) != 0) Thread.sleep(1);
            fork ^= rightMask; //拿起右边的叉子

            while ((fork & leftMask) != 0) Thread.sleep(1);
            fork ^= leftMask;  //拿起左边的叉子
        }

        pickLeftFork.run();    //拿起左边的叉子 的具体执行
        pickRightFork.run();    //拿起右边的叉子 的具体执行

        eat.run();    //吃意大利面 的具体执行

        putLeftFork.run();    //放下左边的叉子 的具体执行
        putRightFork.run();    //放下右边的叉子 的具体执行

        fork ^= leftMask; //放下左边的叉子
        fork ^= rightMask;    //放下右边的叉子
    }
}
```
