我看到这题时，第一反应也是模拟过程。不过考虑到这样做的话至少会有两层循环，所以果断放弃了。

本文尝试解释平方数亮着的原理，而最后提供代码。
先简述一下过程,设总共有 n 个灯泡， 使用i (i∈[1,n])表示第 i 个灯泡。使用 ai(i∈[1,n])表示第i个灯泡的当前状态。
第0轮：全部关闭
第1轮：间隔0个灯泡操作，
    操作第1,2,3,……,n个灯泡
第2轮：间隔1个灯泡操作，
    操作第2,4,6,……个灯泡
第3轮：间隔2个灯泡操作，
    操作第3,6,9,……个灯泡
……
    ……
第j轮：间隔j-1个灯泡操作，
    操作第j,2j,3j,……个灯泡
……
    ……
第n轮：间隔n-1个灯泡操作，
    操作第n个灯泡

**1 分析**
1）第j轮的第i个灯泡的状态判断方法：
将包含本轮在内的对第i个灯泡的所有操作次数做和，记为Sij。
若Sij为奇数，说明第i个灯泡，经过j轮以后，是亮着的，因为第0轮一定是关闭的。
同理，若Sij为偶数，说明第i个灯泡，经过j轮以后，是关闭的。

所以问题转变为：
经过n轮，第i个灯泡被操作了奇数次还是偶数次？奇数次则最后是亮的，偶数次则最后是关闭的。

2）观察：
第j轮操作的灯泡的位置，一定是j的倍数。咱们反向观察一下：

第1个灯泡在什么时候会被操作？第1轮
第10个灯泡在什么时候会被操作？第1轮，第2轮，第5轮，第10轮
第20个灯泡在什么时候会被操作？第1轮，第2轮，第4轮，第5轮，第10轮，第20轮

说到这里，会立马发现：第 i 个灯泡只有在第 k 轮会被操作，而 k 一定是 i 的因数。并且 n>=k。所以如果一个数的因数的个数为奇数个，那么它最后一定是亮的，否则是关闭的。
那么问题又转变了：

什么数的因数的个数是奇数个？
答案是完全平方数。

**2 为什么完全平方数的因数的个数是奇数个？**
设P,A,B 为正整数，如果 P=A*B，则A和B为P的因数。
P的因数A和B总是成对出现。也就是说他们总是一起为 P 的因数个数做贡献。但是如果他们相等呢？这个时候他们一起只会为因数的个数贡献 1。

其次，P=A*A，这种情况对于P来说最多只能出现1次，而这种情况只可能出现在完全平方数中。
所以对于正整数而言，只有完全平方数的因数的个数是奇数个。

综上所述，所以每个完全平方数就是答案


```
int bulbSwitch(int n) {
    if(n==1)
        return 1;
    int result = 1;
    while(true) {
        if(result*result>n)
            break;
        result++;
    }
    return result-1;
}
```

