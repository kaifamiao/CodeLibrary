说真的，这道题我做了很多无用功才最终做出来，虽然代码就是一句话的事，但是整个过程还是值得说一说的。
**思路：看了好久题目。我觉得这个题应该不是代码上的难度，主要是题意上。我打算画一个图好好理解下。题目太狗了，就三个，好多规律都看不出来。下面是我画的图，虽然没画完，但是你看到规律了没？对，你没看错，就是没！有！规！律！我随着往下判断随着觉得这么画好傻的，其实这个规律就是硬性规律。我现在的思路就是n轮n个灯泡。创建一个长度n的数组。最开始都是0.0代表开启（第一轮都开启，我就从第一轮开始往后判断，不想填充1装作最开始了）。然后每走一轮判断一次就行了，需要变的0变1,1变0 。这个时候我还觉得应该是很简单的。**
![题目图解](https://pic.leetcode-cn.com/a615b53dcd7fa9b8b6eeb9413aaf7d08c3ffb1572a455c00edf6542d3c29dbe4-file_1586245064142)

很好，第一版本超时了，但是我看了下代码，结果的对的，只能说leetcode不想让我们暴力写呗：
```
class Solution {
    public int bulbSwitch(int n) {
        if(n==0) return 0;
        if(n==1) return 1;
        int[] d = new int[n+1];
        d[0] = 1;//正常应该n个元素，但是我嫌下标和数字差1麻烦，所以补了个0，一直关闭状态，不用管。
        for(int i = 2;i<=n;i++){
            for(int j = i;j<=n;j++){
                //整数倍数则翻转。0变1,1变0
                if(j%i==0) d[j] = d[j]^1;      
            }
        }
        int sum = 0;
        for(int i : d){
            if(i==0) sum++;
        }
        return sum;
    }
}
```
以上是我代码的逻辑，超时真的解决不了，我试着把这个直接当字面量写出来，但是继续提交，还是超时。。所以这是逼着我找规律！
但是别说，两次超时结果的获取我还真的找到规律了！
因为其实99999和100000差的只是最后一个灯。前面的应该都是一样的。所以这道题我竟然看出了dp的感觉。哈哈，我执行的结果是100000最后一个灯没亮，所以两个件结果都是316.我就继续接着按照这个思路测试，还真的有点心得，我把我所有的测试结果列出来。
![结果测试](https://pic.leetcode-cn.com/9cc7c2d19d8d5b567210dff44914d8eb82108cc487321dd21d9c35482a2ba5fa-file_1586245064152)
![结果测试](https://pic.leetcode-cn.com/fcf12c6d23639ebc0f665cf3367df19abdd351f8eb84a04447faa78acae5fb2c-file_1586245064153)
![结果测试](https://pic.leetcode-cn.com/1b9df6e44cfe1cfaf31f921565fed3999a4e3eedc40b151b206bafce3af35595-file_1586245064155)
之所以附上这么多截图就是为了找到这个规律。我再画个统计图能更明了的看出来：
![结论！](https://pic.leetcode-cn.com/91912c0ac35204388856d34c20e358454c2423ad0f47c669bc9795afb11ea6cc-file_1586245064156)

好的吧，现在发现了没，这个规律简直简单的不行。就是从平方开始，到下一个平方的前一个数的灯数是平方的向下取整。
这句话我可能说的不是很明白，但是应该一看就能看懂了。所以我也就不多bb了，我去写代码了。
```
class Solution {
    public int bulbSwitch(int n) {
        return (int)Math.sqrt(n);
    }
}
```
说真的，这个题是我做过的最简单的题目。没有之一。。甚至说数据库内置函数我都用的理直气壮。毕竟这道题不是考实现平方根的。
哈哈，虽说废了一下时间，但是觉得还是挺好玩的。