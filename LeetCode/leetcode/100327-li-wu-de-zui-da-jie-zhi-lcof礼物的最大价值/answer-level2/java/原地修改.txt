把第1行 和 第1列 用前缀和的方式处理。
再双重for循环：
- 外层for从第2行开始，最后1行结束
  - 内层for从第2列开始，最后1列结束
    - 比较**左方**和**上方**的值，并取其中**较大者**，加到当前位置的值上

返回最右下角的值。

如：
[1,3,1]
[1,5,1]
[4,2,1]

把第1行 和 第1列 分别用**前缀和**的方式处理，得：
[**1,4,5**]
[**2**,5,1]
[**6**,2,1]

再遍历**剩余位置**，取所遍历的**当前位置**的**上边**和**左边**中的**较大者**，加到当前位置的值上：
[1,4,5]
[2,**5,1**]
[6,**2,1**]

**加粗部分**为所要遍历的位置，先从**加粗的5**开始(**第2行，第2列**)，取**左边**(2)和**上边**(4)的**较大者**(4)加到当前位置的值(5)上，得：

已处理**第2行，第2列**：
[1,4,5]
[2,9,**1**]
[6,**2,1**]

重复上述步骤，依次得到:
已处理**第2行，第3列**(1 + max(9, 5) = 1 + 9 = 10)：
[1,4,5]
[2,9,10]
[6,**2,1**]

已处理**第3行，第2列**(2 + max(9, 6) = 2 + 9 = 11)：
[1,4,5]
[2,9,10]
[6,11,**1**]

已处理**第3行，第3列**(1 + max(11, 10) = 1 + 11 = 12)：
[1,4,5]
[2,9,10]
[6,11,12]

全部处理完毕，返回最右下角的值(12)
```java
class Solution {
    public int maxValue(int[][] grid) {
        int row = grid.length, col = grid[0].length;
        for (int i = 1; i < row; ++i)
            grid[i][0] += grid[i - 1][0];
        for (int j = 1; j < col; ++j)
            grid[0][j] += grid[0][j - 1];
        for (int i = 1; i < row; ++i)
            for (int j = 1; j < col; ++j)
                grid[i][j] += Math.max(grid[i - 1][j], grid[i][j - 1]);
        return grid[row - 1][col - 1];
    }
}
```
