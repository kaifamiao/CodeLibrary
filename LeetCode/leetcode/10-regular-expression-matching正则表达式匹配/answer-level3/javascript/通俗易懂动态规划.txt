两个字符串进行比较，容易想到的是采用两层循环对比。但是这两个字符串并不是一对一进行比较的， `*` 字符存在匹配 0 个或者多个字符的情况，因此需要额外的变量保存前面已经遍历过的状态。

维护零散的变量并不是简单的事情，我们可以考虑将这些变量使用集合来维护。

在遍历过程中，当前的匹配状态依赖于子串的匹配状态的。因此我们可以考虑使用动态规划来做。

动态规划的三要素：

1. base case
2. 最优子结构
3. 状态转移方程

我们采用二维数组 dp，来存储子串的匹配状态，横向表示 p 字符，纵向表示 s 字符。

![20200130104438.png](https://pic.leetcode-cn.com/14cfd3be15033c9135505bbe144136770ae8993468cfc0605b42a6701511ea72-file_1580528831411)

## 1.base case

base case 是状态转移的初始值，横向初始值是以 s 作为空字符串("")与 p 模式字符进行匹配的结果，纵向初始值是以 s 字符串与空模式串 p 进行匹配的结果。

模式串 p 为空字符串时，当且仅当 s 为空字符时才会匹配。

当 s 为空字符时，就不仅仅只与空字符串 p 匹配了。它还与 `a*` 、 `a*b*` 、 `a*b*c*` 、... 匹配。

因此在遇到 `*` 时，空字符串 s 与 p 的匹配情况需要根据 `*` 向前退两个字符的子串匹配情况决定。

> 根据题意 `*` 能够与重复它前面一个字符 0 次或者多次的字符匹配，因此 `*` 前面的字符必然不能为空字符。

以 `s = ""` 和 `p = "a.b*"` 为例子， 当遇到 `*` 时， `"a.b*"` 回退两位的子串是 `"a."` ， `s = ""` 和 `"a."` 不匹配，所以 `s = ""` 与 `a*b*` 也不匹配。

![20200130111146.png](https://pic.leetcode-cn.com/a12ad10e46ac7750031c0bfe52aa9169e387204c6a1669ee48122db234105a93-file_1580528831420)

用伪代码表示：

``` js
if (p[j] == '*') {
  dp[i][j] = dp[i][j - 2];
}
```

## 2. 最优子结构

s 的子串 s[0:i] 和 p 的子串 p[0:j] 的匹配关系，可以根据 p 在下标 j 处的字符内容分为三种子结构：

1. p[j] == a-z
2. p[j] == '.'
3. p[j] == '*'

如果 p[j] 字符为 a-z ，并且 p[j] != s[i] 那么 dp[i][j] 必然是 false。如果 p[j] == s[i] 或者 p[j] = '.' 字符，s[0:i] 和 p[0:j] 的匹配关系由 dp[i][j] 由 dp[i-1][j-1] 决定。

如果 p[j] 为 `*` ，要考虑当前 s[i] 字符与 `*` 前一个字符 p[j-1] 发生匹配的次数。分为 0 次、1 次和多次情况来讨论。

上述情况都可以由 s[0:i] 和 p[0:j] 子串的三种子结构记录在 dp[i][j] 数组内的状态推导而来。

## 3. 状态转移方程

1. p[j] == s[i]，p[i] 和 s[j] 字符相同，则 s[0:i] 和 p[0:j] 子串的匹配情况由 s[0:i-1] 和 p[0:i-1] 的情况决定；
2. p[j] == '.'， `.` 点符号能够匹配任意的字符，因此 p[0:i] 和 p[0:j] 子串匹配情况由 s[0:i-1] 和 p[0:i-1] 的情况决定；
3. p[j] == '*'， `*` 的处理需分为匹配次数来讨论，我们接下来会讨论；
4. 其它情况均不匹配。

### 星号匹配 0 次

如果星号匹配 0 次，则需要忽略星号以及它前面的一个字符，dp[i][j] 的前一个状态由 s[i] 与 p[j-2] 字符串的匹配情况 dp[i][j-2] 推导。

![20200130160917.png](https://pic.leetcode-cn.com/b75f7cb909929a8ffac178dbe927885cc8b4dcaf1a077d928892bd36350b3cb8-file_1580528831426)

### 星号匹配 1 次

模式串 `a.b*` 与 `aab` 中的 `b` 发生一次匹配。它们的匹配关系由 `a.b` 和 `aab` 的匹配关系 dp[i][j-1] 推导而来。

![20200130162435.png](https://pic.leetcode-cn.com/377e011fabbf65253ce74d3ef4d18a98e0587f2cfe80e4a2e9a7c54d26e03811-file_1580528831428)

### 星号匹配多次

模式串 `a.b*` 与 `aabb` 中的 `b` 发生多次匹配。它们的匹配关系由 `a.b*` 和 `aab` 的匹配关系 dp[i-1][j] 推导而来。

![20200130164551.png](https://pic.leetcode-cn.com/276dd33a4b562b48741463d1de4b2cba6a741641a92e49e95320feb7471314f9-file_1580528831432)

为什么？

多次匹配的推导关系有点难以理解，它为什么不是由 dp[i-1][j-1] 推导而来呢？如果由 dp[i-1][j-1] 推导而来，前一个字符可能和当前字符不相同，就不属于重复匹配了。

多次匹配的前提是已经发生了一次匹配，即在 `a.b*` 和 `aab` 的基础上的匹配情况，也就是 dp[i-1][j] 的值。

> 注：图中 dp 数组的维度会比 s 和 p 字符的长度大 1，新增的维度用于存储推导初始值。文中为了方便当前待匹配情况用 dp[i][j] 表示，代码中实际使用的是 dp[i+1][j+1]。



```
/**
 * @param {string} s
 * @param {string} p
 * @return {boolean}
 */
var isMatch = function(s, p) {
  const dp = new Array(s.length + 1);
  for (let i = 0; i <= s.length; ++i) {
    dp[i] = (new Array(p.length + 1)).fill(false)
  }
  
  // base case
  dp[0][0] = true;
  for (let i = 0; i < p.length; ++i) {
    if (p[i] === '*') {
      dp[0][i+1] = dp[0][i-1];
    }
  }
  
  for (let i = 0; i < s.length; ++i) {
    for (let j = 0; j < p.length; ++j) {
      if (p[j] === s[i] || p[j] === '.') {
        dp[i+1][j+1] = dp[i][j];
      }
      
      if (p[j] === '*') {
        if (p[j-1] !== s[i] && p[j-1] !== '.') {
          // 0 occurrence
          dp[i+1][j+1] = dp[i+1][j-1];
        } else {
          // 1 occurrence dp[i+1][j]
          // n occurrence dp[i][j-1]
          dp[i+1][j+1] = (dp[i][j+1] || dp[i+1][j-1] || dp[i+1][j]);
        }
      }
    }
  }
  
  return !!dp[s.length][p.length];
};
```
