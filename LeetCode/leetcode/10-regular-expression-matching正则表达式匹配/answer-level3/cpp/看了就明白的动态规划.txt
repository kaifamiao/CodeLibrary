## 1. 状态
```dp[i][j]``` 表示 ```s``` 的前```i```个能否被 ```p``` 的前 ```j``` 个匹配，其实是在比较 ```s[i-1]``` 与 ```p[i-1]```。
## 2. 状态转移方程
### T1. ```s[i - 1] == p[j - 1]```  
```dp[i][j] = dp[i - 1][j - 1]```  
### T2. ```s[i - 1] != p[j - 1]```  
#### (1) ```p[j - 1] == '.'```
```.```是万能字符，相当于```s[i - 1]```的值,```dp[i][j] = dp[i - 1][j - 1]```  
#### (2) ```p[j - 1] == '*'```
首先给了 ```*```，明白 ```*``` 的含义是匹配零个或多个前面的那一个元素，所以要考虑他**前面的元素** ```p[j-2]```。```*``` 跟着他前一个字符走，前一个能匹配上 ```s[i - 1]```，```*``` 才能有用，前一个都不能匹配上 ```s[i - 1]``` ，```*``` 也无能为力，只能让前一个字符消失，也就是匹配 0 次前一个字符。总的来说，对于一个 ```*``` 来说，就是对其前面那个字符匹配 0 次，1 次，多次。
##### 1) ```p[j - 2] != s[i - 1]```
这就是刚才说的那种前一个字符匹配不上的情况。比如```(ab, abc * )```。遇到 ```*``` 往前看两个，发现前面 ```s[i]``` 的 ```ab``` 对 ```p[j-2]``` 的 ```ab``` 能匹配，虽然后面是 ```c*```，但是可以看做匹配 0 次 ```c```，相当于直接去掉 ```c *```  
```dp[i][j] = dp[i][j - 2]```
##### 2) ```p[j-1] == s[i] || p[j-1] == "."```
- 取 0 个字符: ```s: aab, p: aabb*```, 虽然 ```j - 2``` 和 ```i - 1``` 相等, 但是```dp[i][j-2]```已经匹配了, 直接删去```j - 1``` 和 ```j - 2``` 即可（你来之前我们就已经是总冠军了）  
```dp[i][j] = dp[i][j-2]```
- 取 1 个字符: ```s: aab, p: aab*```  
```dp[i][j] = dp[i][j-1]```
- 取多个字符: ```s：###b, p：###b*```,```dp[i-1][j]``` 就是看 ```s``` 里 ```b``` 多不多，```###``` 和 ```###b*``` 是否匹配，一旦匹配，```s``` 后面再添个 ```b``` 也不影响，因为有 ```*``` 在，也就是 ```###b``` 和 ```###b*```也会匹配  
```dp[i][j] = dp[i - 1][j]```  

以上三者满足一种就能匹配上。  

```c++
bool isMatch(string s, string p) {
    if (s == "" && p == "") {
        return true;
    }
    unsigned long m = s.length(), n = p.length();
    bool dp[m + 1][n + 1];
    memset(dp, false, sizeof(dp));
    dp[0][0] = true;
    for (int j = 1; j <= n; j++) {
        if ((p[j - 1] == '*') && dp[0][j - 2]) {
            dp[0][j] = true;
        }
    }
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s[i - 1] == p[j - 1] || p[j - 1] == '.') {
                dp[i][j] = dp[i - 1][j - 1];
            }
            else
                if (p[j - 1] == '*') {
                    if (p[j - 2] == s[i - 1] || p[j - 2] == '.') {  //三者满足其一即可
                        dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j-2];
                    }
                    else
                        dp[i][j] = dp[i][j-2];  //p[j - 2] != s[i - 1]
                }
         }
    }
    return dp[m][n];
}
```