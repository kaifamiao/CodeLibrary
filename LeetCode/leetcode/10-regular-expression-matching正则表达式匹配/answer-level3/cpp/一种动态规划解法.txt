```
class Solution
{
public:
    bool isMatch(string s, string p) {
        int m = s.size(), n = p.size();
        vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
        dp[0][0] = true;
        if (m != 0 && (p[0] == s[0] || p[0] == '.')) dp[1][1] = true;
        for (int i = 1; i <= n; i++) dp[0][i] = p[i - 1] == '*' && (dp[0][i - 1] || dp[0][i - 2]);
        if (p[1] == '*') dp[0][2] = true;
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                if (p[j - 1] == s[i - 1] || p[j - 1] == '.') {
                    dp[i][j] = dp[i - 1][j - 1];
                } else if (j > 1 && p[j - 1] == '*') {
                    if (p[j - 2] == s[i - 1] || p[j - 2] == '.') {
                        dp[i][j] = dp[i][j - 1] || dp[i - 1][j] || dp[i][j - 2];
                    } else {
                        dp[i][j] = dp[i][j - 2];
                    }
                }
            }
        }
        return dp[m][n];
    }
};
```
**如果采用动态规划的解法，这道题的难点有两处，一处是状态转移方程的确立，另一处是dp初始化的取值。两者结合起来，还需要在代码中做一定的特判。**
首先讲解一下状态转移方程的确立：也就是如果将dp看成一个矩阵，dp[i][j]是如何由其左上方的点变换而来。
由于这里只有元字符 . * ，所以首先可以从两个大方面进行判断：
 - 1. p[j] == s[i] || p[j] == '.' 则 dp[i][j] == dp[i - 1][j - 1]
 - 2. p[j] == '*'
 - - 2.1 如果 * 前一个字符，也就是p[j - 1]与s[i]不匹配的话，那么 \* 只能起到将其前一个数划掉的作用，也就是dp[i][j] = dp[i][j - 2]，这里说一下为什么要让p[j - 1]与s[i]进行匹配，因为 \* 只能起到重复的作用，如果想让p[j]与s[i]匹配，那么必须要有 p[j - 1] == s[i], 为什么要这么匹配呢，因为 \* 这个元字符是进可攻，退可守，方便做判断，其实也可以进行别的方式判断，但是可以尝试一下，其他的判断方式会增加if else 条件。
 -  - 2.2 p[j - 1] == s[i] || p[j - 1] == '.' 这种就是前一个字符和s[i]匹配上了，那么 * 可以做几种操作，

 -- (1) 把前面的字符干掉：dp[i][j] = dp[i][j - 2]
 -- (2) 把自己干掉：dp[i][j] = dp[i][j-1]
 -- (3) 重复前面的字符：dp[i][j] = dp[i - 1][j], 这个是有点难想的，举个具体的例子就知道了，aaa和a*匹配，有dp[0][0] = 1,dp[0][1]=0,
dp[0][2] = 1, dp[1][0] = 0, dp[1][1] = 1, dp[1][2] = 1, dp[2][0] = 0, dp[2][1] = 0, dp[2][2] = 1, dp[3][0] = 0,dp[3][1] = 0,
现在判断到dp[3][2]这里了，j = 2，代表p的第二个数，也就是p[1]，这个时候是* ，这个时候需要判断aa能不能被上一步的a\*所表示，也就是
dp[i][j] = dp[i - 1][j]，这里需要好好想一下。

然后就是初值的赋值，dp[0][0] = 1, 然后对所有的dp[0][j]进行判断，并赋值，然后考虑一种特殊的情况 p的前两个字符是 .* 时，dp[0][2] = 1;
因为有些需要进行 i - 2 和 j - 2的判断，所以要对i == 1和 j == 1的情形进行特判，总体来说就是这样，感觉这道题还是挺难的。