## 思路

分享一个有限状态自动机的思路，尽管时间复杂度和空间复杂度在这道题上不尽人意(也可能是我代码水平捉急)，但不失为一个很好的解题思想。

### 构建有限自动机

首先，我们可以通过遍历模式串`p`来构造有限状态机，可以从下面的角度来考虑构建的过程：

1.  **状态**：状态的意义、数量等等；
2.  **转移**：转移条件、转移限制等等；
3.  **初始状态**：从哪些状态开始；
4.  **终止状态**：到达哪些状态算结束；

以本题来说：

1.  状态代表**当前**匹配的**结果**；
2.  转移代表，从当前状态下，利用一个字符，**可以到达哪些状态**；
3.  初始状态代表，没有开始匹配时，应该处在哪一个状态；
4.  终止状态代表，到达这些状态算是匹配结束。

构建方法会在代码的注释中详细叙述，这里说一下构造状态机时，容易忽略的点：

-   自动机**可以有不止一个终止状态**；
-   直接构建的自动机被称为“非确定的有限自动机(NFA)”。其含义是，从一个状态下，通过某个转移，自动机**可能会到达不止一个状态**；

### 使用有限自动机

在使用自动机时，将匹配串`s`输入到自动机中，判断是否能够到达终止状态。
定义两个集合：
-   待转移状态集合`preStates`：存储了到上一部为止，当前自动机可能到达的所有状态；
-   当前状态集合`nowStates`：存储了`preStates`在当前模式串字符的转移下，可能到达的所有状态；

匹配过程如下：
1.  将初始状态加入到待转移状态集合`preStates`；
2.  对匹配串`s`的每一个字符`s[i]`按顺序遍历：
    1.  对于`preStates`中的每一个状态`tranState`，我们将试探其是否能够通过当前遍历字符`s[i]`的转移，到达某些状态，如果是，将可能到达的所有状态加入到`nowStates`；
    2.  对于`preStates`中的每一个状态`tranState`，我们将试探其是否能够通过通配符`.`的转移，到达某些状态，如果是，将可能到达的所有状态加入到`nowStates`；
    3.  如果`nowStates`为空，代表匹配失败，返回`false`；如果不为空，将`preStates`更新为`nowStates`，置空`nowStates`；
3.  遍历完成后，检查`preStates`中是否包含终止状态，如果是，则匹配成功，反之匹配失败。

## 代码

```cpp
bool isMatch(string s, string p) {
    if (p[0] == '*') return -1;
    // 一、 构建有限状态自动机
    // 用一个数据结构存储状态机，每个状态用数字表示
    // 1. 状态的数量等于模式串p中非`*`字符的数量+1，最多有p.size()+1个状态；用map来表示状态和状态的连接关系
    // 2. 每个状态通过某个字符，可以转换到多个状态，用集合来存储
    vector<unordered_map<char, set<int> > > states(p.size()+1);
    
    // 记录所有终止状态
    set<int> endStates;
    
    // 记录当前状态
    int state(0);
    for (int i(0); i < p.size(); ++i){
        // 模式串当前字符p[i]为'*'，则代表前一个字符p[i-1]字符可以重复多次->自动机从当前状态，通过p[i-1]回到q当前状态。
        if (p[i] == '*'){
            states[state][p[i-1]].insert(state);
        }
        else{
            // p[i]不为'*'，自动机从当前状态，通过当前字符p[i]切换到下一个状态
            states[state][p[i]].insert(state+1);
            
            // 1. 如果p[i+1]为'*'，表示自动机从当前状态state，通过p[i+1]的后一个字符p[i+2]，到达状态state+2(= state+1+1)；
            // 2. 如果1.的条件满足，我们接着检查p[i+3](= p[i+1+1*2])是否为‘*’，如果是，代表当前状态可以通过p[i+4](= p[i+2+1*2])，直接到达状态state + 3(= state+2+1);
            // 3. 如果上一步条件满足，则重复检查p[i+1+count*2]是否为'*'，如果是，则代表当前状态可以通过p[i+2+count*2]，直接到达状态state+2+count;
            // 特别地，如果p[i+1+count*2]为'*'，且i+1+count*2 == p.size()-1，那么代表当前状态可以作为终止状态。
            int count(0);
            while (i + 1 + count * 2 < p.size() && p[i + 1 + count * 2] == '*'){
                if (i + 2 + count * 2 < p.size()) states[state][p[i + 2 + count * 2]].insert(state + 2 + count);
                else endStates.insert(state);
                ++count;
            }
            ++state;
        }
    }
    // 最后一个状态必然为终止状态
    endStates.insert(state);
    
    
    // 二、匹配有限状态自动机
    set<int> nowStates; // 记录当前遍历中，可能到达的所有状态；
    set<int> preStates; // 上一次遍历中，可能到达的所有状态；
    preStates.insert(0);    // 我们从初始状态开始遍历
    for (int i(0); i < s.size(); ++i){
        for (auto j: preStates){    // 枚举上一步s可能到达的所有状态
            for (auto tranState: states[j][s[i]]){   // 如果上一步的状态通过当前字符s[i]可以发生转移，则将可能到达的所有状态加入到nowStates中
                nowStates.insert(tranState);
            }
            for (auto tranState: states[j]['.']){    // 如果上一步的状态可以通过任意字符进行转移，则将可能到达的所有状态加入到nowStates中
                nowStates.insert(tranState);
            }
        }
        if (nowStates.empty()){
            return false;
        }else{
            preStates = nowStates;  // 为下一次遍历更新状态
            nowStates.clear();
        }
    }
    
    // 遍历结束。检查所有可能到达的状态，如果其中包含了终止状态，则代表匹配成功，否则匹配失败
    for (auto e: endStates){
        if (preStates.count(e)) return true;
    }
    
    return false;
}
```

## 复杂度分析

设模式串`s`的长度为`m`，匹配串`p`的长度为`n`

### 时间复杂度

易知，使用有限自动机匹配时，时间复杂度为$O(m)$。下面我们简单分析构建自动机的时间复杂度。

-   如果不考虑`*`，则构建自动机的时间复杂度为$O(n)$；
-   最坏情况下，`p`中`*`的数量达到$\frac{n}{2}$，则此时的时间复杂度为$O(\frac{n(n+1)}{8})$，即$O(n^2)$；

总体时间复杂度为$O(n^2+m)$。

### 空间复杂度

空间复杂度主要由三部分组成：

1.  有限自动机
2.  终止结点集合
3.  状态记录集合

这三部分都正相关于状态的数量。通过观察易知，状态的数量等于模式串`p`中非`*`结点的数量 + 1。

对于有限自动机来说，每个状态都要存储相应的转移状态集合。在`p`中`*`的数量达到$\frac{n}{2}$时，需要保存的状态数量最多有$O(\frac{n(n+1)}{8})$个，即$O(n^2)$

所以总体空间复杂度为$O(n^2)$。