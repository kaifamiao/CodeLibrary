###  两种解法

**先看这！！**这个题只是稍微比 [191.只出现一次的数字](https://github.com/ustcyyw/yyw_algorithm/blob/master/easy/BitOperation/hammingWeight.md)多了一点东西，其实两种解法都可以直接借鉴一下，然后就很简单了。

##### 1.移位操作

```java
public int hammingDistance(int x, int y) {
        int count = 0;
        while(y != 0 || x != 0){ // 直到移位使得都为0，那么更高位均为0，是相等的就不用去统计了。
            if((y & 1) != (x & 1)) // 除了当前位，一定都变0（和0进行与运算），当前位则保留（和1进行与运算）
                count++;
            y >>= 1; // 右移动一位
            x >>= 1;
        }
        return count;
    }
```

思路分析：

* 求两个数中二进制不同的的位置的数目，本质上还是需要知道两个数每一位是0还是1，如果不相等就`count++`。不断获得每一位是0还是1参考191题。这里注意一下循环条件，当某个数被移动为0后，另外一个数不为0的话，还有不相等的位置没有统计完成。所以循环条件为`y != 0 || x != 0`。
* 时间复杂度：$O(1)$ 。运行时间依赖于数字x,y的位数。由于这题中 x,y 都是 32 位数。空间复杂度是$O(1)$的。

运行结果：

* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.05%的用户

##### 异或的使用

```java
private int hammingDistance2(int x, int y) {
        int n = x ^ y;
        int count = 0;
        while (n != 0) {
            count++;
            n = n & (n - 1);
        }
        return count;
    }
```

思路分析：

* 求两个数中二进制不同的位置的数量。异或正好是相同为0，不同为1。如果我们将两个数先进行异或，那么相同的位都变成0，不同的位都是1，只需要统计异或的结果的二进制表示中有多少个1即可。成为了191题。
* 运用一个常用技巧，任何数 x在进行了 x & (x - 1)后都将其二进制表示的最低一位1变成了。统计一个数的二进制表示中有多少个1，就去计算进行多少次 n & (n - 1)后（别忘了赋值），n变为0即可。
* 时间复杂度：$O(1)$ 。运行时间依赖于数字`int n = x ^ y`中1的位数，至多进行32次操作。空间复杂度是$O(1)$的。

运行结果：

* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.05%的用户

更多LeetCode题解请看我的[github](https://github.com/ustcyyw/yyw_algorithm)，地址https://github.com/ustcyyw/yyw_algorithm。还有别的小项目也很好玩~卑微求个小星星💖