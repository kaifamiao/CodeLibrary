基础操作是先将x,y取异或记结果为z（程序中仍赋值给x是为了节省内存），得到所有不同的位置。

但是如果是遍历异或后结果的每一位，此时循环的次数较多（32次）且循环内需要做当前位是否为1的判断，时间复杂度仍有提升空间，若使用z&(z-1)，则每次操作必然会使得z失去最靠后位置的一个1，这种方式可以减少循环次数，并且省去判断操作。

eg：
00100**1**00    :z
00100011    :z-1
00100**0**00    :z&(z-1) 

```
class Solution {
public:
    int hammingDistance(int x, int y) {
        int cnt=0;
        x^=y;
        while(x!=0){
            cnt++;
            x&=(x-1);
        }
        return cnt;
    }
};
```