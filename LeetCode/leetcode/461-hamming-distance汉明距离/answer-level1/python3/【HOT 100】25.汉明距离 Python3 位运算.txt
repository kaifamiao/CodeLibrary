
### 1.和1相与，按位判断是否相等

看到两个整数二进制位的不同的位数，就想到是位运算，那位运算怎么算呢？

算不同，第一反应是按位计算异或，然后同时将两个数右移一位，但是按位计算异或怎么搞呢（当时想整体两个数异或，然后移位完全不行），就一直没想到。。。就想那按位看每一位是否相等吧，怎么比较呢，然后想到和1进行相与，这样1每次只代表一位，这样每次我也只对比一位，然后如果两个数和1相与的结果不同，那么count+1，然后每次都要将两个数同时右移一位

但是又想，那二进制位数长度不同怎么办，这个循环的结条件是什么呢，肯定不能是两个都不为0，有可能有一个数上来就一两次次对比之后就为0了，而另一个数还很大，那么就去想循环的结束条件，那肯定是两个数都为0的时候就结束吧，那这样一想，循环的条件就出来了，只要这两个数，有一个不为0，那就要继续下去：`while x != 0 or y != 0`，那么也就是`while x or y`

```
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        count = 0
        
        while x or y:
            if (x & 1) != (y & 1):
                count += 1
            '''同时将x和y向右移一位，而且不能是x>>1，必须是x=x>>1'''
            x = x >> 1
            y = y >> 1
        
        return count
```


![image.png](https://pic.leetcode-cn.com/26ae490c64f32c9f852dd2abb898f86c185c91914c2e765180ff1e1599808e83-image.png)


### 2.异或，统计异或值里二进制位1的个数

写完上面的答案之后，去看了一下题解，发现诶异或确实是考虑的思路，只不过我考虑的方向偏了。。。
不能按位异或，就两个数一起异或，获得异或值，相异为1，那么这个异或值上二进制位等于1的地方都是原来两个数二进制位上不相等的那些位置
我们统计1的个数，就能知道有哪些位数不相等了


```
class Solution:
    def hammingDistance(self, x: int, y: int) -> int:
        count = 0
        
        s = x ^ y
        
        while s:
            if s & 1:
                count += 1
            s >>= 1
        
        return count 
```


![image.png](https://pic.leetcode-cn.com/a93141c7d0511e90f48a40c643b90ac40ee0e9cfae7beb2beb81906ff102b7b0-image.png)


【昨天欠一道题。。今天欠3道题。。】
完全没办法动脑子，最近事情太多了，那就先慢慢写吧，希望早点稳定下来然后安心刷题，plz希望否极泰来，我去看视频去了downdown
1026