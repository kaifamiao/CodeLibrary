#### 方法一：优先队列

我们可以将题目转化为：对于每一个 `l`，要找到一个最小的 `r`，使得 `k` 个列表都至少有一个数出现在区间 `[l, r]` 中，`r - l` 最小的区间 `[l, r]` 即为答案。显然，最小的区间 `[l, r]` 中的 `l` 一定是列表中的每个数，因此我们只需要枚举列表中的每个数作为 `l` 即可，具体的方法如下：

- 将 `k` 个列表合并为一个列表 `T`，并将 `T` 中的所有数从小到大进行排序；

- 枚举 `T` 中的每一个数 `x`，假设 `x` 属于列表 `i`，那么我们在除了 `i` 之外的 `k - 1` 个列表中，分别找出大于等于 `x` 的最小的数，这些数中的最大值记为 `y`，那么 `[x, y]` 是一组满足条件的答案；

- 在枚举结束后，返回 `y - x` 最小的那一组 `[x, y]`。

上述方法的时间复杂度较高。假设 `k` 个列表的平均长度为 `N`，那么总时间复杂度为 $O(Nk\log(Nk) + Nk^2\log n)$，其中 $O(Nk\log(Nk))$ 用来对 $T$ 进行排序，$O(Nk)$ 用来枚举 `T`，$O(k\log n)$ 用来在列表中找数。我们需要在上述的方法中挖掘一些潜在的性质，从而优化我们的算法。

不失一般性，假设 `T` 中所有的数都不相同（若相同，我们可以任意指定它们的大小关系，并不会影响接下来的优化方法），并假设在枚举 `T` 的某一步中，枚举到的数 `x` 属于第一个列表。记在第 `[2 .. k]` 个列表中，大于等于 `x` 的最小的数分别为 `y2 .. yk`，即满足 `yj > x`。那么对于 `T` 中的下一个数为 `x0 > x`，有两种情况：

- `x0` 也属于第一个列表，那么对于所有的 `y2 .. yk` 一定也有 `yj > x0`。否则若有某个 `yj < x0`，那么根据 `yj > x`，`yj` 在 `T` 中一定出现在 `x` 与 `x0` 之间，因此 `x` 的下一个数一定不是 `x0`，矛盾。因此如果 `x0` 也属于第一个列表，那么 `x` 对应的 `y2 .. yk` 与 `x0` 对应的 `y2 .. yk` 完全相同，即我们并不需要在枚举到 `x0` 时，重新找一遍对应的 `y2 .. yk`；

- `x0` 不属于第一个列表，不失一般性，假设 `x0` 属于第二个列表。此时可以用类似的反证法得到 `x0 = y2`，并且 `y2` 是 `y2 .. yk` 中的最小值。那么对于 `x0` 而言，在第 `[3 .. k]` 个列表中大于等于 `x0` 的最小的数分别为 `y3 .. yk`，而在第一个列表中，大于等于 `x0` 的最小的数为 `x` 在第一个列表中后面的那个数。因此如果 `x0` 属于第二个列表，那么 `y2 .. yk` 也不需要变化（`y2` 此时作为 `x0`），只需要将 `x` 替换为其在第一个列表中后面的那个数即可。

根据上面的分析，我们发现，无论是哪种情况，我们都只需要将 `x` 替换成其在对应列表中的后面那个数，再将原本的 `k - 1` 个数和这个新的数中最小的那个置为 `x` 即可，因此我们得到了一种优化的方法：

- 给 `k` 个列表均分配一个指针，初始时这些指针指向列表的第一个元素；

- 在每次操作中，找出这 `k` 个指针指向的元素中最小的元素 `x` 以及最大的元素 `y`，此时对应一组满足条件的答案 `[x, y]`；

- 将 `x` 对应的指针往右移动一位，若移出列表，则结束，否则返回上一步。

我们可以用优先队列（小根堆）维护 `k` 个指针指向元素中的最小值，每次从堆中取出最小值后，将其对应列表中的后面那个数放入堆中，并更新堆中元素的最大值即可。

```Java [sol1]
public class Solution {
    public int[] smallestRange(int[][] nums) {
        int minx = 0, miny = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        int[] next = new int[nums.length];
        boolean flag = true;
        PriorityQueue < Integer > min_queue = new PriorityQueue < Integer > ((i, j) -> nums[i][next[i]] - nums[j][next[j]]);
        for (int i = 0; i < nums.length; i++) {
            min_queue.offer(i);
            max = Math.max(max, nums[i][0]);
        }
        for (int i = 0; i < nums.length && flag; i++) {
            for (int j = 0; j < nums[i].length && flag; j++) {
                int min_i = min_queue.poll();
                if (miny - minx > max - nums[min_i][next[min_i]]) {
                    minx = nums[min_i][next[min_i]];
                    miny = max;
                }
                next[min_i]++;
                if (next[min_i] == nums[min_i].length) {
                    flag = false;
                    break;
                }
                min_queue.offer(min_i);
                max = Math.max(max, nums[min_i][next[min_i]]);
            }
        }
        return new int[] { minx, miny};
    }
}
```

**复杂度分析**

* 时间复杂度：$O(Nk\log k)$，所有的 $k$ 个指针总共最多移动 $Nk$ 次，在每一次移动后，都需要更新优先队列，时间复杂度为 $\log k$。

* 空间复杂度：$O(k)$。