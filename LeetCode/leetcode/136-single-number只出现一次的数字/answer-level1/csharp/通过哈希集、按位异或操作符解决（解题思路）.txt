**写在前面：**

我看 **C#** 是已有一篇题解的，但写题解好玩啊，就不管重复啥子玩意了。

在这篇题解里共会介绍两种解题方法。

---

**分析该题：**

题目有个条件可谓相当重要，即凡重复的元素最多重复一次（原话：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次）。

如果缺失了这一个条件，那么本篇介绍的两种解决方案都将不再适用（至少给出的代码将存在问题）。

---

**解决方案：**

**一、哈希集（HashSet）**

**哈希集**有个重要特性，其是不包含任何重复元素的无序集合。所以，对于此题可谓是相当适用的，毕竟我们要求的值就是唯一的。

故当我们向哈希集添加重复元素时，如果添加失败，则移除当前试图向哈希集添加的元素。

代码如下：

```csharp [-C#]
public static int SingleNumber(int[] nums)
{
    HashSet<int> set = new HashSet<int>();
    for (int i = 0; i < nums.Length; i++)
    {
        //该判断语句的整体作用是：如果当前数字（nums[i]）已经在之前出现过，那么在哈希集实例（set）中移除当前数字
        // Add 方法的作用是添加当前数字于哈希集中，如果当前数字和该集合（set）元素存在重复，则返回 False 。故在此采用了逻辑非操作符（!）
        if (!set.Add(nums[i]))
            set.Remove(nums[i]); ;
    }
    //因为每个重复元素最多存在两个，而重复元素的第一个添加后均被移除，而第二个均未添加成功，故此时哈希集只保留唯一且未重复的元素
    // First*1 方法的作用是返回该序列的第一个元素
    return set.First();
}
```

通过哈希集实现的代码虽然效率较为理想，但就空间占用方面并不完美（其实要不了多少内存，但当要进行操作得数组大到一定程度时，这种解决方案可能会和下面将介绍得方案形成较大差距）。

值得注意的是，哈希集实例的 *First* 方法是由 **Enumerable** 类提供的。其于微软开发者网络（Microsoft Developer Network，即常称的 MSDN）中的释义是：返回序列中的第一个元素。由于所求数唯一，故可以通过 First 方法返回哈希集中唯一的元素。并且此方法包含重载，另一个方法*2的释义为返回序列中满足指定条件的第一个元素。

说了一些不相关的事，但希望对大家能有所帮助

1. `First<TSource>(IEnumerable<TSource>)`

2. `First<TSource>(IEnumerable<TSource>, Func<TSource,Boolean>)`

**二、按位异或（xor）操作符**

这一种解决方案应该并不如哈希集那般容易被想到，毕竟按位操作符也相对其他操作符挺少用到的，但连这玩意都不知道的道友就有些基础欠佳了。

**在运用按位异或操作符之前得先了解一下，什么是按位异或操作符？（大佬直接略过）**

按位操作符的字面意思很好理解，即对值的二进制格式进行处理的操作符。而异或的作用为：假设有值甲、乙，当甲乙值相等时，异或操作后结果为不等（False，0），反之，为相等（True，1）。所以按位异或操作符的释义便显而易见了：对某值的每个位上的值（0或1）进行异或操作。

举一例例子：

甲：0 0 0 0 1 1 0 0 （值为12）

乙：0 0 0 0 0 1 1 1 （值为7）

甲和乙进行按位异或操作得到新值丙

丙：0 0 0 0 1 0 1 1 (值为11)

可见，当两值的某一位的值不同时，按位异或操作后所得新值某一位的值将为 1 （如从右到左第一位），反之为 0 （如从右到左第三位）。

既然有异或操作符，那么很可能会有同按位的操作符，但我就不再一一介绍了，毕竟我介绍按位异或操作符只是为显得我写的题解内容翔（空）实（洞）。

**逻辑思路**

有了按位异或操作符，我们就可以依照其独特的性质，敲除一段极其华丽的代码。

但题解是题解，不是我擅长的搬砖，我得先把逻辑思路捋清。

有一个数组，含有值：12，7，12。并含有一个变量甲，其值为0。（先不要纠结为何要这么定义，这是为了了解按位异或操作符的神奇性质）

对数组进行遍历，且遍历所得的每个值都和变量甲进行一次按位异或操作。
```
——————第一次：

12：0 0 0 0 1 1 0 0 

甲：0 0 0 0 0 0 0 0

异或

甲：0 0 0 0 1 1 0 0（值为12）

——————第二次

 7：0 0 0 0 0 1 1 1

甲：0 0 0 0 1 1 0 0

异或

甲：0 0 0 0 1 0 1 1（值为11）

——————第三次

12：0 0 0 0 1 1 0 0

甲：0 0 0 0 1 0 1 1

异或

甲：0 0 0 0 0 1 1 1（值为7）

——————遍历结束
```
返回值：甲。甲值为 7 ，数组中唯一元素为 7。


通过观察，和结合按位异或操作符的性质我们可以发现一个按位异或操作的性质：一个值和0进行按位异或操作所得为该值，相同的两个值进行异或操作，所得为0（甲 按位异或 0 得 甲，甲 按位异或 甲 得 0）。

根据这个性质，由于每个重复元素重复两次，故他们在遍历后将相互抵消，而唯一元素只出现一次，故将得到保留（如果我举的例子不具有说服力，请自行演算————码字太枯燥了……）。

**依此逻辑，得代码如下：**

```csharp [-C#]
public static int SingleNumber(int[] nums)
{
    //注意，这里为0而不是其它值得原因并不是盲目的：甲 按位异或 0 得 甲，甲 按位异或 甲 得 0
    int result = 0;
    for (int i = 0; i < nums.Length; i++)
    {
        // ^ 为C#提供的按位异或操作符，而 ^= 相似 += ,其效果等价于 result = result ^ nums[i]
        result ^= nums[i];
    }
    return result;
}
```

**结束**

码字不易，各位大佬，给个赞敷衍下我 bie~。







