## 0、异或运算解法

题目中写到的不使用额外空间来实现，也就是不能创建新的序列来存储和筛选重复元素。否则，使用链表等结构，对重复出现的数据遍历一次筛选，时间复杂度都可以做到O(n). 如同其他题解，这里先展示异或解法，然后下面介绍位运算的概念。

从异或的概念（1&0=1,1&1=0,0&0=0）去推演，可知：

一个数和 0 做 XOR 运算等于本身：a⊕0 = a

一个数和其本身做 XOR 运算等于 0：a⊕a = 0

而异或满足交换律和结合律：a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b

代码实现中，我们将数组里每一个元素依次进行异或处理，存在两个的元素最后都会归0，只有存在单个的那一个元素会保留结果。

这道题使用异或能得到最优解，但是要求首先知道位运算这个玩法。



代码：

```java
public int singleNumber(int[] nums) {
    int ans = 0;
    for(int num: nums) {
        ans = ans^num;
    }
    return ans;
}
```

## 1、位运算的理解

这里能够做到不消耗额外空间的，只能是用位运算。我们先来看看位运算是什么。

计算机中的数据结构，都是二进制保存，然后转化十进制的。下面是整数1的二进制32位表示，任何整数的数学计算还原到二进制就是位移。例如把1变成2，就把整个二进制数左移一位，达到乘2的效果。

32位的1：0000 0000 0000 0000 0000 0000 0000 0001

32位的2：0000 0000 0000 0000 0000 0000 0000 0010



## 2、Java的位运算

Java提供的位运算符有：左移( << )、右移( >> ) 、无符号右移( >>> ) 、位与( & ) 、位或( | )、位非( ~ )、位异或( ^ )，除了位非( ~ )是一元操作符外，其它的都是二元操作符。左移、右移相对比较好理解。

### 2.1无符号右移(>>>)

Java中int类型占32位，可以表示一个正数，也可以表示一个负数。正数换算成二进制后的最高位为0，负数的二进制最高为为1.

-5换算成二进制后为：

1111 1111 1111 1111 1111 1111 1111 1011

可以想象一下，带符号右移一定是保留最高位原本为0或者为1的。相反，如果无符号右移，那正数还是正数，负数就变成了一个巨大的正数了。

-5无符号右移3位后就变成了：

0001 1111 1111 1111 1111 1111 1111 1111

换算成十进制就是536870911.



### 2.2 移动补位

正数右移，高位用0补，负数右移，高位用1补。

当负数使用无符号右移时，用0进行部位(自然而然的，就由负数变成了正数了)。

正数或者负数左移，低位都是用0补。



### 2.3 位与( & )

首先要了解与的概念：1&0=0,1&1=1,0&0=0

这里我们用5&3来演示

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0***101***

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0***011***

1转换为二进制：0000 0000 0000 0000 0000 0000 0000 0***001***



### 2.4 位或( | )

同样，或的概念：1&0=1,1&1=1,0&0=0

这里我们用5|3来演示

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

7转换为二进制：0000 0000 0000 0000 0000 0000 0000 0111



### 2.5 位非( ~ )

位非是一元操作符，也就是只作用于一个位上：~1=0,~0=1

这里我们用~5来演示

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

-6转换为二进制：1111 1111 1111 1111 1111 1111 1111 1010



### 2.6 位异或( ^ )

异或的概念：1&0=1,1&1=0,0&0=0

也就是两个位的比较，相同则结果为0，不同则结果为1

这里我们用5^3来演示

5转换为二进制：0000 0000 0000 0000 0000 0000 0000 0101

3转换为二进制：0000 0000 0000 0000 0000 0000 0000 0011

6转换为二进制：0000 0000 0000 0000 0000 0000 0000 0110


部分参考：

https://blog.csdn.net/xiaochunyong/java/article/details/7748713

https://leetcode-cn.com/problems/single-number/solution/hua-jie-suan-fa-136-zhi-chu-xian-yi-ci-de-shu-zi-b/