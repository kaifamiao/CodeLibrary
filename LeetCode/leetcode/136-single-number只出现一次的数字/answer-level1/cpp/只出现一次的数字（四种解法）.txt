[题目描述](https://leetcode-cn.com/problems/single-number/)
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
>示例 1:
输入: [2,2,1]
输出: 1
示例 2:
输入: [4,1,2,1,2]
输出: 4

这个题我初步拿到后，想到的一个思路，就是排序之后，查找， 其实这个题最好的思路是利用异或操作， 下面介绍一下这个题的四种思路。
#### 1. 暴力
暴力的解法，这里不像多说，因为这种题目想到暴力一般会超时，并且效率也不会太高，并且暴力的思想在这种题目中尽量别养成习惯，虽然能够解决题目，但是不会有用，不仅要追求做出来，还要想想一些好的方法。
> 暴力的话，两层循环，外循环遍历，内循环找

时间复杂度O(n^2)  空间复杂度O(n) 不需要额外的空间
#### 2.  快速排序
我初步思路就是用的这种方法， 就是首先对数组进行快速排序，然后从头开始遍历，因为如果是相同的两个数，肯定是挨着的，此时我会把他们全都置为-1，所以最后遍历一遍之后，不是-1的就是答案。 但是这种方式要注意可能测试样例本身就有-1， 所以最后如果找不出答案，返回-1.

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int len = nums.size();

        sort(nums.begin(), nums.end());

        for (int i=0; i<len-1; i++)
        {
            if (nums[i]!=-1 && nums[i]==nums[i+1])
            {
                nums[i] = -1;
                nums[i+1] = -1;
            }
        }
        for (int i=0; i<len; i++)
        {
            if (nums[i] != -1)
                return nums[i];
        }

        return -1;
    }
};
```
时间复杂度 O(nlogn), 空间复杂度O(n)  不需要额外的存储空间

#### 3. 数学上的方式
这个想法是看过题解之后的方法，感觉挺巧妙，没想到，所以记录了一下，题目中给出的信息，只有一个是出现一次，其他出现了两次。 这个信息很重要，竟然可以利用和差的方式算出来。 数学公式：
>2*（a+b+c） - (a+a+b+b+c) = c

c就是最后的答案，所以这个题也可以利用这种方式，只不过C++中，需要用到set筛选元素得到(a+b+c)的和，这样额外开辟了空间，应该是不满足题意的，但是这种思想很巧妙。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int len = nums.size();

        set<int> s;

        int sum1 = 0;
        int sum2 = 0;
        for (int i=0; i<len; i++)
        {
            sum1 += nums[i];
            if (s.count(nums[i]) == 0)
            {
                s.insert(nums[i]);
                sum2 += nums[i];
            }
        }
        return 2*sum2 - sum1;

    }
};
```

#### 4. 异或原理
这是这个题的最优解法，也是看过题解后发现的最好的一种解法，异或运算有下面的几个特点：
>一个数和 0 做 XOR 运算等于本身：   a⊕0 = a
一个数和其本身做 XOR 运算等于 0： a⊕a = 0
XOR 运算满足交换律和结合律：   a⊕b⊕a = (a⊕a)⊕b = 0⊕b = b

所以，这个题只需要遍历一遍数组，把所有的元素进行一次异或运算，就可以得到最后的答案，时间复杂度O(n)， 空间复杂度O(n) 不需要开辟额外的空间

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int len = nums.size();

        int res = 0;
        for (int i=0; i<len; i++)
            res ^= nums[i];
        return res;
    }
};

```

#### 总结
小总一下，这个题目又领略到了思路开放是多么的重要，有时候做题的最终目标并不是最后会有什么样的结果，而是去追求四个字： 见多识广。