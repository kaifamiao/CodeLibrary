0 ≤ x < 10^n   
n = 0时 x = 0 输出 1（只有一个0满足要求）  
n = 1时 0≤ x < 10 输出 10 （明显0-9,10个数字均满足要求）    

n = 2时 0≤ x < 100 输出 91   
我们来看下91的构成，之前已经有0≤ x < 10的这个条件下的解了，我们只要考虑[10,100)的情况，然后将两者加起来即可。  
这样就符合动态规划的要求了，每次使用前面已知的结果来构成本次的解。  

根据我们排列组合的知识，假设一个 xx 2位的整数，要满足题目要求那么第一位只能从1-9中任取一个有9种情况，接下来第二位可以从0-9（这个0-9其实是9位因为被前面用掉一个数）所以还是有9种可能。  

由此如果n=3的情况的话，那么整个解的构成就是由n = 2时的解加上由 xxx 位满足题目的解。  

状态转移方程 f(x) = f(x-1) + 9*9*8..;  
```
int countNumbersWithUniqueDigits(int n){
    if(n == 0)
     return 1;
    if(n == 1)
     return 10;
     int dp[n+1];
     dp[0] = 1;
     dp[1] = 10;
    for(int i = 2; i <= n; i++)
    {
        int temp = 9;
        for(int j = 0; j < i-1;j++)
        {
            temp *= 9-j;
        }
        dp[i] = dp[i-1] + temp;
    }
    return dp[n];
}
```


