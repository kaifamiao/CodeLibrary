执行用时 : 0 ms, 内存32.5MB  
给定非负整数n, 寻找在区间[0, 10^n)之间所有不存在相同数字的数目，我们用dp[n]表示满足要求的数字总数  
dp[0] = 1，dp[1] = 10,    
dp[2] = 91,  很容易发现， 区间[0, 10^2)可以拆分为[0, 10^0）V [10^0, 10^1) V [10^1, 10^2）这三个区间的并集，  
而dp[0]表示 [0, 10^0）满足要求的数字个数  
dp[1]表示 [0, 10^0）V [10^0, 10^1) 满足要求的数字个数，容易联想到dp[1] = dp[0] + X， X表示在[10^0, 10^1)上满足要求的数字个数，   
dp[2]表示 [0, 10^0）V [10^0, 10^1) V [10^1, 10^2）满足要求数字个数， 同理， dp[2] = dp[1] + X,  X表示在[10^1, 10^2)上满足要求的数字个数，  即不含重复数字的两位数，一共有`9*10 = 90`个
推广开来  
 n >= 1
 dp[n] = dp[n-1] + X
 X表示不含重复数字的n位数，对一个位数为n的数字，用0~9的数字去填充，一共有`9*9*8.....*(9-(n-2))`种不包含重复数字的可能,

![dp.png](https://pic.leetcode-cn.com/5647e810da0666e9758ff93ac3c921ca0404c60e8625f5c559c01eecd405ac48-dp.png)
  
  
当n> 10 时， 显然对于任何一个超过10位的数，我们在n位数中找不到任何一个不含重复数字的数，所以此时  
dp[n] = dp[10]  
所以代码如下：

```
class Solution {
    public int countNumbersWithUniqueDigits(int n) {
        if(n == 0){
            return 1;
        }
        int[] dp = new int[11];
        dp[0] = 1;
        int per = 1;
        for(int i = 1; i <= 10; i++){
            dp[i] = dp[i-1] + 9*per;
            per = per*(10-i);
        }
        if(n <= 10){
            return dp[n];
        }else{
            return dp[10];
        }
    }
}
```
