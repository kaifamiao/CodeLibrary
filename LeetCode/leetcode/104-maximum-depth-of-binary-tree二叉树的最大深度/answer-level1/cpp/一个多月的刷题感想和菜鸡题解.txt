### 解题思路
第一次在Leetcode上写题解，系统推荐写就点进来写一下，算记录自己一个多月的刷题的一个节点。

1.刷题感想
   我是选择top100刷，然后挑中等和简单的题在做，困难的暂时跳过了，准备放在最后啃硬骨头。
   一开始做的时候对刷题充满新意，但奈何没有技术，黑猫白猫抓到耗子就是好猫，脑子里有想法就写，也不管是多冗余的方法，
   这种情况到现在也有，对于程序的美观与优化、高效，肯定是我们最高的最求。 可惜，菜鸡的我背道而驰。
   到目前为止，大概刷了有30多道，在编程语法上，感觉c++用的更熟练了，发现stl真是个好东西，那么多数据结构可以信手拈来，对于对象以及指针的理解更深了，可以避免低级的错误，也改变不用拼音来命名，low啊。
   对于算法，说真的，最多的就是回溯法了吧，每次自己很笨的写完，再去看人家的回溯法，真感觉自己写的太冗余了，但又在自己做的时候很难有一个整体的思路，就导致走一步看一步，结果最后总要为程序的健壮性而拆东墙补西墙，最后勉勉强强通过后，发现与大佬的答案难以相比。
   总结下来，程序框图真是个好东西，或者说随便画个图真是有帮助，思路在脑子里总不能想到的太长远，太完全，画出来就好很多。
   另外就是，算法即使当时看会了，过一段时间也会忘，或者说“背”大佬的程序感觉没什么用，最主要还是逼自己做出来，这也就是为什么我自己写的那么烂，我也要坚持写完的原因吧。当然，看大佬的程序肯定是有帮助的，我现在偶尔会做一道，看五道，感觉也不错。
   最后，希望自己能坚持到100完成吧，那感觉会很不错，看到这里的兄弟，共勉。
2.回到这道题
   菜鸡的我就说说我的解题过程吧，反正也没什么亮点，哈哈，写下来全当无聊
   a.我第一感觉肯定是能不能中序遍历，层次遍历一下啊，直接出来结果，用上几个题做的结论来搞一下，貌似层次遍历的层数就是这个的深度，可以往那方面想，就像之前用的队列做层次遍历，但又有问题，就是队列输出层次遍历，其实是没记录层数的，上一题那个分层输出的层次遍历，我又做的很复杂，不可取不可取。
   b.然后就写一个递归或者说回溯吧，总感觉他俩差不多，我开始写的时候，是读到叶子节点，就把当前记录的深度与过去的深度比较，更大就保存，要不然就把深度的记录归1。问题很明显啊，归1肯定歇菜，是要返回上一层的深度。
   c.然后我又改成减1，然后又有问题，因为我只在发现叶子节点的时候减1，而忽略了，中间节点计算完毕后的减1，更改之后就完成啦。
   d.真的很菜，哈哈，继续努力吧。

### 代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        int res = 1;
        int res_old = 1;
        if(root == NULL){
            res--;
            return res;
        }
        Depth(root,res,res_old);
        return res_old;
    }
    void Depth(TreeNode* root,int& res,int& res_old){
        if(root->left == NULL&&root->right == NULL){
            if(res_old < res){
                res_old = res;
            }
            res--;
            return ; 
        }
        if(root->left != NULL){
            res++;
            Depth(root->left,res,res_old);
        }
        if(root->right != NULL){
            res++;
            Depth(root->right,res,res_old);
        }
        res--;
        return;
    }
};
```