## 要点
##### 1. 可用0和1的个数可以看成不同容量的背包(二维)
    dp[i][j]    i 表示可用0的个数， j 表示可用的1的个数
##### 2. 对应每一个01串， 做的事情： 
    对于可以放得下的背包  ①不放，则查看原旧背包容量　②放，则 1（当前01串）+ 变小的 旧背包容量

##### 3. 状态转移方程： 
    dp[i][j] = max(dp[i][j],  1 + dp[ i-item_count0 ][ j-item_count1 ])

## 举例子说明：
```
输入: Array = {"10", "0001", "111001", "1", "0"}, m = 5, n = 3
输出: 4
解释: 总共 4 个字符串可以通过 5 个 0 和 3 个 1 拼出，即 "10","0001","1","0" 。
```
#### dp[i][j]，，0<=i<=3 ，，0<=j<=5，,要把二维数组的每一个都要看成一个背包
#### 初始化背包，
```
dp   0列    1列     2列     3列  （列表示背包1的可容纳大小）
0行   0      0       0      0
1行   0      0       0      0
2行   0      0       0      0
3行   0      0       0      0
4行   0      0       0      0       
5行   0      0       0      0

（行表示背包0的可容纳大小）        d[i][j]值表示 已经装了多少个字符串
```
#### 对于第一个01串 ‘10’
```
可容纳的背包 （√表示可容纳 x表示不可容纳）
dp   0列    1列       2列     3列  
0行   ×      ×       ×      ×
1行   ×      √       √      √
2行   ×      √       √      √
3行   ×      √       √      √
4行   ×      √       √      √       
5行   ×      √       √      √

对于可容纳的背包要依次遍历，不放，则查看原旧背包容量　　放，则　1（当前01串）+ 变小的 旧背包容量 　-> 取最大值
dp   0列    1列     2列     3列  
0行   0      0       0      0
1行   0      1       1      1
2行   0      1       1      1
3行   0      1       1      1
4行   0      1       1      1       
5行   0      1       1      1
```

#### 对于 第二个01串‘0001’
```
可容纳的背包 （√表示可容纳 x表示不可容纳）
dp   0列    1列       2列     3列  
0行   ×      ×       ×      × 
1行   ×      ×       ×      × 
2行   ×      ×       ×      × 
3行   ×      √       √      √
4行   ×      √       √      √       
5行   ×      √       √      √

对于可容纳的背包要依次遍历， 不放，则查看原旧背包容量   放，则 1（当前01串）+ 变小的 旧背包容量  -> 取最大值
dp   0列    1列     2列     3列  
0行   0      0       0      0
1行   0      1       1      1
2行   0      1       1      1
3行   0      1       1      1    
4行   0      1       2      2       
5行   0      1       2      2  <-- max（原本背包价值1【不放】， 1+旧背包dp[5-3][3-1]【放】）
```

## 参考代码

```python []
class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        if len(strs) == 0:
            return 0
        
        dp = [[0]*(n+1) for _ in range(m+1)]   #准备很多个背包
        
        for strs_item in strs:
            item_count0 = strs_item.count('0')
            item_count1 = strs_item.count('1')
            
            #遍历可容纳的背包 
            for i in range(m, item_count0 - 1, -1):  #采取倒序
                for j in range(n, item_count1 - 1, -1):
                    dp[i][j] = max(dp[i][j], 1 + dp[i-item_count0][j-item_count1])
                    
        return dp[m][n] 
```
