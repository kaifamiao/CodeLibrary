这是算法导论第四章介绍分治算法的例题，不过也可以用动态规划的方法实现。我们用数组`DP`储存信息，其中`DP[i]`表示以`nums[i]`结尾的最大子序和（这个子序列必须以`nums[i]`结尾）。如果我们求出了所有的`DP[i]`，那么它的最大值就是题解。因为整个序列的最大子序和一定以某一个`nums[i]`为结尾。

`DP`的初始点为：
- `DP[0] = nums[0]`

这是因为以`nums[0]`结尾的子序列只有一个，那就是它本身。

`DP`的递推式为：
- `DP[i] = nums[i]`，若`DP[i - 1] <= 0`
- `DP[i] = DP[i - 1] + nums[i]`，若`DP[i- 1] > 0`

这是因为如果`DP[i - 1] <= 0`，那么前面的都可以舍弃不要（相当于拖后腿的），只选择`nums[i]`作为子序列；如果`DP[i - 1] > 0`，那么说明把前面的子序列也包含进来求和，会比只要`nums[i]`更大。

Python的代码如下：
```Python
def maxSubArray(self, nums: List[int]) -> int:
    DP = [0] * len(nums)
    DP[0] = nums[0]
    for i in range(1, len(nums)):
        DP[i] = nums[i] + max(0, DP[i - 1])
    return max(DP)
```

时间复杂度：$O(N)$，因为只需遍历一次
空间复杂度：$O(N)$，因为开辟了一个数组的位置记录`DP`

由于`DP[i]`只与`DP[i - 1]`有关，因此也可以不储存全部的`DP`，只需记录`DP[i - 1]`，这样可以将空间复杂度降低为$O(1)$
