# 思路
其实分治算法就相当于分类问题，把一个大问题细分到一个个小问题，最后再总合每个小问题的答案就是最终答案啦。

就以这个例子来讲，`nums = [-2,1,-3,4,-1,2,1,-5,4]`
分成三类小问题来求解，从中间把数字分为左右子序 `mid =[ 0 + (nums.size()-1) ]/2`，这里mid = nums[4] = -1（4为索引值）
1. 左序为`[-2,1,-3,4,-1]`及其子序比如[-2,1]、[-2,1,-3]、[-2,1,-3,4]、[1,-3]、[1,-3,4]、[1,-3,4,-1]······所有的组合
2. 右序为`[2,1,-5,4]`及其子序比如[2,1]、[2,1,-5]、[1,-5]、[1,-5,4]······所有的
3. 跨中间的，如何保证能够不重复计算，当跨中间的同时含有左序的最后一个及右序的第一个就肯定不会与前面两个有重复的，即同时含有索引为`mid`和`mid+1`的元素。

前面两个很好计算，就用递归就行。
1. 左序`maxSubArrayHelper(nums,left,mid);`找出左序的最大值leftSum;
2. 右序`maxSubArrayHelper(nums,mid+1,right);`找出右序的最大值rightSum;

最最让我困扰的就是跨中间的怎么计算，终于看懂了！这里还是把它分为左边和右边，分开来计算，最后再相加。
```
================================================================================================
```

已知：跨中间必须要同时包含`mid`和`mid+1`
     所以我们可以先分别计算包含`mid`的最大值leftMax和包含`mid+1`的最大值rightMax；
```
================================================================================================
```

包含`mid`的所有子序为[-2,1,-3,4,-1]，[1,-3,4,-1]、[-3,4,-1]、[4,-1]，[-1]找出这几个的最大值就是我们的leftMax;

包含`mid+1`的所有子序为[2,1,-5,4]、[2,1,-5]、[2,1]、[2]找出这几个的最大值就是我们的rightMax;
```
================================================================================================
```

最后最大的左边加上最大的右边那就是最大的中间了！即`midSum = leftMax+rightMax`

所有的最后，就是比较三个分类的结果了，即midSum、leftSum和rightSum的大小，最大值就是所求解。

可以参考大佬们的代码理解理解_(:ι」∠)_