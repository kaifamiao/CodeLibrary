### 解题思路
题目的要求是求连续子组数的最大和，一个明显的解法是暴力枚举，两层循环，复杂度为o(n^2),当然这样时间复杂度就超了。凡是暴力枚举法超过时间限制的题目，我感觉基本上都可以用动态规划来求解，动态规划本质上就是穷举+修剪（冗余的情况）。
接下来是动态规划的分析过程，动态规划缺失时比较难以思考的，在思考过程强迫自己去思考“状态”，以及状态改变的过程。假设nums= [-2,1,-3,4,-1,2,1,-5,4],dp[i]存储包含第i个数的数组的最大连续和，这点很关键，那么状态转移方程则为 dp[i]=max(dp[i-1]+nums[i],nums[i]),为什么是这种呢？还有假设状态转移方程改为dp[i]=max(dp[i-1]+nums[i],dp[i-1]) 可以吗？为什么？

先说 dp[i]=max(dp[i-1]+nums[i],nums[i]) 当前求和要么为自己本身，要么为前一个dp[i-1]+自身，这样在i从1开始一次遍历nums时，总能保证包含自身最大的连续和，dp[i]=num[i]很明显，但dp[i]=dp[i-1]+nums[i]，能保证是连续数组的和吗？ 当然可以因为dp[i-1]中绝对包含num[i-1],以此类推，最后求max(dp),最大值就是最大连续子序列的和，一个dp[i]中每一个元素都是包含自身的最大连续子序列的和。

再看 dp[i]=max(dp[i-1]+nums[i],dp[i-1])，它代表什么意思，假设起始条件dp[-1]=0 的话，那就是最大子序列（可以不连续）的和了，当然用贪心来说就是选正的子序列就好了。

所以说，动态规划找好状态以及写对状态转移方程非常重要，只要做好这两步基本上就解决问题了，剩下就是代码实现的过程

### 代码

```python
class Solution(object):
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        #要求左右两端同时 要求连续 二维状态 二维状态db table 暴力法时间会超出纬度 状态转移方程不一样 最终呈现的结果也是前差万别 
        size=len(nums)
        if size<1:
            return 

        dp=[0]*size
        dp[0]=nums[0]
        for i in range(1,size):
            dp[i]=max(dp[i-1]+nums[i],nums[i])
        #print(dp)    
        return max(dp)
```