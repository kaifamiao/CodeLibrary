### 解题思路
1.思路：最直观是暴力破解，找出所有的子序列，存储所有子序列的和，然后找到最大值，但是当数组比较大时候规模将会呈现爆炸增长，相当于数学中求非空真子集个数，
将会是 2^n -1 个 ；
动态规划思路：设置两个概念，结果项和游标项，结果项含义是永远保持当前最大子序列的和；游标项是保持单位子序列的最大和。
先把第一个元素当作结果项和游标项，然后开始元素的遍历，先开始是游标项，当自身是正数时游标项就把该元素加进来，否则就就舍弃当前，把下一个元素当作新的游标项，
当然可能新的游标项目可能比之前的还有小，此时结果项进行判断，判断是要上一个游标项还是新的游标项。
这个把该问题分解为求多个重复的游标项值，游标项最大的就是和最大的子序列。

### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
    let currentSum = nums[0];  //最大子序列的和，理解成结果项
    let n= nums[0]; //单位子序列的和,理解成游标项
    for(let i=1;i<nums.length;i++){
        if(n>0){   //判断是否是正数
            n = n + nums[i];  //是正数越加也大，所以这个元素能要
        }else {
            n = nums[i]; //是负数，直接要下一个元素
        }
        if(currentSum < n){
            currentSum = n; //当前最大子序列的和 是比游标项大的就要，不然就继续保持原来得值
        }
    }
    return currentSum;
};
```