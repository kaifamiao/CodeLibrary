拒绝采样，顾名思义，就是丢掉我不想要的结果，重新来过。

具体到这一题，要用7生成10，那一次肯定不够，于是我们有了生成出两个数相加的想法。但你如果直接生成，那是[2,14]，显然不符的。于是理所当然的，我们想到了把一些碍眼的结果不要（比如7），重来。这样一来，就成了[2,12]了。

好了，相信聪明的你已经看出来，无论怎么去重新来过，你这个1是铁定出不来的。那我们在深入地想一想，1为什么没有？因为没有0！于是乎，就需要把第一次（或者第二次）生成的数做替代了。好，第一次取[1,7]，可不可以？显然不行！既然你第一次都把[1,7]算好了，那第二次肯定是要冲击[8,10]的，于是乎，相当自然的（**好吧，这一步最为关键**），你要把第二次的[1,7]分为{0,3}（比如[1,3]视为0,[4,6]视为3,碰到7就重来）,这不对嘛是吧，第二次不是纯粹的只出现一次[1,10],而是[1,7]和[4,10],你看这交叉了，它不均匀。同理取[1,6]，最后结果会是[1,6]和[5,10]，还是交叉。最后取到[1,5]，终于得到了[1,5]和[6,10]，这就是我要的结果！

总结一下，在做拒绝采样时，拒绝的结果是为了缩小问题域而使得概率均匀的分布。比如像我这种凑数，第2次凑的结果要么是原封不动的保留第一次（取0）（不妨设它为情况A），要么是得到与A不同的数（不妨设它为情况B）。所以，为了得到样本数相同的情况A与情况B，就有必要拒绝第一次的一些结果，把它们划分到情况B中。

```
class Solution {
public:
    int rand10() {
        int num1,num2;
        do{
            num1=rand7();
        }while(num1==6||num1==7);
        do{
            num2=rand7();
        }while(num2==7);
        num2=num2<=3?0:5;
        return num1+num2;
    }
};
```
