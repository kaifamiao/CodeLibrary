### 解题思路
这个题开始以为之只要是有一个字符串包含在另一个字符串中，那么就要压缩在里面。
`例如：words=["I","am","a","boy"]`
`压缩后是 S="I#am#boy#"`
但是仔细一想不对啊，如果是这样的话，就不能通过索引表进行解码了。这就让我想到了学习哈夫曼编码时，要要求必须是前缀码（任何一个字符的编码都不是另外一个字符的前缀），要不然就不能都唯一的解码。
那顺着这种思路，我就想那么这种压缩编码到底应该满足什么条件，而哪些情况是不行的。

我想了一下有两种情况是不行的：
1. 一个字符串不能是另外一个字符串的前缀
2. 一个字符串不能是另外一个字符串内部的一个子串，此处说的内部是指me是somewhere的字串这种的（当然如果是sometime这种的，就是可以的)

**只有一个字符串是另外一个字符串的后缀码（我也不知道用什么表达，就姑且这样说喽），那么这样才可以真正的压缩，并且可以通过索引表来解码。**
我的思路来源自“#”和栈，如果我给每一个单词都加上“#”，那么这样我在判断这个字符串是不是另一个字符串的后缀码是就方便多了，因为大家都有“#”，所以不影响判断子串，但是每个单词后面都有一个“#”，那么我判断是不是子串的同时就选择的一定的后缀码。那接下来就是如何进行压缩了。首先将一个单词进栈，然后在将下一个单词进栈，如果前者包含后者，那么将后者出栈；如果后者包含前者，那么前者出栈（即两者都出栈在让后者进栈）；否则，就让前者把后者给包含进来（正所谓打不过就加入，哈哈哈！），依次按照这种方式，直到最后一个单词，最后在栈中的字符串就是压缩后的。我只是借助了栈的思想，但是实现的时候并没用栈。
***
这只是我个人的理解，如有不正确的请指正。

### 代码

```java
class Solution {
    public int minimumLengthEncoding(String[] words) {
        String S=words[0]+"#";
        String temp;
        for(int i=1; i< words.length;i++){
            temp = words[i]+"#";
            if(S.contains(temp)){
                continue;
            }
            else if(temp.contains(S)){
                S = temp;
            }
            else{
                S += temp;
            }
        }
        return S.length();
}
}
```