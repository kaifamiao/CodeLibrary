题目让我们使用索引字符串和索引列表能确定所有的单词，索引列表只给出了单词开始的index，而单词结束的位置通过`#`指出。

所以，如果某个单词`s`能被单词`t`包含，那么它必须是`t`的后缀！如果是后缀,则`s`可以被压缩。举例：`me`是`time`的后缀，因此这两个可以用`time#`索引字符串的`[0,2]`索引列表进行压缩。

如果所有单词两两的进行判断是不是后缀，那么总的时间复杂度是`O(N^2)`，有没有更简单的方法呢？

一个降低时间复杂度的技巧是：如果需要判断的单词都是相邻的就好了！这种情况下，我们只需要遍历一遍就行。那怎么让相同后缀的单词相邻？排序呀！**遇事不决先排序！**

为了能够通过排序让结尾相同的单词邻近，可以考虑先把单词翻转。（也可以自定义排序函数，按照单词的逆序进行排序）

所以解题方法：

1. 把所有单词进行翻转，并且按照**字符序**排序，这样相同结尾的单词就会天然弄到了一起。
2. 然后，通过一次遍历，判断前面的单词是不是后面的单词的**前缀**（已经翻转了），如果不能的话说明前面的单词需要独立成一个新的以`#`的，所以结果的长度要加上len(last) + 1.

举个例子，对于输入：

	words = ["time", "me", "bell"]

为了看一个单词能否包含另一个单词，先倒序，在排序，得到：

	words = ["em", "emit", "lleb"]

为了能让最后一个单词也进行判断，可以在words末尾添加一个空字符串`""`。

	words = ["em", "emit", "lleb", ""]

从左向右遍历，判断前一个单词是不是后一个单词的前缀，如果是的话就忽略这个单词；否则就拼接上前面这个单词。

得到最终结果`emit#lleb#`，长度是10。

Python代码如下：

```python3
class Solution:
    def minimumLengthEncoding(self, words):
        """
        :type words: List[str]
        :rtype: int
        """
        words = sorted([word[::-1] for word in set(words)])
        last = ""
        ans = 0
        for word in words + [""]:
            if not word.startswith(last):
                ans += len(last) + 1
            last = word
        return ans
```

欢迎关注[负雪明烛的刷题博客](https://blog.csdn.net/fuxuemingzhu)，刷题800多，每道都记录了写法！

力扣每日一题活动建群啦，一起监督和讨论，我自建监督网址：[http://140.143.79.116/](http://140.143.79.116/)，加入方式可以通过利用邮件（fuxuemingzhu#163.com，把#换成@）给我发微信号。


![20200328010219.jpg](https://pic.leetcode-cn.com/0ff374e53861231c95ee43b39d0c967b2d65b7b9289cd5757768af76bee0e231-20200328010219.jpg)
