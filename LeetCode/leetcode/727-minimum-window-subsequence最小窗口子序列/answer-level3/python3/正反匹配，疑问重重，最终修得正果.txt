### 解题思路
一个比较容易想到的思路就是正反匹配，即从i开始，先正向找到第一个符合题意的最短字串区间S[i...j], 则应有S[j] = T[-1],再从j逆向向前找到k,容易证明在区间S[i,j]之间，最短的符合题意的子串就是S[k...j]。

一开始的思路是将整个S分为若干个这样的字串，S[i1...j1], S[i2...j2] ...，然后从每个子串中找到最短字串，再取最小值就是最终答案。提交上去，通过了48/53个案例。WTF?你要么通过几个，要么TimeOut，这通过一大半是什么鬼？

看了题解，官方给出的都是动态规划的套路，时间复杂度是O(NK)，可是我的是O(N)啊！ 继续看题解，发现也有跟我一样的用正反匹配的，但是人家都AC了！

研究了半天，发现我犯了一个大错，我将整个S划分成若干个不重叠的区间是错误的，因为这种符合条件的区间是有可能重叠的！如果要避免这种错误，我的第一直觉是每找到一个区间[i...j]，下一个从i+1开始找，可是这直接导致了算法的时间复杂度从O(N)变成了O(N^2)。

继续研究，发现我们在找到区间[i...k...j]之后，我们不需要从i+1开始找，而只需要从k+1开始即可。因为：

**若从i + 1 ~ k的任一点i'开始搜索，那么得到的最后新的j'必然与上一轮的j相同！之后又从j逆向搜索，结果必重复**！这一点大家可以细细体会一下，因为根据之前搜索区间[i...j]的方式, j必为在区间[i...j]中所有符合条件的子串的最后一个点，而k为以j为结尾的符合条件的最后一个起始点。只有从k+1搜索，才能保证得到的新区见[i'...j']中的j' > j，而不做无用功。

时间复杂度分析:事实上这个解法的时间复杂度分析比较复杂，虽然此法已经击败了92%的python3玩家，但是我认为在最坏的情况下，时间复杂度仍然为O(NK)，例如S = "ab"*1000, T = "ab"（比较蠢的例子哈！事实上只要加个判断就可以跳出循环了）


### 代码

```python3
class Solution:
    def minWindow(self, S: str, T: str) -> str:
        lenS = len(S)
        lenT = len(T)
        s0 = 0
        e0 = lenS

        def findleagal(start):
            # 找到从start开始的符合条件的S的最短子串，返回的为区间结束点j
            k = 0
            for i in range(start, lenS):
                if S[i] == T[k]:
                    k += 1
                if k == lenT:
                    return i
            return -1
        
        def findshortest(j):
            # 从j逆向搜索找到k
            assert S[j] == T[-1]
            k = lenT - 1
            for i in range(j , -1, -1):
                if S[i] == T[k]:
                    k -= 1
                if k == -1:
                    return i
        
        i = 0
        while i < lenS:

            j = findleagal(i)
            if j == -1:
                break
            i = findshortest(j)
            
            if  j - i + 1 < e0 - s0:
                s0 = i 
                e0 = j + 1
            i += 1


        return S[s0:e0] if e0 - s0 != lenS else ""
```