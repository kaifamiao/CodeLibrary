```
class Solution {
public:
    bool divisorGame(int N) {
        if(N==1) return false;
        vector<bool> res(N+1,false);
        for(int i=1;i<=N;++i)
        {
            for(int x=i/2;x>=1;--x)
            {
                if(i%x==0)
                {
                    if(res[i-x]==false)
                    {
                        res[i]=true;
                        break;
                    }
                }
            }
        }
        return res[N];
    }
};
```
**解释：**
爱丽丝先手,总是寻找最有可能胜利的数字x，去减N.
1、N=1,因0<x<N,找不到合适的x,爱丽丝失败。
2、N=2,爱丽丝只有x=1可选,选完后鲍勃面对的情况就是N=1,和上一条爱丽丝面对的情况相同,鲍勃失败->爱丽丝胜利。
3、N=3,爱丽丝只有x=1可选,选完后鲍勃面对的情况就是N=2,和上一条爱丽丝面对的情况相同,鲍勃胜利->爱丽丝失败。
4、N=4,爱丽丝有x=1和x=2可选：
   1）当爱丽丝选择了x=1,鲍勃面对的情况就是x=3,鲍勃会做出和爱丽丝同样的选择，他必然失败->爱丽丝胜利;
   2）当爱丽丝选择了x=2,鲍勃面对的情况就是x=2,鲍勃会做出和爱丽丝同样的选择，他必然胜利->爱丽丝失败。
在爱丽丝看来，为了取得胜利，当然要选择x=1。
5、……

按照这种思想，需要一个(N+1)长的一维数组去存储小于N的各个整数爱丽丝的胜负情况，计算结束后最终结果就是res[N]。
针对每一次迭代x的可能取值,若想N能被x整除,x的值只可能在[1,(N/2)]之间。N=N-x,将x的各种可能取值代入,若存在res[N-x]=false(也就是鲍勃必输),爱丽丝必会选择使用这个x.若所有取值都是鲍勃必赢(因为鲍勃也跟爱丽丝一样会选择最优解),爱丽丝必输。
