### 解题思路
n=1时，先走输；
n=2时，先走赢；
这些先存进dp数组里，代表子问题的最优解。

n=3之后，先走的如果想赢（爱丽丝如果想赢），就需要找到小于n的数k，能使得在符合条件（n%k==0）的基础上还能让n-k（下一局的n）是先走输。（即n-k的最优解是输，即下一局的人再怎么聪明也是输。）

即在内层循环中如果找到一个数使得if((dp[i-j]==false)&&(i%j==0)),那么该数是先走赢，一层循环走下来找不到这么一个数的话，那么该数是先走输。故只要找到一个符合条件就可以直接跳出循环了。

### 代码

```c
bool divisorGame(int N){
    bool dp[1001];

    dp[1]=false;
    dp[2]=true;

    for(int i=3;i<=N;i++)
    {
        dp[i]=false;
        for(int j=1;j<i;j++)          //内层循环，此时i即为被除数n，j为除数k
            if((dp[i-j]==false)&&(i%j==0))
            {
                dp[i]=true;
                break;
            }
    }
                 
    return dp[N];            
}

```