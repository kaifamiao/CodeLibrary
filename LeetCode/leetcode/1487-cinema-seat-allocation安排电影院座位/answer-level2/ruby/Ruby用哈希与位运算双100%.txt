执行用时 :100 ms, 在所有 Ruby 提交中击败了100.00%的用户
内存消耗 :10.9 MB, 在所有 Ruby 提交中击败了100.00%的用户

### 解题思路
被一个10^9以超时与超空间双重阻拦。
情不得已优化再优化，在失败了9次后终于AC了。
由于是在竞赛中，代码的可读性可能差一些，请多多包涵。

为了节省空间这里用了二进制位储存，被占的位置也改用哈希来存
```
reserved_seats.each do |xy|
	next if xy[1] == 1 || xy[1] == 10
	a[xy[0] - 1] += (1 << (xy[1] - 1))
end
```
先遍历reserved_seats。
只有1，3，5（图中的2，4，6）位置符合要求，因此列的原始数据为1或10的直接跳过
用二进制数的位0代表该位留空，1代表该位被占

之后遍历前面存下的哈希，key在这里用不到
如果位1~4为空，那么先能坐下一家，之后5~8还有可能坐下一家
不是上面的状况，就只能坐下最多一家，要么是3~6，要么是5~8

哈希中没有的为`n - a.size`行，每行固定可以坐下2家。
遍历哈希得到的数加上其他行的就是总数`k + 2 * (n - a.size)`。


### 代码

```ruby
def max_number_of_families(n, reserved_seats)
	a = Hash.new(0)
	reserved_seats.each do |xy|
		next if xy[1] == 1 || xy[1] == 10
		a[xy[0] - 1] += (1 << (xy[1] - 1))
	end
	k = 0
	a.each do |_,d|
		if d & 0b11110 == 0
			k += 1
			k += 1 if d & 0b111100000 == 0
			next
		end
		if d & 0b1111000 == 0
			next k += 1
		end
		k += 1 if d & 0b111100000 == 0
	end
	k + 2 * (n - a.size)
end
```