### 思路
1. 分析题意得知，首先第 1 列和第 10 列，对 4 人家庭来说没有影响，后续的处理中已全部排除掉

2. 每一行中能够安排家庭就坐，所有可能的情况只有，`2345`， `4567`， `6789` 这 3 种

3. 进一步分析，其实 `2` 和 `3` 中任一个被预定，都会导致 `2` 和 `3` 整体不能被使用
    31. 所以变成这样的状态：[23] [45] [67] [89] ，我们可以通过 $/ 2$ 来将两个座位捆绑成一个状态位
    32. 使用 `0` 代表 [23]， `1` 代表 [45]， `2` 代表 [67]， `3` 代表 [89]
    33. 3 种可以安排家庭的状态就表示为：`01`， `12`， `23`

4. 其中 `01` + `23` 没有重叠，如果都有空位，可以在一行安排 2 个家庭
    41. 反过来说，只要有任意一个位子被预定，那么就不可能容纳 2 个家庭

5. 当不可能容纳 2 个家庭时，如果 `01`， `12`， `23` 中任意一种情况有空位，还可以安排 1 个家庭
    51. 使用 `(x & 0b0011) == 0` 即可判断 `01` 状态位是否全部是空位

6. 因此，我们按照以下流程来计算
    61. 按行整理预定信息，将对应的座位转换成位状态保存
    62. 先计算 n 行最多可以容纳多少个家庭，`2 * n`
    63. 再使用整理之后的预定信息，对每一行的座位进行调整
    64. 如果有预定信息，就说明这一行不可能容纳 2 个家庭，先将预先算上的都减去 `ans -= 2;`
    65. 如果这其中能找到能容纳一个家庭的空位，再加上 1
    66. 所有预定信息处理完毕就是最终结果


### 图解
```
输入：n = 3, reservedSeats = [[1,2],[1,3],[1,8],[2,6],[3,1],[3,10]]
输出：4
```
![图片.png](https://pic.leetcode-cn.com/d94730447b30efe9128d45798e2997da1f663a8bd3cc4817f2cf26f54099a197-%E5%9B%BE%E7%89%87.png)
![图片.png](https://pic.leetcode-cn.com/836069e62e7520af47011c5d8a948ad40b35915060440cf74f0d938825f2684e-%E5%9B%BE%E7%89%87.png)



### 答题
```C++ []
int maxNumberOfFamilies(int n, vector<vector<int>>& reservedSeats)
{
    unordered_map<int, int> rsCnt;
    for (auto& rs : reservedSeats)
    {
        if (rs[1] == 10 || rs[1] == 1) continue;
        rsCnt[rs[0]] |= 1 << ((rs[1] - 2) / 2);
    }
    int ans = 2 * n;
    for (auto& p : rsCnt)
    {
        ans -= 2;
        ans += ((p.second & 0b0011) == 0 || (p.second & 0b0110) == 0 || (p.second & 0b1100) == 0);
    }
    return ans;
}
```



### 致谢

感谢您的观看，希望对您有帮助，欢迎热烈的交流！  

[我的leetcode](https://github.com/AhJo53589/leetcode-cn)

