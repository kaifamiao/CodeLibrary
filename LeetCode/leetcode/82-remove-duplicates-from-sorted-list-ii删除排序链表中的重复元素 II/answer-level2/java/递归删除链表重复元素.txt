I 问题分析：
    题目的意思是要删除有序链表中所有的重复元素，比价容易想到的两种分析方法就是
    (1) 穷举链表可能出现的情况：
        ①  1 -> null
        ②  1 -> 1 -> null
        ③  1 -> 1 -> 2 -> null
        ④  1 -> 2 -> 2 -> null
        ⑤  1 -> 1 -> 2 -> 2 -> 3 -> null
        有序链表出现的情况都在以上5类中，可能有其它变体，但是逻辑实现上我们只需要考虑这几种情况就能写出能通过测试的代码。
        对于①的情况 只需要将一开始做个判断就行

        对于②，③，④ 这三种情况，我们需要比较前后元素是否相同，并跳过重复的元素将后面的元素返回赋值给 result.next；

        对于⑤这种情况，我们需要将跳过相邻的重复的元素，将下一个不重复的元素返回赋给 result.next,这种情况的存在说明我们不能单独只看当前元素是否重复，还得看后面
        的元素是否重复，只有找到第一个不重复的元素才能添加到返回结果链中。

        考虑到第⑤中情况的存在，采用直观的解法可能会比较烧脑，我们可以考虑下使用递归的解法

    (2) 针对单独每一个元素作分析：
        上面的分析方向可能是从整体到部分，现在我们从部分到整体分析一下：
        对于每一个元素的处理，我们其实是可以按照
        ① 若当前节点和下一个节点相等，相等则跳过当前重复节点，对下一个不相等的节点做处理
        ② 若当前节点和下一个节点不相等，将当前节点添加到返回结果列表中
        ③ 若当前节点为null 或者 当前节点的下一个元素为 null, 则返回当前节点

        ①，② 两步是递归中的递的过程，③则是递归中归的过程；

        实际上，我们将删除重复节点的问题拆分成了对每一个取值的节点做检查的子问题，并按①，②的处理方式来处理每一个子问题，然后以③作为问题的边界条件。这就是问题递归解法的两个必要条件

        1) 拆分为子问题             --------  递归时"递"的过程,子问题能"递"下去的前提条件是递的过程中子问题的描述没有变
        2) 找到子问题的边界条件      --------  递归"递"到最后时遇到该条件开始"归"

II 代码实现：
    这里只给出递归代码的实现：

```
    ListNode delecteAllDuplicated(ListNode head){
        if(null == head || null == head.next) return head;

        if(head.next.val == head.val){
            while(head.next != null && head.next.val == head.val){
                head = head.next;
            }
            head = delecteAllDuplicated(head.next);
        }else{
            head.next = delecteAllDuplicated(head.next);
        }
        return head;
    }
```

