最直观的解法，利用Dfs遍历所有的可能性，复杂度为O(n!)。可以通过剪枝大大减少不必要的遍历。
剪枝1：当前交换次数已经不小于记录次数，退出
剪枝2：当前交换后，i和j位置的元素交换后，A[i]==B[i]且A[j]==B[j]，不需要遍历同层级的其他路径。
（上述解法直观易懂，但对于特性用例，剪枝策略没有效果，但好像leetcode没有构造类似用例）
