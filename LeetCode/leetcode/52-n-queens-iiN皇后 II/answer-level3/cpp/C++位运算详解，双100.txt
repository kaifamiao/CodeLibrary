
### 位运算
|符号|描述|规则|
|:-:|:-:|:-:|
&|与|1&1=1,1&0=0,0&1=0,0&0=0
`|`|或|1`|`1=1,1`|`0=1,0`|`1=1,0`|`0=0
~|取反|0变1,1变0
^|异或|1^1=0,1&0=1,0&1=1,0&0=0
<<|左移|二进制位左移若干位
>>|右移|二进制位右移若干位


**各运算的基本性质与应用**
- 与运算&：指定位清零(x&0=0)、取指定位(x&1=x)；
- 或运算`|`：指定位置1（x`|`=1）；
- 异或运算^：翻转指定位(x和1异或后变~x)，保持运算(x和0异或后还是x)；
- ~运算：使一个数的最低位为零；
- 左移运算：乘2；
- 右移运算：除以2。

**基本操作的延伸**
- 使a的最低位为0，可以表示为：`a & ~1`，1取反的值为 1111 1111 1111 1110，再进行"与"运算，最低位为0。
- `-n = ~ n + 1`(补码表示下)。
- `x & (x - 1)` 将x的最后一位 1 变成 0，`01001100 -> 01001000`
- lowbit运算：n的二进制表示中，最低的一位1，lowbit(11011000)=00001000，`-n & n`
......

### 解题思路
设标识row，ld，rd，其含义分别为：
$$row:当前行中各列是否可用 \\ ld:左斜(右上到左下方向) \\ rd:右斜(左上到右下方向) \\ 为1表示被占用$$

例子：

![8-Queens](https://pic.leetcode-cn.com/50ce24057892bbcc4bb4bef51d94bc37a262acee443aa15d2761fae7928fc967-file_1586503513486)

row，ld，rd进行“或”运算，求得所有可以放置皇后的列，对应位为0，然后再取反“与”上全1的数，此时1代表可以放，0代表不可以放。
```
pos = ~(row | ld | rd) & ((1 << n) -1)
```
接下来就继续回溯搜索，首先选择最右边可以被选择的位置，考虑到位运算`x & -x`会得到`x`最后面的1：`p = pos & -pos`
回溯的时候，考虑位运算`x & (x - 1)`会把末尾的1变0，所以`pos = pos & (pos - 1)`，这样就开始考虑下一个可放置皇后的位置。
对`row，ld，rd`状态的更新：
由于可被选择的位置用`pos`中的1表示，所以`row`的更新只需要与`p`或运算就可以了`row = row | p`。
下一行的`ld`和`rd`就是当前值与`p`或运算后向左 / 右移动一位，推得：
`ld = (ld | p) << 1 , rd = (rd | p) >> 1`

### 代码

```cpp
class Solution {
public:
    int count = 0;
    int totalNQueens(int n) {
        calNQueens(n, 0, 0, 0, 0);
        return count;
    }
    void calNQueens(int n, int r, int row, int ld, int rd) {
        if (r == n) {
            count++;
            return;
        }
        int pos = ~(row | ld | rd) & ((1 << n) - 1);
        while (pos) {// 如果pos=0,表示没有位置可放了
            int pick = (pos & -pos);
            calNQueens(n, r + 1, (row | pick), (ld | pick) << 1, (rd | pick) >> 1);
            pos &= (pos - 1);
        }
        return;
    }
};
```
### 运行结果
![result](https://pic.leetcode-cn.com/f4b4b386c0eccec6d033bae8faf94cf5e15fa68375944fa159eb6d56dfd2d86e-100.PNG)
