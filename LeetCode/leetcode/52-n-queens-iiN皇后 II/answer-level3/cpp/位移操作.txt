### 解题思路 

关于N皇后问题的位移操作参考了[@nortondark](/u/nortondark/)作者的代码

位移操作因为是**低位到高位是从右到左**，因此矩阵也遵循同样的方向
其次是当前位置放皇后后，会对 后面的列`（col）`、左下的对角`（ledown）`、右下`（ridown）`有影响
**每行或每列只能放一个**

**说明**：如何得到一个数的最低位是1 以及删除该位就不讲了

首先先看`N=4`的直观图像：
**第一行**因为开始，所以每个位置都可以放（`1`表示放有皇后）
既 `1 1 1 1`（这是我们假设的所有结果，实际分布只能选择一个）
此时我们从右往左，进入第一个放 `1` 后 进入下轮，既` 0 0 0 1`（实际分布也是 `0 0 0 1`）
进入下轮前考虑此时对下轮的影响：（只考虑对下轮影响）
列方向：`1` 对应位置的下列肯定不能放皇后，列的特性我们直接将 `0 0 0 1`投影到下行，
既第二轮的最右边不能放了（关键字 平行投影）
左下方向：从坐标上就是`[i][j]-->[i+1][j-1]`,既将 `0 0 0 1` 左移一位水平投影变成 `0 0 1 0`
（回溯自然进入下轮）
右下方向：同样的道理 `0 0 0 1` 右移`1`位水平投影变成 `0 0 0 0`；

至此考虑完了该轮对下轮的影响，进入下轮：
**第二行**
上轮的三个位数： `0 0 0 1`；`0 0 1 0`；`0 0 0 0`  将三者进行`|`操作理论得到的是放有皇后的位置：
得到的 `0 0 1 1` 表明 这轮已放有的皇后及位置（不是真有皇后，是不能放皇后了，否则冲突）；
说明这轮只能前两个位置放皇后  `~`操作：`1 1 0 0`（不是实际分布，实际分布只能选一个）
如第一轮，依次遍历这两个可以放皇后的位置
因为考虑积累，第二轮有必要讲：
第二行首先取得是 `0 1 0 0`，此时实际分布是 `0 1 1 1`（后两个`1`是上轮的影响）
对下轮的影响 ：
列方向：按道理是 直接投影为 `0 1 0 0` ，但此时还有前一轮的作用呢 ，因此应该是 
`0 1 0 0 | 0 0 0 1 `得到 `0 1 0 1` ，显然才符合
左下方向：按道理左移 `1 0 0 0`，考虑前面的作用，应该：`（0 0 1 0 | 0 1 0 0 ）<<1`;
右下同理；

### 代码

```cpp
class Solution {
public:
    int totalNQueens(int n) {
        dfs(0, 0, 0, 0, n);  
        return count;
    }
    void dfs(int row, int qCol, int ledown, int ridown, int n) {
        if (row >= n) 
            count++;
        int bits = (~(qCol | ledown | ridown)) & ((1 << n) - 1);//得到能放皇后的位置（不是实际位置）
        while (bits != 0) {//==0说明这轮没有能放皇后的地方了
            int tryBit = bits & -bits;  // 获取最低位(既该轮所有可能放皇后的位置，右到左)
            dfs(row + 1, qCol | tryBit, (ledown | tryBit) << 1, (ridown | tryBit) >> 1, n);
            bits &= bits - 1; // 该位置的皇后“利用”完后清除，下一个皇后安排上（其左边的）
        }
    }
    int count=0;
};
```