这道题如果采用暴力解法，即对每个数组元素都向后查找是否存在与它相加等于target的数，最坏情况下需要查找1/2 N^2次（N为数组长度），因此时间复杂度为O(N^2).这个时间复杂度太高了。

想要降低时间复杂度，一个常用的办法就是“**用空间换时间**”。具体到这道题，就是采用一个额外的哈希表来存储数组元素。采用哈希表可以非常快速的确定某个数值的元素是否存在，而不再需要像数组那样向后遍历比较。因为哈希表是用于存储数组元素的，所以空间复杂度为O(N).

具体实现时，可以先遍历整个数组，将所有的元素放入哈希表中，然后再遍历一遍数组查找符合条件的两个元素。这样做的时间复杂度为O(N)，但这样显然太麻烦了。其实直接遍历一遍数组即可，在遍历的过程中，每次先查找哈希表，看是否有满足条件的元素。找不到则将当前的元素加入哈希表。这样在遍历元素对中靠前面的元素时，无法知道是否存在满足条件的元素。但是遍历元素对中靠后面的元素时，因为前面已经添加了元素到哈希表，所以还是能够找到满足条件的元素对。

总的来说，这题不难，但背后“**以空间换时间**”的思想非常重要。

Python3代码如下：
```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        record = {}
        for i, num in enumerate(nums):
            complement = target - num
            if complement in record:
                return [i, record[complement]]
            else:
                record[num] = i
        return []
```
