一开始直接的想法也是暴力破解法，后来去参考官方的哈希表解法，但因为知识面不够反而踩了坑，于是跳出哈希表，只参考逻辑，总算是完成我的第一道算法题。
相当简单，解法如下：
1.实例化一个List<int>类型的集合list，然后循环nums数组，将数组元素添加到集合中(数组→集合，后续会用到集合的方法)。
2.上一个循环全部结束后，再一次循环nums数组，在循环体中定义int参数a获取target-nums元素的值。
3.对得到的a值判断其被包含在list中，并且a在list中的索引不等于当前循环的索引i(list.Contains(a) && list.IndexOf(a) != i)，满足条件则返回结果( return new int[] { list.IndexOf(a), i })，若全流程结束无结果则返回空
ps:一开始数组转集合的时候使用了linq的扩展包中的ToList方法，导致程序体积增大。
后来干脆去掉了using，自己写循环去转换，反而减轻了体积也略微加快了效率。第三步其实就是按照官方的逻辑来的。