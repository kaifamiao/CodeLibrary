![image.png](https://pic.leetcode-cn.com/b147838b9180d4fcf0be34509e3071a3e6df6c8734fcb520bf25d0f81de6cc38-image.png)

填坑了。

首先，推箱子问题算是一个非常经典的问题，基础算法就是两重宽搜，进阶算法就是一重箱子A\*和一重人best-first，和迷宫寻路都算是A\*算法的入门题。

从搜索的资料来看，目前中文网络尚未有人写出关于推箱子问题利用强连通分量的解决方案，这里也算原创了，在提交了以后去外站查看英文题解，确实前排也有人用了tarjan，不过都没我的代码快就是了。

当然，不至于没人想到，两种方法就都是图论经典算法，只是没人先写出来而已。

引入了强连通分量预处理后，可以让人寻路的复杂度降低到$O(1)$。

最快方法具体可看方法三，方法一和方法二都属于基础方法。

**方法一，朴素双款宽搜BFS：**

![image.png](https://pic.leetcode-cn.com/48c64a7ab2eca6a75104d1b28f8cac61b4c77cee5a74d1e582a5dec7ccc3be63-image.png)

按层扩展队列，并不需要在队列元素里面记录步长，除了使用复数计算外，即使不做其他优化都可以到192ms。

并不需要优先队列就可以解决，复数处理坐标省空间也很快，逻辑也最简单，时间复杂度$O({M}^{2}{N}^{2})$。

```python []
class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        #row, col为行列的大小
        row, col = len(grid), len(grid[0])
        #classify为将坐标转换成复数的分类器，转成复数可以方便计算和判断边界
        classify = collections.defaultdict(list)
        for i in range(row):
            for j in range(col):
                #按坐标转成复数
                classify[grid[i][j]].append(complex(i, j))
        #player, box, target为三个关键初始坐标，语法上用了python的解包，单元素的列表解包成单元素
        player, box, target = *classify['S'], *classify['B'], *classify['T']
        #legalFloor为合法的地面集合，包括三个关键坐标以及'.'所属的列表，多元素列表会解包成迭代器
        legalFloor = {player, box, target, *classify['.']}
        #directions是以复数表示的四个扩展方向
        directions = (1, -1, 1j, -1j)
        #人用的标准层次宽搜函数，三个参数分别为人的起始坐标，目标坐标，以及人合法的活动范围集合
        def playerBfs(begin, end, legalFloorForPlayer):
            #playerBfsSet为人的宽搜集合初始化
            playerBfsSet = {begin}
            #按层次遍历集合，中途如果遇到终点就可以返回True，反之在集合为空时返回False
            while playerBfsSet:
                #tempSet为层次遍历用的临时集合
                tempSet = set()
                #遍历宽搜集合的各个元素
                for currPlayer in playerBfsSet:
                    #遍历四个拓展方向
                    for direction in directions:
                        #nextPlayer为按方向拓展的坐标
                        nextPlayer = currPlayer + direction
                        #如果坐标合法则继续
                        if nextPlayer in legalFloorForPlayer:
                            #如果到达终点则返回True
                            if nextPlayer == end:
                                return True
                            #将下一个坐标拓展进临时集合
                            tempSet.add(nextPlayer)
                            #将下一个坐标移除合法的活动范围
                            legalFloorForPlayer.remove(nextPlayer)
                #宽搜集合层次迭代，如果tempSet为空，即没有新的层次拓展，将跳出循环
                playerBfsSet = tempSet
            return False
        #steps为箱子的推动步数，也是最终的输出
        steps = 1
        #playerBoxStateBfsSet为人和箱子的宽搜状态集合初始化
        playerBoxStateBfsSet = {(player, box)}
        #stateVisited为人和箱子的访问状态记录集合
        stateVisited = set()
        #遍历人和箱的宽搜集合
        while playerBoxStateBfsSet:
            #tempSet为层次遍历用的临时集合
            tempSet = set()
            #将状态从集合中取出，currPlayer, currBox分别代表此状态下人和箱子的坐标
            for currPlayer, currBox in playerBoxStateBfsSet:
                #遍历四个方向
                for direction in directions:
                    #nextBox为下一个箱子移动坐标
                    nextBox = currBox + direction
                    #nextPlayer为人所需要到达的下一个坐标，为箱子移动坐标的反方向
                    nextPlayer = currBox - direction
                    #如果下一个箱子坐标合法，且这个状态没被访问过，且人可以从当前坐标到达下一个所需要的坐标则继续
                    #playerBfs函数传入人的前后坐标以及合法活动范围集合，注意箱子的当前坐标不合法，需要从集合里剔除
                    if nextBox in legalFloor \
                        and (nextPlayer, currBox) not in stateVisited \
                            and playerBfs(currPlayer, nextPlayer, legalFloor - {currBox}):
                        #如果到达目标则返回所需的步数
                        if nextBox == target:
                            return steps
                        #临时集合拓展状态
                        tempSet.add((currBox, nextBox))
                        #访问状态集合进行状态记录
                        stateVisited.add((nextPlayer, currBox))
            #宽搜集合层次迭代，如果tempSet为空，即没有新的层次拓展，将跳出循环
            playerBoxStateBfsSet = tempSet
            #步数按层次累加
            steps += 1
        #如果按层次遍历完所有坐标都没有到达目标点，则返回-1
        return -1
```

**方法二，箱子用A*算法，人用best-first算法：**

![image.png](https://pic.leetcode-cn.com/e8d0a6b9f0811587e26adf593772caa484c1a4f5d8facb98a30c512131209622-image.png)

箱子用了A\*，估价函数`f`返回值里，第一比较值是取曼哈顿距离和已走步数之和，保证在箱体内搜索出步数最优值，后续比较值是box的坐标。

人用best-first算法，原理和A\*相似，只是不用考虑最短步数，只优先考虑距离终点近点的扩展。

因为复数不能在堆里直接比较，所以加了`time`和`pTime`计数器保证优先处理先进堆的元素，且不会比较到复数坐标。

A\*算法和BF算法单轮无障碍情况下不大于$O((M+N)log(M+N))$的时间，对数计算来自于堆的复杂度，单轮有障碍则是$O(MNlog(MN))$，所以总的最坏时间复杂度则是$O({{M}^{2}{N}^{2}log(MN)}^{2})$，考虑三个关键点的大多分布在地图周围，但人的行走步数拓展层次多数情况下不会很深，且由于估价函数的存在，大大提升了寻路效率，线上测试平均优化掉一半时间是符合逻辑的。

```python []
class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        m, n, g = len(grid), len(grid[0]), collections.defaultdict(list)
        for i in range(m):
            for j in range(n):
                #复数存入集合
                g[grid[i][j]] += [complex(i, j)]
        #A*算法的估价函数f，返回值为元组，第一参数是曼哈顿距离和已走的步数，第二参数是当箱子坐标到目标点的欧氏距离
        f = lambda b, s: (abs((b - target).real) + abs((b - target).imag) + s, abs(b - target))
        #关键点的初始坐标，time为防止复数比较的计数器
        player, box, target, time = *g['S'], *g['B'], *g['T'], 1
        #floor为可以行走的地面，alphaStarQueue为箱子的A*优先队列
        floor, alphaStarQueue = {player, target, box, *g['.']}, [(f(box, 1), 1, time, player, box)]
        #directions为复数表示的四个方向，visited为访问过的人箱状态，例如(player, box)这样的元素
        directions, visited = (1, -1, 1j, -1j), set()
        #最好优先算法，参数为人开始的坐标，结束的坐标，以及合法地面坐标集合
        def bestFirst(begin, end, legalFloor):
            #防止复数比较的计数器pTime
            pTime = 1
            #行走的优先队列，估价函数为当前点和目标点的距离
            playerQueue = [(abs(begin - end), pTime, begin)]
            #遍历人的优先队列
            while playerQueue:
                #取出优先队列的值，其中估价函数和计数器是队列拓展时不必要的变量
                _, __, currPlayer = heapq.heappop(playerQueue)
                #如果可以到达点就，返回True
                if currPlayer == end:
                    return True
                #按方向拓展状态
                for direction in directions:
                    nextPlayer = currPlayer + direction
                    #如果该点合法，则拓展优先队列
                    if nextPlayer in legalFloor:
                        heapq.heappush(playerQueue, (abs(nextPlayer - end), pTime, nextPlayer))
                        pTime += 1
                        #将拓展过的点从合法坐标集合中去除
                        legalFloor.remove(nextPlayer)
            return False
        #遍历箱子移动的优先队列
        while alphaStarQueue:
            #取出当前步数，人的坐标和箱子的坐标，其中估价函数和计数器是不必要的变量
            _, steps, __, currPlayer, currBox = heapq.heappop(alphaStarQueue)
            #按方向拓展当前状态
            for direction in directions:
                #nextPlayer表示达到下一个状态时所要求的人的坐标，nextBox表示成功推完箱子后的坐标
                nextPlayer, nextBox = currBox - direction, currBox + direction
                #如果下一个箱子坐标合法，且这个坐标及方向没被访问过，且人可以从当前坐标到达目标坐标，则可以拓展状态
                if nextBox in floor \
                    and (nextPlayer, currBox) not in visited \
                        and bestFirst(currPlayer, nextPlayer, floor - {currBox}):
                    #如果拓展后到达target，则返回步数
                    if nextBox == target:
                        return steps
                    heapq.heappush(alphaStarQueue, (f(nextBox, steps + 1), steps + 1, time, currBox, nextBox))
                    time += 1
                    #状态hash去重
                    visited.add((nextPlayer, currBox))
        return -1
```

**方法三、tarjan & A*算法**

![image.png](https://pic.leetcode-cn.com/cb8f4b5cb0f9480cbfc6bbb1d393f5383b5ac481eeddadb9d7b4b2ce7fbbae94-image.png)
![image.png](https://pic.leetcode-cn.com/451eda031d5eafc336957629958aa889398de97894cf3e2294cb7e2be36318af-image.png)

少见的中英文站都是双100%。

方法二的已经解释了，箱子的移动使用A\*算法是非常合适的，朝着目标优先宽搜是很快的，最优解则需要通过限定箱体来解决。

再者就是看为什么使用tarjan了，首先，我们先把地图用tarjan处理成缩点后的地图，类似于并查集的集合归属。

传统的tarjan退栈法比较有利于求割点缩点以及桥，但并不能直接像并查集一样直接求出集合归属，所以要额外处理一下。

考虑推箱子的过程中，人每次从上一个坐标，到达下一个准备推箱子坐标，则不管箱子在哪，有没有挡路，如果前后两个人的坐标属于同一个强连通分量，根据强连通分量的定义，可以保证人必然有一条路径可以到达目标点。

另外考虑到前后两个人的坐标与箱子的坐标的距离必然为`1`，如果两个点属于不同的强连通分量，说明箱子正在两个强连通分量割点上，箱子把两个强连通分量给分割开来了，则可知两个人的坐标若不在同一个强连通分量里，则在推箱子的过程中，不可相互到达。

如果箱子在割点上仍可以移动的话，则箱子在移动的过程中，人的坐标也完成了强连通分量的转移，所以即便是宽度为`1`的碎片化的强连通分量隧道，也不影响上述结论。

人移动所用到的tarjan预处理强连通分量的时间复杂度为$O(MN)$，箱子移动所用的到A*算法的时间复杂度不大于$O(MNlog(MN))$，对数计算来自于堆的复杂度，人的寻路过程为$O(1)$，综合可得总的时间复杂度为$O(MNlog(MN))$，较之前两种方法大大增强了寻路性能，复数处理算是Python的特点，其他不支持复数的语言换成对应坐标法就可以了。

```python []
class Solution:
    def minPushBox(self, grid: List[List[str]]) -> int:
        m, n, g = len(grid), len(grid[0]), collections.defaultdict(list)
        for i in range(m):
            for j in range(n):
                #分类存入复数坐标
                g[grid[i][j]] += [complex(i, j)]
        #箱子移动用的A*的估价函数，和方法二基本没区别，只是把防止复数比较的time计数器放进了估价函数里
        def f(b, s): 
            nonlocal time
            time += 1
            boxToTarget = b - target
            return (abs((boxToTarget).real) + abs((boxToTarget).imag) + s, abs(boxToTarget), time)
        #关键点的初始坐标，time为防止复数比较的计数器
        player, box, target, time = *g['S'], *g['B'], *g['T'], 1
        #floor可以行走的空白路面，语法上使用了python的解包
        floor = {player, target, box, *g['.']}
        #alphaStarQueue箱子用的A*优先队列
        alphaStarQueue = [(f(box, 1), 1, player, box)]
        #directions为复数拓展方向，visited为推箱子状态记录
        directions, visited = (1, 1j, -1, -1j), set()
        #地图坐标对应的强连通分量映射，默认都为0
        low = dict.fromkeys(floor, 0)
        #每个坐标对应的访问时间戳，和low的初始值一致
        dfn = low.copy()
        #count为tarjan算法专用的时间戳计数器
        count = 0
        #建立坐标与时间戳的映射，方便计算各个坐标所归属的强连通分量
        index = {}
        #标准无向图tarjan深度优先扩展函数，参数currIndex为当前拓展点，记录拓展的父节点防止重复拓展
        def tarjan(currIndex, parentIndex):
            nonlocal count
            #时间戳加一，记录当前访问到点的时间戳双向映射，强连通分量初始时等于自身的时间戳
            count += 1
            dfn[currIndex] = low[currIndex] = count
            index[count] = currIndex
            #拓展方向
            for direction in directions:
                nextIndex = currIndex + direction
                #如果下一个坐标nextIndex合法，且不为父节点，就进行强连通分量修改
                if nextIndex in floor and nextIndex != parentIndex:
                    #如果该节点没被访问过，就深搜扩展
                    if not low[nextIndex]:
                        tarjan(nextIndex, currIndex)
                    #如果访问过的节点时间戳比当前节点的时间戳要小，则表示属于同一个强连通分量，取较小那个
                    low[currIndex] = min(low[currIndex], low[nextIndex])
        #运行tarjan函数，初始值为box的坐标，因为坐标都在复平面第一象限，初始父节点取-1不影响计算
        tarjan(box, -1)
        #遍历坐标压缩强连通分量归属，类似于并查集的压缩路径，虽然是二重循环，但时间复杂度很低，大多数点不需要压缩
        for currIndex in floor:
            connect = [currIndex]
            #寻找时间戳等于强连通分量的点，如果不等于就加入connect列表
            while dfn[connect[-1]] != low[connect[-1]]:
                connect.append(index[low[connect[-1]]])
            #connect最后一个元素必为归属点，倒数第二个元素必直接指向归属点，所以只用遍历之前的元素
            for w in connect[: -2]:
                low[w] = low[connect[-1]]
        #遍历箱子移动状态的A*优先队列
        while alphaStarQueue:
            #估价函数为不必要的参数，取出拓展状态的步数，及人箱坐标
            _, steps, currPlayer, currBox = heapq.heappop(alphaStarQueue)
            #拓展方向
            for direction in directions:
                #nextPlayer表示达到下一个状态时所要求的人的坐标，nextBox表示成功推完箱子后的坐标
                nextPlayer, nextBox = currBox - direction, currBox + direction
                #如果下一个箱子坐标合法，且这个坐标及方向没被访问过，且人前后两个坐标属于同一个强连通分量，则可以拓展状态
                if nextBox in floor \
                    and nextPlayer in floor \
                        and (nextPlayer, currBox) not in visited \
                            and low[currPlayer] == low[nextPlayer]:
                    #如果到达目标点则输出步数
                    if nextBox == target:
                        return steps
                    #箱子的A*优先队列拓展
                    heapq.heappush(alphaStarQueue, (f(nextBox, steps + 1), steps + 1, currBox, nextBox))
                    #hash记录访问过的状态
                    visited.add((nextPlayer, currBox))
        return -1
```

其实在计算完强连通分量后可以加一个剪枝，即如果人或目标点没被计算到，则表示三个关键点不在同一个并查集里面，可以直接返回`-1`，不过估计这样的用例很少，所以写不写也无所谓：

```python []
    if not low[player] * low[target]:
        return -1
```


以测试用例里的最大数据为例：

```
grid = [
    ["#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".","#","#","#","#","#","#","#","#"],
    ["#",".",".",".","#","#",".","#","#","#","#",".","#","#","#",".","#","#","T","#"],
    ["#",".",".",".",".",".",".","#",".","#",".",".","#","#","#",".","#","#",".","#"],
    ["#",".",".",".","#",".",".",".",".",".",".",".","#","#","#",".","#","#",".","#"],
    ["#",".","#",".",".",".",".",".",".",".",".",".","#","#","#",".","#","#",".","#"],
    ["#",".","#",".","#","#","#","#","#","#","#",".","#","#","#",".","#","#",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".","B",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".",".",".",".",".",".",".",".",".","#",".",".","#"],
    ["#",".",".",".",".",".",".",".","S",".",".",".",".",".",".",".","#",".",".","#"],
    ["#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#","#"]
]
```

关于箱子的寻路处理：

1、箱子使用朴素BFS算法拓展时的访问路径及对应步数：

```
[
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##'],
    ['##','15','16','15','16','17','18','19','20','21','22','23','##','##','##','##','##','##','##','##'],
    ['##','14','15','14','##','##','17','##','##','##','##','22','##','##','##','26','##','##','29','##'],
    ['##','13','14','13','14','15','16','##','20','##','22','21','##','##','##','25','##','##','28','##'],
    ['##','12','15','12','##','18','17','18','19','20','21','20','##','##','##','24','##','##','27','##'],
    ['##','11','##','11','20','19','18','19','20','21','22','19','##','##','##','23','##','##','26','##'],
    ['##','10','##','10','##','##','##','##','##','##','##','18','##','##','##','22','##','##','25','##'],
    ['##',' 9',' 8',' 9','10','11','12','13','14','15','16','17','18','19','20','21','##','23','24','##'],
    ['##',' 8',' 7',' 8',' 9','10','11','12','13','14','15','16','17','18','19','20','##','22','23','##'],
    ['##',' 7',' 6',' 7',' 8',' 9','10','11','12','13','14','15','16','17','18','19','20','21','22','##'],
    ['##',' 6',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','15','16','17','18','##','22','23','##'],
    ['##',' 5',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','15','16','17','##','23','24','##'],
    ['##',' 4',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','15','16','##','24','25','##'],
    ['##',' 3',' 2',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','15','##','25','26','##'],
    ['##',' 2',' 1',' 2',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','##','26','27','##'],
    ['##',' 1',' 0',' 1',' 2',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','##','27','28','##'],
    ['##',' 2',' 1',' 2',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','##','28','--','##'],
    ['##',' 3',' 2',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','15','##','--','--','##'],
    ['##',' 4',' 3',' 4',' 5',' 6',' 7',' 8',' 9','10','11','12','13','14','15','16','##','--','--','##'],
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##']
]
```

2、箱子使用best-first算法拓展时的访问路径及对应步数，比A\*快，但无法获得最优解，所以只能人用，不能箱子用：

```
[
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','##','##','##','##','##','##','##','##'],
    ['##','--','--','--','##','##','--','##','##','##','##','--','##','##','##','26','##','##','31','##'],
    ['##','--','--','--','--','--','--','##','--','##','--','--','##','##','##','25','##','##','30','##'],
    ['##','--','--','--','##','--','--','--','--','--','--','--','##','##','##','24','##','##','29','##'],
    ['##','--','##','--','--','--','--','--','--','--','--','--','##','##','##','23','##','##','28','##'],
    ['##','--','##','--','##','##','##','##','##','##','##','--','##','##','##','22','##','##','27','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','19','20','21','##','--','26','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','17','18','19','20','##','--','25','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','15','16','--','--','21','22','23','24','##'],
    ['##','--','--','--','--','--','--','--','--','--','13','14','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','11','12','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--',' 9','10','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--',' 7',' 8','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--',' 5',' 6','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--',' 0',' 1',' 2',' 3',' 4','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##']
]
```

3、箱子使用标准A\*算法拓展时的访问路径及对应步数，最优解和效率取平衡：

```
[
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','##','##','##','##','##','##','##','##'],
    ['##','--','--','--','##','##','--','##','##','##','##','--','##','##','##','26','##','##','29','##'],
    ['##','--','--','--','--','--','--','##','--','##','--','--','##','##','##','25','##','##','28','##'],
    ['##','--','--','--','##','--','--','--','--','--','--','--','##','##','##','24','##','##','27','##'],
    ['##','--','##','--','--','--','--','--','--','--','--','--','##','##','##','23','##','##','26','##'],
    ['##','--','##','--','##','##','##','##','##','##','##','--','##','##','##','22','##','##','25','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','18','19','20','21','##','--','24','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','17','18','19','20','##','--','23','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','15','16','17','18','19','20','21','22','##'],
    ['##','--','--','--','--','--','--','--','--','--','13','14','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','11','12','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--',' 9','10','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--',' 7',' 8','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--',' 5',' 6','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--',' 0',' 1',' 2',' 3',' 4','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','--','--','--','--','--','--','--','--','--','--','--','--','--','--','--','##','--','--','##'],
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##']
]
```

关于人的寻路处理：

tarjan处理后对应点所属的强连通分量直观归属，同一强连通分量内，无论箱子怎么阻挡路径，人都可以直接到达目标点：

```
[
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','##','##','##','##','##','##','##'],
    ['##',' 1',' 1',' 1','##','##',' 1','##','##','##','##',' 1','##','##','##','63','##','##','54','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1','##','131','##',' 1',' 1','##','##','##','62','##','##','53','##'],
    ['##',' 1',' 1',' 1','##',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','##','##','61','##','##','52','##'],
    ['##',' 1','##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','##','##','60','##','##','51','##'],
    ['##',' 1','##',' 1','##','##','##','##','##','##','##',' 1','##','##','##','59','##','##','50','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','27','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1',' 1','##','28','28','##'],
    ['##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##','##']
]
```

如果是朴素宽搜的话，势必要把所有点都访问完了，而且在左上部分的迷宫里，人需要消耗非常多的搜索资源，无优化的宽搜这个图里人需要拓展18000+步，BF优化的也需要拓展15000+步，tarjan算法算上预处理的话不到300步，差了一个半数量级。