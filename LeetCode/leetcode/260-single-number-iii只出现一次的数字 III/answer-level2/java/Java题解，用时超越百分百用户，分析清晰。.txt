### 解题思路
#### 异或^运算
首先，介绍一下异或操作，任何一个数和0异或都是其本身，两个相同的数异或等于0，并且异或满足交换律。
我们如果做过只有一个数字出现一次，其他数字都出现两次那道题的话，对于这个特点应该很熟悉。
#### 那么这一题有两个出现一次的数字，我们该怎么办呢？
如果我们给这一组数据分组，两个出现一次的数字在不同的组内，然后组内再进行如上的异或操作，这不就满足条件了吗？可是，怎么分组呢？
#### 如何将这组数据正确的分组？
首先还是用0和该组数据异或到结束，只不过这个结果并不是出现一次的数字，而是这两个出现一次的数字的异或结果，那么我们知道异或运算的性质可以总结为"同0异1"，也就是说当前位，如果两个数相同，则为0，反之为1，这也就是说，如果我们找到这个异或结果的第一个1（从后往前），那么这两个出现一次的数字肯定这一位是不同的，又因为其他数字都出现了两次，所以他们肯定在这一位上是相同的，所以他们也肯定会被正确的分组。最后在组内各自异或到结束即可，这样我们就找到了这两个只出现一次的数字。

### 代码

```java
class Solution {
    public int[] singleNumber(int[] nums) {
        if (nums == null || nums.length == 0) {
            return new int[]{};
        }
        int first = 0;
        //异或完的结果
        for (int val : nums) {
            first ^= val;
        }
        //找到第一个二者不同的位置，也就是first中从后往前第一个1出现的位置，因为1代表着二者在这一位上是不同的
        int index = 0;
        for (int i = 0; i < nums.length; i++) {
            if ((first & (1 << i)) != 0) {
                index = i;
                break;
            }
        }
        int[] ans = new int[2];
        //根据找到的1的位置对原数组分组，并且各自进行异或
        for (int val : nums) {
            if ((val & (1 << index)) != 0) {
                ans[0] ^= val;
            } else {
                ans[1] ^= val;
            }
        }
        return ans;
    }
}
```