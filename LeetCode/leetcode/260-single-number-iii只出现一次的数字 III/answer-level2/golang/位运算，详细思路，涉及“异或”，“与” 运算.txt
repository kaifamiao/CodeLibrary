### 代码
* 时间复杂度：O(n) ,空间复杂度：O(1)
* 大致：
```golang
func singleNumber(nums []int) []int {
    tmp := 0
    //由于题目给出了，只有两个元素（假设为A和B）出现一次，其余元素出现的次数都是两次（两次划重点）
    //异或：如果两个相同的元素进行异或运算，结果必然是0
    //对数组进行异或运算循环，得出的结果必然和 A ^ B 结果一致
    //异或运算解决的问题是，先排除相同元素，找出 A和B 的联系

    for _,x := range(nums) {
        tmp ^= x
    }

    //两个不相等元素异或得出的结果，二进制中必定存在1

    //将异或后的结果和取负数进行 与 运算
    //目的：得出 A或B 结果最低位右边第一个为1的 所处位置
    //例如A=1 B=3  A(01)^B(11) = 2(10)：
    //2 & (-2) => 2(10) //最右边为1的最高位 为2(10)
    //例如A=2 B=3  A(10)^B(11) = 1(01)：
    //1 & (-1) => 1 //最右边为1的最高位 为1
    //例如A=3 B=5  A(011)^B(101) = 6(110)：
    //6 & (-6) => 2 //最右边为1的最高位 为2(10)
    
    right_mask := tmp & (-tmp)

    //拿到right_mask,再次循环数组，先判断 与 运算，why:
    //A和B 和 right_mask进行 与 运算，必定有且只有一个 等于 0  或者 不等与0
    //而其他的，由于都是成对出行，所以 进入到 if 里面的 异或运算 不会对结果造成影响
    //通俗的讲：if判断 只是为了过滤掉 A 或 B 其中一个

    res1,res2 := 0,0
    for _,y := range(nums) {
        if (right_mask & y) == 0 {
            res1 ^= y
        }
    }

    //拿到 A 或 B 的结果，也就是 res1
    //进行 异或运算  A = B & tmp  、 tmp = A ^ B 、 B = tmp ^ A 这个是公式 前提 ：A ！= B

    res2 = tmp ^ res1
    return []int{res1,res2}
}
```

```
执行用时 :4 ms, 在所有 Go 提交中击败了98.56%的用户
内存消耗 :4.2 MB, 在所有 Go 提交中击败了100.00%的用户
```