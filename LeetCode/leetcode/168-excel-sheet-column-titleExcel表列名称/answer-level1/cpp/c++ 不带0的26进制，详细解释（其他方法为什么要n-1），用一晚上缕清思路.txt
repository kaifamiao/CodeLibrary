### 解题思路
对于这道题，我的第一印象是用模运算和除法运算，求结果，我只是自己算了几个数得到的这个结论，其本质问题没弄清楚，所以导致这道题我一直解不出来。

要想彻底弄明白，首先可以先理解一些10进制转16进制的问题。
例如把22转化为16进制则为16。来看一些解题过程：
1.  X3*pow(16,2)+X2*pow(16,1)+X1*pow(16,0)=22
    这个等式，可以通过对16取模，得到X1的值。0+0+X1=6 -->X1=6   ->这部对应了取模的运算
    将X1带回去，得到：X3*pow(16,2)+X2*pow(16,1)+6=22 -->X3*pow(16,2)+X2*pow(16,1)=16
2.  为求X2的值（X2的系数为16），需要把上面得到的是等式同时整除16，得到：
    X3*pow(16,1)+X2*pow(16,0)=1 -->X3*16+X2=1
    对于这个等式，可以通过两边对16取模，X2=1；
    把X2=1带回去。得到X3*16+1=1--> X3=0(这部注意，其实X3之前还可以有好多参数，但是为了表示方便就没写)
    X3==0也是计算终止的标志。
3.  所以最后求得22的16进制为：16。
---------------------------上面是10进制转16进制----------------------------
那么对于26进制其实也是一样的，但是注意这道题A-Z的表示没有0，所以，遇到0的话要把0加上26。 
以求52的表达形式为例（其他的非特殊情况和正常进制转换一样）

1.  X3*pow(26,2)+X2*pow(26,1)+X1=52;
    首先求X1的值，两边对26取模。X1=0， 这里就要注意了因为不存在0的表示（这是这道题和普通进制的区别，普通进制满进位就用0表示，而这道题满进位用26表示），所以这里我们强制把X1+26，这样X1=26。
    把X1=26带回去， X3*pow(26,2)+X2*pow(26,1)+26=52 -->X3*pow(26,2)+X2*pow(26,1)=26;
2.  X3*pow(26,2)+X2*pow(26,1)=26; 可以根据这个等式求X2的值。
    两边除以26，令X2的系数为1。 X3*pow(26,1)+X2=1 -->X2=1;
    把X2=1带回去。 X3*16+1=1-->X3=0;
3. 所以最后52可以表示为AZ。

--------------------解释一下为什么其他方法使用n=n-1--------------------------------
仔细观察上面的方法，其实每次求得X1、X2的同时都一个向表达式回带的过程。所以才有了要减去一个结果的步骤。
但是我并不认为编程的时候要写n=n-1; 因为这不好理解，应该写 n=n-mod_(mod_为每次求得的结果，也就是X1、X2....的值，0用26表示。)
之所以n=n-1能得到正确答案，是因为利用了整除的性质。其实n-1到n-26之间的所有数都能得到正确结果，但是为了清晰理解，我用了n=n-mod_。



### 代码

```cpp
class Solution {
public:
    string convertToTitle(int n) {
        string res;
        while(n>0)
        {
            int tmp=n%26;//取得每一位的值
            if(tmp==0)//0用26代替
                tmp=26;
            n=n-tmp;//n=n-tmp，对应了每次求得值后向原表达式回带的过程。
            res.insert(0,1,'A'+tmp-1);
            n=n/26;
        }
        return res;
    }
};
```