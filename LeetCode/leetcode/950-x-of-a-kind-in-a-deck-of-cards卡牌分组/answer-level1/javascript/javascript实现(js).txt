思路：首先还是读题。

读题知道「相同的数被分在一组」，每一组除了数值相同以外，我们还关心一个属性：这个组里元素的个数，很容易想到应该统计元素个数；
那是不是统计元素然后判断都相等就好了呢，我们还需要认真看示例。
题目文字和示例 3 和告诉我们：如果检测到某个组里元素只有 1 个，可以直接返回 false。

示例 5 非常特殊，是一个很重要的示例，[2, 2, 2, 2] 硬是被拆成了 2 组，为的是与组 [1, 1] 的元素个数相等。这对应了题目「每组都有 X 张牌」 的要求。

分析到这里，相信就不难想到思路了。

1、遍历一次，统计每个数值的个数，如果某个数值只有 1 个，直接返回 false；
2、再看一下示例 5，想更一般化的情况，输入 [2, 2, 2, 2, 3, 3, 3, 3, 3, 3]，其实也是符合题意的分组，2 有 44 个，3 有 66 个，相同的 2 和 3 都需要拆成 2 个一组，因此这里的 X = 2，很显然 22 是这两个组的元素个数的公约数。

为此，我们需要对所有的数值的个数，求公约数。只要能找到任意的公约数（要严格大于 1）都可以。为此，可以从 2 开始，依次用素数去判定它是不是所有数的约数。但其实我们是有现成的算法求最大公约数的，这个最大公约数只要严格大于 11 就行。

忘了或者不知道怎么求最大公约数和如何得到所有的素数，没有关系，查资料，做笔记，我也是今天早上查的（题解最后是笔记）。让人来求最大公约数其实是很繁琐的，交给计算机来做发现简单很多。

感兴趣的朋友可以顺便看一下如何通过作图的办法，理解求解最大公约数，并且了解一下裴蜀定理（贝祖定理）。这个知识点在周赛中有出现过（次数不多），并不难理解。

```javascript
/**
 * @param {number[]} deck
 * @return {boolean}
 */
var hasGroupsSizeX = function(deck) {
    const len = deck.length;
    if (len < 2) {
        return false;
    }

    const arr = new Array(10000);
    arr.fill(0);
    for (let i = 0; i < len; i++) {
        arr[deck[i]]++;
    }
    let res = arr[deck[0]];
    for (let i = 0; i < 10000; i++) {
        if (arr[i] === 1) {
            return false;
        }
        if (arr[i] > 1) {
            res = gcd(res, arr[i]);
            if (res === 1) {
                return false;
            }
        }
    }
    return true;
};

function gcd(a, b) {
    if (b === 0) {
        return a;
    }

    return gcd(b, a % b);
}
```