
采用了加一个辅助同步栈来实现。
辅助同步：在push和pop的时候，同步维持当前主栈对应的最小值。
如果你把辅助栈理解为快照，就会比较好理解。
主栈的每一行（姑且这么理解），对应的辅助栈都有一行快照，存放这主栈每一个情况对应的最小值。
举个例子(伪代码)：



```
1,stack = new(MiniStack)
stack.Push(1)
此时
主栈               辅助栈（未存在快照）

|   |             |   |
|   |             |   |
|_1_|             |___|  
因为主栈只有一个元素，所以可以直接把当前的最小值放入辅助栈
主栈               辅助栈（未存在快照）

|   |             |   |
|   |             |   |
|_1_|             |_1_| 

2，stack.Push(2)
此时
主栈               辅助栈（未存在快照）

|   |             |   |
| 2 |             |   |
|_1_|             |_1_|  

重点在于，这时候主栈有两个元素，但辅助栈没有对应的快照，所以要生成一个存入辅助栈。
|   |             |   |
| 2 |             | 1 |
|_1_|             |_1_| 

```

