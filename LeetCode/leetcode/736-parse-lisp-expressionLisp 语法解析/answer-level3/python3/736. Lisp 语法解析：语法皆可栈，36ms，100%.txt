在右括号前面加了空格，再用空格把主字符串分离，可以单独处理表达式计算，主要思想还是栈操作。

赋值是用浅拷贝字典栈处理的，出现`let`就压入浅拷贝字典，处理完`let`就弹出栈顶字典，数据不大，空间还好，理论上可以用二分查找优化，对这题来说太麻烦了，不另写了。

表达式计算完毕从栈顶弹出时，要判断新栈顶是否是`let`关键字的栈，如果是的话，要根据新栈顶长度的奇偶性来判断是否写入字典栈的顶元素。

剩下的全都在分支里面了。

```python []
class Solution:
    def evaluate(self, expression: str) -> int:
        s = [[]]
        d = [{}]

        for e in expression.replace(')', ' )').split():
            
            if e[0] == '(':
                s += [[e[1: ]]]
                if s[-1][0] == 'let':
                    d += [d[-1].copy()]

            elif e[0] == ')':
                if s[-1][0] == 'let':
                    if s[-1][-1][0].isalpha():
                        s[-2] += [d[-1][s[-1][-1]]]
                    else:
                        s[-2] += [s[-1][-1]]
                    d.pop()
                elif s[-1][0] == 'add':
                    s[-2] += [str(int(s[-1][1]) + int(s[-1][2]))]
                elif s[-1][0] == 'mult':
                    s[-2] += [str(int(s[-1][1]) * int(s[-1][2]))]
                if s[-2][0] == 'let' and len(s[-1]) % 2:
                    d[-1][s[-2][-2]] = s[-2][-1]
                s.pop()

            elif e[0].isalpha():
                if s[-1][0] == 'let':
                    if len(s[-1]) % 2:
                        s[-1] += [e]
                    else:
                        d[-1][s[-1][-1]] = d[-1][e]
                        s[-1] += [d[-1][e]]
                else:
                    s[-1] += [d[-1][e]]

            else:
                if s[-1][0] == 'let':
                    d[-1][s[-1][-1]] = e
                s[-1] += [e]

        return s[0][0]
```

样例的栈动态过程：

```
expression: "(let x 2 (mult x (let x 3 y 4 (add x y))))"

"(let"
s: [[], ['let']]
d: [{}, {}]

"x"
s: [[], ['let', 'x']]
d: [{}, {}]

"2"
s: [[], ['let', 'x', '2']]
d: [{}, {'x': '2'}]

"(mult"
s: [[], ['let', 'x', '2'], ['mult']]
d: [{}, {'x': '2'}]

"x"
s: [[], ['let', 'x', '2'], ['mult', '2']]
d: [{}, {'x': '2'}]

"(let"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let']]
d: [{}, {'x': '2'}, {'x': '2'}]

"x"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x']]
d: [{}, {'x': '2'}, {'x': '2'}]

"3"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3']]
d: [{}, {'x': '2'}, {'x': '3'}]

"y"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3', 'y']]
d: [{}, {'x': '2'}, {'x': '3'}]

"4"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3', 'y', '4']]
d: [{}, {'x': '2'}, {'x': '3', 'y': '4'}]

"(add"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3', 'y', '4'], ['add']]
d: [{}, {'x': '2'}, {'x': '3', 'y': '4'}]

"x"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3', 'y', '4'], ['add', '3']]
d: [{}, {'x': '2'}, {'x': '3', 'y': '4'}]

"y"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3', 'y', '4'], ['add', '3', '4']]
d: [{}, {'x': '2'}, {'x': '3', 'y': '4'}]

")"
s: [[], ['let', 'x', '2'], ['mult', '2'], ['let', 'x', '3', 'y', '4', '7']]
d: [{}, {'x': '2'}, {'x': '3', 'y': '4', '4': '7'}]

")"
s: [[], ['let', 'x', '2'], ['mult', '2', '7']]
d: [{}, {'x': '2'}]

")"
s: [[], ['let', 'x', '2', '14']]
d: [{}, {'x': '2', '2': '14'}]

")"
s: [['14']]
d: [{}]

result: 14
```

36ms，仅供参考。

![image.png](https://pic.leetcode-cn.com/67f119a24ea1beec79654260e178447cc4e942a154dc41e11856e796518337e5-image.png)
![image.png](https://pic.leetcode-cn.com/44564806a3700fdf8407649bbdbff2ab7e5d9e6299f8fac84b62d2424d442296-image.png)
