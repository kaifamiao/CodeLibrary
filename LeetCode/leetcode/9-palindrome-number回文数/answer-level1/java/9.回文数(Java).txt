题目说不能用字符串解决，就想到了用逆置数字解决。
先排除掉[负数]、[末尾带0的**非零**数字] (例如10,1100,120900)，这两类显然不是回文。
然后处理其他数字，容易想到的是将数字**完全逆置**，再和原来的数字比较是否相等，**不需要考虑位数的奇偶**。
```
public static boolean isPalindrome(int x) {
	if (x < 0 || (x % 10 == 0 && x != 0))
		return false;
	
	int q = x;//保存原数字
	int p = 0;//保存逆置后的数字

	while (x != 0) {//逆置
		p = p * 10 + x % 10;
		x /= 10;
	}

	return p == q ? true : false;
}
```
考虑到回文数字的对称性，可以将回文数字的**后半段逆置**，然后与前半段比较
需要注意的是，这里要**区分**原数字**位数的奇偶**。
举个例子：
- 具有奇数位数字的12321
	- 前半段：12
	- 后半段逆置：123
- 具有偶数位数字的123321
	- 前半段：123
	- 后半段逆置：123
```
public static boolean isPalindrome(int x) {
	if (x < 0 || (x % 10 == 0 && x != 0))
		return false;
		
	int p = 0;//保存后半段逆置的数字
	while (x > p) {//逆置结束后，x保存前半段数字
		p = p * 10 + x % 10;
		x /= 10;
	}

	return (x == p || x == p / 10) ? true : false;
}
```