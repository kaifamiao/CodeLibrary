利用**数字倒置**后的结果与先前的数字进行比较
亲测：此方法比 逐个**取前后对称位**两个数字比较的数学方法 的运行更短一些

在转入参数x后，先排除**x<0**的特殊情况
由于*第一位不可能是0*，故把可以**被0整除的数字**也过滤掉
再根据将**数字反转倒置**的方法，将反转的数字与原始数字进行比较，回文数必定满足两数相等。
```
class Solution {
    public boolean isPalindrome(int x) {
        int ans = 0;
        if(x < 0 || (x%10==0 && x!=0)) return false;
        int pre = x;
        while(x != 0){
            int pop = x%10;
            x /= 10;
        	ans = ans*10 + pop;
        }
        if(ans == pre){
        	return true;
        }else{
        	return false;
        }
    }
}
```
此方法可以省去判断数字的奇偶位数的操作，易于理解和过渡更巧妙的方法，
可以想想此方法的优化：取出后半段数字进行翻转，可以省去一半的判断，
但进阶的前提，必定先把前驱方法理解后再衍生优化此方法。


