### 解题思路
应题目要求，没有将它转化成字符串来做，只能用了大量的pow（用来指数运算的函数）来算，直接的后果就是运行时间很长以及占用内存很多。
这里思路很简单：就是掐头去尾一个个比较，比如对于一个数1234321，那么首先将左右的1都取下来，怎么取呢？就是让**1234321/1000000 = 1**和**1234321%10 = 1**，然后再用**1234321-1000000得到234321**，然后**234321/10 = 23432**就完事了，然后照着这样做下去就好了。

### 代码

```C
bool isPalindrome(int x){
    if(x < 0) return false;//负数不可能是回文数；
    int len = 0, tmp = x;
    while(tmp){
        len++;
        tmp /= 10;
    }//这里用来计算这个数的长度；
    tmp = x;
    int i = 1;
    len = len-1;//这里jlen-1是为了为pow做准备的；
    while(len > 0){
        if(tmp/(int)pow(10,len) != tmp%(int)pow(10, i)) return false;//如果不相等就返回false；
        这里举个例子，比如121，那么就是121/100 ！= 121%10；
        tmp -= (tmp/(int)pow(10,len))*(int)pow(10, len); //121-100；
        tmp /= 10; //21/10
        len -= 2;;//这里为什么-2呢，因为一个数比如121，每对比一次就是少了两位变成了2；
   }
    return true;
}
```