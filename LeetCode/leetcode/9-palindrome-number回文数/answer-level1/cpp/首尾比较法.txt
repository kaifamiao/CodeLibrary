### 解题思路
法一：字符串，比较简单，但是时/空间复杂度不好；
法二：首尾比较，时/空间复杂度都很好；

### 代码

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if(x < 0)  return false;            //负数直接可以确定
        else if(x == 0) return true;       
        else if(x % 10 == 0) return false;  //若x最后一位为0，直接可以return false( 0 除外！！！)，但更重要的是
                                            //这样会导致下面构造的x, y位数不匹配（y会由于0少一位）

        int y = 0;                      //y表示从结尾往中间的数（例如 123567 中的 765）
        while(x > y){
            y = y * 10 + x % 10;
            x /= 10;                    //x表示从开头往中间的数（例如 123567 中的 123）
        }                               //结束while循环后，x <= y(例如原数为1234567，则x = 123, y = 7654)
                                        //                      (再如1234321，x = 123, y = 1234)
        return y/10 == x || y == x;     //首尾比较，若原数的位数为奇数，则构造出的y会比x高一位，
                                        //例如上面的例子 因此用 y/10
                                        //若原数的位数为偶数，则用y和x比较即可
    }
};
```