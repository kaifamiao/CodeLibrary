### 解题思路
以下是我给自己的废话大家要是看这个题解的话不用看直接看下一点就可以
先说下我的心路历程
- 本着算法的思想，我决定不用存储每位数字进行比较
- 只要计算出后半部分的数据就可以了么
- 提交 -> error
- 嗯 10 的时候出错了 因为数据是0，导致被认定为奇数个位数的回文数
- 我修改了下又提交error嗯，没错还是那个问题，我耍了小聪明
- 行吧，那我就存储下每位数据把，很遗憾又error了至于为什么我忘记了
- 我用vector跑过了如我所想时空很垃圾
- 再思考了下这不就是10的整数倍下面的思想不能用么
嗯，还是要注意代码逻辑和思路逻辑啊，写的这什么狗屎东西

### 正题
要想判断回文数字，不投机取巧（把数字转换成字符串，reverse，然后判断是否相等）咳咳别这么做哈
我们需要思考以下的问题
- 如何把数字翻转
    - 注意翻转过后可能会导致越界
- 能否不用数组存储每一位数据
    - 整数的位数对我们的判别是否有影响
    - 我们并不知道整数有多少位
    - 有哪些可以直接判别的特殊情况或者有哪些与我们的方案相悖的情况（特判）
### 整数翻转   
对整数翻转参考这篇题解[7.整数翻转](https://leetcode-cn.com/problems/reverse-integer/solution/fan-zhuan-fan-zhuan-zai-fan-zhuan-by-gtenlmenhunte/)
- **0.0版本**
- 如果我们设置整数 cmp_x 与 x比较然而翻转过后可能导致整数越界
- 一个回文数的特点是首尾对应数据相等
- 那么我们只要比较翻转后的前半段数据与未翻转前的前半段数据就可以了 
- 可以设置数组将数据的每一位数据存储下来，设置头尾指针(i, j)比较数据
    - `while (i < j && temp[i] == temp[j]) {++i;++j}` 
    - `if i<j` 存在数据不相等
- 考虑一些特殊情况
    - 如果为负数必不可能为回文数
    - 如果数字<10一定为回文数
**能否不用数组呢？**
- **1.0版本**
- 实际上我们要比较的只是后半段翻转后的数据理论上只需要一个int型变量
- 但是如何退出循环呢： 当后半段翻转后的数据 >= 剩余数据时退出循环
- 在判别的时候还要注意，当数据个数为奇数的时候，尽管是回文数，但是cmp_x > x
- 此时我们需要把多余的一位去掉`cmp_x %10 == x`此时仍然为回文数
- 判断是否为回文数`cmp_x == x || cmp_x %10 == x`
- 2.0版本
- 可以在一进入循环的时候就让当前数据*10这样取余后得到的数据就可以直接加入cmp_x中可以减少大量运算时间
### 代码
数组版本的代码快
慢且浪费空间
```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        // 前后数据一样
        // 翻转后半部分数据看是否与前面数字是否匹配
        // 全部翻转可能会溢出
        vector<int> x_bit;
        if(x<0) return false;
        else if(x<10) return true;
        while(x>0)
        {
            int pop = x%10;
            x/= 10;
            x_bit.push_back(pop);
        }
        int len = x_bit.size();
        int j = len-1; //指示最后一个元素
        int i = 0;
        while(i<j && x_bit[i] == x_bit[j]){++i;--j;}
        if(i<j) return false;
        else return true;
    }
};
```
真正应该的代码
```
```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        // 前后数据一样
        // 翻转后半部分数据看是否与前面数字是否匹配
        // 全部翻转可能会溢出
        // 如果可以被10整除尾数会一直为0
        int cmp_x = 0;
        if(x<0||(x%10 == 0&&x!=0)) return false; // x为10的整数的时候下方无法计算，x==0的话是true的
        else if(x < 10) return true;
        while(cmp_x < x)
        {
            cmp_x *= 10;
            cmp_x += x%10;
            x /= 10;
            /*int pop = x%10;
            x /= 10; // 位运算估计会更快点
            cmp_x = cmp_x * 10 + x%10; */
        }
        return cmp_x!=x && cmp_x/10 != x ? false : true;
    }
};
```
```
