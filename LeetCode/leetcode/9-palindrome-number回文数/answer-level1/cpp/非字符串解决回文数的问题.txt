### 解题思路
转化成字符串就很简单了，就不赘述了，既然不转换成字符串，那就从数字本身入手，举几个例子吧：
121
10
9
-1
12321
100001
100000
10000011
100010001
不难看出，负数肯定不是回文，个位数一定是回文，十的倍数必定不是回文。
然后我们自然可以想到字符串的比较方法，两边向中间靠拢，而对于一个数字来说，第一位是num / pow(10，位数-1)，最后一位是num%10。
所以这样可以解决121,12321,12322这样的问题。
然后再看下一个问题，1000011，这个数第一次操作是没有问题的，但是移动第一位的时候，对于int是不会存成00001的，位数直接跳到了1，这样之前的算法就无法解决了，因为对称性被破坏了。
不难发现，假设从2000012经过一次操作变成1，位数跳了5位，也就是丢失了4个0，如果这个数是回文的话，那么必定在1的后面也应该有四个0，所以我们判断一下每次取模移动第一位的时候，跳了几位数，如果大于一位数，就记录下丢失了几个零，然后从这个数的后面去数，如果没有就返回false，这样我们就能解决这道题啦。

### 代码

```cpp
class Solution {
public:
    bool isPalindrome(int x) {
        if(x<0)
            return false;
        if(x%10==0 && x!=0)
            return false;
        if(x>=0&&x<=9)      // 以上为特判
            return true;
        int idx = 1;
        while(x/(int)pow(10.0,idx)>0)  // 是几位数
            idx++;
        idx--;
        // 34543
        while(x>10&&idx>0){
            if((int)x/(int)pow(10.0,idx)!=x%10)
                return false;
            int last = x;
            x%=(int)pow(10.0,idx);  // 右移第一位
            int sub = lowbit(last)-lowbit(x);  // 求相差几位数
            x/=10;  // 左移最后一位
            if(sub>1){
                idx-=(sub-1)*2;  // 先把准备好以后要用的幂指数
                while(sub>1 && x){
                    if(x%10!=0)     // 看看丢失的0是否对称
                        return false;
                    x/=10;
                    sub--;
                }
               
            }            
            idx-=2;  // 别忘了之前移动的两位
        }
        return true;            
    }
    int lowbit(int x){
        int sum = 0;
        while(x)
            sum++,x/=10;
        return sum;
    }
};
```