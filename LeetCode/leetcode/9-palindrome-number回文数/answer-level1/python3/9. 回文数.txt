### 我的解题思路
既然不能使用字符串，这里考虑使用暴力反转的方法。
对整数求余获取整数的最后一位赋给y，将y乘10并与下一个余数相加，循环可得反转数。将得到的反转数与原数字比较即可。
在此之前，我们可以直接判断，小于0的数不是回文数。
执行用时 80ms
### 代码

```python3
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 or (x%10==0 and x!=0):
            return False
        if x == 0:
            return True
        y = 0
        while x > y:
            y = x%10 + y*10
            x = x//10
        return y==x or x==y//10


```

### 官方解题思路
同样使用求余获取整数的每一位，并使其反转。当整数的前半段和后半段相等时，该整数即为回文数。
这里的重点在于如何判断求余操作过后获得的数字为原整数的一半。
当获得的反转数大于除10取整的整数时，即可判定获得的数字为原整数的一半。
此时我们需要考虑两种情况：1)原整数为奇数位，此时由于该整数的中间数字并不影响回文，如12321中的3，当获得了后三位数字的反转数123后，对其除10即可删掉该为，与前半段的12比较。2)原整数为偶数位，此时直接比较即可。
在此之前，我们可以直接判断，小于0的数不是回文数，除0以外其他以0结尾的数也不是回文数。
- 执行用时 100ms
### 代码

```python3
class Solution:
    def isPalindrome(self, x: int) -> bool:
        if x < 0 or (x%10==0 and x!=0):
            return False
        if x == 0:
            return True
        y = 0
        while x > y:
            y = x%10 + y*10
            x = x//10
        return y==x or x==y//10


```