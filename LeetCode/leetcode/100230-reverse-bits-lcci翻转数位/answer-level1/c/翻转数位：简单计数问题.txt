### 解题思路
本题思路很直接，就是直接尝试将数字中的每一位0尝试变成1，然后统计最大值就行了
注意到每一个0位都可以找到对应的一对{x, y}值，x和y分别表示这个0左边和右边连续1的数量，可以为0.
例如：
- 111**0**11 => {3, 2}
- **0**111 => {0, 3}
- 111**0** => {3, 0}
- 11**0**0 => {2, 0}

易知，对于每个为0的数位，将其变成1后能得到的最大连续1的数量为x + y + 1。
我们也不难发现这是一遍扫描就能完成的统计。

最后说一下实现时候需要注意的细节：
1. 位运算的时候，用右移，因为最后会有一个很大的测试例，左移的话得开一个long long，显然这不够优美。
2. 跳出循环后，还需要做一次判断，以应对“0”，“1111”等这种需要最高位左边再加一个1的情况。




### 代码

```c
int reverseBits(int num){
    int max = 0;
    int cnt = 0, cntPre = 0;
    
    while(num)
    {
        if(1 & num)
        {
            cnt++;
        }
        else
        {
            if(cntPre + cnt + 1 > max) max = cntPre + cnt + 1;
            cntPre = cnt;
            cnt = 0;
        }
        num >>= 1;
    }

    if(cntPre + cnt + 1 > max) max = cntPre + cnt + 1;
    return max;
}
```

### 复杂度分析

**时间复杂度**：对于整数N来说，扫描的循环次数是log(N), 时间复杂度是log(N)
**空间复杂度**：O(1)，只用了常数个变量