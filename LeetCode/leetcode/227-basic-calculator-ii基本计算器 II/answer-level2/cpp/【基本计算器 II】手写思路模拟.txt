### 思路
1. 按照手算思路模拟实现。
	11. 从左到右读取数字和操作符。
	12. 遇到一个操作符，如果后面的操作符优先级不是更高，就把这两个数计算了。
	13. 如果后面的操作符优先级更高，那先算后面的。

2. 用一个 `stack<int> nums` 记录操作数，用 `stack<char> op` 记录操作符。

3. 顺序遍历，按顺序读取每个操作符。
	31. 空格再见。
   	32. 如果是数字，记录一下。
   	33. 如果是 $+-×÷$ ，就要开始计算了。原则是这样的。
   	* 只要上次的操作符是 $×÷$ ，那么上个操作数和当前刚拿到的第二操作数都在，直接计算这一步的结果，然后把他们出栈。
   	* 如果这一次的操作符是 $×÷$ ，那么不管上个操作数是 $+$ 还是 $-$ ，操作数和操作符都要入栈。因为优先级高。
   		* 当然如果你上个操作数是空，也要入栈。
   	* 剩下唯一一种情况，就是上个操作符是 $+-$ 了，可以取出来计算，再将结果入栈，本次的操作符也入栈。
4. 因为遇到操作符才会计算，为了在循环里一同处理，在字符串最后加个操作符 $+$ 。

5. 遍历完毕的时候，因为遇到操作符 $+$ ，会把能算的都算完，所以 `nums` 顶为计算结果。

> 觉得挺简单的，结果错了好几次，还需要修炼。
> 尤其最后那两个 if 写的也是改了好几次。 T_T


### 答题
```C++
int calculate(string s)
{
	s.append("+");
	stack<int> nums;
	stack<char> op;

	int num = 0;
	for (auto c : s)
	{
		if (isspace(c)) continue;
		if (isdigit(c))	// 取得数字
		{
			num = num * 10 + (c - '0');
			continue;
		}

		if (!op.empty() && (op.top() == '*' || op.top() == '/'))
		{
			// 先解决上一次的 */ 
			num = (op.top() == '*') ? nums.top() * num : nums.top() / num;
			nums.pop();
			op.pop();
		}

		// 这里不是 else if ，解决完上次的 */ 之后，可以继续处理这次的计算
		if (op.empty() || c == '*' || c == '/')
		{
			nums.push(num);
			op.push(c);
		}
		else
		{
			// 如果本次不是 */ ，可以把上一次的 +- 处理了
			nums.top() += (op.top() == '+') ? num : -num;
			op.top() = c;
		}
		num = 0;
	}
	return nums.top();
}
```



### 致谢
感谢您的观看，希望对您有帮助，欢迎热烈的交流！  

[我的leetcode](https://github.com/AhJo53589/leetcode-cn)