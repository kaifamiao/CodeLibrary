【中序遍历】

由于二叉搜索树是一种排序树，通过中序遍历可以按从大到小或从小到大访问节点。

我们先对[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]进行排序，结果为：
1,2,3,4,5,6,7,8

分析一下：
很容易想到，对于最大的节点8，没有比它更大的节点，因此节点的值保持不变。
比7大的有一个节点，是8，因此7+8=15。
比6大的有两个节点，分别是7和8，因此6+7+8=21。
比5大的有三个节点，分别是6、7和8，因此5+6+7+8=26。
...

通过上面的分析，我们可以总结出一个解决问题的思路：
1. 降序处理每一个节点；
2. 对于每一个节点，相当于将当前节点的值，加上前一个节点的值（更新后）。
例如节点8不变，节点7的值为7+8=15，节点6的值为6+15=21，...

因此，我们可以在倒序进行中序遍历，访问节点的时候更新节点的值。

那么，剩下的问题就是，如何获取前一个节点的值？

由于中序遍历可以保证对节点的访问是按顺序访问的，因此在每次访问节点的，记录一下最后一次访问的节点值即可。

写成代码如下：

```
    // 记录最后一次访问的节点更新后的值，初始化为0
    private int lastVal = 0;

    public TreeNode bstToGst(TreeNode root) {
        traverse(root);
        return root;
    }

    private void traverse(TreeNode root) {
        if (root == null) {
            return;
        }
        // 1.遍历右子树
        traverse(root.right);

        // 2.访问当前节点. 加上前一个节点更新后的值，更新最后一次访问的节点值
        root.val += lastVal;
        lastVal = root.val;

        // 3.遍历左子树
        traverse(root.left);
    }
```
