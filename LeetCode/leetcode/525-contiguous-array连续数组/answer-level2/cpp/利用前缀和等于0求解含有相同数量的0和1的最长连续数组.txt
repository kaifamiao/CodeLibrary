### 解题思路
1、如果把0看成-1的话，0和1的数量相等--》-1和1的数量相等--》对该区间求和，则区间和等于0； 该题转换成找区间和等于0的最长连续子数组
2、求区间和，则自然想到前缀和，区间[i, j]的区间和=f[j] - f[i-1] （f[]为前缀和数组）
3、f[j]-f[i-1] = 0---> f[j] = f[i-1], 该题进一步转成在前缀和数组f[]中找重复的值，则可以想到利用哈希来查重
4、因为要返回区间的长度，因此还需要记录数组的索引 ，因此设计哈希映射，存储前缀和以及第一次出现的下标索引
5、综合1~4，需要做如下几件事：
5.1） 遍历原数组，计算前缀和数组f[i] = f[i-1] + nums[i]（注意要将0转成成-1）;
5.2） 对于每一个前缀和f[i], 在哈希表中查重，如果是第一次碰到，则将和以及第一次的下标索引存储在哈希表中；如果是重复碰到，则计算区间长度（当前的下标索引-第一次的索引）
5.3） 当前缀和等于0的时候，也是一个符合要求的子数组，注意处理这种情况
5.4） 利用计算得到的区间的长度更新maxLength
6、在步骤5中可以看到，实际的计算过程只依赖前一个前缀和，因此，为了节省空间，不需要存储所有的前缀和，只需要一个变量来记住前一个前缀和就行了，这样空间复杂度就进一步优化了
7、复杂度：
时间复杂度：O(N), 只需要遍历数组一次， 哈希查找的效率是O(1); 
空间复杂度：O(N), 需要一个哈希表来存储

### 代码

```cpp
class Solution {
public:
    int findMaxLength(vector<int>& nums)
    {
        int maxLength = 0;
        if (nums.size() <= 1) {
            return 0;
        }

        unordered_map<int, int> sum;
        int prev = (nums[0] == 0) ? -1 : 1;
        sum[prev] = 0;
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] == 0) {
                prev -= 1;
            } else {
                prev += 1;
            }
            
            int temp;
            if (sum.count(prev) == 0) {
                sum[prev] = i;
            }

            temp = (prev == 0) ? (i + 1) : (i - sum[prev]);
            maxLength = max(maxLength, temp);
        }

        return maxLength;
    }
};
```