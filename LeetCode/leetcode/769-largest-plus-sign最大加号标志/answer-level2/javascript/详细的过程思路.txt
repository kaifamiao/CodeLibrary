```javascript
var orderOfLargestPlusSign = function(n, mines) {
  // 创建 N * N 的网格，每个格子表示最大的阶数，初始化时都为 n（n 是必然不可达到的阶数）
  const t = new Array(n).fill(0).map(() => new Array(n).fill(n));

  // 将 mines 中为 0 的格子写入值
  mines.forEach(a => t[a[0]][a[1]] = 0);

  // 遍历 第 i 行以及第 i 列
  // 对于行，将会从上到下，依次计算每行的从左以及从右的连续非 0 值
  // 对于列，将会从左到右，依次计算每列的从上以及从下的连续非 0 值
  // 完成循环时，必然将所有格子的四个方向的连续非 0 值计算了一遍
  // 并且通过每次方向得到的值，与原本格子所存的值进行比较并更新，即可得到每个格子四个方向连续非 0 值的最小值，即为该格子的最大阶数
  for (let i = 0; i < n; i++) {
    // 存放四个方向目前的连续非 0 的最大值
    let [l, r, u, d] = [0, 0, 0, 0];
    
    // l：遍历第 i 行从左到右连续非 0 的值
    // r：遍历第 i 行从右到做连续非 0 的值
    // u：遍历第 i 列从上到下连续非 0 的值
    // d：遍历第 i 列从下到上连续非 0 的值
    for (let j = 0, k = n - 1; j < n; j++, k--) {
      // 如果 遇到了 0，将对应的 l,r,u,d 重置为 0，表示连续的非 0 已经断裂，需要重新计数
      l = t[i][j] && l + 1;
      r = t[i][k] && r + 1;
      u = t[j][i] && u + 1;
      d = t[k][i] && d + 1;

      // 如果当前得到的 l,r,u,d 值比原有值小
      // 一种可能是，原本存的值是默认值
      // 另一种可能是，曾经的某个方向得到的连续非 0 长度比当前方向的连续非 0 长度大，由题意知，这里需要取较小值
      if (l < t[i][j]) t[i][j] = l;
      if (r < t[i][k]) t[i][k] = r;
      if (u < t[j][i]) t[j][i] = u;
      if (d < t[k][i]) t[k][i] = d;
    }
  }

  // 求得所有格子所存的最大值
	return Math.max(...t.map(v => Math.max(...v)));
}
```
