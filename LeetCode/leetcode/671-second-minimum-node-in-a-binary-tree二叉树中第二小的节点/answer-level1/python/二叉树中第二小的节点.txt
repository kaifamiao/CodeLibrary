##  解决方法：
####  方法一：暴力法 [通过]

**算法：**
- 通过深度优先搜索遍历树，并使用集合结构唯一性记录树中的每个唯一值。 
- 然后，我们将查看第二个最小值的记录值。第一个最小值必须是 $\text root.val$。 


**复杂度分析**

* 时间复杂度：$O(N)$。其中 $N$ 是给定树中的节点总数。我们只访问每个节点一次。
* 空间复杂度：$O(N)$，存储在 $uniques$ 中的信息。 


####  方法二：
**算法：**
- 让 $\text{min1 = root.val}$。当遍历结点 $\text{node}$，如果 $\text{node.val > min1}$，我们知道在 $\text{node}$ 处的子树中的所有值都至少是 $\text{node.val}$，因此在该子树中不此存在第二个最小值。因此，我们不需要搜索这个子树。
- 此外，由于我们只关心第二个最小值  $\text{ans}$，因此我们不需要记录任何大于当前第二个最小值的值，因此与方法 1 不同，我们可以完全不用集合存储数据。  

**复杂度分析**

* 时间复杂度：$O(N)$。其中 $N$ 是给定树中的节点总数。我们最多访问每个节点一次。 
* 空间复杂度：$O(N)$，存储在 $\text{ans}$ 和 $\text{min1}$ 中的信息为 $O(1)$，但我们的深度优先搜索可能会在调用堆栈中存储多达 $O(h) = O(N)$ 的信息，其中 $h$ 是树的高度。