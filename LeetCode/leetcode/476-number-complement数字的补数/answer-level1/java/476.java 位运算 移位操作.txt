### 解法： 位运算

```java
public int findComplement(int num) {
        int move = 0;
        int res = 0;
        while(num != 0){
            int temp = num & 1;
            if(temp == 0) res += (1 << move);
            move++;
            num >>>= 1;
        }
        return res;
    }
```

思路分析：

* 要对该数的二进制表示取反，首先需要知道每一位二进制位的数字是多少。这个做法就是常规的，用`int temp = num & 1;`得到当前位的数字。不断移位的操作也是常规的while循环和无符号右移`num >>>= 1`。

* 但是怎么将数字取反后放到合适的位置。可以看一个例子。以 110010为例子

    * ```
        第一位是0，该位取反为1   000001
        第二位是1，该位取反为0   000000
        第三位是0，该位取反为1   000100
        第四位是0，该位取反为1   001000
        第五位是1，该位取反为0   000000
        第六位是1，该位取反为0   000000
        相加                  001101 即为110010的按位取反
        ```

    * 所以我们发现，当第`i`位数字为0时，就应该将1左移`i-1`位，成为最后结果的加数之一。当然第`i`位数字为1时，取反为0，就没必要进行移位相加了（反正都是0不影响）

    * 所以我们用一个变量`move`来表示需要左移多少位。

* 注意到题目说每个数都没有前导零位，所以循环结束的标志就是`num == 0`。

* 时间复杂度为$O(n)$，空间复杂度为$O(1)$。

运行结果：

* 执行用时 :0 ms, 在所有 Java 提交中击败了100.00%的用户
* 内存消耗 :36.3 MB, 在所有 Java 提交中击败了5.33%的用户

更多LeetCode题解请看我的[github](https://github.com/ustcyyw/yyw_algorithm)，地址https://github.com/ustcyyw/yyw_algorithm。还有别的小项目也很好玩~卑微求个小星星💖