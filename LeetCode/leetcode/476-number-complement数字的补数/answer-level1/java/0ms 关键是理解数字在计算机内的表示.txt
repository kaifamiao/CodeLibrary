```
    public int findComplement(int num) {
        int t = ~num;
        int sum = 0;
        int w = 0;
        while (t != -1) {
            sum += (t & 1) << w;
            t = t >> 1;
            w++;
        }
        return sum;
    }
```
>java中的int为32位，并且是补码的形式存储
看到本题的第一眼，就想到：难道不是按位取反嘛？
但是本题有一个规定，忽略前导0，也就是说5的二进制是101，而不是0000..0 101(32位)
所以如果直接对int按位取反，得到的是111...1 010,从而是-6
而题目要求的是101三位取反，得到010，即2
--------------------
因为本题的参数是正整数，所以符号位一定是0，从而取反后的符号位一定是1，我们要做的就是把most significant的一串1，排除在外，把剩下的位的值求出来（因为那一串1就是由前导位取反的来的，而题目不考虑他们
但是我们并不知道给出的参数有多少位（当然可以按位数出来），从而不知道循环在何处终止
不过注意到，对于补码，一串的1，不管多少位，数值都是-1，所以我们可以在等于-1时停止
那么会不会在循环开始之前就是-1，从而没有能够 进入循环呢？
不会的，-1的补码表示是全1，全1取反就是全0，也就是代表参数为0，而本题给出的是正整数
综上，我们可以用-1，作为终止条件

