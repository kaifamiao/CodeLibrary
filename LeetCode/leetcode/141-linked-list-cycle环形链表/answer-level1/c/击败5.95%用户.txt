### è§£é¢˜æ€è·¯
èœé¸¡æ€è·¯ï¼Œä¸€ä¸ª`cur`å‘å‰è·‘ï¼ŒåŒæ—¶`cur_pos`è®°å½•è·‘çš„ä½ç½®ï¼Œç„¶åæ¯æ¬¡ç”¨`prev=head`ä»å¤´è·‘åˆ°`prev_pos=cur_pos-1`çœ‹æ˜¯ä¸æ˜¯å¾ªç¯ã€‚
+ basecase:ç©ºè¡¨æˆ–å•ç‹¬å¤´èŠ‚ç‚¹æ²¡æœ‰`nextåŸŸ`(è¿˜æœ‰å•ä¸ªèŠ‚ç‚¹è¿è‡ªèº«çš„æ“ä½œ)
![image.png](https://pic.leetcode-cn.com/c90da1ef2f4b1ebf3357d6eba7d56caf2ad21a1691aa2936b6fc95b0780a84e8-image.png)

### ä»£ç 

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
bool hasCycle(struct ListNode *head) {
    if (!head || !head->next) return false;  // ä¸€ä¸ªä¸€å®šæ²¡æœ‰(è¿˜æœ‰å¯èƒ½ä¸€ä¸ªæŒ‡å‘è‡ªå·±))
    struct ListNode *prev, *cur = head->next;  // curæ˜¯å­˜åœ¨çš„head!=null
    int cur_pos = 1, prev_pos;
    while (cur) {
        cur = cur->next;  // å…ˆèµ°ä¸€æ­¥
        cur_pos++;
        /* ä»å¤´å¾€åè¿½ */
        prev_pos = 0;
        prev = head;
        while (prev_pos < cur_pos) {
            if (cur == prev) return true;  // æŒ‡é’ˆç›¸ç­‰
            prev = prev->next;
            prev_pos++;
        }
    }
    return false;
}
```

æ—¶é—´å¤æ‚åº¦ï¼šåº”è¯¥æ˜¯O($n^2$)å§ï¼Œä¸ç„¶æ€ä¹ˆå¯èƒ½è¢«95%ç”¨æˆ·æ‰“è´¥ï¼ŸğŸ˜«
ç©ºé—´ï¼šO(1)