### 题解
——————
**一、理清思路：**
——————
试着想一下，如果我们要将一个字符串反转成一个新的字符串会怎样做呢？

可否：从右至左反向遍历字符串的每一个位，再重新拼接成一个字符串？

其实这种思路运用于颠倒某个数的二进制形式并生成一个新的数也同样适用。但由于**正整数**（ uint 类型）并不可以通过下标去访问其于二进制上的每一位的比特值，所以可以通过按位操作符来取得相同的效果。

**二、准备工作：**
——————
- 如何读取每一个位？

假设我们已经拥有了一个其二进制仅有一个比特位值为 **1** 的数 **C**（详见注释1）。我们可以通过按位与操作符（ **AND** ，**&**）来判断某个数（如 32 ）是否与数 **A** 共同包含值为 **1** 的比特位：**32 AND C** ，如果其结果为**零**，则说明 32 并不包含 **C** 所代表的比特位，反之则包含。

*注释1：如 2 其二进制表示为 00000010 ，或 16 表示为 00010000。*

- 如何获得一个仅有一个比特位值为 **1** 的数？

可以运用移位操作符：2 = 1 << 1，4 = 1 << 2。由此可见，我们可以通过左移位操作符来表示任何一个比特位所代表的数。

- 步骤如下

目标：颠倒数 **C** 的二进制位

（1）、通过左移位操作符获取最高位所代表的的数 **R** （最高位为 16 ，则可表示为 1 << 15）。
（2）、取得数 **B** ，其为最低位所代表的数（值为 1 ）。
（3）、判断 **C** 是否包含 **R** 所代表的比特位，如果包含则累加数 **B** （因为数 **B** 仅有一个比特位，所以加 **B** 或者按位或 **B** 的效果相同，不明白按位或的话也没关系，不用纠结）。
（4）、将 **R** 右移一位（ R >> 1 ）, **B** 左移一位（ B << 1），重复上述过程。
（5）、当 **R** 等于最低位数 1 时（准确来说是到了 R >> 1 ，R 等于 1 时），累加结果就是颠倒数 **C** 二进制位后的数。

**三、代码：**
——————
初步代码如下：
```csharp []
public uint reverseBits(uint n) 
{
    uint result = 0;
    //常量后缀 U 表示该值为 uint 类型，如果在这不进行后缀，会类型转换异常
    uint reader = (1U << 31);
    uint builder= 1;
    for(int i = 0; i < 32;i++)    
    {
        result += ((n & reader) != 0 ? builder : 0);
        reader /= 2;//也可以 reader = reader >> 1;
        builder *= 2;//也可以 builder = builder << 1;
    }
    return result;
}
```
```cpp []
uint32_t reverseBits(uint32_t n) 
{
    uint32_t result = 0;
    //这里貌似没有 C# 一般的要求
    uint32_t reader = (1 << 31);
    uint32_t builder= 1;
    for(int i = 0; i < 32;i++)    
    {
        result += ((n & reader) != 0 ? builder : 0);
        reader /= 2;//也可以 reader = reader >> 1;
        builder *= 2;//也可以 builder = builder << 1;
    }
    return result;
}
```
且不论代码质量如何，至少其已经足够清晰明了了。然而，若我们细心琢磨一下，就可以发现，用 `reader `变量来表示某一比特位所代表的数其实是多余的。我们可以直接用 `1 << (31 - i)` 来表示 `reader` 的值，`builder` 的值同理。

最终代码如下：
```csharp []
//讲真的，我很想把 reverseBits 改为 ReverseBits
public uint reverseBits(uint n) 
{
    uint result = 0;
    for(int i = 0; i < 32;i++)    
    {
        result += ((n & (1U << (31 - i))) != 0 ? 1U << i : 0);
    }
    return result;
}
```
```cpp []
uint32_t reverseBits(uint32_t n) 
{
    uint32_t result = 0;
    for(int i = 0; i < 32;i++)    
    {
        result += ((n & (1 << (31 - i))) != 0 ? 1 << i : 0);
    }
    return result;
}
```
**四、结尾**
——————
虽然题目挺简单的，但我还是写了比较多，甚至于有点啰嗦。但或许存在一些小伙伴对相关知识不那么精练……

嗯~
