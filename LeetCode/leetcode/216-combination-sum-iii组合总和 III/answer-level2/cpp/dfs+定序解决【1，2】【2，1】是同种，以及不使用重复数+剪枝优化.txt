# 处理【1，2】【2，1】是同一种的问题
**一开始想到是：数 加起来 和 乘起来 一样就说明 同，再配合哈希表**
我们想想搜索树，9^9=387 420 489=最后一层，整棵树就有2*9^9-1个结点 
7e8次循环，再加上拷贝9*9^9=9^10   ----》**TLE**
# 收获:尽量减少在dfs结束条件使用循环，
这会最后一层结点*循环次数的复杂度
然而 增加多一个形参来记录信息 也能做到同样的效果

# 实际上：
为了避免重复计数，比如 {1, 2, 3} 和 {1, 3, 2} 是同一个集合，我们对集合中的数定序，每次枚举时，要保证同一方案中的数严格递增，即如果上一个选的数是 xx，那我们从 x+1x+1 开始枚举当前数。
为什么这样可以？
我们看看这段代码
**如果选择了i，下一位就从【i+1，9】中选，所有都是如此**
这样的复杂度是：一般的搜索树的最后一层节点数量和整个搜索树的节点数的数量级是相同的，而我写的代码里搜索树的最后一层节点数量就是方案数量，因此总共的dfs执行次数和方案数是相同级别的，然后每个dfs中的计算量最多是 O(k)，因此总时间复杂度就是 O(方案数×k)。**O(Ck9×k)**
**求组合数一般要记个起始下标(图中的start)，求排列数一般每次从头开始枚举。**
处理数不重复的问题，即不会有【3，3】的**优化**
**在上面的记个起始下标就已经能控制不会有重复数了，因为选了x，下一位就从x+1开始。**
模拟以上代码，可以发现当n=9   k=3位
第一位的范围是【1， 7】   这里假设前3次dfs，即选了1 2 3 
第二位		  【2， 8】
第三位		  【3， 9】

在已经只能选1 – 9的数，又不重复，**第一位不可能从8开始，这里能理解把。。。**
**因为撑死也取不到3位，  只能8、 9两位 
所以这里是将后界缩小，假设后界和后界+1 、+2、。。。9全取**

```
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> path;

    vector<vector<int>> combinationSum3(int k, int n) {
        dfs(k, n, 1);
        return ans;
    }

    void dfs(int k, int n, int start)
    {
        if (!k)
        {
            if (!n) 
                ans.push_back(path);
            return;
        }

        for (int i = start; i <= 10 - k; i ++ )//题目说了方案的数是 没有重复 可以这样减少一下循环次数
            if (n >= i)
            {
                path.push_back(i);
                dfs(k - 1, n - i, i + 1);//i+1 定序
                path.pop_back();
            }
    }
};
```
