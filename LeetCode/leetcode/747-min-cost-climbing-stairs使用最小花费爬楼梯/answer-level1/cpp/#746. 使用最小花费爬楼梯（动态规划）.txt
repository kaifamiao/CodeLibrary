1. 假设 f(i) 代表爬到第 i 个台阶的最低消耗，则 
***f(0) = cost[0]，f(1) = cost[1]
f(k) = min(f(k-1), f(k-2)) + cost[k]***
问题问的是到楼顶的最低消耗，所以到楼顶前的最后一步可能是 f(cost.size()-1) 或者 f(cost.size()-2)
所以最后应该 `return min(f(cost.size()-1), f(cost.size()-2));`

2. 假设 i 表示 cost 数组的大小，f(i) 代表爬到楼顶的最低消耗，则
***f(2) = min(cost[0], cost[1])
f(3) = min(cost[0]+cost[2], cost[1])
f(4) = min(cost[0]+cost[2], cost[1]+cost[2], cost[1]+cost[3])
f(k) = min(f(k-2)+cost[k-1], f(k-3)+cost[k-2]+cost[k])***
由于问题与我们的假设是相符合的，所以最后只要 `return f(cost.size());`

- 为什么第二种做法得到的状态转移方程比第一种做法复杂这么多？
原因在于第二种做法的假设不好，第二种方法直接拿问题形式作为通项的意义。
假设 i 表示 cost 数组的大小，f(i) 代表爬到楼顶的最低消耗，那么爬到楼顶前的最后一步可能是 i-1 阶 或者 i-2 阶,f(1) 等于（爬到第 i-1 阶的消耗不加 cost[i] 的消耗）和（爬到 i-2 阶的消耗加 cost[i] 的消耗）两者之间较小值。但是怎么表示爬到第 i-1 阶的消耗呢，当然不是 f(i-1)，而是f(i-2)+cost[i-1]，而爬到第 i-2 阶的消耗等于f(i-3)+cost[i-2]!之所以这么绕都是因为 f 的假设不够好！

- **总结：在推导状态转移方程的时候，不要轻易得将通式 f 定义成与问题相同的形式，有时稍微转变一下 f 的定义可以得到更容易地得到更简洁的状态转移方程，最后再做一个转换得到问题的答案。**

- 更新：这道题跟 #198 打家劫舍很像，区别就本题每次可以爬 1 个阶梯或者两个阶梯，导致到楼顶只能由倒数第一块阶梯或者倒数第二块阶梯得到，这时候用第一种假设方式就很适合。而 #198 是每次跨越的步数是大于等于 2 的，所以用第二种假设方式就很适合。
