题目要求计算从第一个元素跳到最后一个元素最少的操作次数。首先容易想到的是，坐标位于最后一个元素时，结果应为0，因为不用任何操作；对于这个元素紧挨着的左右元素（此时只存在左边的元素），它的操作数是1，因为只需要跳一次就跳到了最后；同理，对于数组里值和最后一个元素相等的那些数，他们的操作数都是1。
然后，对于倒数第二个元素，它的操作数前一步已经求得为1，它右边数的结果也已经知道了，是0；它左边的数如果不等于最后一个数，那么它跟最后一个数的`距离`应为2。这里距离的意思是指操作次数，即跳两次才能到达最后一个数；同样，和倒数第二个数相等的那些元素最小的操作数也都是1+1=2.

这样，可以理解为最后一个数所在层数为`0`，第`1`层就是挨着它的元素以及值和它相等的那些数，第`2`层就是第一层挨着的元素以及值和第一层元素相等的那些数...按层次依次往上加。因为题目要求最少操作数，对于“挨着它的元素”如果前面已经求出了距离（层数），这时就不用再去算了，因为+1之后结果只会更大。例如，用一个数组`dis[]`表示每一个元素对应的最小操作数，初始化一个大数，如果对于元素`i`它左边有`dis[i-1]`等于这个大数，就表明`i-1`位置还没有求，于是`dis[i-1]=dis[i]+1`;如果`dis[i-1]`不等于这个大数就说明左边的元素前面已经算过了，就不要再去给它+1。

为了去找数组中和某一个数相等的所有元素位置，使用`HashMap`来存下所有值和相应位置（列表）的映射，可以避免一遍遍遍历这个数组去寻找。
（这时候你就可以自己动手去写了，小总结：一个数组存结果，一个Map映射和一个队列来广度优先搜索）

现在写出的代码运行那几个试例是没问题的，不过提交的时候会遇到一个满页是7，最后一个数是13的测例，可能会超时。这里还可以继续优化：对于那堆7，从倒数第二个元素开始其实就已经算出了他们的距离是[2,2,...,2,1,0],每次他都会把新出现的7放入队列，然后又遍历一遍7所在的所有位置。于是可以用一个数组`visited[]`来记录这个数是否被访问（计算）过，如果已经访问过了就没必要再去map里遍历它对应的所有位置了。


```
class Solution {
    final int MAX = Integer.MAX_VALUE;
    public int minJumps(int[] arr) {
        int n = arr.length;
        Queue<Integer> queue = new LinkedList<>();
        Map<Integer, List<Integer>> map = new HashMap<>();
        for(int i=0; i<n; i++){
            int a = arr[i];
            List<Integer> list = map.getOrDefault(a, new ArrayList<>());
            list.add(i);
            map.put(a, list);
        }
        int[] dis = new int[n]; //每个元素到最后一个元素的距离，用来存结果
        Arrays.fill(dis, MAX);
        dis[n-1] = 0;
        queue.offer(n-1);
        boolean[] visited = new boolean[n]; //记录元素是否被访问过，初始都是false
        while(!queue.isEmpty()){
            int x = queue.poll();
            if(x-1>=0 && dis[x-1]==MAX){ //等于MAX说明x左边的元素还没有计算过
                dis[x-1] = dis[x]+1;
                queue.offer(x-1);
            }
            if(x+1<n && dis[x+1]==MAX){
                dis[x+1] = dis[x]+1;
                queue.offer(x+1);
            }
            if(!visited[x]){
                for(int i: map.get(arr[x])){
                    if(dis[i] == MAX){
                        dis[i] = dis[x]+1;
                        queue.offer(i);
                        visited[i] = true;
                    }     
                }
            }         
        }
        return dis[0];
    }
}
```

因为每个元素只计算了一次，对整个数组的遍历也控制在常数次范围内，所以时间复杂度为O(n).

