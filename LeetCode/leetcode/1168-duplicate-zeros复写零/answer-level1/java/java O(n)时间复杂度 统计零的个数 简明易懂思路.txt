### 解题思路
好像看到大多是双指针之类的思路，这里分享一个自己的思路
首先本题目要求我们只能O(1)，所以我们不能借用其他的额外空间，如果暴力的话虽然思路简单，但是我们的时间复杂度会大幅上升，那我们回归到题目中，我们的最终目的是要把数组里的每个数字都放到它的最终位置上，所以这时候我们会去考虑如何在不改动数组里每个数字本来位置的情况下，去得到每个数字所存放的最终位置，再进行一次性的整体位置变动。
那么我们回归题目，我们会发现影响最终位置的变量只有0，那么我们是不是只要能统计出零的个数，就能通过很简单的加减法来计算出每个元素的最终位置

### 代码

```java
class Solution {
    public void duplicateZeros(int[] arr) {
        int count=0;
        for(int i=0;i<arr.length;i++)//统计数组里到底有几个零
        {
            if(arr[i]==0)count++;
        }
        int ptr=arr.length-1;//设置一个数组末尾的指针，从末尾开始遍历
        //从末尾遍历是防止覆盖掉有用的元素，因为元素只能往后退，不从末尾开始遍历，前面的可能会覆盖掉后面的
        while(count!=0)//开始从末尾遍历
        {
            if(arr[ptr]==0)//遍历到0数字
            {
                count--;//首先，自己不会影响自己与前面数字的最终位置，所以count要减1
                if(ptr+count<arr.length)arr[ptr+count]=0;//根据自己前面0的个数往后退，注意越界
                if(ptr+1+count<arr.length)arr[ptr+1+count]=0;//还有自己复制，也要往后退，注意越界
            }else{//遍历到非0数字时，根据它前面零的个数让它往后退，同时要注意有没有越界
                if(ptr+count<arr.length)arr[ptr+count]=arr[ptr];
            }
            ptr--;
        }
    }
}
```