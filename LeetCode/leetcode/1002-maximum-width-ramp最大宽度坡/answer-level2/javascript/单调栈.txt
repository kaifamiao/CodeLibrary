### 过程：
&emsp;&emsp;单调栈解法应该是最惊奇的O(N)时间复杂度的算法了，单调栈其实就是栈内元素以单调递增或单调递减进行存放（本题中是采用单调递减），单调栈求解由两个部分组成，一个是初始化单调栈的过程，一个是利用单调栈计算的过程。
1. 初始化单调栈
初始化过程即从序列中找到一个单调递减的子序列，比如在[6,0,8,2,1,5]中从初始位置开始的单调递减序列就是[6,0]（不连续是可以的），单调栈中把序号记录下来即[0,1]。

2. 单调栈计算
计算过程很简单，从后往前遍历，当元素比栈顶序号的元素大（或等于）时，就计算栈顶的序号（并弹出）和位置i的差值，因为我们要找到最大的两者之差（即宽度）。

### 原理：
&emsp;&emsp;单调栈中实际记录了，从后往前每个大分段“坡底”所在的序号。然后，从后往前取出每一个序号i，如果比栈顶序号j大，就说明从i到j这一整段满足“坡”的定义 $A_j \le A_i(j < i)$ ，那就继续弹出栈顶，计算下段“坡”。因为我们是采用贪心的方法，从后面（最可能出现最长宽度的情况）往前计算，所以，某个元素i“战胜”的栈顶元素越多，它的宽度也就越宽，也就越可能是一个最大宽度坡。当然，i的序号应该比ans大，因为i比ans小不可能会出现比ans大的宽度坡了，所以可以提前结束循环。

### 代码：
```javascript
var maxWidthRamp = function(A) {
    let ws = [], ans = 0;
    for(let i=0; i < A.length; ++i) {
        if(!ws.length || A[ws[ws.length - 1]] > A[i]) {
           ws.push(i);
        }
    }
    for(let i=A.length - 1; i > ans; --i) {
        while(ws.length && A[ws[ws.length - 1]] <= A[i]) {
            ans = Math.max(ans, i - ws.pop());
        } 
    }
    return ans;
};
```