# 只出现一次数字Ⅱ

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

------

（2020/03/03修订 可能有很多人不太了解卡诺图的工作原理或者对这个思路本身还有疑惑，这里我做一些细节上的解释，觉得有帮助的可以点个赞哦:)）

## 思路分析

回顾“只出现一次数字Ⅰ”

> 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了两次。找出那个只出现了一次的元素。

我们把每个数拆分到独立的二进制位考虑（不妨假设数组的数均为八位数），同时设立一个计数数组`cnt[8]`对应数的八个二进制位。遍历题干中的非空整数数组，当每个数第i个二进制位为1时，`cnt[i]++`。遍历完毕后，我们对计数数组进行模2的操作即`cnt[i] = cnt[i] % 2`,不难理解此时`cnt[i]`正好对应那个仅出现了一次数的第i个二进制位。

当然这样做只是为了直观上对题目有一个认知，在具体的实现过程中我们希望有一个操作可以隐性地实现这个模2的过程。我们先来列出状态转移方程，这里我们将`a`称作是一个记录位。

| a    | x    | new_a |
| ---- | ---- | ----- |
| 0    | 1    | 1     |
| 1    | 1    | 0     |
| 0    | 0    | 0     |
| 1    | 0    | 1     |

这个转移方程说了件啥事儿呢？它的意思是当读取的数为1时，记录位a会切换至下一个状态，读取的数为0时，记录位保持不变。而记录位的转移规律是`0->1->0->1`，两次一循环。基于这个想法，只要我们找到一个操作满足上面的操作规律，并在遍历数组的过程中依次将其中的数与记录位（初始化为0）执行上述操作，那么剩下的数一定是那个仅出现了一次的数。相较于前文中计数数组的方法，这里我们只是用状态转移的思路隐去了位数累积的过程，本质上是一致的。

接下来这个问题就转换成了——如何找到这个操作。对于这题来说，其实看到这个状态转移方程就应该一目了然了，这不就是异或操作的真值表嘛。于是结果产生

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a = 0;	//记录位
        for (auto x : nums) {
			a ^= x;
        }
        return a;
    }
};
```

回到原题，此时我们需要寻找一个能隐式表达模3含义的状态转移过程，即三次一循环。显然一个记录位已经不够描述三个状态了，因此这里我们设两个状态位来描述`00->01->10->00`的状态转移过程。

同样的写出一个状态转移矩阵

> 如图所示，这张图给出了每一个状态（由a,b,x决定）的下一个状态。

| a    | b    | x    | new_a | new_b |
| ---- | ---- | ---- | ----- | ----- |
| 0    | 0    | 1    | 0     | 1     |
| 0    | 1    | 1    | 1     | 0     |
| 1    | 0    | 1    | 0     | 0     |
| 0    | 0    | 0    | 0     | 0     |
| 0    | 1    | 0    | 0     | 1     |
| 1    | 0    | 0    | 1     | 0     |

这次似乎就没办法直接看出我们我们所需执行操作的具体形式了（当然能看出最好）

那咋办呢？此时就要祭出卡诺图了。

下面是一个关于b的卡诺图，第一排和第一列为标识状态的几个变量(a,b,x)，如果拆散开ab的话应该是个三维图表。表中的数为对应状态的下一个状态中`b`的值。



| x\ab | 00   | 01   | 11   | 10   |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 1    | 0    | X    | 0    |
| 0    | 0    | 1    | X    | 0    |

不难写出如下转移方程

`b = (x & ~a & ~b) | (~x & ~a & b) =  (b ^ x) & ~a`

再画出a的卡诺图

| x\ab | 00   | 01   | 11   | 10   |
| ---- | ---- | ---- | ---- | ---- |
| 1    | 0    | 1    | X    | 0    |
| 0    | 0    | 0    | X    | 1    |

` a = (x & b) | (~x & a)`

> 这里也许大家会有疑问，觉得状态转移方程应该写成`a = (x & ~a & b) | (~x & a & ~b)`。这里就涉及到卡诺图的一个小Trick，卡诺图中的X代表这一格对应的状态无效的，例如`(a,b,x) = (1,1,0),(1,1,1)`，因此我们在转移方程中加上对应的部分也不影响到它的正确性。如上图所示，` a = (x & ~a & b) | (~x & a & ~b) | (x & a & b) | (~x & a & b) =(x & b) | (~x & a) `。~~卡诺图中的X感觉就像***里的癞子一样~~

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int a = 0, b = 0;
        int tmp;
        for (auto x : nums) {
            tmp = b;
            b = (b ^ x) & ~a;
            a = (x & tmp) | (~x & a);
        }
        return b;
    }
};
```

由于代码的实现中，每一位的计算并不是并行进行的，所以可以通过画一个行列由a,new_b,x构成的卡诺图来利用先生成的位。

| x\a new_b | 00   | 01   | 11   | 10   |
| --------- | ---- | ---- | ---- | ---- |
| 1         | 1    | 0    | X    | 0    |
| 0         | 0    | 0    | X    | 1    |

`a = (x ^ a) & ~ new_b`

```c++
int singleNumber(vector<int>& nums) {
    int a = 0, b = 0;
    for (auto x : nums) {
        b = (b ^ x) & ~a;
        a = (a ^ x) & ~b;
    }
    return b;
}
```

