这个题其实就是求，在其他数都出现k次的数组中有一个数只出现一次，求出这个数。

而上面那个k次的是有通用解法的。

使用一个32维的数组，用这个32维的数组存储所有数里面第0位1的总数，第1位1的总数。。。第31位1的总数。

# 假如第0位1的个数是k的倍数，那么要求的这个数在该位一定是0，若不是k的倍数，那么要求的这个数在该位一定是1，第1位的1一直到第31位的1的个数同理。

为什么呢？因为假如说数组中的某些数在该位置是1，那么因为这个数要么出现k次，那么出现1次。

因此，该位置一定可以表示成k*m或者k*m+1，m代表该位是1的数的种类。

当表示成k*m的时候代表该位为1的数都是出现k次的，而当表示为k*m+1的时候代表该位为1的数还有只出现一次的。

我甚至觉得这个和“n瓶药有1瓶有毒，求最少的老鼠数来试毒”是一个原理。。。

java 代码：

```
class Solution {
    public int singleNumber(int[] nums) {
        
        int ans = 0;
        int[]temp = new int[32];
        for(int num:nums)
        {
            int r = 1;
            int j = 31;
            while(j >= 0)
            {
                if((num&r) != 0)temp[j]++;
                j--;
                r = r << 1; 
            }
        }
        int r = 1;
        int j = 31;
        
        while(j >= 0)
        {
            if(temp[j]%3 != 0)
                ans = ans ^ r;
            r = r << 1;
            j--;
        }
        
        return ans;
    }
}
```