# 137. 只出现一次的数字 II

## 题目

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。

**说明：**

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

## 例子

```java
输入: [2,2,3,2]
输出: 3

输入: [0,1,0,1,0,1,99]
输出: 99
```

## 解法

本题的解法思路与136题类似，在136题中我们使用异或运算使得相同的两个数运算的结果为0，在本题中，我们需要思考的问题是，我们是否能够定义一种运算（代替异或），使得三个数运算的结果为 0 呢？

答案是肯定的，在这里我们使用一种数字电路设计的思路来设计。

重新回到本题，我们的目标是使得三个数的运算结果为 0。你会发现三进制不计进位的加法恰好符合我们的要求：三个1相加结果为0。因此我们需要设计一个三进制的计数器。

首先，三进制需要2个bit来表示（00，01，10，11），因此我们用 `one` 和 `two` 这两个变量分别存放我们的 2 个 bit。因为我们要求的是三进制，因此我们只需要 `00`, `01`, `10` 这三个状态，首先我们列出状态转移方程：

| one | two | num | newOne | newTwo |
| --- | --- | --- | ------ | ------ |
| 0   | 0   | 1   | 0      | 1      |
| 0   | 1   | 1   | 1      | 0      |
| 1   | 0   | 1   | 0      | 0      |
| 0   | 0   | 0   | 0      | 0      |
| 0   | 1   | 0   | 0      | 1      |
| 1   | 0   | 0   | 1      | 0      |

这个表格的意思是，当下一个数的对应bit为1时，`one`和`two`的值会进入下一个状态，例如，当`one`和`two`都为`0`时，下一个数对应bit的值为`1`，那么`one`和`two`就会变为他们的下一个状态`01`，`one`，`two`会经历`00->01->10->00`的循环。

接下来，我们需要通过状态转移表来得出`newOne` 和 `one`，`two`，`num`以及`newTwo`和`one`，`two`，`num`直接的逻辑关系。为了简化这种逻辑推断的复杂度，我们使用卡诺图来做，首先画出`newOne`的卡诺图：

| num/one，two | 00  | 01  | 11  | 10  |
| ------------ | --- | --- | --- | --- |
| 0            |
| 1            |

我们先画出这样一张空表，顶排的 00，01，11，10代表one当前bit和two当前bit的真或者假，左侧的0，1代表num目前bit的真或假，根据状态转移方程填表：

| num/one，two | 00  | 01  | 11  | 10  |
| ------------ | --- | --- | --- | --- |
| 0            | 0   | 0   | X   | 1   |
| 1            | 0   | 1   | X   | 0   |

因为我们的表中没有 11 这一项（不需要）因此填入X，代表这一位的真假我们并不关心。接下来在卡诺图上画圈，画圈的具体规则是：

- 区域必须是长方形（正方形）
- 卡诺图上下左右是联通的
- 区域内只能包含1或X
- 区域的大小必须是2的幂（2，4，8……）
- 每个区域尽可能地大
- 画完后不能有1在区域外

因此我们得出的结果是：

![127.png](https://pic.leetcode-cn.com/62f4ac79ec886cb802df9e71918fa14eed23315f357a48bc3ba1c0c5c58f92c2-127.png)

然后我们便可以通过圈来得出newOne 和 one，two，num直接的逻辑关系。首先我们观察上方的圈，圈住的区域one一直为真，而two则真假都有，说明其值并不影响，同时num一直为假，因此我们得出这个圈代表的逻辑是：`one & ~num`。 同理，我们可以得出下方的圈代表的逻辑是：`two & num`, 将这些圈或起来，我们得出：`newOne = (one & ~num) | (two & num)`。使用相同的方法，我们也可以得出：`newTwo = (~one & ~two & num) | (two & ~num)`。

这样我们就创造出了我们新的运算，代码就很简单啦：

### 代码

```java
class Solution {
    public int singleNumber(int[] nums) {
        int one = 0, two = 0, temp = 0;
        for (int num : nums) {
            temp = (two & num) | (one & ~num);
            two = (~one & ~two & num) | (two & ~num);
            one = temp;
        }
        return two;
        // 这里return two的原因是第二个状态为 01，one 为 0，two 为 1
    }
}
```