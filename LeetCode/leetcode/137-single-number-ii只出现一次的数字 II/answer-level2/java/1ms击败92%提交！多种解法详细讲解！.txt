这道题和只出现一次的数字I看起来似乎是很相似的，不同之处仅仅是在于原来是出现**2**次，现在是变成了**3**次，原来有异或的运算操作，可以让`a^a=0`，如果有一个操作符号使得`a?a?a=0`，那这个问题就迎刃而解了。好像并不存在这样的运算符，那就想想其他的方法。

首先看看异或运算符的特点，`1^1=0`、`0^1=1`、`1^0=1`、`0^0=0`，联想到加法运算，`01+01=10`取低位为`0`，所以其实就是运算符左右相加去掉进位（相当于对2取模）。如果想让三个`1`相加得到`0`，那就用十进制里面的相加然后对`3`取模就可以了的。

这样对这个数组里面的每个数字二进制位的每一位相加并且最后对`3`取模，得到的就是只出现一次的数字的每一个二进制位的结果。初步想法的代码如下：

```java
public int singleNumber(int[] nums) {
    int bit;
    int res = 0;
    for (int i = 0; i < 32; i++) {
        bit = 0;
        for (int num : nums) {        // 计算第i位的1的个数
            bit += (num>>i)&1;
        }
        res |= (bit%3)<<i;        // 根据1的个数取模得到结果
    }
    return res;
}
```

这其实也是一个比较通用的解法，这里出现的次数是3次，如果换成了4次、5次也能用这个方法解决。看了很多其他人的解法，还有一个更加精妙的解法，参考[这里](https://leetcode-cn.com/problems/single-number-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--31/)。

在上面的解法里面，我们用一个`bit`来保存所有的数字的某一位的和，每个元素都是`int`类型的，但是这道题的最多的重复次数是**3**，而且我们最后需要的结果并不是这个和，而是和对3取模，所以如果能够在计算的过程中不停的取模，就能控制每一位的和**小于3**，最多2位的二进制数字就可以了，并不需要32位的`int`来保存。虽然在java里面没有一个只有2位bit的二进制数字，但是可以用两个1位的二进制数字来表示，这样整个数组用两个`int`类型的数字表示就可以了。上面解法的另外一个问题是整个数组被遍历了32遍，因为每计算一位都要遍历一遍，但是如果用两个`int`来代表的话，用适当的位操作，可以把遍历次数降低到一次！

先用`lower`和`higher`代表这个二进制数字的低位和高位，每次遇到一个二进制数字的数字的时候的变化可以用下图表示（因为遇到3取模得到0，所以不可能有`lower=1 higher=1`这种状态，只能是中间存在的一种过渡状态）。

num | higher(old) | lower(old) | higher(过渡) | lower(过渡) | mask(掩码)       | higher(new) | lower(new)
:-: | :-:         | :-:        | :-:         | :-:        |:-:          | :-:         | :-:
0   | 0           | 0          | 0           | 0          |1            | 0           | 0
0   | 0           | 1          | 0           | 1          |1            | 0           | 1
0   | 1           | 0          | 1           | 0          |1            | 1           | 0
1   | 0           | 0          | 0           |1           |1            | 0           | 1
1   | 0           | 1          | 1           |0           |1            | 1           | 0
1   | 1           | 0          | 1           |1           |0            | 0           | 0

是不是感觉有点懵逼，得到了这样的一个表格又要怎么把它变成公式呢？

首先看一下从老的状态到过渡状态，完全就是一个二进制的加法，低位的数值根据`lower`和`num`可以得到的过渡状态是`lower=lower^num`；而高位的数值需要得到低位的进位，也就是`lower&num`，然后加上原来的高位就是`higher^(lower&num)`，通过这两部就可以轻松计算出过渡状态的高位和低位。

过渡状态可以出现`higher=1 lower=1`的状态，如果是出现是4次的话，这道题就直接解决了，不用任何额外的操作就可以得到最后的新状态，但是我们这里要求的是3次，也就是当`higher=1 lower=1`的时候需要把两位同时置零，为其他的状态时就保持不变。这个时候就要用到掩码，先计算出掩码，再通过掩码把过渡状态**修正**成最终的状态。掩码时根据过渡状态的高低位决定的，如果过渡状态的高低位组成的数字达到了我们想要的阈值（这道题里面是3），掩码变成`0`，高低位同时进行`&`操作置零；没有达到的时候就是`1`，使用`&`操作相当于维持原来的值。可以看到这道题当`higher=1 lower=1`时掩码`mask=0`，其他时候`mask=1`，很熟悉的操作，这不就是`mask=~(higher&lower)`吗！这道题已经水落石出了！

最后的新状态直接用过渡状态和掩码按位与，`higher=higher&mask`和`lower=lower&mask`就到了新的值。

遍历完了整个数组之后，出现了三次的数字计算得到的`higher`和`lower`一定是0，出现了一次的数字的`higher`一定也是0，而`lower`低位就是表示的出现一次的数字的二进制位的值，所以最后得到的`lower`就是需要的返回结果。

```java
public int singleNumber(int[] nums) {
    int higher = 0, lower = 0, mask = 0;
    for (int num : nums) {
        higher = higher^(lower&num);
        lower  = num^lower;
        mask = ~(higher&lower);       // 计算掩码
        higher &=mask;
        lower &= mask;
    }
    return lower;
}
```

上面的求解过程简单点来将就是先用加法得到过渡状态，再用掩码计算出最终的新状态，对于任何出现了`k`次的数组中找到只出现了一次的数字的题目都能用，这里只有两位（一个高位，一个低位）。如果`k=5`，那么2位就不够了，需要3位数字来表示`s1`、`s2`和`s3`，而掩码的计算就变成了`mask = ~(s3&~s2&s1)`（当过渡状态为`101`的时候掩码为`0`）。

如果把上面的掩码的计算变成了`mask=~(higher&~lower)`，这段代码就可以直接放到*只出现一次的数字*这道题里面。

除了使用过渡状态，还可以使用卡诺图来直接解决新老状态转换的问题，具体的解题方法可以看这个[帖子](https://leetcode-cn.com/problems/single-number-ii/solution/li-yong-qia-nuo-tu-sheng-cheng-zhuang-tai-zhuan-yi/)。

更多内容请看我的[**个人博客**](http://sunshuyi.vip)