### 解题思路
此处撰写解题思路
这个题做的真的是一波三折，作为动态规划刚刚入门的菜鸟这里记录一下整个题的思路吧，希望能帮助像我一样的初学者能好好理解这个题。首先题目意思一定要理解透 匹配字符串中'.'表示任意一个字符（不含空字符！！！）'*'只能和它前面的字符连在一起用，可以让前面一个字符出现任意次数，0次也行。比如a*可以表示(" "或者"aaaaaaa"不管几个a都可以的).按照动态规划方法解决字符串的常规套路我们选用dp[j][i]表示匹配字符串中(0,j)的字符和目标字符串中(0,i)的字符的匹配结果，可能是true,也可能是false.
ok!相信机智的你一定在基于以上的理解上面画出了动态规划表格,假如pattern="c*a*b" s="aab";
有以下表格:
     " " a a b
" "   1  0 0 0
c     0  0 0 0
*     1  0 0 0
a     0  1 0 0
*     1  1 1 0
b     0  0 0 1
ok!!可以试着分析自己填一下这个表格。
那么整个代码的思路就是先分析第一行和第一列  。然后分析dp[j][i];
如果p[j-1]=='*'那么要想dp[j][i]==1,有两种情况
1.使得*前面的那个字符出现次数是零，也就是说在（0，j-2）已经匹配(0,i)!!! so,dp[j-2][i]==1那么一定能匹配
2.使得*前面的那个字符出现的次数大于零,那么这个时候p里面应该缺了些字符，那么这个时候假如（0，i-1）和（0，j）匹配并且p[j-2]==s[i-1]或者p[j-2]=='.'似乎能解决问题。

### 代码

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
       vector<vector<int>> arr(p.size()+1,vector<int>(s.size()+1,0));
       arr[0][0]=1;
       //初始化第一行  pattern是空字符串  
       for(int i=1;i<arr[0].size();i++)
           arr[0][i]=false;
        //初始化第一列
        for(int j=1;j<arr.size();j++)
            arr[j][0]=((j>1)&&(p[j-1]=='*')&&(arr[j-2][0]));
        for(int j=1;j<arr.size();j++)
        {
            for(int i=1;i<arr[0].size();i++)
            {
                if(p[j-1]=='*')
                {
                    arr[j][i]=(arr[j-2][i])||(arr[j][i-1]==1&&(p[j-2]==s[i-1]||p[j-2]=='.'));
                }
                else
                {
                    arr[j][i]=arr[j-1][i-1]&&(p[j-1]=='.'||p[j-1]==s[i-1]);
                }
            }
        }
    /*      for(int j=0;j<arr.size();j++)
        {
            for(int i=0;i<arr[0].size();i++)
            {
                cout<<arr[j][i]<<" ";
            }
            cout<<endl;
        }*/
        return arr[p.size()][s.size()];
    }
};
```