### 解题思路
  碰到这样的题，考虑最多就是两种。直接排完序遍历一遍就可以了。或者直接哈希记录，判断大于n/2的数字。
  但是有的时候就想找一些写起来简单，跑起来时间和空间复杂度都是差不多最低的，往往会使自己一道简单题都半天想不出。
  回归正题，这个做法和排序遍历原理上有点像。因为多数元素是保证个数大于 n/2 的。因此，多数元素的个数比其他元素的个数始终是多一个以上的。那我可以去统计每个个数去抵消后的情况，那么剩下的一个就是所要求的多数元素。这个叫做摩尔投票法。
  比如 1 2 1 3 1 是多一个 ， 1 2 1 1 1 那就是多三个了。但是本质是不会发生变化的，我只要去用多的去抵少的，就能抵完少的，剩下就是多的。

### 代码

```cpp
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int n = nums.size();
        //两个及以下不用考虑了
        if(n <= 2)return nums[0];
        //用来统计个数，也就是抵消的
        int s = 0;
        //用来标记多数元素
        int num;
        for(int i = 0 ; i < n ; i++){
            //抵消完了，就给它新的，这个数不要求是多数元素或者其他元素，因为最后都会被多数元素抵消
            if(s == 0){
                num = nums[i];
                s++;
            }
            //如果是相同的数就加一
            else if(nums[i] == num){
                s++;
            }
            //不相同就抵消元素
            else s--;
        }
        return num;
    }
};
```