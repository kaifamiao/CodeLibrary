### 解题思路
直觉上可以转化成子问题求解，用动态规划。因为：
- 1个节点的时候dp[1] = 1
- 两个节点其实就是选定1或者2为根节点的情况，dp[2] = 2
- 三个节点就是可以理解成选定一个根节点，剩下的节点为一坨，比如3的话就是右边放一坨(1,2)，1同理。但是2的时候因为要满足BST性质所以一坨要分开，且以2为分界点分为(1),(3)
- 四个节点的时候分布情况就是：`(1,2,3)4` / `(1)2(3,4)` / `(1,2)3(4)` / `(1,2,3)4`
......

- 当根节点是n或者1时，所有节点都在根节点的同一子树上，另一边子树是0个节点所以是dp[0]，其他情况都是dp[n-i-1]*dp[i]。比如n=4以2为root的可能BST就是左子树dp[1]和右子树3,4节点的dp[2]相乘
- 综上可以推出状态方程了就是`dp[n] = dp[0]dp[n-1] + dp[1]dp[n-2] + ... + dp[n-1]dp[0]`。每个乘积的索引和为n-1


### 代码

```python
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [1] * (n+1)
        i = 2
        while i <= n:
            res = 0
            for j in range(i):
                res += dp[j] * dp[i-j-1]
            dp[i] = res
            i += 1
        return dp[n]


```

- 看了题解才知道这个数是卡特兰数，通过卡特兰数的性质可以用公式一层循环解决。呃...只刷面试题所以数学推导就略了。