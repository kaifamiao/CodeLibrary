假设一共是n个节点，那么根节点是肯定有一个的。剩下的n-1个节点则要分配给根节点的左子树和右子树，那么左边可能的个数left是0,1,2,.....n-1；右边则是（n-1）- left 。能用动态规划填表的原因是，当给定个数为x的时候，这个二叉搜索树里面的数字不管是1,2,3....x还是3,4,5,....,x+3其实效果是一样的，我们只要考虑数字列的次序就可以了，它实际上是什么数字是不重要的。因此，对于1,2两个数字来说dp[2]=2；对于2,3两个数字来说dp[2]=2仍然是成立的。另外还要注意左右两边子树的可能个数是要相乘的，不是相加。

```
class Solution:
    def numTrees(self, n: int) -> int:
        dp=[0]*(n+3)
        dp[0]=1
        dp[1]=1
        dp[2]=2
        
        if n<3:
            return dp[n]
        
        for i in range(3,n+1):
            for j in range(0,i):
                left=dp[j]
                right=dp[i-1-j]
                dp[i]+=left*right
        return dp[n]
```

>执行用时 :
48 ms
, 在所有 Python3 提交中击败了
87.36%
的用户


>内存消耗 :
12.9 MB
, 在所有 Python3 提交中击败了
99.68%
的用户