对于任一n个节点的二叉树，将1到n填入二叉树中使其成为二叉搜索树只有一种填法。原因是二叉搜索树可以按节点从左到右的顺序来遍历来得到一个升序序列。
那么题目实际上要找的就是不同形态的二叉树。
对于所有包含n个节点的二叉树集合设为S，我们可以对S进行如下划分：
Si={二叉树|根节点的左子树有i个节点，右子树有n-1-i个节点的二叉树}；
S=S0∪S1U···∪Sn-1。
这样就给出了一个各个集合无交集的S的划分。
所以|S|=sum(|Si|*|Sn-1-i|),i=0,1,···,n-1。    PS：有大佬告诉我这里怎么打数学公式吗？
这样就可以用动态规划来做了，dp[i]表示有i个节点的二叉树的个数。

```C++ []
class Solution {
public:
	int numTrees(int n) {
		int* dp = new int[n + 1];
		dp[0] = 1;
		for (int i = 1; i < n + 1; i++) {
			int sum = 0;
			for (int j = 0; j < i; j++) {
				sum += dp[j] * dp[i - 1 - j];
			}
			dp[i] = sum;
		}
		return dp[n];
	}
};
```
