### 解题思路
动态规划的大体思想就是找到最后一步，比如有n个节点，并且知道前n-1，n-2,n-3,....1,0个节点能组成多少搜索树，能否用前面的结果来表示n的结果呢? 这就是动态规划的思想。我们称f[n]表示用n个节点能组成多少搜索树。
1.在有n个节点的情况下，可以选第一个节点做头，如果选第一个节点做搜索树的根的话，这个根的左子树肯定是比第一个节点小的节点，右子树是比第一个节点大的节点，所以左子树有0个节点，有f[0]种搜索树，右子树有n-1个节点，有f[n-1]种搜索树。同理，如果选第二个节点做搜索树根节点时，左子树只有第一个节点，能组成的搜索树有f[1]种，右子树有n-2个节点，能组成f[n-2]个搜索树...以此类推。
2.如果一个根节点，左子树有m种搜索树的形式，右子树有n种搜索树形式，那么这个根节点有m*n种搜索树。
3.结合1&2 得出状态转移方程 f[n]=f[0]*f[n-1]+f[1]*f[n-2]+...+f[n-1]*f[0],初始条件就是f[0]=1 (空树也是一棵树)，f[1]=1 (一个节点只有一种可能)
4.从n=2开始一直算到n就是答案。

优化思路：
第一项f[0]*f[n-1] 和 最后一项f[n-1]*f[0] 可以合并为 2*f[0]*f[n-1] 这样计算时循环的次数会减少一半
然而需要判断一下n为奇数还是偶数
奇数的话需要多加一项f[i/2]*f[i/2];

### 代码

```cpp
class Solution {
public:
    int numTrees(int n) {
        if(n<=1)    return 1;
        int f[n+1];
        f[0] = 1;
        f[1] = 1;
        for(int i=2;i<=n;++i)
        {
            f[i]=0;
            if(i%2==0)
            {
                for(int j=0;j<i/2;++j)
                    f[i]+=2*f[j]*f[i-1-j];
            }
            else
            {
                for(int j=0;j<i/2;++j)
                    f[i]+=2*f[j]*f[i-1-j];
                f[i]+=f[i/2]*f[i/2];
            }
            cout<<f[i]<<endl;
        }
        return f[n];

    }
};
```