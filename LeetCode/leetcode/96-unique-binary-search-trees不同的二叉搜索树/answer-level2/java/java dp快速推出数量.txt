### 解题思路
从95过来的，95中只考虑了所有插入的情况，但是没有考虑具体有多少种，怎么算。

如果直接复用我95题解中的方法，return list.size();
这样会报超时错误。其中还有构造树，遍历树，复制树等操作。递归较多。

**dp思路**
1. 从后往前看
2. 要求n，1~n-1的数量都已知。
3. 那么，要求n。
    - 在n中，1~n都可能是树的根，对应的根左右节点的总数也不同。
    - 比如，以n为根节点，那么他的左子孙节点的总数就是n-1,右子孙节点的总数就是0
      然后，我们就可以退出p(n)=f(n-1)，这是n中以n为根节点的树的数量。那么依次类推，我们可以推出
        f(n)=p(1)+p(2)+...+p(n))
    - 随后就是怎么出每个状态的值。比如要求p(n-5)，按照上面求n的思路我们可以推出，左子孙节点的总数，也就       是1~n中比n-5小的数量。不难推出n-6。同理右子孙节点的总数:5。
    - 我们可以这样想。他的左子树就是n-6个不同的节点组成的树，数量为f(n-6)。同理，右子树f(5)
       那么：p(n-5) = f(n-6)*f(5)。
    - 按上面的思路，求出每个根对应的数量，相加即可。

以上，速度较快，占的空间较多。

### 代码

```java
class Solution {
    public int numTrees(int n) {
        if (n<3)
            return n;
        else {
            int[] treeNum = new int[n+1];
            treeNum[0] = treeNum[1] = 1;
            treeNum[2] = 2;
            for (int i = 3;i<=n;i++){
                for (int j = 0;j<i;j++){
                    treeNum[i] += treeNum[j]*treeNum[i-j-1];
                }
            }
            return treeNum[n];
        }
    }
}
```