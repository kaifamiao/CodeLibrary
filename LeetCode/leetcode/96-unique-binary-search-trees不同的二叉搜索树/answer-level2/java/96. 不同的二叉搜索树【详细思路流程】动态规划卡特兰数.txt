思考：
    我们考虑题目，可以通过获得左右子树的结果，然后经过处理得到当前树的返回值，这种由子状态推导到当前状态的情况都可以使用动态规划来解决。动态规划最后最重要的就是找到动态转移方程。
过程：
    1、要获得以当前值为根节点的二叉树个数，如果知道了左子树和右子树的二叉树种类数 ，那我当前的结果只需要把左右可。假设函数 f(i) 表示以节点n为根的二叉树的个数。
    2、为了表达f()，我们需要定义一个函数为长度为n能够拥有多少种二叉排列树组合，假设这个函数为G(n)，则可以知道G(n) = f(1)+f(2)+...+f(n)，即可等于以任何一个节点为根节点的二叉树的个数和。
    3、同样的，我们可以推导到f(i) = 左子树的二叉树的种类数目 * 右 子树的二叉树的种类数目，
f(i) = G(i-1)*G(n-i)
    4、可以发现这个转移方程是两步进行的，合并可以得到关于G的最终的动态转移方程
G(n) = G(0)G(n-1)+G(1)G(n-1)+G(2)G(n-2)...+G(n-1)G(0);
    5、因此，实现代码需要对长度为n的数组的每一个节点进行遍历，使其为根节点，循环Index为g
        其次是遍历左右子树的长度，不断合并结果。


根据以上思路实现代码：

```
public int numTrees(int n) {
        //动态规划
        //卡特兰数
        // G(n) 表示长度为n的数组有多少种二叉排序树，其相当于以其中任何一个节点为root的二叉排序树的和，G(n) = f(1)+f(2)+....+f(n)
        // f(i) 表示以节点n为根的二叉树的个数，其相当于 左子树长度有多少种，右子树有多少种，乘一下，即排列组合,f(i) = G(i-1)*G(n-i)
        //可以看到这两个函数的互相关联的，但是实际上写代码是不能相互引用，因此需要进行一个整合
        //G(n) = f(1)+f(2)+...+f(n) = G(0)G(n-1)+G(1)G(n-1)...G(n-1)G(0),看G()函数为动态规划数组

        //设置边界值
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;

        //对于任何长度
        for (int g=3;g<=n;g++){
            //结果都是递进增加
            for (int f=1;f<=g;f++){
                dp[g] += dp[f-1]*dp[g-f];
            }
        }
        return dp[n];
    }
```
