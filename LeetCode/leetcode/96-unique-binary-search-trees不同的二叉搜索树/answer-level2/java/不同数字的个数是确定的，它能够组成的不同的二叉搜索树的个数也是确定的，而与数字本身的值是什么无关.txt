class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n+1];
        if(n<=2)return n;
        
        dp[1] = 1;
        dp[2] = 2;
        
        for(int i=3;i<=n;i++){
            dp[i] += dp[i-1] + dp[i-1];                 //-----（1）
            for(int j=2;j<i;j++){                       //-----（2）
                dp[i] += dp[j-1]*dp[i-j];               //-----（3）
            }
        }
        
        return dp[n];
    }
}

// 动态规划，时间复杂度O(n^2)),空间复杂度O(n)
// 先说初始边界状态:
// dp[1] = 1：因为只有一个数字只有一种树，就是单个根结点
// dp[2] = 2: 因为两个数字可以组合成两种二叉搜索树

// 其次先说dp[k]数组的意义，dp[k]代表着有k个不同的数字的时候可以组合成不同的二叉搜索树的个数
// 所以不要理解错了。为什么要这么设计？因为你可以想，例如，1，2，3和5，6，7虽然在数值上有不同，但是因为
// 都是3个不同的数字，因此它们各自能够组成的不同的二叉搜索树的个数是一样的，理解这一点至关重要：结论就是
// 不同的数字的个数是确定的，那么它能够组成的不同的二叉搜索树的个数也是确定的，而与数字本身的值是什么无关

// 理解了上述那一点之后，其实状态转移方程就非常地好理解了
// 先说标号(1)处，为什么这里要加两个dp[i-1],以n=3为例，那么无论是选中1作为根节点还是3作为根节点，这两种
// 情况能够组合成的不同二叉搜索树的数量都是一样的，都是2个，因为不论是把1去掉还是把3去掉，最后都是剩下两个
// 不同的数字，还记得上面的那个结论吗？如果你理解了上面那个结论，这里为什么要直接加上两个dp[i-1]就很显然啦
// 再说标号(2)处，为什么从j从2开始直到i-1，因为标号（1）处我们已经把这两种情况算完啦,其次这个遍历是尝试
// 把每一个数字都作为根节点时的情况的结果加起来
// 再说标号(3)处，状态转移方程为什么是这样？到了这里就非常显然了，因为左侧有(j-1)个不同的数，右侧有(i-j)个
// 不同的数，那么自然把j作为根节点时会有dp[j-1]*dp[i-j]种合法的二叉搜索树了
