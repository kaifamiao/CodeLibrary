### 解题思路
对于任意的元素n，我们定义G(n)表示长度为n的序列所能组成二叉树的个数
同时对于任意的1<=i<=n,我们用F(i,n)表示以i为根节点的长度为n的序列所能组成的二叉树的个数
可以看出G(n) = (i从1到n)F(i,n)的总和
同时F(i,n) = G(i-1)*G(n-i)
所以G(n) = (i从1到n的求和)G(i-1)*G(n-i)

### 代码

```java
class Solution {

    /**
     * 对于任意一个节点i
     * 它的左子树是1到i-1 和 i+1到n
     *
     * 我们定义两个函数
     * 对于任意的元素n，G(n)表示n序列的二叉搜索树的个数
     * 对于任意的n中的一个i,以i为根节点不同的二叉搜索树的个数 F(i,n)
     * 那么G(n) = i从1到n求和 F(i,n)
     * 对于F(i,n)而言  F(i,n) = G(i-1)*G(n-i) 第一项左边n-1组成的子树个数,第二项表示右边n-i组成的子树个数
     * 所以G(n) = i从1到n求和  G(i-1)*G(n-i)
     */
    public int numTrees(int n) {
            int[] G = new int[n+1];
            G[0] = 1;
            G[1] = 1;
            for(int i = 2;i<=n;i++){
                for(int j = 1;j<=i;j++){
                    G[i] += G[j-1]*G[i-j];
                }
            }
            return G[n];
    }
}
```