### 解题思路
二叉搜索树的特点是

对于树上任意一个节点，它左子树上的节点值都小于它，而它右子树上的节点值都大于它。

构造二叉搜索树时记得要遵循这条准则。

我们从最基本的情况开始看起，按照解题思路

	* 当n等于1时，就只能形成一颗单节点的二叉搜索树，因此数量是1。
	* 当n等于2时，我们有1和2两个数字可以来构造二叉搜索树，

		* 我们可以把1作为根节点，数字2作为它的右子树
		* 也可以把2作为根节点，数字1作为它的左子树
		* 因此可以构成两颗不同的二叉搜索树。
	* 当n等于3时，这个时候有1、2、3共三个数字可以使用，

		* 如果把1作为根节点，左子树上没有数字可用，而右子树有2、3两个数字可用，我们很容易就能看出2、3可以构成的二叉搜索树数量和1、2可以构成的数量是一样的，也是2颗。这个结论也很容易泛化到i个递增的数字可以构成的二叉搜索树的数量是一样的，无论这些数字是什么，我们可以用d(i)来表示这个数量

**d(i)表示i个递增的数字能构成的二叉搜索树的数量**

这样一来，当我们把1、2、3中的数字1作为根节点时，它的左子树上没有数字，于是能构成的二叉搜索树数量记为d(0),

它的右子树上有两个递增数字，可以构成二叉搜索树的数量是d(2)。

1作为根节点时总共可以形成的二叉搜索树的数量是这两个数字的乘积。也就是左右子树不同，二叉搜索树的组合。

正因如此，d(0)这个最基本的情况应该设置为数字1.而d(2)是已知的等于2.

接着我们把2作为根节点，它的左右子树各有1个节点，因此可以构成的二叉搜索树的数量是`d(1)*d(1)`,也就是1*1。

最后把3作为根节点，它的左子树有1、2两个数字可用，右子树没有数字可用，

因此总共形成的二叉搜索树的数量是`d(2)*d(0)`,也就是2*1。

最后我们就可以得到1、2、3这三个数字构成的二叉搜索树数量是所有情况之和。

也就是`d(0)*d(2)+d(1)*d(1)+d(2)*d(0) = 1*2+1*1+2*1 = 5.`

通过对1、2、3的演示，我们可以得到对于一般的数字i，1~i这i个数字可以形成的二叉搜索树的数量d(i),

等于所有d(j-1)乘以d(i-j)之和，其中j从1遍历到i。

最后我们只要返回d(n)即可。这种方法需要从d(1)计算到d(n)，总共n轮，

而每一轮中d(i)需要O(i)的时间才能计算出来，因此总的时间复杂度是O(n^2),

需要额外使用一个大小为n的数组，因此空间复杂度是O(n)

### 代码

```golang
// 动态规划 Time: o(n^2), Space: O(n)
func numTrees(n int) int {
  // 处理边界情况
  if n < 0 {
    return 0
  }
  // 定义大小为n+1的辅助数组
  d := make([]int, n+1)
  d[0] = 1 // 初始化d(0)=1
  // 接着i从1遍历到n，去计算d(i)的值
  for i := 1; i <= n; i++ {
    // j从1遍历到i，d(i)是所有d(j-1)乘以d(i-j)之和
    for j := 1; j <= i; j++ {
      d[i] += d[j-1] * d[i-j]
    }
  }
  return d[n] // 最后返回d(n)即可
}
```

### 解题思路
如果对卡特兰数比较熟悉，

![1.png](https://pic.leetcode-cn.com/86e350fcf354a9a968ecc1bb851c2ba10f8304d236a46408870104b85ac7d56a-1.png)

发现这个题目，其实就是在求第n项的卡特兰数，于是可以直接卡特兰数的通项公式进行求解。

时间复杂度是O(n)，不需要使用额外的空间，因此空间复杂度是O(1)。

### 代码

```golang
// 卡特兰数的通项公式 Time: O(n), Space: O(1)
func numTrees(n int) int {
  // 处理边界情况
  if n < 0 {
    return 0
  }
  result := 1 // 定义结果
  // 接着k从1遍历到n
  for k := 1; k <= n; k++ {
    // 套用公式，对n+k除以k进行连乘
    result = result * (n + k) / k
  }
  // 注意公式里是k从2遍历到n，因为这里涉及到整数相除
  // 不像做数学运算，我们可以把所有相乘的项都写出来，然后进行约分
  // 在这里如果前面的项相乘出现无法整除的情况，答案就会出错
  // 举个例子，只要n取奇数，k从2开始，第一项就会无法整除，
  // 让k从1开始，我们就会让result先乘上n+1,从而避免无法整除的情况，
  // 由于循环里多乘以了一个n+1,因此最后的结果还要除以n+1再返回.
  return result / (n + 1)
}
```