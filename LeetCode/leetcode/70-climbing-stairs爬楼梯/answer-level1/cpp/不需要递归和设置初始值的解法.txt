根据递推公式：
  爬到第0阶（还没走）时，走法数量f(0)=0
  爬到第1阶时，走法数量f(1)=1
  爬到第2阶时，走法数量f(2)=2(走1步\*2或走1\*2步)
  爬到第n步时的走法数量=上一步走1步前的走法数量+上一步走2步前的走法数量
  即：f(n)=f(n-1)+f(n-2)
由此可知走第n步的走法数量是n的斐波那契数，而众所周知，斐波那契数的纯递归算法是
会耗费大量不必要的时间的
因为
    f(n)=f(n-1)+f(n-2)
    =f(n-2)+f(n-3)+f(n-3)+f(n-4)
    =f(n-2)+2*f(n-3)+f(n-4)
    =...
两个分支会有大量数字的重复计算
因此可以设置一种方法，“逆向”计算斐波那契数
`class Solution {
public:
    int climbStairs(int n) {
        int a=0,b=1;
        for(int i=0;i<n;i++){
            if(i%2) a+=b;
            else b+=a;
        }
        return a+b;
    }
};`
其中变量设置为a表示初始f(0),b表示初始f(1),这里我从第0步开始计算，这和传统的斐
波那契数更相似，你也可以从第1步或第2步开始计算，a,b的初值和循环额初始值则要同
时修改。当第一次计算时，a+=b表示a从f(0)变为f(2),第二次计算，b从f(1)变为f(3)；
之所以步数需要%2是因为对于求f(n-1)和f(n)的值时有一个数字是不需要变化的就是f(n-2)
这就是“逆向”计算斐波那契时我们省去的重复计算步骤，在f(n-1)和f(n)之间，保持f(n-2)
的值不变（进入i%2的另一个分支）


