### 解题思路
因为上楼梯只有上一阶或者上两阶。上一阶的话，就是dp[n-1]再上一阶，上两阶的话就是dp[n-2]再上2阶。那就是爬上（n-1）的方法加上爬上（n-2）的方法。
那么动态规划中的状态移动方程为：dp[i] = dp[i - 2] + dp[i - 1];
注意        dp[1] = 1; dp[2] = 2; 第一阶只有一种方法，第二阶有两种方法。  跳三阶的方法就是：跳第一阶再跨两阶（即dp[1]），或者跳到第二阶再跨一阶(即dp[2]),那么跳三阶楼梯的方法有这么多中：dp[1]+dp[2]。
用dp[i]记录之前跳到第i阶楼梯的方法和，比起递归可以降低时间复杂度。

### 代码

```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n+1);
        if (n == 0) return 0;
        if (n == 1) return 1;
        if (n == 2) return 2;
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++)
        {
            dp[i] = dp[i - 2] + dp[i - 1];
        }
        if(n>=3)
        {
            return dp[n];
        }
        return 0;
    }
};
```
执行结果：
    通过 显示详情
执行用时 :
    0 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗 :
    7.9 MB, 在所有 C++ 提交中击败了99.95%的用户