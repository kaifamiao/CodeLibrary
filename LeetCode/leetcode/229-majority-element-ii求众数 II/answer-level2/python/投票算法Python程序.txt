### 解题思路
我看解题基本上没有Python代码就写个Python的解题吧，代码是真心烂，但是主体思维还是投票算法，由于楼主是学生，这里就按照学生的思维写攻略了。

首先先来了解下投票算法，这里举一个简单点的例子，我们来选出超过1/2数组长度个数的元素。
我们先一点点一点点的分析，我们要知道，超过1/2数组长度个数的元素肯定至多只有一个，那么我们设置一个计数器，如果遇到这个元素就加一，如果没有遇到就减一，由于这个元素的个数超过了1/2数组长度，所以加一的情况肯定大于减一的情况，因此我们的计数器最后一定是正的，这就如同是投票一样，所以，我们知道，采取这种方式计数，对于计数元素是超过1/2数组长度个数的元素的情况下，计数器最后一定是正数(如果是严格超过，这里计数器甚至不可能是0)
然后我们看看如果我们计数的对象是小于1/2数组元素个数的元素呢？那么减一的情况肯定大于加一的情况，所以最终我的计数器的值一定是负的。
所以，我们会想，能不能用x组计数器来记录每个不同的元素，最后看哪个计数器的值大于0能？当然可以，但是这样一来，我的空间复杂度就不是o(1)了呀，有没有更好的办法呢？当然有，就是我们最开始提到的，元素个数超过1/2数组长度的元素最多只有1个啊，那么我们干脆把元素全部归为元素个数大于1/2数组长度的元素和元素个数小于1/2数组长度的元素吧，我们稍微修改一下上面的算法：
1.设置一个计数器count=0和一个计数对象cond=None
2.我们开始遍历数组
3.如果我的count=0，那么遍历的这个元素就是我的计数对象，同时我的count+=1，并且跳过下面的步骤继续遍历
4.如果遇到的是cond，那么计数器+1，否则-1

反应较快的小伙伴应该看出来了，这样做就能只用一组计数器就能找出元素个数>1/2数组长度的元素了
没看出来也不要紧，这里解释一下：
我们分析两种情况，1.如果我一开始遍历的时候就是元素个数大于1/2数组长度的元素，在这种情况下经过我们最开始的分析，加一的情况要大于减一的情况，因此最后一定是正的，这就相当于一个该元素可以抵消一个元素个数小于1/2数组长度的元素的情况下，我最后留下的肯定是该元素。
2.如果我们一开始遍历的元素是元素个数小于1/2数组长度的元素，那么，由于该元素数目较少，因此总存在一个点是的count=0，这时开始记录元素个数大于1/2数组长度的元素，因为之前的count是正的，因此在该点之前，一定有元素个数大于1/2数组长度的元素的个数<元素个数小于1/2数组长度的元素的个数，那么在该点以后，一定存在一定有元素个数大于1/2数组长度的元素的个数>元素个数小于1/2数组长度的元素的个数，那么从该点开始遍历就变成了情况1

当然，你说上面写得那么复杂没有看懂，没关系，上面是为了贴合程序写的思路，这里有一种简单的理解方法：
我们计：元素个数大于1/2数组长度的元素为a，元素个数小于1/2数组长度的元素为b
那么我们假设数组为[a,b,a,b,a,b,a,b.....a,a,a,a,a]，即存在一个点i，使得i之前的元素按照a,b,a,b...的顺序排列，i之后的元素按照a,a,a...的顺序排列，因此再应用刚刚的算法，一定能够计数出元素个数大于1/2数组长度的元素
上面的写法只是便于理解，但它不是一个证明。
至于从1/2变换到1/3那么需要改一下上述算法：

1.设置两个计数器count0=0,count1=0和两个计数对象cond0=None,cond1=None
2.我们开始遍历数组
3.如果我的count0=0而且该遍历元素不是cond1，那么cond0=遍历的这个元素，同时count=1，并且跳过下面步骤继续遍历
4.如果我的count1=0而且该遍历元素不是cond0，那么cond0=遍历的这个元素，同时count=1，并且跳过下面步骤继续遍历
5.如果遇到的是cond0，那么count0+=1，否则执行下一步
6.如果遇到的是cond1，那么count1+=1，否则执行下一步
7.count0-=1，count1-=1


至于为什么上述算法可以实现，大家可以接合上面的思路自己想一想，因为是现学现卖，所以可能有一些问题，欢迎大家补充和纠正。谢谢！！！望点赞(￣▽￣)~*

### 代码

```python3
class Solution:
    def majorityElement(self, nums: list) -> list:
        lens = len(nums)
        
        if lens==1:
            return nums
        if lens==2:
            if nums[0]!=nums[1]:
                return nums
            return [nums[0]]
        
        count0 = 0
        count1 = 0
        cond0 = None
        cond1 = None
        num0 = 0
        num1 = 0
        
        
        for i in nums:
            if i!=cond1 and count0==0:
                cond0 = i
                count0=1
                continue
            if i!=cond0 and count1==0:
                cond1 = i
                count1 = 1
                continue
            
            if i==cond0:
                count0+=1
            elif i==cond1:
                count1+=1
            else:
                count0-=1
                count1-=1
            
        for i in nums:
            if i==cond0:
                num0+=1
            if i==cond1:
                num1+=1
                
        p = []
        if num0>lens/3:
            p.append(cond0)
        if cond0!=cond1 and num1>lens/3:
            p.append(cond1)
            
        return p
            
```