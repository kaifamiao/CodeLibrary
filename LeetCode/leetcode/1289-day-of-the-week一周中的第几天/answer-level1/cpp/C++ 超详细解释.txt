### 解题思路
首先明确3个基础知识:
1. 闰年是公历中的名词。**闰年分为普通闰年和世纪闰年**。
        普通闰年:**公历年份是4的倍数的，且不是100的倍数**，为闰年。（如2004年就是闰年）；
        世纪闰年:公历年份是整百数的，**必须是400的倍数才是世纪闰年**（如1900年不是世纪闰年，2000年是世纪闰年）；
        公历中只分闰年和平年，平年有365天，而闰年有366天（2月中多一天）；平年中也可能有闰月（如2017年是平年，农历有闰月，闰6月）。
2. **1971.1.1 is Friday**
3. 1880年到2100年中是闰年的有以下这些年份：
1880年、1884年、1888年、1892年、1896年、1904年、1908年、1912年、1916年、1920年、1924年、1928年、1932年、1936年、1940年、1944年、1948年、1952年、1956年、1960年、1964年、1968年、1972年、1976年、1980年、1984年、1988年、1992年、1996年、2000年、2004年、2008年、2012年、2016年、2020年 2024,2028,2032,2036,2040,2044,2048,2052,2056,2060,2064,2068,2072,2076,2080,2084,2088,2092,2096

### 代码

```cpp
class Solution {
public:
    constexpr bool isLeapYear(int year) { // 利用constexpr加速程序
        return !(year % 4) && (year % 100) || !(year % 400);
    }
    string dayOfTheWeek(int day, int month, int year) {
        const string WEEK[]{"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" } ; // 这里有个顺序问题 应该按照实际星期几对应比较好 下标1代表星期一, 一直到下标6代表星期六, 最后才是下标0代表星期天 刚好与下标对应起来 就不用再-1了
        const int BASE_DAY = 4; // 从1971.1.1号算第一天 那么前一天就是星期4 那么这个基础量就是4 后面再加上偏移量求余即可
        
        const int MONTH_DAYS[]{-1, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30}; // 和星期同样的道理 下标1对应月份1..直到下标11对应月份11, 12月份可以不用了 因为这个天数是放在参数day中算的 不可能有需要加12月份天数的情况 前面是按一年天数算的
        int yearsDays = 0;
        // 从1971开始算 如果给定1972年 那么你只能算1971的天数啊! 所以 <(小于)终点年数 后面交给月+日去算了
        for (int y = 1971; y < year; ++y) yearsDays += 365 + isLeapYear(y);

        int monthsDays = 0;
        //同样的 月份数也才1月开始算 不能等于month 因为剩下的天数交给day去算了
        for (int i = 1; i < month; ++i) monthsDays += MONTH_DAYS[i];
        monthsDays += month > 2 && isLeapYear(year); // 如果已经过了2月 注意是大于2 而不是大于1 必须要过2月才算是否是闰年从而+1 如果只是2月 剩下天数交给day去算就好了

        int allDays = yearsDays + monthsDays + day;
        
        return WEEK[(allDays + BASE_DAY) % 7]; // 所有天数加上baseday 再求模7即可
    }
};
```