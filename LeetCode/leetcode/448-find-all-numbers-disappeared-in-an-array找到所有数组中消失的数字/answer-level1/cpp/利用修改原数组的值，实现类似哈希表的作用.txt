## 解题思路


### 方法一、哈希表 `O(N)` + `O(N)`

一开始的方法，利用 `unordered_map<int, int>` 记录数组中已出现过的数。

那么我们再遍历一次 `1 to n`，判断哪个数不存在 `unordered_map<int, int>` 中，即可得到不存在的数。


#### 1）复杂度分析
时间复杂度是`O(N) + O(N) = O(N)`（遍历一次数组 + 遍历 `1 to n`）

空间复杂度是`O(N)`（最多存储 `N` 个数）

#### 2）AC代码

```cpp
class Solution {
public:
    unordered_map<int, int> mp;
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0;i < n; ++i)
        {
            if(mp[nums[i]] == 0)
                mp[nums[i]] = 1;
        }
        vector<int> ans;
        for(int i = 1;i <= n; ++i){
            if(mp[i] == 0)
                ans.push_back(i);
        }
        return ans;
    }
};
```


### 方法二、修改原数组的值，判断对应的下标 + 1 的数在不在 `O(N)` + `O(1)`

我们可以利用更改数组的值，用于判断这个值对应的下标 + 1 这个数存不存在。

有点像哈希表一样，比如我们遍历到数组中的某个值 3，那么我们要知道 3 这个数是存在的，我们把 3 变成下标，然后利用 这个数对应的下标 的那个数组的数变成一个**设计好的数**，那么我们下一次碰到这个数，我们就知道，这个数对应下标的数是存在。

那么问题，我们是顺序遍历数组，我们把某个下标的数变成**设计好的数**，接着到这个数的时候，我们还要知道它原来的数是什么，那么就要**如何去设计**

我们要把一个数，变成另一个数，同时保留原本数，而且还要和原来数不同，根据题目的要求，原来的数一定是 `1 to n`的其中一个，那么我们把数，变成负数，即可以知道这个数是变动了，而且还能知道原本的数是什么。

**设计规则 : 如果一个数变成其相应的负数，那么这个数对应的下标 + 1 这个数，是存在于原来数组的**

整个程序的流程
- 先遍历一次数组
    - 取出对应的值（由于这个值可能变为负数了），因此先保证要回到正数
    - 说明这个数是在原数组存在的，那么我们把这个数，作为下标
    - 将对应下标的数组数，变成负数
- 再遍历一次数组
    - 如果这个数是负数，说明这个数对应的下标值 `1 to n`中是存在的
    - 如果这个数还是正数，说明对应的下标值，在`1 to n`中是不存在的。

举一个例子：
> 输入 [1 4 4 2]  ，说明要问 `1 to 4` 中有哪个数不存在  
> 1. 一开始，取出 1，说明 1 存在，那么把 下标为 `1 - 1 = 0`的数变为负数 -> [-1 4 4 2]  
> 2. 接着，取出 4，说明 4 存在，那么把下标为 `4 - 1 = 3` 的数变为负数 -> [-1 4 4 -2]   
> 3. 接着，取出 4，说明 4 存在，那么把下标为 `4 - 1 = 3` 的数变为负数 -> [-1 4 4 -2]   
> 4. 接着，取出 -2，要保证变回正，说明 2 存在，那么把下标为 `2 - 1 = 1` 的数变为负数 -> [-1 -4 4 -2]  
> 5. 最后遍历一回数组，如果还是正数的下标对应的值，在 `1 to 4`中是不存在的，所以发现是 `2 + 1 = 3` 这个数是不存在的


这道题，主要就是，通过利用修改原数组的值，得到这个数的下标是否存在，而且这个值还要保留原来值的信息，防止还没使用，要使用的时候，可以知道原数组的值。



#### 1）复杂度分析
时间复杂度是`O(N) + O(N) = O(N)`（遍历一次数组 + 遍历 `1 to n`）

空间复杂度是`O(1)`

#### 2）AC代码

```cpp
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0;i < n; ++i) {
            // 此时下标的数
            int idx = nums[i];

            // 说明在原数组中，这个数存在，那么我们把这个数当作下标，把对应下标的那个数变成负数，这样子，说明是负数的对应的下标值的数，是存在的
            if(idx < 0) idx = -idx;  // 因为数可能前面变为负数了，而下标是正的，所以变回来
            if(nums[idx - 1] > 0) nums[idx - 1] = -nums[idx - 1];  // 变成负数
        }

        vector<int> ans;
        for (int i = 0;i < n; ++i) {
            if (nums[i] > 0)  // 还是 > 0 的数对应的下标值，是不存在 1 to n 中的
                ans.push_back(i + 1);
        }
        return ans;
    }
};
```
