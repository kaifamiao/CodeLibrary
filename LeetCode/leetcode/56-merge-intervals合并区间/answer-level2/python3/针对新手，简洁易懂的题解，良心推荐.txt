从第二个区间开始（i=1），对于第i个区间，一共只有三种情况，并且保证每次对第i个区间只进行**删除**或**不变**两种操作，对第i-1个区间只进行**合并**或**不变**两种操作：
if 第i个区间的左边界(seq[i][0])落入第i-1个区间：

    1. 若第i个区间的右边界(seq[i][1]) ≥ 第i-1个区间的右边界(seq[i-1][1]):
        比如第i个区间是[3,6],第i-1个区间是[1,4]，那么区间[3,6]删除，区间[1,4]--->[1,6] 合并

    2. 若第i个区间的右边界(seq[i][1]) ≤ 第i-1个区间的右边界(seq[i-1][1]):
        比如第i个区间是[3,4],第i-1个区间是[1,4]，那么区间[3,4]删除，区间[1,4]--->[1,4] 不变

else:
     比如[1,4],[6,9]

    3. 此时第i与第i-1个区间不能合并，搜索下一个区间，判断是否能与[6,9]区间发生合并
    
```
class Solution:
    def merge(self, seq: List[List[int]]) -> List[List[int]]:
        seq = sorted(seq) # 区间从小到大排序，若左边界相等，则对右边界排序；
        i = 1 # 初始位置从第二个区间开始
        while i < len(seq):
            if seq[i][0] >= seq[i-1][0] and seq[i][0] <= seq[i-1][1]:
                if seq[i][1] <= seq[i-1][1]:
                    seq.remove(seq[i])
                else:
                    seq[i-1] = [seq[i-1][0], seq[i][1]]
                    seq.remove(seq[i])
            else:
                i += 1
        return seq
```
