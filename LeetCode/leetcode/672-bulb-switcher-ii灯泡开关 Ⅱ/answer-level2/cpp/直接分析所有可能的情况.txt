首先根据4种功能可以发现，所有功能执行2次与不执行效果一致。因此可以将所有功能分为`执行0次与执行1次`。

由这4种功能可以很容易的看出解空间有限：
（以下以a, b, c, d分别代表执行4个按钮功能，末尾的斜体表示达到效果需执行的最少次数）

* 执行a的效果 == 执行b的效果 + 执行c的效果 *(1 | 2)*
* 执行b的效果 == 执行a的效果 + 执行c的效果 *(1 | 2)*
* 执行c的效果 == 执行a的效果 + 执行b的效果 *(1 | 2)*
* 执行d的效果 == 执行a的效果 + 执行a的效果 + 执行d的效果 *(1 | 3)*
* 执行a的效果 + 执行d的效果 *(2)*
* 执行b的效果 + 执行d的效果 == 执行a的效果 + 执行c的效果 + 执行d的效果 *(2 | 3)*
* 执行c的效果 + 执行d的效果 == 执行a的效果 + 执行b的效果 + 执行d的效果 *(2 | 3)*
* 回归初始状态 *(n > 1)*
* 不执行或执行无效 *(仅当n == 0或m == 0时成立)*

解空间共9种可能的情况，因此输出则是解空间各种情况的排列组合

然后再根据灯的数量n和操作次数m进行分析：

1. n = 1, m = x时（x为任意大于0的整数）
    **无论如何操作也仅有2种情况**
    
2. n = 2, m = 1时
    **因为d操作效果和c操作一致，共3种情况**
    
    m >= 2时，
    **执行a的效果 + 执行d的效果 == 执行b的效果**
    **执行b的效果 + 执行d的效果 == 执行a的效果**
    **执行c的效果 + 执行d的效果 == 不执行任何操作**
    **因此共4种情况（在m=1的基础上多了初始状态）**

3. n>=3, m = 1时
    **共4种情况**
    
    m = 2时，
    **执行两次无法实现执行d的效果，所以共7种**
    
    m > 2时，
    **共8种情况**
    
4. n == 0 或 m == 0时 **仅有1种情况**
    
```c++
class Solution {
public:
    int flipLights(int n, int m) {
        if(n ==0 || m == 0){
            return 1;
        }
        if(n == 1){
            return 2;
        }
        else if(n == 2 && m == 1){
            return 3;
        }
        else if((n == 2 && m >= 2) || m == 1){
            // n < 3的情况已被前面的if排除
            // 因此当n>=3时，只需判断m==1即可
            return 4;
        }
        else if(n >= 3 && m == 2){
            return 7;
        }
        else {
            return 8;
        }
    }
};
```