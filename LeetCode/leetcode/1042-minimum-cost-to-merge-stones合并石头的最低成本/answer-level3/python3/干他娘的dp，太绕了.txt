一眼看去就知道是dp，因为每增加一个数，不能只用到前面的一种状态，每增加一个数就增加了多种情况
所以至少是二维的dp。
自然而然的dp[i][j]就表示从i到j的最小开销。但是这个题有一个恶心的点在于不是每次都能凑整，有时候还需要求出一些不能完全合并但是要尽最大可能合并的一些ij，比如k=3，然后合并4个点最后只能求出开销最小的结果为2个堆的情况。为什么非要求这个呢，因为每一次想一段序列的最小开销的时候，你都要把他们分成（3个数，剩下的）其中三个数肯定是满足了合并一个堆，剩下的肯定最终是要变成两个堆的，这样三个在一起才能成为最终的一个堆，所以肯定有一种不满足合并为一个堆的，也能为后面计算做准备。
prefix数组为一个方便使用的数组，记录的是区间总体的和，当满足最终能合并为1的时候将这个加上去，为最后的一次开销
m为想要合并的数组数，必须从小的开始不然动态规划就没有意义了，从简单到复杂
i为可以合并m的行，对于每一个m，i的范围自然是（0-总数-（m-1））
每一次基本操作时对于i到i+m这段求最小开销，分为两种情况，第一种情况是最终可以合并为一个堆时，另外一种是不能合并，区别就是是不是要加上之前那个prefix计算最后一次合并的开销。
最小开销就是依次总最左边开始切割，为左边开销+右边开销，求那种情况切分的话开销最小，！！！！！这里要保持统一切分规律，就是每次切分都是左边一个堆，右边是最终成为两个的堆。
因为如果不是这样切的话，比如k=3，切到4个的时候，如果切2，2这样最后开销为0，所以必须保证至少包含一个包含开销的数组。
```
class Solution:
    def mergeStones(self, stones: List[int], K: int) -> int:
        N = len(stones)
        if (N - 1) % (K - 1): return -1
        prefix = [0] * (N+1)
        for i in range(1,N+1): prefix[i] = stones[i-1] + prefix[i-1]
        dp = [[0] * N for _ in range(N)]
        for m in range(K, N+1):
            for i in range(N-(m-1)):
                dp[i][i+m-1] = min(dp[i][k] + dp[k+1][i+m-1] for k in range(i, i+m-1, K-1)) + (prefix[i+m] - prefix[i] if (m-1)%(K-1) == 0 else 0)
        return dp[0][N-1]

```
