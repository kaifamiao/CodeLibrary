
```
#首先通过题目，我们可以有这种想法：

既然是最小的正整数，那自然数一个一个判断不就完事了。
比如：1在不在数组，1要是不在，那答案就是1。
      1在的话，那就考虑2......
```

进一步可以产生这种想法：

```
#求出数组的大小为n（该操作时间复杂度不会超过o(n)），那之前的自然数判断程序顶多就判断n次啊。
```

所以会有以下两种情况：
```
1 从1到n全在数组里面，那最小自然数就是n+1
2 从1到n只有一部分在数组里面，那答案就是未出现的最小值
```
这种想法通常实现的方式的就是，建立一个键为1到n的哈希表，遍历数组，如果是1到n之间的数，值就为True（值默认为FALSE），表示存在。之后遍历自然数1到n，输出第一个值为FALSE的键。

```
#但是上面这种做法会引入一个o（n）的空间复杂度，因此在这里，我们需要利用数组本身来存储信息。
```
有两种方法可以利用数组存储信息:

**1 给数字加上一个极小的小数携带信息**

如果遍历数组遇到一个小数，那就说明该角标`i + 1`的数存在啦。比如数组`i = 3`遍历到一个为`5.1`的小数，一是表明该数原来是`5`，二是说明`i+1`也就是`4`存在于数组中了。所以`1`到`n`中的`4`已经存在了。

```
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        #抽屉原理
        #上一个题全是正数，可以用负数来标注这个位置有没有占，那这个题可以用小数来标记
        n = len(nums)
        for x in nums:
            if 1<=int(x)<=n:
                nums[int(x)-1] +=1/(n+1)
        for i in range(n):
            if nums[i]-int(nums[i])==0:
                return i+1
        return n+1
```

**2 将所有不在`1`到`n`的数转为一个较大的正数，之后给数字转负**

在经历将所有无关的数转为正数之后（这一步不会影响答案），如果遍历数组遇到一个负数，那就说明该角标`i + 1`的数存在啦。比如数组`i = 4`遍历到一个为`-6`的数，一是表示该数原来为`6`，二是`5`存在于数组中。

```
class Solution:
    def firstMissingPositive(self, nums: List[int]) -> int:
        #抽屉原理
        n = len(nums)
        #首先把不合条件的数转正
        for i in range(n):
            if nums[i]<1 or nums[i]>n:
                nums[i] = n+1
        #接着数字往相应的位置填，因此如果当前元素为负，那么意味着这个元素对应的角标 +1的数字存在。
        for x in nums:
            if 1<=abs(x)<=n and nums[abs(x)-1] >0:
                nums[abs(x)-1] *=-1
        #最后如果元素为正，则意味这该角标+1数字不存在。
        for i in range(n):
            if nums[i]>0:
                return i+1
        return n+1
```

