### 解题思路
关键是要想到并理解一些技巧，太难想出来了：
不管数组里面的数字有多大，有多么不规则，但只需要考虑从1到数组长度n-1个整数的范围里分布情况。

如果数组长度为5，那么就看1,2,3,4,5这5个数字的情况：
比如：给出的数组里面恰好就是1,2,3,4,5，而且顺序错乱，那么排好序之后，就会很有规则，比如0号位是1,1号位是2,2号位是3。。。那么遍历一遍发现所有的数字都在他们应该站的位置，我们就得到了答案：最小的数字是6。

假如数组中给出的数字里面，有1个数字造成“空洞”比如：1,2,3,4,2147483647，最后一个数字很大。那么在排序时可以尽量让1,2,3,4这四个数字站在应该站的位置，即0号位为1,1号位为2,2号位为3,3号位为4，那么4号位只能给了2147483647。此时遍历一下数组就可以得出，最小的数字是5。

假如数组中给出的数字是1,10,100,1000,10000，那么排序后只有一个1，站在了它应该站的位置0号位上，其他数字都无处安身。1和10之间出现了空洞。我们遍历数组就可以得到最小的正数是2。

所以得出一个规律，假如给的数组里面的数字，排序后数字之间会形成“空洞”，不管这些空洞有多大，我们只关心他们从1开始向右出现的第一个空洞，一定发生在数组里面，即从0号位的1到n号位的n+1，那么策略就是，让能归位的数字归位，之后就遍历这个数组，碰到第一个“空洞”的就得到了答案。

剩下的就是排序的问题，排序不能用nlogn的方式来排，对于每一个数组元素，去计算它原本应该站在哪个位置上，进而去交换，如果无法交换（可能这个数字是2147483647，但数组长度只有5），或者已经处于正确位置（就是当前的位置），就continue下一个元素数组。

代码中while语句的条件里，nums[i] - 1是nums[i]应该站的位置，比如nums[i]是5，那么它正确位置是4。
所以while的条件其实就是交换的条件：nums[i]是要大于0的，他的正确位置不在i上，他的正确位置应该在0到size_nums-1区间，而且目前正确位置上的元素已经是另一个它了。

为什么用while而不是if，因为交换一次之后，还可能再次需要交换，考虑：
[3,4,-1,1]
第0个元素3的正确位置是2，而位置2目前是-1，那么交换，成为[-1,4,3,1]
第1个元素4的正确位置在3，而位置3目前是1，那么交换，成为[-1,1,3,4]
注意，如果不用while而用if，那么此时新的第1个元素1将不再被处理了（而是继续处理第2个元素3了），进而判断出缺失的第一个正整数为1（而1是存在的）
所以while的意义是，为了防止从后面交换过来的数字，本来可以和前面位置交换的，但被忽略了。

### 代码

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int size_nums = nums.size();
        for (int i = 0; i < size_nums; ++i) {
            while (nums[i] > 0 && i != nums[i] - 1 && nums[i] - 1 >= 0 && nums[i] - 1 < size_nums && nums[nums[i] - 1] != nums[i]) {
                int swap_pos = nums[i] - 1;
                nums[i] = nums[i] ^ nums[swap_pos];
                nums[swap_pos] = nums[i] ^ nums[swap_pos];
                nums[i] = nums[i] ^ nums[swap_pos];
            }
        }

        for (int i = 0; i < size_nums; ++ i) {
            if (i + 1 != nums[i]) {
                return i + 1;
            }
        }
        return size_nums + 1;
    }
};
```

![微信图片_20191231144524.png](https://pic.leetcode-cn.com/5bdec3229e73cbe38c05d75bade6da7f92173c7d5a8e06a03f1ae9d216ee6dee-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191231144524.png)
