> 关注公众号【算法码上来】，每日算法干货马上就来！

![宣传图片.jpg](https://pic.leetcode-cn.com/62557ee64db9793280c61c6b8edcdbc9d794b4fb1472129477d87c05fd66e458-%E5%AE%A3%E4%BC%A0%E5%9B%BE%E7%89%87.jpg)


## 题解
如果之前一直坚持看我题解的同学，应该前几天刚看过下面这道题：   
[【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法](https://godweiyang.com/2020/03/16/leetcode-interview-17-19/ "【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法")

[【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法](https://zhuanlan.zhihu.com/p/113534188 "【每日算法Day 71】面试官想考我这道位运算题，结果我给出了三种解法")

那道题是要求 $1$ 到 $n$ 中缺失的两个数，于是我们开辟一个大小为 $n$ 的数组，将所有数字放到下标对应的位置，然后看哪两个位置是空着的。为了使用原地算法，我们直接在原数组上进行操作。

回到本题，我们要寻找的是第一个缺失的正整数。其实问题的本质是一样的，如果数组的长度是 $n$ ，那么最多只能填充 $1$ 到 $n$ 这 $n$ 个正整数，所以缺失的正整数一定小于等于 $n+1$ 。

那么我们把小于等于 $0$ 或者大于 $n$ 的数全部赋值为 $-1$ ，因为它们是多少不要紧，不影响最后的结果。然后和上面题目方法一样，用原地算法，把每个数字放入对应下标的位置。最后从左到右扫描一遍数组，如果发现有位置是 $-1$ ，那么第一个缺失的正数就是它了。如果扫描完 $1$ 到 $n$ 发现全都在，那么第一个缺失的就是 $n+1$ 了。当然可能缺失很多正数，所以扫描到第一个缺失正数之后，就要直接返回结果了。

因为我们要保存 $1$ 到 $n$ 之间的数，所以数组长度不够，要在后面扩充一个才行。

时间复杂度是 $O(n)$ ，空间复杂度是 $O(1)$ 。

## 代码
### c++
```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        int n = nums.size();
        nums.push_back(-1);
        for (int i = 0; i <= n; ++i) {
            if (nums[i] <= 0 || nums[i] > n) {
                nums[i] = -1;
            }
        }
        for (int i = 0; i <= n; ++i) {
            while (nums[i] != -1 && i != nums[i] && nums[i] != nums[nums[i]]) {
                swap(nums[i], nums[nums[i]]);
            }
            if (nums[i] != -1 && i != nums[i]) {
                nums[i] = -1;
            }
        }
        for (int i = 1; i <= n; ++i) {
            if (nums[i] == -1) return i;
        }
        return n+1;
    }
};
```
