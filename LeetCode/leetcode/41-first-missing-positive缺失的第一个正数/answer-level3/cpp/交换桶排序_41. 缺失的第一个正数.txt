### 解题思路
    /*
     * 桶排序
     *
     * 因为题目要求的时间复杂度O(n)和空间复杂度O(1),
     * 常规的暴力法、排序法和哈希表法都无法满足，
     * 桶排序能满足时间复杂度在O(n)，但常用的桶排序空间复杂度是O(n),
     * 所以此处通排序不能使用额外的空间存储数组，
     * 对原数组的数进行交换，可以达到目的。
     * 桶排序的核心思想是该数存放在该数对应索引位置，
     * 在遍历原数组的过程中，如果该数大小在原数组的size范围内，
     * 同时不在该数对应索引位置，就将该数与其对应索引位置的数进行交换。
     * 当所有数据均有序存放在各自对应索引位置，
     * 重新遍历重排后的数组，如果位置与数不对应，则返回该对应索引.
     * 如果数组中的数都按照对应位置存放，则返回最后一个数加1
     * */
### 代码

```cpp
int firstMissingPositive(std::vector<int> &nums) {
    if (nums.empty()) {
        return 1;
    }

    int m = nums.size();

    // 遍历原数组
    for (int i = 0; i < m; i++) {
        // 如果nums[i]在size范围内，
        // 同时nums[i]不是在i+1对应的位置，
        // 则对该数与i—1位置的数进行交换
        while (nums[i] > 0
               && nums[i] <= m
               && i != nums[i] - 1
               && nums[i] != nums[nums[i] - 1]) {
            std::swap(nums[i], nums[nums[i] - 1]);
        }
    }

    // 重新遍历交换后的数组
    // 如果位置与数不对应，则返回i+1
    for (int i = 0; i < m; i++) {
        if (i != nums[i] - 1) {
            return i + 1;
        }
    }

    // 如果数从1开始都按顺序排好，则返回size+1
    return m + 1;
}
```