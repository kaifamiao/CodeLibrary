### 解题思路
本来这道题目我的最开始想法是直接sort，然后遍历的，但是不符合题目的**内存常量**要求。
因此，只能再本身的vector上做文章了。

我们的想法是对其本身的数据进行交换，那么数据的交换条件就需要确定下来！

首先，根据本题目的要求，是找最小的正整数。
**1、要交换的数据大于0，这个是必须的。**
如果所有的数据都比数据的长度大，那么显然，都是没必要交换的，因为最小的正整数肯定为1。
**2、要交换的数据不能比数据长度大；**
交换是再一个循环中，确保数据能正确进入到下标之中，所以，要设定循环进行的条件。
**3、交换双方的数据不能相等；**
如果交换后的下标值加1等于当前值，则说明放到了对应的位置。
**4、当前值的下标加1不能和当前值相等。**

因此，根据上面的四个条件，就可以进行数据的交换了。

而至于要求的时间复杂度，由于while循环中的swap并不是全部都操作，所以，再for里面进行swap的交换，应该是可以满足时间复杂度的需求的O(n);
至于空间复杂度，并没有使用另一个vector来进行数据的存储，再原地进行的修改，所以，符合常量空间。

hard的题目的难处在于整个逻辑的思考，很难把逻辑条件列的这么清楚详细。
### 代码

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        if(nums.size() == 0) return 1;
        for(int i=0;i<nums.size();i++){
            //交换的判定条件
            while(nums[i] > 0 && nums[i] <= nums.size() && 
                nums[i] != nums[nums[i]-1] && i+1 != nums[i]){
                    swap(nums[i],nums[nums[i]-1]);
                }
        }
        for(int i=0;i<nums.size();i++){
            if(i+1 != nums[i]) return i+1;
        }
        return nums.size() + 1;
    }
};
```