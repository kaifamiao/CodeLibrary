**1.此题使用额外的空间很容易求得解,下面介绍一种交换数字得到接近有序的有序数组;
2.此题和《***》第3题‘找出重复的数字’类似,也推荐这本书给入门想进阶的同学;
3.简单来讲就是:原数组：{3,4,-1,1} → {1,-1,3,4},即要把每个数字放到对应下标的位置减1处(数字 1 放到 1-1=0 下标位置),最终放置的效果为：{1,2,3,4},第一个位置从 1 开始;
4.从数组第一个数字开始遍历,首先这个数字要在 1-nums.length 长度范围内,否则越界无法交换;
5.例如：交换`{3,4,-1,1}`。(1):进入循环交换 3、-1,得到`{-1,4,3,1}`,i无自增;(2):再进入循环 i 还是 0 ,但if不符合条件,`i++`;(3):再次进入循环 i = 1,交换 4、1,得到`{-1,1,3,4}`,i 无自增;(4):再进入循环,交换-1,1,得到`{1,-1,3,4}`,i 无自增,(5):再进入循环,`i++`;(6):`i++`;(7):再进入循环,`i++`;(8):`退出`。
6.最后通过 while 循环从数组左至右找第一个不符合条件的值即可,如果没有的话,那么数组就是排序好的 1-nums.length 的数值,返回i + 1 即可;
7.if + else {i++;},也可替换为 while 但别忘记再加for循环中的 i++;
8.完结。**


        public int firstMissingPositive(int[] nums) {
            for (int i = 0; i < nums.length;) {
                if (nums[i] <= nums.length && nums[i] >= 1 && nums[i] != nums[nums[i] - 1]) {
                    int temp = nums[nums[i] - 1];
                    nums[nums[i] - 1] = nums[i];
                    nums[i] = temp;
                } else {
                    i++;
                }
            }
            int i = 0;
            while (i < nums.length && i + 1 == nums[i])
                i++;
            return i + 1;
        }