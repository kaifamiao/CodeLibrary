### 解题思路
- 上例子:以 5 + 7 = 12 为例，分步走：
- 相加各位的值，不算进位，得到2。
- 计算进位值，得到10。如果这一步的进位值为0，那么第一步得到的值就是最终结果。
- 重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。
- 相同思想运用于二进制加法运算

- 同样我们可以用三步走的方式计算二进制值相加，5 = [0101]，7 =  [0111]

1. 相加各位的值，不算进位，得到 010，二进制每位相加就相当于各位做异或操作，101 ^ 111。
2. 计算进位值，得到 1010，相当于各位做与操作得到 101，再向左移一位得到 1010，(101 & 111) << 1。
3. 重复上述两步， 各位相加 010 ^ 1010 = 1000，进位值为 100 = (010 & 1010) << 1 。
4. 继续重复上述两步：1000 ^ 100 = 1100，进位值为 0，跳出循环，1100为最终结果。
--------------------------------------------------------------------------------------------------------------------
### 可能遇到的问题
- 上面是整个的算法部分,但是我想有的小伙伴在使用python的时候会遇到问题,因为python中的负数二进制的表示是和其他语言不同的,Python 里的数是无所谓 Overflow 的，即没有位数限制，因此也就无所谓补码，因为补码都是相对于位数来说的，32 位补码和 16 位补码，肯定是不一样的。但是这样就导致了一个问题，就是无法直接得到32位二进制补码。
- 在32位的系统中int类型的表示范围为[-2**31,2**31-1],在python里如果补码超过了`2**31-1`这个边界,那么他代表的原码就是一个负数,我们需要将它转换成对应的源码,而正数的补码等于其源码不用转换
- 关于python中原码和补码的转换我也简单总结了一下:
1. 原码转补码:
- 正数的原码即补码不用转换,如果是负数的话通过`n & 0xffffffff`进行转换
2. 补码转原码(两种)
- 通过`-(((~n)+1) & 0xffffffff)`或者`~(n ^ 0xffffffff)`都可以进行转换,这是`n`的实际值为负数的时候的转换方式

### 代码

```python
class Solution(object):
    def add(self, a, b):
        """
        :type a: int
        :type b: int
        :rtype: int
        """
        # (n & 0xffffffff)进行这种变换的原因是,如果存在负数则需要转换成补码的形式,正数补码是他本身
        a &= 0xffffffff#
        b &= 0xffffffff
        while b != 0:
            carry = ((a & b) << 1) & 0xffffffff#如果是负数,转换成补码形式
            a ^= b
            b = carry
        if a < 0x80000000:#如果是正数的话直接返回
            return a
        else:
            return  ~(a^0xffffffff)#是负数的话,转化成其原码

```