为了降低时间复杂度O(n^2)，我们有必要获取一些序列的信息，先扫描一遍序列，我们可以得到
- 0的个数
- 最大最小值
- 正负数的个数

有了这些数据后，我们首先能够把三个0的情况填进去，如果只有正数或者只有负数，肯定也是不行的。之后我们再考虑无解的情况，如果三个数中，最小的数的两倍都没有最大的数大，那肯定凑不齐0，所以我们可以对序列的范围进行放缩。
```java
if (zeroS >= 3) {
    res.add(Arrays.asList(0, 0, 0));
}
if (negS == 0 || posES == 0) {
    return res;
}
if (minValue * 2 + maxValue > 0) {
    maxValue = -minValue * 2;
} else if (maxValue * 2 + minValue < 0) {
    minValue = -maxValue * 2;
}
```
考虑正数一定要和负数搭档，所以我们尝试将正数和负数分开成两个数组，同时我们注意到为了避免重复的问题，只需要记录不同的正负数就行了，这里我们使用桶排的想法，如果这个数已经在桶中，就不把他再放到正负数组里面了。
```java
for(int i = 0; i<nums.length;i++)
{
    if (nums[i] >= minValue && nums[i] <= maxValue) 
    {
        if (map[v - minValue]++ == 0) 
        {
            if (v > 0) poses[posSize++] = nums[i];
            else if (v < 0) negs[negSize++] = nums[i];
        }
    }    
}
```
接下来我们对正负序列排序，然后从最大的负数开始计算有没有相同的可能，这是因为最大的负数对应最小的正数，设最大的负数为p，那么我们需要寻找两个正数（为了简化讨论，暂时不考虑正负数相同），这两个正数必然其中一个比(-p)/2要大，一个比(-p)/2要小，否则加起来不会等于0，这样我们让负数慢慢变小的同时，(-p)/2在慢慢变大，所以我们从大到小遍历负数的时候，正数的数组也就自然遍历完了。

当我们从一个负数q出发，找到了大于等于(-q)/2的第一个正数t的时候，我们就可以找到另一个正数 0 - q - t了，接着我们遍历从t到正数中最大的数，就可以找到从负数q出发的所有不重复三元组了。

时间复杂度为
O(n) + O(negSlog(negS)) + O(posESlog(posES))
第一次扫描+两次排序+最后的遍历，但是最后的遍历的时间复杂度计算我不知道该怎么算，从leetcode提交的结果上看比双指针的算法要稍微快一点，大概在13-25ms左右