## 思路
1. 先排序，从小到大，有序数组方便快速过滤，不然时间复杂度就是O(n3)了。
1. 从右到左循环数组，因为最少得3个数，所以最小循环到第3个数就截止。
1. 如果右侧最大的3个连续数字加起来，还比0小，那左边不可能有数字加起来为0了。
1. 如果当前数字就右边的数字一样大，那就是重复数字，直接跳过
1. 如果本次循环中，当前数字加上最左侧的两个数字，和大于0，那么加上其它数字只会更大，所以也直接跳过本次循环
1. 定义两个指针l(左侧指针)、r(右侧指针)，每次循环时，左侧指针从0开始，右侧指针从当前下标i左边第一个数字开始，慢慢让两个指针往中间移动，直到两个指针相撞
    - 当左指针加右指针的和太大时，说明需要更小的值，要把右指针往左移动
    - 当左指针加右指针的和太小时，说明需要更大的值，要把左指针往右移动
    - 如果指针移动后的值和移动前一样大，那就继续移动，直到值不一样了。
    - 当左指针加右指针的和正好时，我们就找到了一组解，这时再同时移动左右指针。因为只移动一个的话，已经有两个数字是固定的了，要算得到解，第3个数字也一定是一样的。
1. 在判断指针相撞的while里，还可以加个条件（在本次循环中，如果最左侧的两个数字之和大于需要的数字，那其它数字之和就更大了，所以可以直接跳过本次循环；如果最右侧的两个数字之和小于需要的数字，同理），进一步过滤多余数据。但是这个条件本身也需要计算，被它过滤掉的计算量也不大，两者相比，不一定哪个更优。实测结果还是不加这个条件稍好一点。

## 代码
```
var threeSum = function(nums) {
    nums = nums.sort((a, b) => a - b);
    let arr = [];
    for(let i = nums.length-1; i>1 && nums[i] + nums[i-1] + nums[i-2] >= 0; i--){
        if(nums[i] === nums[i+1] || nums[i] + nums[1] + nums[0] > 0) continue;
        const s = 0 - nums[i];
        let l = 0, r = i - 1;
        //while(l<r && nums[l]+nums[l+1]<=s && nums[r]+nums[r-1]>=s){
        while(l<r){
            if(nums[l] + nums[r] > s){
                do{--r}while(nums[r]===nums[r+1])
            }else if(nums[l] + nums[r] < s){
                do{++l}while(nums[l]===nums[l-1])
            }else{
                arr.push([nums[l], nums[r], nums[i]]);
                do{--r}while(nums[r]===nums[r+1]);
                do{++l}while(nums[l]===nums[l-1])
            }
        }
    }
    return arr;
};
```
