### C++ 首先明确题意, K >=0, A >= 0。 都是正整数
###  A中的每个值，可以加上K 也可以减去K。 如A[3] = 5. k = 2; 那么A[3]既可以加上5也可以减去5，得到7或者3 
下面是解题思路
1: 首先对数组进行由小到大排序， 为什么要进行排序呢？ 可以想象下这下值在0到10000的线段上，通过排序可以找到最大值与最小值，但此时的最大最小值并不是真正意义上的最大最小， 如A:[0, 10], K = 2; 我们需要尽可能的使两边的元素向中间某个点靠齐，使得极大与极小值的差最小。因此A:[0, 10], k = 2; 向中间坍缩 =》 [2, 8]. 两个极大值与极小值的差为6,这就是我们所需要的结果
2: 由上可知，我们需要找到那个中间点，使得两边的元素向它靠拢， 即中间点左边元素+k, 中间点（包含中间点）右边元素-k. 此时两边的极大极小值之差为我们的结果。 （下面称中间点为point） 3：那么如何找到我们需要的那个point呢？ 我们可以进行一次遍历， 假设从1到A.length()的长度中任意一点都有可能是我们的point。
那么在该任意一点的 。
3: 
- 极小值只有两种可能:   
   A[0] + K 或 A[point] - K ; (数组最左侧的点加K,或中间点减K) -----> 取最小   
- 极大值只有两种可能: 
  A[A.length() - 1] - K 或 A[point - 1] + K；(数组最右侧点的减K，或中间点左侧的点+K） ------>取最大

4: 找到极小值与极大值后， 两数之差即为当前point的最大最小值之差， 当最大与最小值之差最小时，那个点才是我们真正意义上的中间点。换句话说，中间点的最大最小值之差最小。 所以取每次差的最小值即可
```
class Solution {
public:
	int smallestRangeII(vector<int>& A, int K) {
		// 数组排序
		sort(A.begin(), A.end());
		
		// 可能的最坏结果：(最大值与最小值同时加上K，或者同时减去K)
		int result = A[A.size() - 1] - A[0];
		for (int i = 1; i < A.size(); i++) {
			// 以当前i为中间点时，可能的最小值
			int minValue = min(A[0] + K, A[i] - K);
			// 以当前i为中间点时，可能的最大值
			int maxValue = max(A[A.size() - 1] - K, A[i - 1] + K);
			// 中间点的最大值与最小值的最小差值
			result = min(maxValue - minValue, result);
		}
		return result;
	}
};
```
