### 解题思路
题目让我们找到所有的等差数列。我们可以利用贪心的思想，找到所有长度尽可能大的等差数列，再求这些等差数列中包含了多少个等差数列，最后累加起来便是我们想要的结果。
##### 步骤
1. 使用变量len记录等差数列的长度，从1开始；
2. 当数组长度不满足等差数列的条件时，使用变量step记录当前元素与前一个元素的差；
3. 当到达了等差数列的尾部时，即不满足等差的条件或者到了数组的最后一个元素时，计算该等差数列中包含的所有等差数列的个数，这里有个规律，子等差数列的长度是从3开始，到其最大长度结束，因此个数是1+2+...+(len-2)，我们可以利用公式很快的求和：(len-2)*(len-1)/2;
4. 计算完当前的等差数列后，记得下次计算差值时，应从当前位置开始计算。
举个栗子：
![image.png](https://pic.leetcode-cn.com/fe692f0d83e8ade6c171d7d170dbdf8c6bc53408c311a5d6837929434e372621-image.png)


### 代码

```java
class Solution {
    public int numberOfArithmeticSlices(int[] A) {
        if(A.length==0)return 0;
        int res=0;
        int len=1,step=0;
        for(int i=1;i<A.length;i++,len++){
            //计算差值
            if(len<2)step=A[i]-A[i-1];
            //到达等差数列的边界
            else if(A[i]-A[i-1]!=step||(i==A.length-1)){
                //如果到达了数组尾部，并且等差，则将数组长度加一
                if(A[i]-A[i-1]==step)len++;
                //该数组长度满足成为等差数列的条件，即最小为3
                if(len>=3){
                    //该等差数列中包含的子等差数列的数目
                    res+=(len-2)*(len-1)/2;
                }
                len=0;
                //重要，因为此时等差数列的最后一个元素可能是新的等差数列的第一个元素
                i--;
            }
        }
        return res;
    }
}
```
- 时间复杂度：O(N)
- 空间复杂度：O(1)