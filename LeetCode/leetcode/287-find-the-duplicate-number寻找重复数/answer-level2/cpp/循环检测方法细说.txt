### 解题思路
本题要符合时间复杂度小于n2，空间复杂度1的话，官方解答的前两种方法都不满足，只有循环检测的方法能够满足，代码也非常简单。
但我认为官方解释没有写的非常完整，这里来试图写的完整一点。

首先，如果从nums[0]开始沿着下标的方式来走，如果没有重复的数字，可能可以走出一条线，因为不可能回到0，所以最后一个节点应该的值应该是n，而不存在索引号为n的节点（因为是从0开始），所以中断了，就退出了。

但是这里的情况是，存在重复的节点，所以这样沿着nums[0]走会发生什么呢？
首先，必定不可能回到0，因为没有值是0的节点，其次，不可能像刚刚一样中断。
这是为什么呢，因为要中断，必然需要节点的值大于最大的索引，但因为有重复，节点的最大值小于等于索引的最大值，所以没有办法中断，所以必定是在一个循环之中。

也就是通过这条路，走着走着进入了一个循环。
可以举个例子，[1,2,3,4,5,3]这样，也就是会 1-2-3-4-5-3-4-5-3-4-5……也就是3-4-5-3这部分陷入了循环，可以发现，重复的地方也就是循环的起始点，也就是3，因为这个3有2个不同的点到达了它，所以造成了循环，它也就是2条路的交叉口。

接下来，用乌龟和兔的方法，假如乌龟一次走1步，兔一次走2步。

所有的情况都可以抽象成先经过i个节点到达重复节点，再进入到长度为S的循环圈中。

那么，如果乌龟和兔同时出发，他们会在哪里相遇呢？
一定是在这个圈中的某点，因为兔的速度是2，乌龟是1，相对速度是1，所以兔子一定能追上乌龟，在圈里的某处。

当乌龟走了距离i到达圈起始点时，兔子已经走了2i，那么兔子相对于乌龟来说是多远呢？也就是i-kS，也就是去掉兔子额外走的k圈。

这时，还是兔子追乌龟，它需要追多远呢？应该是圈剩下的距离，也就是S-（i-ks），也就是(k+1)S-i，也就是乌龟再走这么久，会被追上，这个位置非常巧妙，可以发现这里再经过i就会回到圈的起点，这就让我们想到，在这个地方让另一个乌龟从起点爬起，当起点的乌龟爬到圈起始点时，刚好原来的乌龟也会达到圈起始点，这样就能够得到圈起始点了，也就是重复的元素。

至此，这道题完成。


### 代码

```cpp
class Solution {
public:
    int findDuplicate(vector<int>& nums) {
        int result = 0;
        int slow = nums[0];
        int quick = nums[0];
        do{
            slow = nums[slow];
            quick = nums[nums[quick]];
        }while(slow!=quick);
        
        int p = nums[0];
        while(p!=slow){
            slow = nums[slow];
            p = nums[p];
        }
        result = p;
        return result;
    }
};
```