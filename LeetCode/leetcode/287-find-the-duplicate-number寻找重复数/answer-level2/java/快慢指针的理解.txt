虽然对快慢指针不是很理解，但是有几个规律
假设 慢指针每次走一步 快指针每次走两步
1.有重复数据必然有环
1.有重复数据的情况下。。。首次遍历到重复数据时，重复数据必然为一个环入口
2.在环内 快慢指针必定会相遇
3.快慢指针相遇的点到环入口的步数 加上 环的周长*n （n是一个正整数） 必然等于慢指针从起始点到环入口的步数。


假设一个环有4个节点
1.首先我们从第一个节点就遇到重复数据来考虑,那么相遇点必在起始点（这是一个规律）。
  此时相遇点到环入口步长为0，而慢指针到环入口的步长也为0。
2.假设慢指针从起始节点开始遍历步长1步遇到重复数据（也就是环入口）。
  那么快慢指针的相遇点将移动1+4n步才能到达环入口（这里乘4是环有4个节点，n为一个正整数可以随机）
3.假设慢指针从起始节点开始遍历步长2步遇到重复数据（也就是环入口）。
  那么快慢指针的相遇点将移动2+4n步才能到达环入口（这里乘4是环有4个节点，n为一个正整数可以随机）
。。。。
n.假设起始节点开始遍历步长m步遇到重复数据（也就是环入口）。
  那么快慢指针的相遇点将移动m+4n步才能到达环入口（这里乘4是环有4个节点，n为一个正整数可以随机）

以上规律可以画图。附上官方代码如下：
```java []
class Solution {
    public int findDuplicate(int[] nums) {
        // Find the intersection point of the two runners.
        int tortoise = nums[0];
        int hare = nums[0];
        //下面的代码是为了找到相遇点
        do {
            tortoise = nums[tortoise];
            hare = nums[nums[hare]];
        } while (tortoise != hare);

        // 下面的代码是找环入口
        //根据慢指针到环入口的步长必定等于相遇点到环入口的边长+环的周长乘以一个正整数
        //最终快慢指针会相遇也就是相等
        int ptr1 = nums[0];
        int ptr2 = tortoise;
        while (ptr1 != ptr2) {
            ptr1 = nums[ptr1];
            ptr2 = nums[ptr2];
        }

        return ptr1;
    }
}

```


