### 解题思路
查找链表环入口点——看题解才知道可以用这种方法，理解了一下，整理出来。
#### 抽象为链表
首先是数组抽象成链表，长度n+1的数组内元素大小为1-n，那么可以形成$(i,v_i)$的二元组，那么可以将数组值看为节点，通过二元组可以抽象构建出一个链表，头节点为0。例如`nums = [6,6,5,4,3,2,1]` , 存在`(0,6)->(6,1)->(1,6)`,抽象成链表即为`0->6->1->6`，出现循环，循环入口是6.
循环的入口表示某一个索引对应的值与另一个索引对应的值相等，由于初始节点0不存在前置节点，因此循环的产生不是自循环的结果，是由重复数值导致的结果。问题被转换为寻找链表的环入口点。
#### 寻找链表环的入口点：
假设从起始点到入口点的长度为$a$，环的长度为$b$。
1. `慢指针`步长为1，`快指针`步长为2，当两指针进入环时`快指针`会追上`慢指针`，相遇时两指针距离下次到达环入口点距离为$a$。(可以先假设`慢指针`到到入口点时，`快指针`在环内走到a的位置，距离`慢指针`距离为$b-a$，由于`快指针`速度为`慢指针`两倍，因此下次相遇时`慢指针`在环内走了$b-a$步，距离下次到达环入口点距离为$a$.)
2. 此时从链表起点到环入口点和从相遇点到环入口点距离相同都为$a$，因此`起点指针`与`相遇指针`以相同速度再同时前进，相遇时点即为环的入口节点，即重复数。

### 代码

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0, fast = 0;
        do{
            slow = nums[slow];
            fast = nums[nums[fast]];
        }while(slow != fast);
        int before = 0, after = slow;
        while(before != after){
            before = nums[before];
            after = nums[after];
        }
        return before;
    }
}
```