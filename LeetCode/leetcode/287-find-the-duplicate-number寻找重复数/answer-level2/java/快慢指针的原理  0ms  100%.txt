**要求：寻找重复数：要求时间小于O（n^2），空间为O（1），且不能改变原数组的值。**
这里一共有n+1个元素，且元素的值为 [ 1 , n ]，因此这里把下标i当做结点的标志，nums[ i ]当做是结点i的下一个结点的标志。这样从结点1到结点n中的任一个结点开始跳，必然会出现两种情况：

    1.形成局部环（循环起始点不是初始点）  
    2.形成全局环（循环起始点是初始点）
![环.PNG](https://pic.leetcode-cn.com/a0fe4f6a5ed08019933a0d66cae7212dc0721da557cf665a56672da50cd6715e-%E7%8E%AF.PNG)

情况1：如果是局部环，那么循环起始点的标志就是重复数字。
情况2：如果是全局环，则稍微复杂一点，因为它只能说明环内的结点所对应的值不重复，但整个全局环不一定包含所有结点。为了判断是否含有重复，还需要从剩下的点继续跳。

解决办法：由于情况2比较难处理（因为要判断剩余的结点是哪些），因此这里有一个小小的tips，**我们不再是从结点1到结点n中任意位置起跳，而是从结点nums[ 0 ]起跳，这样即使形成的是全局环，循环的起点依然是重复数字（因为全局环意味着环内的末节点指向初始结点，而结点0又指向初始结点，因此，初始结点即循环起始点就是重复数字）。这样，无论情况1还是情况2，我们只需要找到循环起始点就可以了。**

    而如何找到循环起始点，可以参考第142题的Floyd 算法。
具体代码如下
```
class Solution {
    public int findDuplicate(int[] nums) {
        //先让快慢指针相遇
        int slow=nums[0];
        int fast=nums[0];
        while (true){
            slow=nums[slow];
            fast=nums[nums[fast]];
            if(slow==fast) break;
        }
        //弗洛伊德算法找到循环起始点
        int p1=nums[0];
        int p2=slow;
        while (p1!=p2){
            p1=nums[p1];
            p2=nums[p2];
        }
        return p1;
    }
}
```
