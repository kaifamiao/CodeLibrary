### 解题思路
看了官方解法才反应过来，这就是利用快慢指针求有环单链表的入口问题。

先简单讨论一下快慢指针法为啥能找到链表环的入口。
![链表-环入口.png](https://pic.leetcode-cn.com/e2d1b8b602bf39c10d5f9c5f76706f1b50a0ecf87fa89b6214514857b57ae6bf-%E9%93%BE%E8%A1%A8-%E7%8E%AF%E5%85%A5%E5%8F%A3.png)
如图所示，直链上x个节点，环上y个节点，快慢指针都从起始节点出发，慢指针每次往下移动一个节点，快指针每次移动两个节点的距离。显然，最终两者一定都进入环中，而且必定会相遇。假设第一次相遇的时候，慢指针走了x+k的距离，即快慢指针在环上第k个节点上首次相遇。

快指针走的是慢指针的两倍，所以走了2x+2k。由于快指针先进入了环，所以肯定是在环上绕了几圈后与慢指针相遇，假设快指针多绕了m圈，所以有 2x+2y - (x+k) = my，即x+k = my

这个等式的含义是，一个指针以每次一节点的速度从起始节点往下走x+k距离时，正好也可以绕环走整整m圈。

所以如果又摆上两个慢指针p1和p2，p1从起始节点出发，p2从环上第k个节点出发，最终p1走了x步时达到入环节点时，p2正好也位于入环节点(p2也走了x步，或者说是my - k步)

这意味着可以由上述过程确定入环节点的位置。


至此讨论完链表入环节点求解过程，本题其实完全一样。下标为i的节点的next指针指向下标为arr[i]的节点。起始节点是arr[0]，由于数组最小值不小于1，所以永远不会有节点的next指针指向0位置节点。而如果arr正好装了1~n，则一定是形成一个或多个单链表，不会出现环。而如果有一个数字出现的重复，则说明至少有2个位置指向了同一位置，所以会形成环。而且指向的位置一定是入环点，只有入环点才会有至少两个节点的指针指向它。

最后，入环点的下标就是所求的重复数字。

### 代码

```java
class Solution {
    // 还是有点类似在arr数组上循环怼的技巧，但因为不能修改arr，所以解法不同
    // 把下标间的跳转看作链表，arr中只有一个重复数字时，arr数组实际上是多个链表
    // 其中有且只有一个链表是有环链表，重复数字代表的节点都在环上
    // 所以利用了快慢指针找链表环入口的技巧
    // 
    // 快慢指针法：快指针一次走两步，慢指针一次一步，快慢指针最终在环上某一点x相遇
    // 指针1从头再出发，指针2从x处开始走，都是一次走一步，最终两者在入环点相遇

    // 在本题，入环点就是下标==重复数的值num的节点，因为只有此下标对应的节点会有两个以上的其他节点指向它
    public int findDuplicate(int[] arr) {
        // 选择从arr[0]出发也是很讲究的，因为arr中最小值顶多是1，没有任何可能再回到0下标位置
        int fast = arr[0], slow = arr[0];
        do{
            fast = arr[arr[fast]];
            slow = arr[slow];
        } while (fast != slow);

        int p1 = arr[0], p2 = fast;
        while(p1 != p2){
            p1 = arr[p1];
            p2 = arr[p2];
        }
        return p1;
    }
}
```