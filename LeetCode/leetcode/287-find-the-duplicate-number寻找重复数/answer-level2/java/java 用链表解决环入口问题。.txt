主要分两部分：
#链表成环
明明题目是数组，为什么说到链表了呢？其实数组的下标和数值可以组成一个链表的。数值是下一个链表的指针。下标作为当前链表的值就可以了啊。
我先画个图大概理解下怎么把数组理解成链表
![数组抽象成链表](https://pic.leetcode-cn.com/224df3b2c8f356d8e6f0605da407a4a1ebef81505c4b00cd98cf0746c8c13d7b-file_1585733871234)
如上图，其实我一开始看的时候也不太理解，但是画了几个图才发现，链表一定是有环的，因为下标是从0开始，而数值是从1开始。所以第一步一定是能走出去的！
这个时候指针已经指向下一个了，像8这种自循环的不会被指到，所以也不会是重复的值。我们只要顺着指针往下指，哪怕指到自循环了那么更好了，直接说明这个数重复出现了（别的下标有这个值，这个下标还是这个值，直接就是出现了两次嘛！）
所以放心，只要有重复的值，肯定是有环的。我们现在要做的是从起点开始，快慢指针找到环的交点！
#环的起点
其实这个题我们做过的，当时我也是理解起来比较慢还手动画了个图，就是怎么根据环的交点判断起点的，这里也贴一下：
![快慢指针从交点找环起点](https://pic.leetcode-cn.com/7da98a78bdb93c74d01374976ede77d6546b91aea290d929a63cb48f64f7cc0e-file_1585733871237)
如图，红色是慢指针，红+绿是快指针。因为快指针一次两个，慢指针一次一个。所以红色和绿色是相等的。
然后因为环的起点到交点是一一段共同路径（慢指针走一遍，快指针走了两遍），所以红色实线和绿色实线也是相等的。
此时如果快指针从b开始，再来一个指针从起点开始相同速度走，最终实线会同时走完，并且两个指针肯定相交在环的入口处。

所以这道题就分两步：找到环形交点，找到环的起点。
环的起点就是这个重复元素。
下面是代码实现：
```
class Solution {
    public int findDuplicate(int[] nums) {
        int slow = 0;
        int fast = 0;
        while(true){
            slow = nums[slow];
            //这个下标的下标就相当于走了两步
            fast = nums[nums[fast]];
            if(slow == fast){//相交了
                fast = 0;//从头开始走
                while(slow != fast){//slow == fast 说明相交于环的起点了
                    fast = nums[fast];
                    slow = nums[slow];
                }
                return slow;
            }

        }
    }
}
```
思路清晰了代码其实不难，不过我还是调试了很多次，关于slow值和nums[slow]这类的，while条件是带nums[slow]这类的，返回也要这要的，比较的是直接量，返回的也要是，只要统一了就行了。
这个题乍一看简单，所有的约束条件都用上了的话真的有点烧脑啊，其实环找入口不用额外空间是做过的，但是没和这个题联系起来。还是做题少，见得少。