本题大部分python题解都提到了`return " ".join(s.split()[::-1])`，但很明显这题考的不是这样秀函数。

观察题目，可用快慢双指针解法来解，思路如下：

1. 慢指针`j`是一个状态（`s[i]`为空格或不为空格），
2. 快指针`i`也是一个状态（`s[j]`为空格或不为空格），
3. 当`i`和`j`状态相等，`s[j:i]`是不可分割的片段，即`s[j:i]`全为空格或全为字符；
4. 随着i的推移,当i和j状态不相等，`s[j:i]`就是一个完整的不可分割片段，慢指针`j`就要更新：`j=i`，并且若它是纯字符串，就需要加入到结果字符串中。
5. 快指针`i`遍历所有字符，遍历完成，结果字符串也生成了。

有了上面的思路，我们参考[双指针经典题目的经典解法，适合新手小白！](https://leetcode-cn.com/problems/max-consecutive-ones/solution/shuang-zhi-zhen-jing-dian-ti-mu-de-jing-dian-jie-f/)中的套路代码，写下如下结果代码：
```
class Solution:
    def reverseWords(self, s: str) -> str:

        if len(s)<1:return '' ## 业务代码： 特殊情况
        elif s[-1]!=' ':s=s+' ' ## 业务代码： 体现末尾的状态变化
        else: s=s+'a' ## 业务代码： 体现末尾的状态变化

        j = 0 ## 套路代码：初始化慢指针
        rst = ''## 套路代码：初始化结果
        for i in range(len(s)):## 套路代码：初始化快指针
            if ((s[j]==' ')!=(s[i]==' ')):## 套路代码：构建慢指针更新的触发条件                
                if s[j]!=' ':rst = s[j:i] + ' ' + rst  ## 业务代码
                j = i ## 套路代码：更新慢指针

        return rst[:-1] ## 业务代码：避免第一次执行`if s[j]!=' ':rst = s[j:i] + ' ' + rst`时多一个空格
```
执行用时 :56 ms, 在所有 Python3 提交中击败了45.66%的用户
内存消耗 :14.3 MB, 在所有 Python3 提交中击败了5.02%的用户

虽然效果一般般，但足够在面试时候用了！