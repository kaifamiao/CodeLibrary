#### 复杂度

计算复杂度最坏 $O(v n)$，平均 $O(v^2n/a)$，空间复杂度 $O(2^v)$。
其中，$v$ 指代元音数量 5，$n$ 指代字符串长度，$a$ 指代字母表数量 26。

看到大佬们都是用移位的哈。这真的是因为我不是程序老手，因此非常不习惯用移位操作，并且习惯性地多占用空间，才会想到此下策。

#### 简单例子：单个元音

我们先拿一个简单的例子吧，我曾经一次测试栽在 `"amntyyaw"` 上了。这个例子也足够简单，因为只有一个元音。

我们声明一个字母的状态是，从第一个字母到某一个位置时，元音出现的次数奇偶性。在这个简单的例子中，我们可以用 0/1 代表奇偶性。
但是我 (可能一个不太好的做法) 会尝试保存两种位置信息，一种是 **填入字母前** 的奇偶性，一种是 **填入字母后** 的奇偶性。以 `"amntyyaw"` 为例：
```
 0 1 2 3 4 5 6 7  // 索引
"a m n t y y a w"
 0 1 1 1 1 1 1 0  // 填入字母前的奇偶性
 1 1 1 1 1 1 0 0  // 填入字母后的奇偶性
```
如果我们希望得到一个 *包含偶数 a 字母* 的字符串，那么这个字符串对应的 **首字母填入前** 的奇偶性与 **尾字母填入后** 的奇偶性需要是相同的。譬如 0-6 字母组成的 `amntyya` 就是一个例子，首字母填入前与尾字母填入后的状态均是 0。

这也就意味着，撇开冗余的信息，我们真正关心的状态如下所示：
```
 0 1 2 3 4 5 6 7  // 索引
"a m n t y y a w"
 0 1              // 填入字母前的奇偶性
           1   0  // 填入字母后的奇偶性
```

我们就开一个状态变量 `vector<pair<int, int>> stat`，其中 `stat[0]` 是偶数次 `a` 出现的情形，`stat[1]` 是奇数次 `a` 出现情形。
- `stat[0] = (0, 7)`，意味着第一次 **字母填入前** 状态为 0 (`a` 出现偶数次) 的索引是 0 (字母 `a`)，最后一次 **字母填入后** 状态为 0 的索引是 7 (字母 `w`)。
- `stat[1] = (1, 5)`，意味着第一次 **字母填入前** 状态为 1 (`a` 出现奇数次) 的索引是 1 (字母 `m`)，最后一次 **字母填入后** 状态为 1 的索引是 5 (字母 `y`)。

最终，我们遍历一遍所有 `stat[i]` ($i = 0, 1$) 的 `pair<int, int>` 前后两数的差补 1 即可。
- `stat[0]` 是 7 - 0 + 1 = 8，意味着状态为 0 的最长字符串是 `"amntyyaw"`；
- `stat[1]` 是 5 - 1 + 1 = 5，意味着状态为 1 的最长字符串是 `"mntyy"`。

那么，返回的最终结果就是上述值中最大的一个，即 8。

对于我来说，分析整个问题的最大难点在于这里，而不是程序编写。这感觉也不是一句这道题是动态规划就能悟到的。我花了很长一段时间，在纠结到底我们保留的状态是填入字母前的，还是填入字母后的。我现在认为，这两者都需要保存，但都只需要保存一个值即可。


#### 另一种理解方式：单个元音

这段参考了 [mnizy](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/jian-dan-de-si-lu-by-mnizy/) 的题解。

我们仍然拿 `"amntyyaw"` 为例。我们只记录填入字母后的奇偶性；但引入 `-1` 位的字符串索引：
```
 -1 0 1 2 3 4 5 6 7  // 索引
"   a m n t y y a w"
  0 1 1 1 1 1 1 0 0  // 填入字母后的奇偶性
```
那么我们能得到，状态为 0 的最大索引差是 7 - (-1) = 8，而状态为 1 的最大索引差是 5 - 0 = 5。因此也能得到答案为 8。这与上面的做法是等同的，但更为简洁。

我自己在写代码的时候，尚没有按照这种做法来实现。


#### 例子与代码说明：多元音情形

在我看来，多元音的问题没有比单元音复杂，只是程序上需要一些技巧。

首先，我们需要对字母所处的状态进行合适的编码。尽管 `vector<bool>` 也是可以的，但我们还是使用数字编码。譬如，现在 `a, o` 出现了奇数次，其余字母出现了偶数次，那么我们对其表示如下：
```
u o i e a
0 1 0 0 1  // 每个元音的奇偶性
```
二进制编码是非常合适的。因此，我们可以将 `01001` 转为二进制 `9`。

即使两个字母的状态相差得不大，只要有差别，就是两个不同的状态。譬如说对于字符串 `"aetae"` 的子字符串 `aeta`，
```
    "a e t a e"
  a  0     0   // +: 字母填入前该索引的状态
  e  0     1   // -: 字母填入后该索引的状态
iou  0     0   // *: 被编码后的元音状态
  *  0     2
     +     -
```
即使上述两个状态中，只有 `e` 有差别，但不能被认为相同的状态，`aeta` 也不是符合题意的每个元音都包含偶数个的子字符串。

- `aeiou_to_int` 就是在做这件事。`aeiou_to_int([F,T,F,F,T]) = base2(01001) = 9`；
- `cur_aeiou` 则是保存当前元音状态的变量，譬如 `[F,T,F,F,T]`；
- `int_aeuou` 是为了程序效率引入的变量：只有当扫描字符串 `s` 遇到元音时，才需要真的更新元音状态的编码，譬如 `9`。
    由于只有五个元音字母，因此最大不值超过 31。这也是能硬编码 `stat` 状态信息为长度 32 的向量的原因。

对元音状态能编码之后，剩下的事情就与单元音的情形没有区别了。
其余的代码细节在代码中就有所注释了。


#### 代码

程序并非是在比赛时间内完成的，差了一分钟啊 hh
我甚至会反而觉得后面两道树的题目更简单啊，是我的错觉吗 T.T

执行时间 164ms 左右

```c++
class Solution {
    /// 将元音的状态进行编码
    int aeiou_to_int(const vector<bool>& b) {
        int r = 0, m = 1;
        for (auto v : b) {
            if (v) r += m;
            m *= 2;
        }
        return r;
    }
public:
    int findTheLongestSubstring(string s) {
        int INVALID = -1;
        unordered_map<char, int> aeiou = { {'a', 0}, {'e', 1}, {'i', 2}, {'o', 3}, {'u', 4} } // 需要后接分号
        vector<pair<int, int>> stat(32, {INVALID, INVALID});  // 保存的状态信息
        vector<bool> cur_aeiou(5, false);                     // 当前的元音状态
        int int_aeiou = 0;                                    // 编码后的元音状态
        // 扫字符串以更新状态信息
        for (int idx = 0; idx < s.size(); ++idx) {
            if (stat[int_aeiou].first == INVALID)
                stat[int_aeiou].first = idx;                  // 只有第一次遇到状态时，才需要记录*第一次字母填入前索引*
            if (aeiou.find(s[idx]) != aeiou.end()) {
                cur_aeiou[aeiou[s[idx]]] = !cur_aeiou[aeiou[s[idx]]];
                int_aeiou = aeiou_to_int(cur_aeiou);          // 只有字母是元音的情形下，才需要更新元音状态的编码
            }
            stat[int_aeiou].second = idx;                     // 字母索引 idx 只会越来越大，因此每次都记录当前索引 idx 下的*最后一次字母填入后索引*
        }
        // 从状态信息中，作*最后一次字母填入后索引*与*第一次字母填入前索引*的差减，得到结果
        int result = 0;
        for (int i = 0; i < 32; ++i) {
            if (stat[i].first == INVALID || stat[i].second == INVALID)
                continue;
            int r = stat[i].second - stat[i].first + 1;
            result = max(result, r);
        }
        return result;
    }
};
```