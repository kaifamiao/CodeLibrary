个人认为其实贪心和动态规划是很相似的两种算法，其特点都是如果时间复杂度特别高，尤其是针对枚举的题目，往往需要考虑

用这两种算法。

那么我寻思着，动态规划似乎没办法找到合适的转移方程，根据其特点，要求找到最小的数。

根据数要求最小的特点，可以有这么一条结论：最高位最小，次高位最小，以此类推，得到的必然是最小值。

根据1432219，我们首先删除其中一个，毫无疑问可以发现132219最小，我们需要从最高位开始删除。能够占据最高位的，只

有1和4(删除1后，占据)，显然1是不能够删的。

紧接着考虑次高位，4和3占据，4可以删。

所以我们还可以得到这么一条结论：第i个数字其实可以占据i-1和i位。

从头往后扫描，我们依次删除，A[i]>A[i+1]的中的A[i]。

然后再去考虑边界情况。

很显然，我们需要着重讨论数字0，比如说10010，第二位0加入，第一位的1会被删除。0会到首位，显然0的存在是多余的。

我们就判断新的数组如果为空，且当前需要加入的数字为0那么不加入。

我发现这一整串的过程，其实是入栈和出栈的过程。贪心往往也和栈联合使用。因为栈是很有利用筛选极大值极小值的。
```
char * removeKdigits(char * num, int k){
    int length=strlen(num),top=-1,i=0;
    char *stack=(char *)malloc(sizeof(char)*(length+1));
    for(i;i<length;i++)
    {
        while(top!=-1&&stack[top]>num[i]&&k>0)//出栈
        {
            top--;
            k--;
        }
        if(num[i]!='0'||top!=-1)//入栈，删除了0之前的所有有效数字就不入栈
        stack[++top]=num[i];
    }
    while(k>0&&top>-1)
    {
        top--;
        k--;
    }
    if(top==-1)//里面空空如也
    stack[++top]='0';
    stack[++top]='\0';
    return stack;
}
```
