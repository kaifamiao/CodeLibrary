### 思路
怎样移除才能得到最小的结果呢？
> 起初以为用最小堆做，保存子串中最大的k个，最后删除就好了。

虽然大方向(去除最大，保留最小)是对的，但是由于子串相对顺序不能改变，我们不能保证**去除较大之后的组合**比**包含较大元素的组合小**。

比如
```
221133 k=2
```
去除33后的2211并不比1133小。原因在于并没有按照顺序从左到右选取较小的值。

> 于是我们明确了思路，从左到右寻找较小的值，把找到值的下一个作为左限再次查找，直到找齐n-k个。然后去除前导零。

但需要注意的一点是，我们需要保留足够的值供下一次选择。什么意思呢，我们再来看一个例子。
```
223311 k=2
```
如果只是从左向右找较小值，我们找到11之后就到头了，没法再找第3,4个数了。这就需要我们为范围定义右限。它需满足的条件是:
> n-i<=n-k-s.size()

左边表示目前到尾部还有多少个数字。右边表示我们还需多少个数字才能找齐n-k个。化简后就是
> i<=k+s.size()

看了题解，应用了单调栈的思路就相当简洁了。它的正确性可以这样想：
> 只要k不为零，我们就可以通过减少k来将较小的值替换到栈顶(所谓单调栈),这样高位就获得了较小值。而一旦k为0了，说明已经找到所有需要移除的数了，余下的直接添加到结尾即可。
### 代码
```c++
class Solution {
public:
   	string removeKdigits(string num, int k) {
		int n = num.size(), cur = 0;
		string s;
		if (n == k) return "0";

		while (cur<n&&s.size() < n - k){//外层遍历找n-k个值
			int ans = INT_MAX, i = cur;
			for (; i<n&&i <= k + s.size(); i++){//每次从cur开始找最小值，注意右限。
				if (ans>(num[i] - '0')){
					ans = num[i] - '0';
					cur = i + 1;
				}
			}
			if (ans != INT_MAX)
				s.push_back(ans + '0');
		}

		cur = 0;
		while (cur<s.size() - 1 && s[cur] == '0') cur++;

		return s.substr(cur);
	}

};
```
