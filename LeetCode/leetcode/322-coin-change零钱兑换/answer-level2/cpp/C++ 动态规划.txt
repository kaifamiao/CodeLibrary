* 问题分解
以 coins = [1, 2, 5], amount = 11 为例，
（1）11可以分成10+1, 9+2, 6+5三种情况，所以我们要求11元的最小零钱兑换，实际上是在求10，9，6的最小零钱兑换 + 1.
那么10又可以分成9, 8, 5三种情况，求解方法同上。直到不能再分解——也就是 1，2，5，或者-1。然后再回溯，就能够求得11元的最小零钱兑换。
上述是一种至顶向下的思想，那么如何使用至底向上的方法的呢？ 也就是从1，2，一直递推到...11。
__动态规划__的思想__那就来了__。方法和（1）类似，但是可以从1开始，慢慢求到11.
举个例子：
1 可以分解成 0+1， -1+2， -4+5， 显然，在生活中负数的情况只有你长得帅别人才会给你倒贴。所以负数的情况都剔除，想都不要想，做梦。
2 可以分解成 1+1， 0+2， -3+5， 显然 1的情况我们在上一步求得， 0的情况就是等价交换。同样，倒贴的事情还是先别想。
...
11 可以分解成 10+1， 9+2， 6+5， 很不幸, 10、9、6 我们在之前的工作中都尝试过了，直接用！
* 上代码
```
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) 
    {
        vector<int> dp(amount+1);
        dp[0] = 0;
        for(int i=1; i<=amount; i++)
        {
            int min = INT_MAX-1;
            for(auto n: coins)
            {
                if(i - n >= 0)
                    min = dp[i-n] < min ? dp[i-n] : min;
            }
            dp[i] = min + 1;
        }
        if(dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```