确定状态： 
    最优策略 ： 组成 counts的最少硬币数k
    最后一步： 在最优策略下，前K-1步，拼出27-coins[i]的最少硬币数
    原问题是求:  求组成 counts的最少硬币数k
    子问题： 求 组成 counts-coins[i]的最少硬币数l+1
    f[27]= min(f[27-2]+1 ,f[27-5]+1, f[27-7]+1)
    确定de状态：f[i] 表示组成 i的最少硬币数
转移状态：
f[i]= min(f[i-2] ,f[i-5], f[i-7])
初始条件： 
 	f[0]=0;
边界条件： 
    防止数组越界
    写代码时，边界条件一般都写在for循环中  通过if语句判断
特别注意的：
1. 开辟数组的大小 是  M+1
2. 因为初始条件f[0]=0;所以外层for循环直接从1开始
3. 在代码中写 转移状态时，一定要考虑周全，把限制条件通过if 判断 =都考虑好 再进行