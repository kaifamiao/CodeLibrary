### 解题思路
一般来讲如果是求出多少种或者最少的情况最大情况,也就是返回值是一个整数的题目,应该是优先考虑使用动态规划的方法,如果是让求出所有的集合,一般来讲使用回溯法.回溯的法的话我们需要进行剪枝来降低其事件复杂度.
这道题显然使用动态规划来求解.动态规划实际上就是反向来的递归求解,递归求解是从最大索引往前面求,出现了很多的重复计算,而动态规划是从0索引开始往做大的索引计算,这样可以避免大量的计算但是这样子的算不容易想到,因此我们可以先从递归的想法出发然后将其转化为动态规划的解法.
动态规划一般分为3个步骤
    1.写出数组来表示要求的结果,要想清楚每一个元素代表什么意义
    2.给一些特殊的元素赋初值,比如如果是一位数组的话我们常常考虑是不是可以直接写出0的值,如果是二维数组的话我们首先考虑是否可以给第一行或者第一列或者对角线上面的数赋值
    3.写出转移方程,一般来讲就是dp[n],dp[n-1] 之间的关系,具体问题具体对待,类似于数学归纳法的含义.可以对递推出来结果.

### 代码

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        //这里使用动态规划还是回溯算法呢 ,讲道理应该是是动态规划来计算用法
        //对于所有可能的硬币之后先减去这个然后计算剩下的递归的算法
        //创建数组来存储最后的结果
        if (coins.length==0) return -1;
        int[] dp = new int[amount+1];
        //给数组附上初值
        // for(int i=0;i<dp.length;i++){
        //     dp[i]= Integer.MAX_VALUE;
        // }
        Arrays.fill(dp,amount+1);
        dp[0]=0;
        //循环遍历来求数组的值
        for(int i=1;i<dp.length;i++){
            for (int coin:coins){
                if(i<coin){
                    continue;
                }
                dp[i]=Math.min(dp[i],dp[i-coin]+1);
            }
    }
    return dp[amount]== amount+1 ?-1:dp[amount];

    }
}
```