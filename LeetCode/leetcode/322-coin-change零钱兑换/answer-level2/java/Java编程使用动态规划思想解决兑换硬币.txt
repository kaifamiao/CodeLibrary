### 解题思路

先给出代码执行效率结果：
执行用时 :14 ms, 在所有 java 提交中击败了78.44%的用户;
内存消耗 :35.9 MB, 在所有 java 提交中击败了94.99%的用户;

采用动态规划的解题思路需要符合三个特点，分别如下：
**（1）存在重叠问题**（因为对于适合于动态规划的问题来说，使用递归方法让计算机去穷举会让很多子问题重复计算，使得算法执行效率极其地下，所以我们一般采用“备忘录”或者以空间换时间的“动态规划”方法来解决）；
**（2）符合最优子结构**（子问题之间是相互独立，互不影响的；如果子问题之间成为相互制约因素，则说明不符合最优子结构）；
**（3）能够列出状态转移方程**（顾名思义就是能够将几个状态进行推导的方程）；

**本题“零钱兑换”**，恰好符合上面所说的动态规划三个特征；
（1）首先，你想求amount = 11时的最少硬币数（原问题），如果你知道凑出amount = 10的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案，因为硬币的数量是没有限制的，子问题之间没有相互制，是互相独立的；
（2）其次，如果采用递归方法，会发现其中存不少子问题重叠的，比如你要求amount == 11最好硬币数，此时硬币的面值数组为coins = [1, 2, 5], 所以在求amount = 10和 amount = 9的时候都会重复去计算 amount = 1, 2, 5这些子问题；
（3）根据状态的定义，本题中硬币数量没有限制，唯一对组成最后钱币结果有影响的就是面值本身，所以比较容易可以想到，对于钱币i,能够组成其最小数量F(i)等于其前面能够组成数量 + 1， 即为:

```
// coins为钱币面值数组
for coin : coins
    F(i) = min(F(i), F(i - coin) + 1);
```
由于我们需要自底往上来递推这个方程，所以在最外面我们需要从amount = 1, 2, 3... 11(从"1"元至"11"元);
在下面的代码中需要注意的是:
**a.对于不符合条件的硬币面值直接剪枝;**
**b.初始化时候amount = 0, 状态转移方程值F(0) = 0， 因为金额为0 不需要任何硬币组成；**

时间复杂度: O(kn), 子问题总数不会超过金额数 n，即子问题数目为 O(n), 处理一个子问题的时间不变，仍是 O(k)，所以总的时间复杂度是 O(kn);
空间复杂度: O(n);

### 代码

```java
class Solution {
    public int coinChange(int[] coins, int amount) {

        // 0.因为凑成amount金额的硬币数最多只可能等于amount（全用 1 元面值的硬币），
        // 所以初始化为amount + 1就相当于初始化为正无穷，便于后续取最小值;
        int max = amount + 1;
        // 1.dp[i] = x表示，当目标金额为i时，至少需要x枚硬币
        int[] amounts = new int[amount + 1];

        Arrays.fill(amounts, max);
        // 2.这里很明显在目标金额为0的情况下, 需要0枚硬币即可;
        amounts[0] = 0;
        // 3.然后从底部向上, 也即为从目标金额为: "1"开始至"amount"来推目标状态值
        for (int i = 1; i <= amount; i++) {
            // 3.1 对于每一个金额amount, 枚举所有的硬币面值
            for (int j = 0; j < coins.length; j++) {
                // 对于不符合条件的直接剪枝；
                if (i >= coins[j]) {
                    // 3.2 利用上面推到出来的动态规划状态转移方程；
                    amounts[i] = Math.min(amounts[i], amounts[i - coins[j]] + 1);
                }
            }
        }

        return amounts[amount] > amount ? -1 : amounts[amount];
    }
}
```