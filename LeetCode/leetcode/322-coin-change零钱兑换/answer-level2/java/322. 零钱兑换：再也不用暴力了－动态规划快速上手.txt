### 解题思路
这道题用暴力法（递归）肯定是可以做出来的，但是暴力法实在太暴力了，自从学了动态规划，就在也不想用暴力了
这道题就是动态规划的常见适用题型：求最小值问题
第一步：确定状态
    最优策略的最后一步：就是最后一枚硬币，除去最后一枚我们选择的硬币，前面的选择仍然是最优解，不管最后一枚硬币是选的什么类型的面值，都需要我们选择这一枚硬币
    子问题：我们出去最后一枚硬币，剩余的问题仍然跟原文题是一样的，只是我们要求的范围缩小了，假设最后一枚硬币面值为X,则我们目前的问题就是：求最少数量硬币组合，总面值为 amount-X，最后求出的硬币数量+1，就是本题的结果
第二步：列出转移方程
    从最小子问题哪里我们已经可以大致猜出来转移方程了，F[X]=min{F[X-coins[0]]+1,F[X-coins[1]]+1,...,F[X-coins[n-1]]+1}，其中X为总金额，这里感觉有点像递归，但是递归会出现大量的重复情况，这里不会出现重复情况，这就是动态规划跟递归的区别
    但这里其实大家就可以把本题用动态规划写出来了，但是会有一些边界和初始化问题
第三步：确定初始条件和边界条件
    本题初始条件：F[0]=0，即0元，需要0枚硬币，其实可以用转移方程算出来
    边界条件：比如：如果不能拼出Y元来，应该怎么办？可以设置F[Y]=正无穷，就是代码中设置的Integer.MAX_VALUE
最后一步：确定计算顺序，本题自然就是从小到大的计算，因为大的值需要在小的值的基础上计算出
        动态规划基本都是从小到大，从左到右，从上到下的这种，不过也有特例

### 代码

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int f[]=new int[amount+1];
        int n=coins.length;
        f[0]=0;
        for(int i=1;i<=amount;++i){
            f[i]=Integer.MAX_VALUE;
            for(int j=0;j<n;++j){
                if(i>=coins[j]&&f[i-coins[j]]!=Integer.MAX_VALUE){
                    f[i]=Math.min(f[i-coins[j]]+1,f[i]);
                }
            }
        }
        if(f[amount]==Integer.MAX_VALUE){
            return -1;
        }
        return f[amount];
    }
}
```