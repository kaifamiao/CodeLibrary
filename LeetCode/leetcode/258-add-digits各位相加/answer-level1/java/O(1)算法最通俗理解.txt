## 方法一：

普通方法，循环加递归
```
class Solution {
    public int addDigits(int num) {
        int sum = 0;
        while(num != 0){
            sum = sum + (num % 10);
            num = num / 10;
        }
        if(sum >= 10){
            sum = addDigits(sum);
        }
        return sum;
    }
}
```
## 方法二：
看了不少O(1)算法的解释，都很难懂，这里自己总结一个。

1、我们只需要按照正常的思路想，比如给定一个整数abc，我们要计算各位相加的和，也就是要获取a+b+c的值。

2、拆分一下：
abc=100\*a+10\*b+c=99\*a+9\*b+a+b+c（当然要想到这个式子就需要一点灵感了）

3、这里构造出了a+b+c的形式，我们用这个式子对9求余，也就是%9，可以得到：
abc % 9 = (a+b+c) % 9

4、这里就有了a+b+c的效果，只是多了一个%9。这里我们分析一下：
第一种情况，如果a+b+c此时符合要求（也就是说小于10，是一位数），那么他再次%9的结果还是他自己，直接返回，此时这个%9并不影响我们获得a+b+c的值。
第二种情况，如果a+b+c还是大于等于10（两位数），那我们正常就应该重复上述操作，也就是按照前面的拆分办法（在新的整数上寻找新的a+b+c），那么也就会再次%9（得到新的我们想要的a+b+c），以此往复，直到出现第一种情况为止。

5、唯一要注意的是，如果a+b+c=9，那%9结果为0，但我们不希望返回0，这种情况直接返回9即可

```
class Solution {
    public int addDigits(int num) {
        if(num == 0){
            return 0;
        }
        num = num % 9;
        if(num == 0){
            return 9;
        }
        return num;
    }
}
```