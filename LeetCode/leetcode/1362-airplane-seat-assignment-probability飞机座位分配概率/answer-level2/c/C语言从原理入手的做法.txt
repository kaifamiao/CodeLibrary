不难发现，当n的值为1时，概率为1，否则概率为1/2。如此看来，该程序一句话就能解决。
```c
double nthPersonGetsNthSeat(int n){
    return n==1?1:0.5;
}
```
但是，这样的做法不能体现背后的原理。下面给出的是根据背后的原理写出的程序。
```c
double nthPersonGetsNthSeat(int n){
    if(n==1) return 1;
    else return (1.0/n+(n-2.0)/n*nthPersonGetsNthSeat(n-1));
}
```
下面来介绍背后的原理。实际上，这是一个递归的问题。
给n位乘客编号，1号乘客的座位号为1，如此类推。不妨假设按乘客编号顺序入座。
1号乘客忘记了自己的座位号，所以他准备随机入座。将出现三种情况。情况一，1号乘客恰好坐到了1号座位，后续乘客将陆续入座，仿佛什么也没有发生；情况二，1号乘客恰好坐到了n号座位，接下来除了倒霉的n号乘客，大家都坐到了自己的座位上，n号乘客灰溜溜地坐到了1号座位；情况三，1号乘客既没有坐到1号座位，也没有坐到n号座位，而是坐到了2号座位（也可以是3号等等，但为了方便描述和喜剧效果，假定1号乘客坐到的位置就是2号），可以预见，接下来会出大乱了。
上述情形中，情况一和情况二出现的概率均为1/n，情况三出现的概率为(n-2)/n。
轮到2号乘客选座。其实，此时的情况与刚刚的情况是完全一样的。如果2号乘客坐到了1号座位，将不存在后续的混乱，此时不妨假设原1号座位就是2号乘客的，那么接下来的分析将与上述情形相同。为了便于理解，可以重新编号，原n号乘客变为n-1号，原2号乘客变为1号，其他乘客可以随便编排，当然，座位号也需要重新编排，从1号到n-1号，与乘客编号一一对应。
![新建 Microsoft PowerPoint 演示文稿.svg](https://pic.leetcode-cn.com/9b5797e3081cae21e8f5e3889ed1e9c9e85c46984e4f02e6ddcdf9776e20ee7e-%E6%96%B0%E5%BB%BA%20Microsoft%20PowerPoint%20%E6%BC%94%E7%A4%BA%E6%96%87%E7%A8%BF.svg)
如图，题目所求概率p为后面分叉的和。由于上述情况二n号乘客无论如何都无法坐到自己的位置，所以概率为零，图中已略去。
P.S.此题我提交的代码是从原理入手的代码，并没有遇到运行超时的问题，执行用时达到32ms，内存消耗达到9.8MB。

