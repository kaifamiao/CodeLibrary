很多人发现是 return n=1?1:0.5; 
这里用动态规划的思想讲讲复杂的分析过程：
dp[i]含义为，有i个人和i个位置，每个人都有期望到达的位置，最后第i个人到达期望的位置的概率。
注意，这里的期望到达的位置，不一定是自己本来应该坐的位置，只是我们作为安排者希望他坐的位置，比如：
剩下乘客1、2、3和座位1、2、3，他们的期望位置就是他们本来应该坐的位置；
但是，如果剩下乘客2、3、4和作为1、3、4，那么乘客3、4坐自己本该坐的位置，乘客2坐座位1也未尝不可。
那么，对于dp[i]来说，有三种可能：
1、前一个乘客坐了他该坐的位置，后面全部都能坐正确的位置，概率为 i/1 * 1 ；
2、前一个乘客坐了最后一个乘客的位置，那么无论如何最后一个乘客都坐不到正确的位置，概率为 i/2 * 0 ；
3、前一个乘客坐了其他位置，概率为 (1-i/2) * dp[i-1]。
代码如下：
```
class Solution {
public:
    double nthPersonGetsNthSeat(int n) 
    {
        vector<double> dp(n+1,0);
        dp[0] = 0;
        dp[1] = 1;
        for(double i=2;i<=n;i++)
        {
            dp[i]=(double)1/i;
            double a = 1 - 2/i;
            dp[i] += a*dp[i-1];
        }
        return dp[n];
    }
};
```
