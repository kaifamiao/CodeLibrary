### 解题思路
首先给出一行通过的代码如下：如果n为1那么返回百分百，其余条件返回0.50000，居然飞快地通过了，想也不用想时间空间复杂度肯定是非常令人满意的，那么严格证明是咋样的？为啥绞尽脑汁写一大堆不通过反而是随手瞎蒙的一行就通过了？这背后究竟是人性的扭曲还是道德的沦丧？试图挖掘一下其中的规律。
咳咳，言归正传，下面给出严格证明，从1~n开始我们遍历每一位乘客，n个值分别代表每个座位有人的概率值：
(1)我们从第一个乘客开始，第一个乘客登机，从n个座位随机选，选择每个座位的概率都是1/n;
(2)第二名乘客登机，第二个座位**有1/n的概率被占**和**(1-1/n)的概率为空**，为空的时候直接坐上去；**被占的情况下从剩下(n-1)个座位去找，于是剩下(n-1)个座位被占的概率是1/n(n-1)**，这一步非常关键！主要是考虑被占和不被占的两种情况，也是后续迭代的基础。
(3)第三名乘客同理，第三个座位被占的概率=((1/n)+(1/n*(n-1)))=1/n-1，为空的概率是n-2/n-1直接座，被占的情况下从剩下的(n-2)个座位里面找，剩下的(n-2)个座被占的概率是1/(n-1)(n-2)。
往后迭代发现第n个位置和第1个位置的被占概率计算是相等的，都等于:(1/n) + (1/n*(n-1)) + (1/(n-1)(n-2)) + ... + 1/(n-(n-2))(n-(n-1))，然后打开求和就是最终结果0.5。
 
![微信图片_20191219135044.jpg](https://pic.leetcode-cn.com/371e8f15a8e9575b395adf70be7d216b9b288cf3f597d37ea1b0a677bcdca024-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191219135044.jpg)
当然这个只是对这个题目的一个初步的想法，也不知道推导的结果是否正确，或许只是**误打误撞得到了正确结果**，欢迎大家讨论交流！(ﾉ≧∀≦)ﾉ
### 代码

```python3
class Solution:
    def nthPersonGetsNthSeat(self, n: int) -> float:
        return 1 if n == 1 else 1/2
```