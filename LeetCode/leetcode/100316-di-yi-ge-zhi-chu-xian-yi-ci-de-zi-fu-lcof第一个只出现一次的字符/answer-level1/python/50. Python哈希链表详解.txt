### 解题思路
我相信这道题对于绝大多数人都是so easy，但是我还是想和大家介绍一下哈希链表，因为这个数据结构是一个虽然用的人不多，但是在某些情况下是有奇效的。
哈希链表听起来就是哈希表和链表的结合体，其实事实也是如此，哈希表的每一个位置存放的实际上是一个链表的节点，这些节点又通过首尾相连形成**双向链表**，并且这个链表具有头结点和尾节点（头尾节点并不用哈希表进行索引，只是方便操作加入），大家可以想象一下，这样一个哈希链表在若干操作上具有O(1)时间复杂度：
（1）查找。查找自不必说，由于具有哈希表，当然具有O(1)的查找时间复杂度。
（2）删除。对于哈希表来说删除本来就是O(1)的，但是由于哈希表又索引到了链表，所以问题似乎并不是那么简单。但是别忘了索引的是双向链表，这样我们就可以保证删除操作也是O(1)时间复杂度。
（3）增加。对于增加操作来说，不管是哈希表还是链表都是O(1)的（注意：只是单纯在链表中添加节点），这个没什么可说的。但是，**在Python中**，对于字典dict的哈希表来说，存入键值对的顺序和输出的顺序是**不一定**一样的，这是因为根据哈希函数的不同，我们并不知道后插入的key的哈希值是否大于之前插入的key的哈希值，但是对于哈希链表来说，由于同时维护了链表，所以很容易维护输入的键值对的顺序，这也是哈希链表的一个重要特性。这道题的实现就利用了这个特性。

注：在Python中collections模块的OrderedDict类的实现其实就是一个哈希链表。

### 代码

```python
class Solution(object):
    def firstUniqChar(self, s):
        """
        :type s: str
        :rtype: str
        """
        if s == '':
            return ' '
        from collections import OrderedDict
        char_dict = OrderedDict()
        for ch in s:
            char_dict[ch] = char_dict.get(ch, 0) + 1
        for ch, cnt in char_dict.items():
            if cnt == 1:
                return ch
        return ' '
```