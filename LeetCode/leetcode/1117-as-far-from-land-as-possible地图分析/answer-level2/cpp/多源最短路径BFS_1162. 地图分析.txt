### è§£é¢˜æ€è·¯ä¸€ æš´åŠ›éå†
    /*
     * æš´åŠ›éå† è¶…æ—¶ O(n2)
     *
     * å…ˆå°†çŸ©é˜µä¸­çš„é™†åœ°ç‚¹(1)å’Œæµ·æ´‹ç‚¹(0)æ‰¾åˆ°ååˆ†åˆ«å­˜å‚¨åˆ°æ•°ç»„ä¸­ã€‚
     * å†ä»¥æµ·æ´‹ç‚¹æ•°ç»„ä¸ºæºç‚¹é›†ï¼Œæ‰¾åˆ°æ¯ä¸ªæµ·æ´‹ç‚¹åˆ°é™†åœ°ç‚¹çš„æœ€å°è·ç¦»ï¼Œ
     * è€Œæ¯ä¸ªæµ·æ´‹ç‚¹çš„æœ€å°è·ç¦»ä¸­çš„æœ€å¤§å€¼å°±æ˜¯æµ·æ´‹åŒºåŸŸå’Œæ‰€æœ‰é™†åœ°åŒºåŸŸä¹‹é—´çš„è·ç¦»æœ€å¤§å€¼ã€‚
     * */
### ä»£ç 

```cpp
int maxDistance(std::vector<std::vector<int>> &grid) {
    if (grid.empty()) {
        return -1;
    }

    std::vector<std::pair<int, int>> land;
    std::vector<std::pair<int, int>> ocean;

    for (int i = 0; i < grid.size(); i++) {
        for (int j = 0; j < grid[0].size(); j++) {
            if (grid[i][j] == 1) {
                land.emplace_back(i, j);
            }

            if (grid[i][j] == 0) {
                ocean.emplace_back(i, j);
            }
        }
    }

    if (ocean.empty() || land.empty()) {
        return -1;
    }

    int ans = 0;

    for (auto &i : ocean) {
        int temp = INT_MAX;
        for (auto &j : land) {
            temp = std::min(temp, std::abs(i.first - j.first) + std::abs(i.second - j.second));
        }

        ans = std::max(ans, temp);
    }

    return ans;
}
```

### è§£é¢˜æ€è·¯äºŒ å¤šæºæœ€çŸ­è·¯å¾„ -- BFS
æ¥è‡ªç”œå§¨çš„ç­”æ¡ˆ[ğŸŒŠç®€å•Java, ç§’æ‡‚å›¾çš„BFSï½](https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/jian-dan-java-miao-dong-tu-de-bfs-by-sweetiee/)


    /*
     * å¤šæºæœ€çŸ­è·¯å¾„--BFS O(n2)
     *
     * èƒ½å¤Ÿä½¿ç”¨BFSæ±‚æœ€çŸ­è·¯å¾„,å°†æ‰€æœ‰é™†åœ°ç‚¹å…¥é˜Ÿï¼Œå†ä»¥å„ä¸ªé™†åœ°ç‚¹ä¸ºæºç‚¹ï¼Œ
     * åŒæ—¶å¼€å§‹ä¸€å±‚ä¸€å±‚çš„å‘æµ·æ´‹æ‰©æ•£ï¼Œæœ€åæ‰©æ•£åˆ°çš„æµ·æ´‹å°±æ˜¯æœ€è¿œçš„æµ·æ´‹ã€‚
     * */
### ä»£ç 

```cpp
int maxDistance(std::vector<std::vector<int>> &grid) {
    if (grid.empty()) {
        return -1;
    }

    int rows = grid.size();
    int cols = grid[0].size();

    // æ‰©æ•£çš„å››ä¸ªæ–¹å‘
    int dx[4] = {0, 1, 0, -1};
    int dy[4] = {1, 0, -1, 0};

    // å­˜å‚¨é™†åœ°æºç‚¹çš„é˜Ÿåˆ—
    std::queue<std::pair<int, int>> que;

    // å°†æ¯ä¸ªé™†åœ°æºç‚¹å…¥é˜Ÿ
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            if (grid[i][j] == 1) {
                que.push(std::make_pair(i, j));
            }
        }
    }

    // ä»å„ä¸ªé™†åœ°å¼€å§‹ï¼Œä¸€å±‚ä¸€å±‚çš„éå†æµ·æ´‹ï¼Œ
    // æœ€åéå†åˆ°çš„æµ·æ´‹å°±æ˜¯æœ€è¿œæµ·æ´‹
    bool hasOcean = false;
    std::pair<int, int> point(0, 0);
    while (!que.empty()) {
        // å–é˜Ÿé¦–å…ƒç´ 
        point = que.front();
        que.pop();
        int x = point.first;
        int y = point.second;

        // ä»è¯¥æºç‚¹å¼€å§‹çš„å››ä¸ªæ–¹å‘éå†æµ·æ´‹
        for (int i = 0; i < 4; i++) {
            int newX = x + dx[i];
            int newY = y + dy[i];

            if (newX < 0 || newX >= rows || newY < 0 || newY >= cols || grid[newX][newY] != 0) {
                continue;
            }

            // ä¿®æ”¹åŸæ•°ç»„ï¼Œé¿å…é‡å¤éå†ï¼Œ
            // ä¸”æ¯æ¬¡å¢åŠ 1è¡¨ç¤ºè·ç¦»é™†åœ°çš„è·ç¦»
            grid[newX][newY] = grid[x][y] + 1;
            hasOcean = true;
            // å°†å…¶å››å‘¨çš„æµ·æ´‹å…¥é˜Ÿ
            que.push(std::make_pair(newX, newY));
        }
    }

    // å¦‚æœåªæœ‰é™†åœ°æˆ–åªæœ‰æµ·æ´‹æ—¶è¿”å›-1
    if (!hasOcean) {
        return -1;
    }

    // æœ€è¿œæµ·æ´‹åˆ°é™†åœ°çš„è·ç¦»
    return grid[point.first][point.second] - 1;
}
```