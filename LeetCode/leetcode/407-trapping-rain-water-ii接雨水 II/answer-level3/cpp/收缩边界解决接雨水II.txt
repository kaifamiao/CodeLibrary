##### 思路分析：
此题是将接雨水I从二维扩展到了三维这样问题就麻烦了许多，我们并不能简单的将二维的左右变成上下左右。因为此时一个柱子能装多少水并不是由它同行同列的柱子高度直接决定的，因为它同行同列的柱子装多少水也受自身所在行列柱子的约束，所以一个柱子最终能装多少水受周围所有柱子的影响。

一个可以解决此题的办法就是收缩边界，首先我们知道边界是无法装水的，只有中间的柱子可能能装水，但因为特靠中间的柱子能装多少水是受周围所有柱子的影响的那并不好确定。但是与边界相邻的柱子能装多少水是可以确定的，准确的说是与最小的边界相邻的柱子能装多少水是可确定的。

我们从小到大排列所有的柱子，同时标记所有为边界的柱子，然后我们遍历柱子收缩边界。如果遍历的柱子不是边界那么我们跳过，如果是那么我们就将此边界收缩，即我们检查与它相邻、没被访问且不是边界的柱子。

如果这个柱子不高于我们出发的边界，那么它能装的水最多就到此边界，因为它相邻的是边界再多水就流走了，其次这是当前最矮的边界我们不会装比这个边界还少的水了。如此一来这个柱子能装的水就确定了，我们将这个柱子加水到这个高度然后将它标记为新的边界继续检查它周围的柱子。

直到我们找到一个柱子(也有可能一开始就是)高于我们出发的边界，那么它就一定无法装水了，因为装多少都会从边界流走。所以我们只需直接将它标记为新的边界就行了，因为我们一开始排列了所有的柱子，所以后面我们一定会遍历到它。

这样我们就能逐渐收缩我们的边界，直至遍历完所有的柱子。此算法的复杂度为O(nm)。

```
class Solution {
public:
    int ans,n,m;//定义答案和行列
    vector<vector<int>>mark,rain,edge;//分别定义标记数组、柱高数组、和边界数组
    int posx[4]={1,-1,0,0};//定义方位数组
    int posy[4]={0,0,-1,1};
    void dfs(int x,int y)//得到边界柱子向内收缩
    {
        mark[x][y]=0;//标记这个柱子已被遍历
        for(int i=0;i<4;i++)//检查各个方位
        {
            int a=x+posx[i];
            int b=y+posy[i];
            if(a>=0&&a<n&&b>=0&&b<m&&edge[a][b]==0&&mark[a][b])//如果这个方位没有过界且不是边界且未被访问那么我们就扩展它
            {
                edge[a][b]=1;//将它定为新的边界
                if(rain[a][b]<=rain[x][y])//如果这个柱子小于等于出发的边界那么它能装的雨水就是边界减去它的柱高
                {
                    ans+=(rain[x][y]-rain[a][b]);//将它能装的雨水加入答案
                    rain[a][b]=rain[x][y];//更新这个柱高为边界
                    dfs(a,b);//继续由它向内扩展
                }
            }
        }
    }
    int trapRainWater(vector<vector<int>>& heightMap) {
        n=heightMap.size();
        if(n<3)//如果行列数小于3说明柱子全是边界无法装水、装水为0
            return 0;
        m=heightMap[0].size();
        if(m<3)
            return 0;
        ans=0;//初始化答案为0
        mark.resize(n,vector<int>(m,1));//初始化标记数组1代表没探索过0表示探索过
        edge.resize(n,vector<int>(m,0));//初始化边界数组1代表是边界过0代表不是边界
        rain=heightMap;//将柱高传给全局变量
        vector<pair<int,pair<int,int>>>temp;//定义一个temp用来存储柱子的信息包括柱高、位置
        for(int i=0;i<n;i++)
        {
            for(int j=0;j<m;j++)
            {
                temp.push_back({heightMap[i][j],{i,j}});//将柱子的信息存入temp数组
                if(i==0||j==0||i==n-1||j==m-1)
                {
                    edge[i][j]=1;//同时将边界标记
                }       
            }
        }
        sort(temp.begin(),temp.end());//将temp数组按柱高排序
        for(auto node:temp)//开始遍历排列后的柱高
        {
            int a=node.second.first;//获得柱子的位置
            int b=node.second.second;
            if(edge[a][b])//如果柱子是边界则收缩边界
                dfs(a,b);
        }
        return ans;//返回答案
    }
};

```
