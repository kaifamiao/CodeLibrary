### 解题思路
最长公共子序列（Longest Common Subsequence，LCS）是指：
给定两个字符串（数列），求一个子列，使得这个子列是两个给定字符串的最长公共部分。例如：
```
a b c d e f
b d a f
```
以上两个字符串的LCS就是b d f，接下来用动态规划求解。

形如最大子列和、最长上升子列等动规问题，我们都有一个dp[]数组来表示问题的状态。
例如，在最大子列和问题中，dp[i]表示以nums[i]作为序列末尾时能得到的最大子列和；最长上升子列问题中，dp[i]表示以nums[i]作为序列末尾时能得到的最长上升子列长度。**dp[i]就是问题的状态**，此外，我们会从题目中获取**边界信息**，例如`dp[0] = nums[0]`就是最大子列和问题的边界。然后我们需要写出关键的**状态转移方程**。之后就可以**从边界出发，通过状态转移方程求解状态**了。以上是解决动规问题的一般思路。

而本题我们依然会使用一个dp数组表示问题的状态，只不过这次我们用的是二维数组dp[][]。带着疑惑往下看。
我们用dp[i][j]表示第一个字符串的第1至i号位字符部分与第二个字符串的第1至j号位字符部分的LCS长度，即问题的状态。这里我们用1作为字符串第一个字符的下标。以上面给出的两个字符串为例，dp[4][2]的值就是字符串"a b c d"与字符串"b d"的LCS长度，显然为2。理解了dp数组含义后，其实我们要求解的状态就是dp[len1][len2]，len1为第一个字符串的长度，len2为第二个字符串的长度。

同样的，我们现在知道了状态dp[i][j]是什么，现在该获取边界信息了，即题目隐藏的或给定的一些已知信息。
显然$dp[i][0] = 0 (i = 0,1,2,3,...,len1)$；
$dp[0][j] = 0 (j = 0,1,2,3,...,len2)$。
由于上面提到了，字符的下标从1开始，因此0代表空串，字符串和空串的LCS长度自然为0。

边界信息有了，可以尝试一下写状态转移方程。
为了便于理解，我们先把dp[]][]二维数组画出来。并且根据刚才的边界信息，我们可以在表格的特定位置填上0，如下所示。
|      |      |      | a    | b    | c    | d    | e    | f    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
|      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| b    | 1    | 0    |      |      |      |      |      |      |
| d    | 2    | 0    |      |      |      |      |      |      |
| a    | 3    | 0    |      |      |      |      |      |      |
| f    | 4    | 0    |      |      |      |      |      |      |
接下来，就是完善这个表格。再看一个例子：
dp[4][2]，其中，t1[4] == t2[2]，都是字符d，说明此时LCS长度可以增加1，即`dp[4][2] = dp[3][1] + 1;`。
dp[4][3]，其中，t1[4] != t2[3]，即字符串"a b c d"和"b d a"，不难得到，这两个字符串的LCS长度应该是字符串"a b c"和"b d a"的LCS长度与字符串"a b c d"和"b d"的LCS长度这两个长度的较大者。因为d != a，所以这一对字符不会增加LCS长度，所以LCS长度应该继承dp[3][3]和dp[4][2]的较大者。
按照这个思路完善表格如下：
|      |      |      | a    | b    | c    | d    | e    | f    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      | 0    | 1    | 2    | 3    | 4    | 5    | 6    |
|      | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
| b    | 1    | 0    | 0    | 1    | 1    | 1    | 1    | 1    |
| d    | 2    | 0    | 0    | 1    | 1    | 2    | 2    | 2    |
| a    | 3    | 0    | 1    | 1    | 1    | 2    | 2    | 2    |
| f    | 4    | 0    | 1    | 1    | 1    | 2    | 2    | 3    |
这样，dp[6][4]为3就是两个字符串的LCS长度。

此时可以得到状态转移方程：
$t1[i] == t2[j]时，dp[i][j] = dp[i-1][j-1] + 1;$
$t1[i] != t2[j]时，dp[i][j] = max(dp[i-1][j], dp[i][j-1])。$

时间复杂度为：O(nm)，n、m分别为两个字符串的长度。

### 代码

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        char[] t1 = text1.toCharArray();
        char[] t2 = text2.toCharArray();
        int len1 = t1.length;
        int len2 = t2.length;
        int[][] dp = new int[len1+1][len2+1];
        for(int i = 1; i <= len1; i++)
        {
            for(int j = 1; j <= len2; j++)
                dp[i][j] = t1[i-1] == t2[j-1] ? (dp[i-1][j-1] + 1) : Math.max(dp[i-1][j], dp[i][j-1]);
        }
        return dp[len1][len2];
    }
}
```