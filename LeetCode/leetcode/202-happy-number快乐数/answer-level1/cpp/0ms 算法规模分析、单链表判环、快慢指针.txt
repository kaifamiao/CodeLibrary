这个单链表快慢指针讲很多了，可以直接跳过，去看看算法规模分析吧！

**泛化链表结构**：如果我们 **把链表的节点看成问题中的状态** 的话，它可以代表问题中的一个数字、一个阶段等等，是很泛化的东西。而链表的唯一指向关系它又代表什么呢？它其实代表着 **状态与状态之间是唯一确定转换** 的。也就是说从当前状态是唯一确定转换到下一个状态的。显然快乐数的转换规则完美的符合了这个特性。
![image.png](https://pic.leetcode-cn.com/25c755c664a8e2835db78857a761be762a7d97fc5aa3a20edb6e5c8860aa1793-image.png)

我们根据题目的意思就将 1 作为链表的结尾即 **`NULL`**。

那么在单链表中一直走不到空地址意味着什么？就意味着链表有环呗。那么这个快乐数问题就被抽象为链表中是否有环的问题。即，**如果这个链表有环那么就不是快乐数，如果链表没环，能指到空地址 1 的话那就说明这个数就是快乐数。**

### 算法规模分析

从上面我们得到了解决这个问题的算法思维，但是会不会出现这个链表太长了，有上个几千、几万、几十万的链表单元，影响我们找不到结果呢？**我们来考虑一下这个算法的规模。**

首先，如果输入值为 `int`，那么能知道 `int` 最多也就是一个以 2 开头的 10 位的数字。接着我们来考虑这样一个问题，在 `int` 数据范围中，哪一个数字 `n` 它所对应的下一个数字 `n` 是最大的？

我们能构造得到 `1 999 999 999`，那么只有构造出 1 个 1 ，9 个 9 的数字在 `int` 范围内就是最大的，那么下一个节点时多少呢？根据快乐数的定义能得到 $9^2 \times9 + 1 =730$，那么 730 就是在整形范围之内任何一个数字所能映射到的下一个数字都不会超过 730，也就意味着当前所抽象出来的链表结构中节点数目最多不会超过 730 个，如果快指针一次走两步、慢指针一次走一步的话，那么慢指针走的最多，也只不过走了 $731\times2 = 1462$ 步，而快指针就是走了 $731$ 步。

所以至此就证明完了，在整形快乐数中进行单链表判环的操作的话，操作步骤是有限的，就取个整吧，最多最多也就 2000 步了。所以这个方案是高效可行的。
```cpp
// 执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户
// 内存消耗 :8 MB, 在所有 C++ 提交中击败了89.59%的用户

class Solution {
public:
    bool isHappy(int n) {
        int p = n, q = getNext(n);
        while (q != 1) {
            p = getNext(p);
            q = getNext(getNext(q));
            if (p == q) return false;
        }
        return true;
    }

    int getNext(int x) {
        int n = 0; 
        while (x) {
            n += (x % 10) * (x % 10);
            x /= 10;
        }
        return n;
    }
};
```
##### 其实做这个快乐数题目什么的并不重要，而重要的是需要体会一点：如何从具体的算法推导出算法思维的。这个思维的变换很重要！这也就是真正的算法之美！

### 我的CSDN博客专栏[**有趣的算法思维**](https://blog.csdn.net/yl_puyu/category_9749454.html)有相关算法思维的博文，体验思维的转换与算法之美！