### 解法一：快慢指针
本题采用快慢指针的思想，因为**快慢指针可以找出循环序列的最后一个数**。选择此法的分析如下：
观察题目样例：19->82->68->100->1->1->...
再随机尝试另一个样例：*20->4->16->37->58->89->145->42*->20->4->...
通过若干尝试，可以发现，第二个样例会出现一个循环数列，即只要变换的次数足够多，一个循环数列将重复出现（即20、4、16、37、58、89、145、42）。这样的情况就是题目所描述的“无限循环却始终变不到1”，因而不是快乐数。而第一个样例就是快乐数，即通过不断变换最终变到1，之后无论怎么变换都是1。
综上，需要找出循环数列的最后一个数，如果这个数不是1，则不是快乐数，因为循环数列会无限重复。找循环数列的最后一个数，就可以使用快慢指针，快指针走两步，满指针走一步，这样满指针走完一个循环序列，快指针刚好走完两个，然后快慢指针重合（两指针所指数相等），此时指针所指的数就是循环数列最后一个数。判断是否为1，是则为快乐数，否则不是。

代码

```java
class Solution {
    private int getSum(int n) {
        int sum=0;
        while(n!=0)
        {
            sum += (n%10)*(n%10);
            n /= 10;
        }
        return sum;
    }
    public boolean isHappy(int n) {
        int fast=getSum(n);
        int slow=n;
        while(true)
        {
            fast=getSum(fast);
            fast=getSum(fast);
            slow=getSum(slow);
            if(fast==slow)  break;
        }
        return fast==1;
    }
}
```
### 解法二：找规律
感兴趣的可以写一个程序模拟变换过程，每次变换输出结果，通过若干任意正整数的尝试，会发现若是快乐数最终会变换到1；若不是快乐数，则最终会出现一个循环序列：4 16 37 58 89 145 42 20。由此可得，只要变换过程一旦出现1，则可以确定是快乐数；否则一旦出现上述序列中的任意一个数，可以确定不是快乐数。

代码

```java
class Solution {
    private int getSum(int n) {
        int sum=0;
        while(n!=0)
        {
            sum += (n%10) * (n%10);
            n /= 10;
        }
        return sum;
    }
    public boolean isHappy(int n) {
        while(true)
        {
            if(n==1)    break;
            if(n==4)    break;//一旦出现循环序列中的任意一个数，例如4，则不是快乐数
            n=getSum(n);
        }
        return n==1;
    }
}
```