刚拿到这个题目的时候感觉很懵逼，主要是不知道要如何避免出现“无限循环”的情况，后来参考了别人的解决方案才理解这里会发生“无限循环”的情况：一个数被重复计算。
如果在计算快乐数的过程中，先后对同一个数字进行计算，说明存在这样一个路径：A->B->C->D-> ... ->A-> ... ,在这种情况下永远也不会终止循环。所以要避免这种
情况的发生，就是在计算过程中判断当前数字是否已经被计算过了，如果已经计算过就说明会陷入无限循环，这个数字也不会是“快乐数”。

下面的代码是参考了别人的思路，主要还是为了让自己能更好理解。

```
class Solution {
    public boolean isHappy(int n) {
        // 用来保存已经计算过的数字，避免无限循环的发生。
        HashSet<Integer> set = new HashSet<Integer>();
        while(true) {
            int sum = 0;
            // 如果当前数字已经被计算过了，说明会陷入无限循环，该数字也不是快乐数。
            if (set.contains(n)) {
                return false;
            } else {
                // 第一次计算时，把数字保存起来。
                set.add(n);
            }
            // 数字 n 在每次都会变为原来的 1/10, 当变为0时表示这个数字的每位都已经被计算了。
            while(n != 0) {
                // 累加最后一位数字的平方。
                sum += (n%10) * (n%10);
                // 更新原数字，这样下次计算的就是倒数第二位数字的平方了，依次类推。
                n /= 10;
            }
            if (sum == 1) {
                // 各位数字的平方和为1，是快乐数，直接返回。
                return true;
            } else {
                // 不是快乐数，继续计算新的数字。
                n = sum;
            }
            
        }
    }
}
```
