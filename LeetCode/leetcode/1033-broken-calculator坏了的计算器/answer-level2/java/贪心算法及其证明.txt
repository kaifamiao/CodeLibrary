### 贪心算法

#### 分析：

- 当$Y<X$的值时，$Y$只能由$X$不断的进行减$1$操作得到，共需要$X-Y$次操作，因此这种情形下我们可以直接得到答案。
- 当$Y>X$的值时，该问题必然有有解，因$X$可以不断的做乘$2$操作得到第一个大于等于$Y$的数$Z$，然后再执行$Z-Y$次减$1$操作最终得到$Y$。
- 当$Y>X$时，假设我们已经得到了最短的操作序列为$[X, n_1, n_2, n_3......Y]$，其中$n_1, n_2, n_3$等为乘或减操作产生的中间值。我们可以按照$Y$是否为奇数来分情况讨论。
    1. 当$Y$为奇数时，由于只有乘$2$和减$1$两种操作，又$Y$不可能由某个数乘$2$得到，所以这个最优的操作序列中倒数第二个中间值必定为$Y+1$, 我们记符号$min(Y)$为由$X$转换成$Y$的最小操作步骤数，则易得$min(Y) = min(Y+1) + 1$
    2. 当$Y$为偶数时，不妨设$Y=2*T$,此时$Y$可以由$T*2$或$2*T-1$两种方式得到，若$Y$由$T*2$得到(即倒数第二个中间值为$T$),那么$min(Y) = min(T）+ 1$。若$Y$由$2*T+1$通过减$1$操作得到,则$min(Y)=min(2*T+1)+1$。由于$2*T+1$为奇数，由$1$可知该最优操作序列中倒数第三个数必为$2*T+2=2*(T+1)$，故$min(Y)=min(2*T+2)+2$。此时$2*T+2$为一个偶数，他可以由$(T+1)*2$或$2*(T+2)-1-1...$得到。我们假设最优的解K使得$X \rightarrow ... \rightarrow (T+K)\rightarrow2*(T+K)\rightarrow2*(T+K)-1\rightarrow2*(T+K)-2\rightarrow...\rightarrow Y$这样的操作序列最短。仔细观察可以发现，我们可以选择$(T+K)$这个节点通过$K$次$-1$操作得到$T$然后进行一次乘$2$操作得到$2T=Y$，共需要$K+1$次。而若按照如上的操作序列我们需要$2T+2K-2T+1=2K+1$次操作。显然$Y$由$-1$操作得到的最少操作次数要大于$Y$由$T*2$得到的最少操作次数。因此当$Y$为偶数时，其前一个中间值必为$Y/2$。

#### 算法：
- 根据上述分析，我们可以写出该贪心算法的递归写法
- 当$Y = X$时，返回$0$
- 当$Y < X$时，返回 $X-Y$
- 当$Y > X$ 且 $Y$为奇数时，我们可以得到当前最优序列中倒数第二个数为$Y+1$，递归求解到$Y+1$的最小操作次数。
- 当$Y > X$ 且 $Y$为偶数时, 我们可以得到当前最优序列中倒数第二个数为$Y/2$，递归求解到$Y/2$的最小操作次数。
```java []
class Solution {
    public int brokenCalc(int X, int Y) {
        if (Y <= X)         return X-Y;
        if (Y % 2 == 0)  return 1 + brokenCalc(X, Y/2);
        else                 return 1 + brokenCalc(X, Y+1);
    }
}
```

#### 复杂度分析：
- 时间复杂度：$O(logY)$
- 空间复杂度：$O(1)$




