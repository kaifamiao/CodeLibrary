题目中说到，中心对称数是指旋转了180度后依旧相同的数字，那么我们做个假设：
**就是一个中心对称数的头和尾分别加上一个旋转后会相同的数，新组成的数也是中心对称数。**
为了求证，可以发现，假设我们已知所有长度为n-2的中心对称数，将示例中给出的n=2的中心对称数拆开变成 1和1，6和9 ，8和8，9和6，在两数中间填入长度为n-2的中心对称数，就可以得到长度为n且一定中心对称的数。根据这个特性，我们可以利用递归的方法去解这道题。

当使用递归的时候，我们得考虑递归结束的条件，也就是自顶向下的终点
当n==0, 返回一个空字符串
当n==1，返回 "1" "8" "0"，这是在n为1时的中心对称数
当n==2，却不直接返回示例所示，这是为什么呢？

通过大致地列举我们可以发现，1001也是中心对称数，但是00并不属于长度为n-2=4-2=2的中心对称数，所以我们就无法找到00这个长度为2的数来进行头尾相加，导致结果不够完整。
我们也可以发现，当n=3时，长度为n-2 = 3-2 = 1的中心数中，0 是合法的。但是当n >=4， 中间的n-2个0都是非法的。
那么怎么去解决这种特殊情况呢，就是我们需要在递归中，设置一个totaln来告知下一层递归，我们最终要求的中心对称数的长度是多少，假如这一层递归所返回的中心数长度小于最终中心对称数长度，并且
totaln >= 4时，我们可以在利用更下一层递归中返回的数据来编辑该层的返回的返回值是，除了可以两头加1 1，6 9，8 8，9 6外，再给其两头加0 0。这样，就能保证返回所有有可能的最终中心对称数的子数。简单来说，只要该中心对称数的长度不等于最终的长度，在每一层递归的时候，都可以在两头加0。

代码写到这里，已经是能过完所有的测试数据了，但是当n<0的异常值没去考虑，这点其实在实际做题中是不能忽略的，当然在这就不再添加。 
执行用时84ms，内存消耗25.9mb。

代码如下
```
class Solution {
public:
    vector<string> findStrobogrammatic(int n) {        
        return recursionFunction(n,n);                
    }
     
    vector<string> recursionFunction(int n,int totaln){
        
        if(n == 0){
            vector<string> v;
            v.push_back("");
            return v;
        }
        if(n == 1){
            vector<string> v;
            v.push_back("1");
            v.push_back("8");
            v.push_back("0");
            return v;
        }
              
        vector<string> v2;
        
        if(n >= 2){
            vector<string> v = recursionFunction(n-2,totaln);                     
            for(int i = 0;i<v.size();i++){
                v2.push_back("1" + v.at(i) + "1");
                v2.push_back("6" + v.at(i) + "9");
                v2.push_back("8" + v.at(i) + "8");
                v2.push_back("9" + v.at(i) + "6");
                if(totaln > n && totaln >=4 )  v2.push_back("0" + v.at(i) + "0");
            }
        }
        
        return v2;
    } 
};
```
我是SROMEI，题海无涯苦做舟，让我们在枯燥在题目中玩出花来。