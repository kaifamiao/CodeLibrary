这题的DP确实是有些麻烦，我的大致思路是正确的，但执行的时候出现了一小步的偏差，白白浪费了一下午
这题需要建立一个二维矩阵，如果我们用arr[i][j]表示猜出某个在区间[i j]范围内的数的最小必须花费，那么这题可以理解为，给定n，如何求出二维矩阵arr[1][n]的值。
我们试举几个例子：
假设我们的n为10，那么我们如何求arr[1][10]呢？
我们首先先猜一个值，6，那么如果我们猜错了，那么这个数**要么**是区间[1 5]里面的一个，**要么**是区间[7 10]里面的一个，如果我们想要猜出最终值，那么就要看猜区间[1 5]和猜区间[7 10]哪个代价更大了，我们应该选择代价更大的那个，这样才能确保我们猜出来。
那么在猜6的情况下，我们能够确保猜出最终的数所需要付出的代价就是 **6(猜错了要付的钱)+max(arr[1][5]\(猜一个区间[1 5]内的数所需要的花费),arr[7][10]\(猜一个区间[7 10]内的数所需要的花费))**
那么我们只是猜6吗？
当然不是，我们应该试着猜所有1至10内所有的数，然后将猜这些数所分别需要付出的代价整合在一起，找到其中最小的那个（也就是最优的选择），然后赋值给arr[1][10]
于是状态转移方程应该是：k+max(arr[i][k-1],arr[k+1][j],其中k取遍i到j，然后找到所有k取值的这个式子的最小值，赋值给arr[i][j]

代码如下：
```
func getMoneyAmount(n int) int {
	res:=make([][]int,n+1)
	for k,_:=range res{
		res[k]=make([]int,n+1)
	}
	for i:=n-1;i>0;i--{
		for j:=i+1;j<len(res);j++{
			temp:=res[i][j-1]+j
			for k:=i;k<j;k++{
				t:=max(res[i][k-1],res[k+1][j])+k
				if t<temp {
					temp=t
				}
			}
			res[i][j]=temp
		}
	}
	return res[1][n]
}

func max(i int,j int) int {
	if i>j {
		return i
	}else {
		return j
	}
}
```

