### 解题思路
大声告诉我，我是不是题解里唯一一个不用递归的？！

下面认真说下解题思路：

这道题的核心思想其实就是求二叉树的路径的问题。
求二叉树的路径的关键就是需要你定义一个元组（或者其它你喜欢的数据结构）用于同时存储**遍历到的节点**和**包括该节点在内的探索过的节点的信息**，
比如对于题目中给出示例的这个二叉树：
```
      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1
```
从根出发，初始值是（10，[10]),压入栈；指针指向栈头(此时还是10），把栈头pop掉，然后因为栈头同时存在左子右子，所以把（5，[10,5])和(-3,[10,-3])再压入栈...
如此循环往复直到遍历到叶（此时栈空），最终你可以得到下面四条该二叉树的所有可能的完整路径：
```
[10,-3,11]
[10,5,3,3]
[10,5,3,-2]
[10,5,2,1]
```
本题要求的是求得这四条路径中“路径和等于给定数值的路径总数”，
此时问题又可以转化为：“已知四个数组，求得子数组的和等于特定值”的问题
直接在原数组上算这种问题非常复杂，而且就算你通过某种算法知道了这四个数组中每个数组都包含一个子数组能满足题意，
但是因为题目要你求得的不是完整路径，比如：
```
[10,5,3,3]
[10,5,3,-2]
```
这两个数组中的1号元素和2号元素的和都等于8，按理来说是两条满足题意的路径
但3，-2对应的原二叉树的两片叶子和它们共同的树枝5->3根本没关系！真正满足题意的是5->3，如果你贸然把两片叶子都算上，那你就求重了。
怎么解决这个求重的问题呢？
一个办法就是不要等到四条完整的路径都到手后再去分析它们
可以在遍历二叉树阶段每探访到一个新的节点，就把当前已经探索到的路径拿去分析看是否存在满足题意的路径
当然这里要加上一个条件，**那就是满足题意的路径必须包含这个新节点！**只有加上这个限定，才能避免求重。

### 代码

```swift

class Solution {
    func pathSum(_ root: TreeNode?, _ sum: Int) -> Int {
        
        //空🌲直接返回
        guard let root = root else {
            return 0
        }
           
        //定义一个函数，计算输入的路径里是否存在满足条件的路径
        //它的工作原理是将输入数组的最后一个元素(对应二叉树新遍历到的节点的值)依次和其它元素(对应二叉树已经探访过的节点)相加
        //如果和为指定值，则count+1.计算必须包含新探访到的节点的原因是为了避免求重
        func roots(in arr:[Int], equal sum:Int) -> Int {
            var count = 0
            var temp = arr[arr.count - 1]
            
            if temp == sum {
                count += 1
            }

            for element in arr.dropLast().reversed() {
                temp += element
                if temp == sum {
                    count += 1
                }
            }
            return count
        }

        //初始化一个栈用来存储二叉树 当前指向的节点 和 已经探索过的节点的信息
        var stack:[(TreeNode,[Int])] = [(root, [root.val])]
        //定义返回值
        var result = 0
        
        //遍历二叉树，不断由根向叶探索所有节点。每探索到一个新节点，就把这个节点和该节点的值加入到元组中
        while let node = stack.last?.0, let valueSum = stack.last?.1 {
            stack.removeLast()

            //每探索到一个新节点都去探查下有没有包含这个节点的满足条件的路径
            result += roots(in: valueSum, equal: sum)
            
            if node.left != nil {
                stack.append((node.left!, valueSum + [node.left!.val]))
            }
            
            if node.right != nil {
                stack.append((node.right!, valueSum + [node.right!.val]))
            }
        }
        
        return result
    }
}

```