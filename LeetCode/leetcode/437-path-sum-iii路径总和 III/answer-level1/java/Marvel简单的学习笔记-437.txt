### 暴力递归，3ms
根据题意，需要找出路径和等于给定值的路径总数，且起点不必从根结点开始，终点也不必在叶子结点，这意味着我们需要检查所有结点作为路径起点的情况（满足条件的路径的起点将可能是任意一个结点）。

换个角度，可以检查**所有结点作为路径终点**时的情况。即每遍历到一个结点，就以它为路径终点，向上回溯到根结点，同时在这个回溯的过程中不断累加顶点的和，相当于确定了终点，然后在向上回溯的过程中，把遇到的每个结点都尝试作为路径的起点，计算路径和，判断是否等于给定值，从而得到当前这个结点作为终点时的路径总数。

理解了上面这个过程，就可以得到递归代码了。

从根结点这棵二叉树开始，路径总数等于：根结点作为终点时的路径总数，加上左子树的路径总数，加上右子树的路径总数。
同理，左子树的路径总数等于：左子树根结点作为终点时的路径总数，加上左子树的左子树的路径总数，加上左子树的右子树的路径总数。
以上就是递归的内容。
递归边界就是，遇到空树时，返回0。

至此，还有一个问题需要解决，怎么得到一个根结点作为终点时的路径总数，即如何向上回溯。
借助一个数组作为形参，这个数组存储的是从根结点开始到当前结点的路径上各个结点的值。
同时，还需要一个形参，记录的是当前结点的层号（从0开始）。
这样一来，路径上各个结点的值可以通过层号赋值到数组中，层号对应的就是数组下标，即下标0对应的是根结点的值，下标1对应的是当前路径第1层的结点的值。
回溯时就通过访问数组，得到路径各层结点的值，完成路径和的计算。

### 代码

```java
class Solution {
    private int sum;
    public int pathSum(TreeNode root, int sum) {
        this.sum = sum;
        return getSum(root, new int[1000], 0);
    }
    private int getSum(TreeNode root, int[] vals, int layer) {
        if(root == null)    return 0;
        vals[layer] = root.val;
        int cur = 0;
        int temp = 0;
        for(int i = layer; i >= 0; i--)
        {
            temp += vals[i];
            if(temp == this.sum)    cur++;
        }
        return cur + getSum(root.left, vals, layer + 1) + getSum(root.right, vals, layer + 1);
    }
}
```