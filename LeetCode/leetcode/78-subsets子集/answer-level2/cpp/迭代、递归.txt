这个问题的__关键__就是理解__一个元素要么在集合，要么不在集合中__。

#迭代
在递归中，欲得到不重复的集合，应该怎么操作呢？ 
直接看过程。
eg., [1, 2, 3]
1. res = [[]]
2. res = [[],*[1]*]
3. res = [[],[1],*[2]*,*[1,2]*]
4. res = [[],[1],[2],[1,2],*[3]*,*[1,3]*,*[2,3]*,*[1,2,3]*]
第 i 次迭代和 i-1 迭代最大的区别在于，仅仅在 i-1 迭代的结果上，将所有子集添加了一个新的元素。

上代码：
```
vector<vector<int>> subsets(vector<int>& nums) 
    {
        vector<vector<int> > res(1);
        for (int i = 0; i < nums.size(); ++i) {
            int size = res.size();
            for (int j = 0; j < size; ++j) {
                res.push_back(res[j]);
                res.back().push_back(nums[i]);
            }
        }
        return res;
    }
```

# 递归
话不多说，举个例子
3:{}                               []

2:3                [3]                            []

1:2         [3,2]        [3]                 [2]           []

0:1 [3,2,1]   [3,2]     [3,1] [3]         [2,1] [2]      [1]    []

这里，最左边的元素对表示(depth : element), 深度所对应的元素。 叶结点表示结果。 
左子树表示下一层的元素在子集合中，而右子树表示下一层的元素不再子集合中。
递归的方式能够充分表达出__一个元素要么在集合，要么不在集合中__的思想。
代码可参考 
[@yuexiwen](/u/yuexiwen/)
