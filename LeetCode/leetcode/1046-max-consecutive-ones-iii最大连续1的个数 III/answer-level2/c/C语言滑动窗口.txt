### 解题思路
此处撰写解题思路

### 代码

```c
#define MAX_HTL(a, b) ((a) > (b) ? (a) : (b))

/*
    滑动窗口的算法
    目的：获取最大连续1的个数
    条件：K为能将0变为1的次数
    滑动窗口的题目，控制一个左右窗口指针，向右移动右窗口，zero用于控制0变成1的个数，每用一次zero+1，直到zero>K时，将左窗口移动到离左窗口最近的0的位置，保证使用完K的情况下，最大的连续1的个数，记录为max
    例：1,1,1,0,0,0,1,1,1,1,0 K = 2

    1、【1】,1,1,0,0,0,1,1,1,1,0
    2、【1,1】,1,0,0,0,1,1,1,1,0
    3、【1,1,1】,0,0,0,1,1,1,1,0
    4、【1,1,1,0】,0,0,1,1,1,1,0 zero++
    5、【1,1,1,0,0】,0,1,1,1,1,0 zero++
    6、【1,1,1,0,0,0】,1,1,1,1,0 zero==3 > K 此时左指针++，一直移动到下一个0，的位置
    7、1,1,1,0,【0,0】,1,1,1,1,0
    8、1,1,1,0,【0,0,1】,1,1,1,0
    9、1,1,1,0,【0,0,1,1】,1,1,0
    10、1,1,1,0,【0,0,1,1,1】,1,0
    11、1,1,1,0,【0,0,1,1,1,1】,0
    12、1,1,1,0,【0,0,1,1,1,1,0】 zero ==3 > K 此时左指针++
    13、1,1,1,0,0,【0,1,1,1,1,0】
    总之，窗口内【】最多为K个0时，窗口最大的长度，即为所求
*/
int longestOnes(int* A, int ASize, int K){
    int left, right, zeroCnt, max;

    left = 0;
    right = 0;
    zeroCnt = 0;
    max = 0;
    
    while (right < ASize) {
        if (A[right] == 0) {
            zeroCnt++;
        }
        right++;

        while (zeroCnt > K) {
            if (A[left] == 0) {
                zeroCnt--;
            }
            left++;
        }

        max = MAX_HTL(max, right - left);
    }

    return max;
}
```