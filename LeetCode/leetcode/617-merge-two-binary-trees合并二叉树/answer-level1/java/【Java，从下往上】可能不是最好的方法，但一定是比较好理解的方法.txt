> 思路

先说一下- - 最近感觉刷树这边的题目，真的后序遍历太香了O(∩_∩)O，推荐各位小伙伴如果遇到想不出的问题，不妨用一用后序遍历，说不定会有奇效噢~

回到正题：

**首先归纳下题目要求：把`Tree2`归并（追加）到`Tree1`即可，最后返回`Tree1的根节点`就算完成要求。**

那么问题来了，我们要如何**左右归并**且返回`Tree1的根节点`呢？

只要把这两个问题想清楚，那么题目就迎刃而解了！！！

1. 左右归并（分三种情况）

     1. `Tree1节点 == null && Tree2 ==null`
          这种时候直接返回`null`即可

     2. `Tree1节点 == null || Tree2 ==null`
          经过`a情况`的判断，如果`b情况`符合条件，那么说明`Tree1和Tree2有且仅有一个为null`。
          这种时候，我们只需要看哪个不为null，返回哪个即可。

          ```java
          if(t1==null||t2==null){
              return t1==null?t2:t1;
          }
          ```

     3. `Tree1节点 != null && Tree2 !=null`

          这时候我们只需要把`Tree1和Tree2`节点的`val`相加即可。
          即`t1.val+=t2.val;`

2. 返回Tree1的根节点
     首先我们用正常**从上往下**的思想去做这道题，我们会发现即使遍历到最后，把两棵树归并完整，我们也无法拿到**Tree1的根节点**，这样就不符合题目要求。
     因此，我们这里就采用从**下往上**的思想。从最下面开始归并直到归并到根节点，即最后可以拿到**Tree1的根节点**并返回

     + 其中这里我们要进行`拼接树的操作`
          这里反着讲下如果不拼接会有什么后果。
          这里我们按后序遍历走，假如 t1 是 Tree1的3 ，t2是Tree2的1

          + 接下来再往左子节点走，5 和null 返回5，此时没有问题
          + 接下来走右边，null 和 4 返回4，**此时看起来好像没有问题**，但是我们只要仔细观察就会发现，这里虽然两个节点进行了归并处理，但是3这个节点的**右子节点仍然为null**，所以我们要进行拼接，即把返回的节点拼接到3的右子节点上
          + 反过来也是同理。

          ```
          输入: 
          	Tree 1                     Tree 2                  
                    1                         2                             
                   / \                       / \                            
                  3   2                     1   3                        
                 /                           \   \                      
                5                             4   7                  
          输出: 
          合并后的树:
          	     3
          	    / \
          	   4   5
          	  / \   \ 
          	 5   4   7
          ```

          


<br>
> 代码

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        // 如果两个节点都为null，可以直接return
        if(t1==null&&t2==null){
            return null;
        }

		// 此时如果符合if条件判断，说明t1和t2有且仅有一个为null，此时返回不为null的即可
        if(t1==null||t2==null){
            return t1==null?t2:t1;
        }
        
        // 因为采用后续遍历的思想，左右中
        TreeNode left = mergeTrees(t1.left,t2.left);
        TreeNode right = mergeTrees(t1.right,t2.right);
        
        // 拿到左右节点之后进行从下至上的拼接，以防出现节点归并成功，但树子节点仍然为null的情况
        if(left!=null){
            t1.left=left;
        }
        if(right!=null){
            t1.right=right;
        }
        // 处理完左右，最后处理中，即归并两个节点
        t1.val+=t2.val;
        
        // 因为是后续遍历，所以最后这个t1即代表根节点
        return t1;
    }
}
```
<br>
>结束语

希望大家都越来越强哇(ง •_•)ง！

