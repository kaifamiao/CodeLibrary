# 1. 思路
暴力算法当然可行，但是会超时，降低计算量的方法就是避免重复计算，这个思路有点像动态规划，虽然此题不是动态规划。
那么如何避免重复的计算呢？这道题有个特殊的思路，就是把乘积计算分为左边的乘积和右边的乘积。这样在计算左乘积或者右乘积的时候，就能利用上一步计算的结果，而避免重复计算。最后左乘积与右乘积相乘，得到其它数的乘积。
# 2. 代码
1. 定义两个数组，分别记录当前数的左乘积和右乘积
2. 计算左乘积时正向遍历，计算右乘积时逆向遍历，目的是为了使用上一步的计算结果
3. 左乘积与右乘积相乘，构建乘积数组
```c++ []
class Solution {
public:
    vector<int> constructArr(vector<int>& a) {
        vector<int> L(a.size(), 1);
        vector<int> R(a.size(), 1);
        for(int i=1; i<L.size(); i++){
            L[i] = L[i-1] * a[i-1];
        }
        for(int i=R.size()-2; i>=0; i--){
            R[i] = R[i+1] * a[i+1];
        }
        for(int i=0; i<L.size(); i++){
            L[i] *= R[i];
        }
        return L;
    }
};
```
# 3. 总结
这道题是从保存中间计算结果的思路降低计算量的，这种对称遍历的方式可以记录一下。