    传统的根据通项公式来进行递归会产生大量的重复计算导致超时，主体的思想就是对运算结果进行缓存，从数列底部开始逐步向上计算。
    
    循环方式的实现比较直接，每次循环根据缓存计算结果，并将最高三项的结果进行更新存储。
```
class Solution {

    public int tribonacci(int n){
        if(n <= 2){
            return n == 0 ? n : 1;
        }
        int result = 0,c0 = 1,c1 = 1,c2 = 0;
        while(n>=3){
            result = c0 + c1 + c2;
            c2 = c1;
            c1 = c0;
            c0 = result;
            n--;
        }     
        return result;   
    }    
}
```
    递归方式的实现，也是从底部开始向上计算。但是由于n是数列顶部的索引值，所以需要先通过递归达到数列的底层，在返回攀升时进行计算。
    递归的数据处理可以分两种情况，在攀进时进行计算和在反退时进行计算。自然，当逻辑位于函数名称之前时是攀进处理，当逻辑位于函数名称之后时属于反退计算。
    这里显然需要将计算的逻辑刚在tribonacci函数名称的后面就行了，不需要利用函数的返回值，只起到一个攀进到底部的作用。具体的计算在反退时进行。
    基本情形的设置是根据特殊的前三项，很直接。
```
class Solution {
    int c0 = 1,c1 = 1,c2 = 0;
    public int tribonacci(int n){
         if(n <= 2){ // 基本情形
            return n == 0 ? n : 1;
        }else {
            tribonacci(n-1); // 递归攀进，以达到数列的底部
        }
        // 反退时的计算逻辑
        int result = c0 + c1 + c2;
        c2 = c1;
        c1 = c0;
        c0 = result;
        return result;  
    }    
}
```
    总结：
    1、递归算法的设计可以从解法方案、“基本情形”的设立、处理逻辑的位置三部分入手。先设计出整体的解题方案，在根据方案来寻找、设计“基本情形”与逻辑位置（开始递归的位置）。
    2、在递归中，java的函数是对当前类的函数进行调用，一直使用着一个类。所以全局变量在每次的递归方法中是共有的。
