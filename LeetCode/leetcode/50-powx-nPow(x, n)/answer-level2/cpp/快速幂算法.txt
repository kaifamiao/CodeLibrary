### 解题思路
主要思想是:求 m = x^n，等价于找到n = (a0 * 2^0 + a1 * 2^1 + ... + ak * 2^k) 其中ai = 0或1
如m = x^26 <=> m = x^(16 + 8 + 2) = x^16 + x^8 + x^2
将求m的过程变为求多个x^i之和，而且有x^2 = x^1 * x^1, x^4 = x^2 * x^2 ...因此每一项都是很好求的
求解这个过程等价于求解每个ai的值，怎么求呢，其实将n变为二进制形式，就可以知道每一个ai的值
如n = 26,其二进制形式为11010,故a0=0,a1=1,a2=0,a3=1,a4=1
### 代码

```cpp
class Solution {
public:
    double myPow(double x, int n) {
        double res = 1.0;
        int i = n;
        while(i){
            if(i & 1) res *= x;//i的最低位是否为1
            i /= 2;//i右移一位，注意不能用i >>= 1,因为负数的移位运算不同于正数,-1 >> 1 永远为-1!
            x *= x;//x^1,x^2,x^4,x^8...
        }
        return n < 0 ? 1 / res : res;
    }
    
};
```