### 解题思路
怎样快速求得 $a^b$ 呢？你可能直接想到的是使用一个循环次数为 b 的 for 循环，并在每次循环时都累乘 a，这样在 b 次循环结束时我们就将获得 $a^b$。如：

```
int ans = 1;
for (int i = 1; i <= b; ++i) {
    ans *= a;
}
```
那么该方法是否是最优的呢？我们来看下面这种情况。

假如，将要计算 $a^{32}$。是否需要真的循环 32 次呢？按照我们采用的原始策略，当循环到第 i 次，即 $a^i$。那么，当完成了前 16 次循环时，就已经获得了 $a^{16}$ 的值，要获得 $a^{32}$ 次还需要继续完成后 16 次循环么？答案是否定的，当已经获得了 $a^{16}$ 时，只需将 $(a^{16})^2$，即可计算出 $a^{32}$，这样后 16 次乘法运算用一次平方（同样也是乘法）就完成了。既然 $a^{32}$ 可以由 $a^{16}$ 求平方取得，那么 $a^{16}$ 呢？你还确定我们需要使用 16 次循环来获得该值么？答案也是否定的，$a^{16}$ 只需对 $a^{8}$ 求平方即可，同理 $a^{8}$ 只需对 $a^{4}$ 求平方 ··· ··· 这样一次往复，最后可得到如下计算过程：

$$a^{1}=a$$

$$a^{2}=a*a$$

$$a^{4}=a^2*a^2$$

$$a^{8}=a^{4}*a^{4}$$

$$a^{16}=a^{8}*a^{8}$$

$$a^{32}=a^{16}*a^{16}$$

这样，原本需要使用 32 次乘法才能完成的工作，现在只需要 6 次乘法便能完成，效率提高了将近 6 倍。

大家可能注意到，$a^{32}$ 具有某种特殊性，即指数 32 刚好为 $2^{5}$，所以指数 32 可以一直被二分到 $2^{1}$ 为止。那么假如我们要求的次数不再具有这种特殊性，二分求幂还能适用吗？答案是肯定的。我们以求 $a^{31}$ 次为例，继续了解二分求幂的特点：

$$a^{31}=a^{1}*a^{30}$$

$$=a^{1}*a^{2}*a^{28}$$

$$=a^{1}*a^{2}*a^{4}*a^{24}$$

$$...$$

$$=a^{1}*a^{2}*a^{4}*a^{8}*a^{16}$$

其中，a 的各次幂可以由之前讨论的方法求得，即求得 $a^{1}$ 后，利用对 $a^{1}$ 平方，求得 $a^{2}$；再对 $a^{2}$ 平方，求得 $a^{4}$，以此类推。当求得这些 a 的各次幂（$a^{1}$,$a^{2}$,$a^{4}$,$a^{8}$,$a^{16}$）后，只需按要求对其累积，即可得到答案 $a^{31}$。那么该如何确定哪些 a 的次幂是我们需要的，是要累乘的呢？首先，应该注意到从 $a^{1}$ 出发，$a^{2}=(a^1)^2$，$a^{4}=(a^2)^2$，$a^{8}=(a^4)^2$，即 $a^{2^k}$ 可以由 $a^{1}$ 不断求平方取得。我们的目标即分解 $a^{b}$ 为若干个 $a^{2^k}$ 的**积**，并尽可能减少分解结果的个数。在指数层面即分解 b 为若干个 $2^k$ 的**和**，并尽可能减少分解结果的个数。不难想到，分解 b 为若干个 $2^k$ 的和且分解个数最小，这便是求 b 的二进制数。在求得 b 的二进制数后，各个二进制位为 1 的数位所代表的权重即是分解的结果。

以 $3^{21}$ 为例：

首先求得指数 21 的二进制为 10101，在二进制表达式中 21 即被表达成 $(10101)=1*2^0+0*2^1+2^2+0*2^3+1*2^4=2^0+2^2+2^4$，这就是我们所需的分解结果。即拆 $3^{21}=3^{2^0}*3^{2^2}*3^{2^4}$。

所以，$a^b$ 使用二分求幂，对指数 b 没有任何要求。

### 代码

```cpp
class Solution {
public:
    double myPow(double x, long n) {
        if (n < 0) return 1 / fun(x, -n);
        if (n > 0) return fun(x, n);

        return 1.0;     // n = 0
    }

    double fun(double a, long b) {   // 计算 a^b，0 < b
        double ret = 1;
        while (b) {
            if (b & 1) ret *= a;    // 若当前二进制位为 1，则需要累乘 a 的 2 的 k 次至 ret 中，其
                                    // 中 2 的 k 为当前二进制位的权重
            b >>= 1;
            // 求下一位二进制位的权重，a 求其平方，即从 a^1 次开始，依次求 a 的 2 次，a 的 4 次 ···
            a *= a;     // a^2, (a^2)^2, ((a^2)^2)^2, ... ...
        }
        return ret;
    }
};
```