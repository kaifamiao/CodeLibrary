![F7C48CCB-6077-4AB9-B141-440EAFFEFB63.jpeg](https://pic.leetcode-cn.com/291e51a5f9f08d22c730f4c24d7e16be6ea204f3c9a5353bda2a3be96a958dc9-F7C48CCB-6077-4AB9-B141-440EAFFEFB63.jpeg)

```
#define NUM_1 -1
#define NUM1 1

typedef struct {
    int val;
    int father;
} InitialStruct;

int Find(const int *graphFlag, int a) 
{
    while (graphFlag[a] != -1) {
        a = graphFlag[a];
    }
    return a;
}

void Union(int *graphFlag, int *graphSaveNum, int a, int b)
{
    int tmpA;
    int tmpB;
    tmpA = Find(graphFlag, a);
    tmpB = Find(graphFlag, b);
    if (tmpA != tmpB) {
        graphFlag[tmpB] = tmpA;
        graphSaveNum[tmpA]++;
    }
} 

void StartUnion(const int **graph, int graphSize, int *graphFlag, int *graphSaveNum)
{
    int i, j;
    for (i = 0; i < graphSize; i++) {
        for (j = i; j < graphSize; j++) {
            if (graph[i][j] == 1) {
                Union(graphFlag, graphSaveNum, i, j);
            }
        }
    }
} 


int Cmp(const void *a, const void *b)
{
    long long int tmp = *(int *)a - *(int *)b;
    return tmp > 0 ? 1 : tmp == 0 ? 0 : -1;
}

bool IsSame(int i, const int *initialFather, int initialSize)
{
    int tmpFather = initialFather[i];
    int j;
    for (j = 0; j < initialSize; j++) {
        if (j != i) {
            if (initialFather[j] == tmpFather) {
                return true;
            }
        }
    }
    return false;
}

void InitialMem(int *tmp, int size, int val)
{
    int i;
    for (i = 0; i < size; i++) {
        tmp[i] = val;
    }
}

int RetrunValCon(const int *initial, const int *initialFather, int initialSize,
    const int *graphSaveNum, int *graphFlag)
{
    int returnIndex = -1;
    int i;
    int fatherIndex;
    bool isSame;
    int maxVal;
    for (i = 0; i < initialSize; i++) {
        isSame = IsSame(i, initialFather, initialSize);
        fatherIndex = Find(graphFlag, initial[i]);
        if (isSame == false) {
            if (maxVal < graphSaveNum[fatherIndex]) {
                maxVal = graphSaveNum[fatherIndex];
                returnIndex = initial[i];
            }
        }
    }
    return returnIndex;
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize)
{
    int i, j;
    int returnIndex;
    int *graphFlag = (int *)malloc(graphSize * sizeof(int));
    InitialMem(graphFlag, graphSize, NUM_1);
    int *graphSaveNum = (int *)malloc(graphSize * sizeof(int));
    InitialMem(graphSaveNum, graphSize, NUM1);
    StartUnion(graph, graphSize, graphFlag, graphSaveNum);
    qsort(initial, initialSize, sizeof(initial[0]), Cmp);
    int fatherIndex;
    int *initialFather = (int *)malloc(initialSize * sizeof(int));
    for (i = 0; i < initialSize; i++) {
        fatherIndex = Find(graphFlag, initial[i]);
        initialFather[i] = fatherIndex;
    }
    returnIndex = RetrunValCon(initial, initialFather, initialSize, graphSaveNum, graphFlag);
    free(graphFlag);
    free(graphSaveNum);
    free(initialFather);
    return returnIndex == -1 ? initial[0] : returnIndex;
}
```
