![image.png](https://pic.leetcode-cn.com/f1bf5022b7af0288f884f57c6fdadaff7f534df59a98ab36a8a834cef89db352-image.png)

/*********************************************
* 假设 initial集合: i1, i2, ... in
* if i and j is in the same group, remove i or j, will not impact result
* if i is only one in the initial集合, it's okay to remove i and reduce M[initial]
* however, we need to find one which own the max number(in the M).
*  So:
* 1. create graph set, union all nodes and caculate the numbder of each group members
* 2. caclculate the frequency of each root in the initial 
* 3. find node which only show one time in the initial and own max group  
*/
```
typedef struct _MyGroup {
    int root; // the number of root
    int num;  // if it's root, will record the number of root
} MyGroup;
int FindRoot(int i, MyGroup* m)
{
    while (i != m[i].root) {
        i = m[i].root;
    }
    return i;
}
int comp(const void * p1, const void * p2)
{
    return ( *(int*)p1 - *(int*)p2 );
}
int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){
    MyGroup* m;
    int* isSameGroup;
    int i, j;
    int removed = 0;
    int max = 0;

    m = malloc(sizeof(MyGroup) * graphSize);
    isSameGroup = malloc(sizeof(int) * graphSize);
    for (i = 0; i < graphSize; i++) {
        m[i].root = i;
        m[i].num = 1;
        isSameGroup[i] = 0;
    }

    for (i = 0; i < graphSize; i++) {
        for (j = i + 1; j < graphSize; j++) {
            if (!graph[i][j])
                continue;
            int rootA = FindRoot(i, m);
            int rootB = FindRoot(j, m);
            if (rootA != rootB) {
                m[rootB].root = rootA;
                m[rootA].num += m[rootB].num;
                m[rootB].num = 0;
            }
        }
    }
    qsort(initial, initialSize, sizeof(int), comp);
    for(i = 0; i < initialSize; i++) {
        isSameGroup[FindRoot(initial[i], m)]++;
    }
    removed = initial[0];
    for(j = 0; j < initialSize; j++) {
        int root = FindRoot(initial[j], m);
        if (isSameGroup[root] == 1 && max < m[root].num) {
            removed = initial[j];
            max = m[root].num;
        }
    }

    free(isSameGroup);
    free(m);
    return removed;
}
typedef struct _MyGroup {
    int root; // the number of root
    int num;  // if it's root, will record the number of root
} MyGroup;
int FindRoot(int i, MyGroup* m)
{
    while (i != m[i].root) {
        i = m[i].root;
    }
    return i;
}
int comp(const void * p1, const void * p2)
{
    return ( *(int*)p1 - *(int*)p2 );
}
int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){
    MyGroup* m;
    int* isSameGroup;
    int i, j;
    int removed = 0;
    int max = 0;

    m = malloc(sizeof(MyGroup) * graphSize);
    isSameGroup = malloc(sizeof(int) * graphSize);
    for (i = 0; i < graphSize; i++) {
        m[i].root = i;
        m[i].num = 1;
        isSameGroup[i] = 0;
    }

    for (i = 0; i < graphSize; i++) {
        for (j = i + 1; j < graphSize; j++) {
            if (!graph[i][j])
                continue;
            int rootA = FindRoot(i, m);
            int rootB = FindRoot(j, m);
            if (rootA != rootB) {
                m[rootB].root = rootA;
                m[rootA].num += m[rootB].num;
                m[rootB].num = 0;
            }
        }
    }
    qsort(initial, initialSize, sizeof(int), comp);
    for(i = 0; i < initialSize; i++) {
        isSameGroup[FindRoot(initial[i], m)]++;
    }
    removed = initial[0];
    for(j = 0; j < initialSize; j++) {
        int root = FindRoot(initial[j], m);
        if (isSameGroup[root] == 1 && max < m[root].num) {
            removed = initial[j];
            max = m[root].num;
        }
    }

    free(isSameGroup);
    free(m);
    return removed;
}
```