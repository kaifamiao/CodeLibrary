### 解题思路
此处撰写解题思路
并查集。抄了一下模板：看注释

### 代码

```c
#define MAXN 301
int fa[MAXN], rank[MAXN];

// 初始化
inline void init(int n)
{
    for (int i = 0; i < n; i++)
    {
        fa[i] = i;
        rank[i] = 1;
    }
}

// 寻根
int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));
}

//合并
inline void merge(int i, int j)
{
    int x = find(i), y = find(j);
    if (rank[x] <= rank[y])
        fa[x] = y;
    else
        fa[y] = x;
    if (rank[x] == rank[y])
        rank[y]++;
}

// 排序
int cmp(const void *a, const void *b)
{
    return (*(int*)a > *(int*)b) ? 1 : -1;
}
int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize)
{
    init(graphSize);
    qsort(initial, initialSize, sizeof(int), cmp);

     // hash  
    int *hash = (int*)malloc(graphSize * sizeof(int));
    memset(hash, 0 , graphSize * sizeof(int));

    // 将联系在一起的节点进行Merge
    for(int i = 0; i < graphSize; i++) {
        for(int j = 0; j < graphColSize[0]; j++) {
             // i = j 的时候是对角线，也就是本节点为1，因此跳过否则会影响结果
            if (graph[i][j] == 1 && i != j) {
                merge(i , j);
            }
        }
    }
    int temp = 0;
    int max = 0;
    int result;

    // hash记录每个节点的root出现的值
    for(int i = 0; i < graphSize; i++) {
        temp = find(i);
        if (temp != -1) {
            hash[temp]++;
        }
    }
    // 删除initial中root出现次数最多的，也就是能影响其他节点最多的这个节点,前面对Initial 进行了排序，因此返回的是最小值
    for(int i = 0; i < initialSize; i++) {
        temp = find(initial[i]);
        if(temp != -1 && hash[temp] > max) {
            max = hash[temp];
            result = initial[i];
        }
    }

    return result;
}
```