核心思想
1. 求出联通子图个数
2. 统计各个子图中包含感染节点个数（一个感染节点就足以感染整个子图，所以如果一个子图有多于一个感染节点，那么即使去掉一个，也不会减少受感染节点数）
3. 选择子图中节点最多，且只有一个感染节点的结果
```
#include <limit.h>
int find(int p, int* parent)
{
    if (parent[p] == p) {
        return p;
    }
    parent[p] = find(parent[p], parent);
    return parent[p];
} 
void Add(int x, int y, int* parent) 
{
    int x1 = find(x, parent);
    int y1 = find(y, parent);
    if (x1 != y1) {
        parent[x1] = y1;
    }  
}

typedef struct {
    int size;
    int arr[100];
}Bad;
int comp(const void* a, const void* b) 
{
    return (*(int*)a - *(int*)b);
}
int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){

    int i, j;
    int* parent = (int*)malloc(sizeof(int) * graphSize);
    int* graphStat = (int*)malloc(sizeof(int) * graphSize);
    Bad* badPoint = (Bad*)malloc(sizeof(Bad) * graphSize);
    for (i = 0; i < graphSize; i++) {
        parent[i] = i;
        graphStat[i] = 0;
    }
    memset(badPoint, 0, sizeof(Bad) * graphSize);

    for (i = 0; i < graphSize; i++) {
        for (j = 0; j < *(graphColSize + i); j++) {
            if (i != j && graph[i][j] == 1) {
                Add(i, j, parent);
            }
        }
    }
    for (i = 0; i < graphSize; i++) {
        int gNum = find(i, parent);
        graphStat[gNum]++;
    }
    for (i = 0; i < initialSize; i++) {
        int graphNum;
        int size; 
        graphNum = find(initial[i], parent);
        size = badPoint[graphNum].size;
        badPoint[graphNum].arr[size] = initial[i];
        badPoint[graphNum].size++;
    }

    for (i = 0; i < graphSize; i++) {
        qsort(badPoint[i].arr, badPoint[i].size, sizeof(int), comp);
    }

    int max = INT_MIN;
    int rdx = -1;
    for (i = 0; i < graphSize; i++) {
        int temp;
        if (badPoint[i].size != 0) {
            if (badPoint[i].size > 1) {
                temp = 0;
            } else {
                temp = graphStat[i];
            }
            if (temp > max) {
                max = temp;
                rdx = i;
            }
        }
    }
    int ret = badPoint[rdx].arr[0];
    return ret;
}
```
