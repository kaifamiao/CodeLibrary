![image.png](https://pic.leetcode-cn.com/c519a333a084354e433d714f18ffd2f65d7c11bb6b11dd5906f6b0ba3bd99997-image.png)

### 解题思路
并查集

### 代码

```c
#define MAX_LEN 301

int preNode[MAX_LEN];
int hashInfo[MAX_LEN];

int FindRoot(int pos)
{
    int son = pos;
    int temp;

    if (preNode[pos] == -1) {
        return pos;
    }

    while (preNode[pos] != - 1) {
        pos = preNode[pos];
    }

    while (preNode[son] != -1) {
        temp = preNode[son];
        preNode[son] = pos;
        son = temp;
    }

    return pos;
}

void UnionRoot(int x, int y)
{
    int a = FindRoot(x);
    int b = FindRoot(y);

    if (a != b) {
        preNode[a] = b;
    }
}

int minMalwareSpread(int** graph, int graphSize, int* graphColSize, int* initial, int initialSize){
    int temp;
    int max = 0;
    int result;

    if (graphSize <= 0 || initialSize <= 0) {
        return 0;
    }

    result = initial[0];
    memset(preNode, -1, MAX_LEN * sizeof(int));
    memset(hashInfo, 0, MAX_LEN * sizeof(int));

    //step1：建圈
    for (int i = 0; i < graphSize; i++) {
        for (int j = 0; j < graphColSize[i]; j++) {
            if (graph[i][j] == 1) {
                UnionRoot(i, j);
            }
        }
    }

    //step2：统计各圈长下挂节点数
    for (int i = 0; i < graphSize; i++) {
        temp = FindRoot(i);
        if (temp != -1) {
            hashInfo[temp]++;
        }
    }

    //step3：获取initial列表中节点所属圈中圈长下挂节点数最大的节点
    for (int i = 0; i < initialSize; i++) {
        temp = FindRoot(initial[i]);
        if ((temp != -1) && ((max < hashInfo[temp]) || ((max == hashInfo[temp]) && initial[i] < result))) {
            max = hashInfo[temp];
            result = initial[i];
        }
    }

    return result;
}
```