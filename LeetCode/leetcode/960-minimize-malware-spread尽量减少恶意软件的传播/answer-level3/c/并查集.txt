### 解题思路
此处撰写解题思路
![image.png](https://pic.leetcode-cn.com/59c6cd92250ea8310ae8363f3e8b21e58b767257db33c91c8d469b899be4aa39-image.png)

问题等价于求initial中每个节点的连接个数，找到其中最大的节点，将其索引返回即可，有以下几点可以注意下：
1、先把initial中的节点从小到大排序，后面如果有多个节点满足条件就会自动保存到索引最小的那个。
2、将已经查过的节点都保存下来，后面initial中的节点如果在查过的节点中，说明该节点已经不需要查了。
3、所有initial中能够连接的节点（直接或间接连接）都是等价的。
### 代码



```c
int cmp(const void *a, const void *b)
{
    int *aa = (int *)a;
    int *bb = (int *)b;
    return (*aa > *bb);
}

void GetConnectNodes(int a, int *nodelist, int **graph, int graphSize)
{
    int i;
    nodelist[a] = 1;
    for (i = 0; i < graphSize; i++) {
        if (graph[a][i] == 1 && nodelist[i] == 0) {
            GetConnectNodes(i, nodelist, graph, graphSize);
        }
    }
}

int minMalwareSpread(int **graph, int graphSize, int *graphColSize, int *initial, int initialSize)
{
    int i, j, idx;
    if (graph == 0 || graphSize == 0 || graphColSize == 0 || initial == 0 || initialSize == 0) {
        return 0;
    }

    int max = 0;
    int *setlist = malloc(sizeof(int) * graphSize);
    memset(setlist, 0, sizeof(int) * graphSize);
    int *totallist = malloc(sizeof(int) * graphSize);
    memset(totallist, 0, sizeof(int) * graphSize);
    qsort(initial, initialSize, sizeof(int), cmp);

    for (i = 0; i < initialSize; i++) {
        if (totallist[initial[i]] == 1) {
            continue;
        }

        memset(setlist, 0, sizeof(int) * graphSize);
        GetConnectNodes(initial[i], setlist, graph, graphSize);
        // printf("%d %d", initial[i], setnum);
        int num = 0;
        for (j = 0; j < graphSize; j++) {
            if (setlist[j] != 0) {
                totallist[j] = 1;
                num++;
            }
        }
        if (num > max) {
            idx = initial[i];
            max = num;
        }
    }
    free(setlist);
    free(totallist);
    return idx;
}
```