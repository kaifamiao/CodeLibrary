![image.png](https://pic.leetcode-cn.com/fa1bdfad33d200e8bbaa37c8ece174c994b88c00c2093cb5d1dd812eac76cc7b-image.png)


```
'''
简单无向图处理

如果某个连通分量里面只有1个被感染的节点，那把这个节点删掉，
整个连通分量里面所有节点都不会被感染
问题转换为找只包含一个被感染节点的节点数最多的连通分量
如果找不到这样的连通分量，删掉序号最小的被感染节点，虽然
删掉也没鸟用，但是题目要求要删，特殊情况就只能这样返回了

dfs遍历连通分量即可
'''

from typing import List
class Solution:
    # 查找连通分量中所有的感染节点
    def findUniqueBadNode(self, i, link, visited, bad_nodes, total_node_num, bad_node_list):
        if i in visited:
            return

        visited.add(i)
        total_node_num[0] += 1
        if i in bad_nodes:
            bad_node_list.append(i)

        if i in link:
            for next in link[i]:
                self.findUniqueBadNode(next, link ,visited, bad_nodes, total_node_num, bad_node_list)


    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        if len(graph) == 0 or len(graph[0]) == 0:
            return 0

        m, n = len(graph), len(graph[0])
        link = {}

        for i in range(m):
            for j in range(n):
                if graph[i][j]:

                    if i not in link:
                        link[i]= []
                    if j not in link:
                        link[j] = []

                    link[i].append(j)
                    link[j].append(i)

        visited = set()
        bad_nodes = set(initial)

        max_nodes, bad_node_ans = -1, -1
        for i in range(len(graph)):
            if i in visited:
                continue

            total_node_num = [0]
            bad_node_list = []
            self.findUniqueBadNode(i, link, visited, bad_nodes, total_node_num, bad_node_list)
            #print(i, total_node_num[0], bad_node_list)

            total_node_num = total_node_num[0]
            if len(bad_node_list) != 1:
                continue

            bad_node = bad_node_list[0]

            if total_node_num >= max_nodes:
                if total_node_num == max_nodes:
                    bad_node_ans = min(bad_node_ans, bad_node)
                else:
                    bad_node_ans = bad_node
                    max_nodes = total_node_num

        if bad_node_ans == -1:
            return -1 if len(initial) == 0 else min(initial)
        return bad_node_ans
```
