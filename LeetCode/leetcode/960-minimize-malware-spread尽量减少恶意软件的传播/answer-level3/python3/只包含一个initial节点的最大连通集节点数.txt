1. 对特定initial节点，如果其所在连通图内有另一个initial节点，移除任何一个都无法减少感染的数量。同一个连通图的initial节点在只需要一次DFS
2. 对特定initial节点，如果其所在连通图没有其他initial节点，移除该节点可减少感染数量=所在连通图节点数
3. python可用堆栈实现DFS来找连通图，需要创建一个数组dp记录以及访问的节点。
4. 每个节点最多查找到一次，时间复杂度o(n),236ms。beats100%。空间复杂度o(n),14.6MB，beats100%
```
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial_dic = {} #利用python字典记录每个initial节点可减少感染数量
        n = len(graph)
        for i in initial:
            if i in initial_dic: #那些和之前的initial节点在同一个连通图内的节点，不重复计算
                continue
            stack = []
            stack.append(i)
            dp = [0] * n #标记已经查找过的节点
            dp[i] = 1
            flag = 0 #标记是否有两个initial节点在同一连通图
            ans = 0
            while stack: #利用堆栈实现深度优先搜素DFS
                p = stack.pop()
                for j in range(n):
                    if dp[j] == 1:
                        continue
                    elif graph[p][j] == 1:
                        ans += 1
                        #如果同一连通集中两个节点在initial中，移除任何一个都无法减少感染数量
                        if j in initial:
                            initial_dic[j] = 0
                            initial_dic[i] = 0
                            flag = 1
                        else:
                            stack.append(j)
                        dp[j] = 1
            if flag == 0:
                initial_dic[i] = ans + 1

        #求使得initial_dic[i]最小的i
        res = min(initial)
        temp = initial_dic[res]
        for i in initial:
            if initial_dic[i] > temp:
                res = i
                temp = initial_dic[i]
        return res
```

