找到孤立的initial节点，若不孤立总会被感染

```python3
from collections import Counter


class DSU:

    def __init__(self, n):
        self.par = list(range(n))
        self.sz = [1] * n

    def find(self, x):
        if self.par[x] != x:
            self.par[x] = self.find(self.par[x])
        return self.par[x]

    def union(self, x, y):
        px, py = self.find(x), self.find(y)
        if px != py:
            self.par[py] = px
            self.sz[px] += self.sz[py]

    def size(self, x):
        return self.sz[self.find(x)]


class Solution:

    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n = len(graph)
        dsu = DSU(n)
        for r, row in enumerate(graph):
            for c in range(r+1, n):
                if not row[c]:
                    continue
                dsu.union(r, c)

        initial.sort()
        ranges = [dsu.find(i) for i in initial]
        rng_cnt = Counter(ranges)
        unq_rng = [r for r in rng_cnt if rng_cnt[r] == 1]
        max_influ_idx = (ranges.index(max(unq_rng, key=dsu.size))
                         if unq_rng else 0)
        return initial[max_influ_idx]
```