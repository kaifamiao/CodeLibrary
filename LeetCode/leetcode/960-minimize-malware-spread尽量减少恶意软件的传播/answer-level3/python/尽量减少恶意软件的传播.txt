这个题给了我们一个无向图，并给定了一些受感染的初始节点，相邻节点间会互相感染。要求找出一个初始节点，使得移除它后最终受到感染的节点数量最少。

我们只需要求得与每个初始节点连通的节点数量，然后返回连通节点最多的初始节点即可。

求图的连通分量一般使用并查集。
  
```Python []
class Solution:
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        def find(x):
            nonlocal arr
            f = x if arr[x] == x else find(arr[x])
            arr[x] = f
            return f
        n = len(graph)
        arr = list(range(n))
        counter = [1] * n
        for i in range(n):
            for j in range(n):
                if graph[i][j] == 1:
                    x = find(i)
                    y = find(j)
                    if x != y:
                        arr[x] = y
                        counter[y] += counter[x]
        mx = 0
        res = 0
        for i in initial:
            f = find(i)
            if counter[f] > mx or (counter[f] == mx and i < res):
                mx = counter[f]
                res = i
        return res
```  

  
这道题还可以使用深度优先搜索（dfs）解答，只需要在进行 dfs 是记录每个节点的根节点和每个根节点连接有多少子节点即可。  
  
```Python []
class Solution:
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        def dfs(x, root):
            nonlocal vis,graph,n,counter,initial,father
            counter[root] += 1
            father[x] = root
            for i in range(n):
                if graph[x][i] == 1 and not vis[i]:
                    vis[i] = True
                    dfs(i,root)  
        n = len(graph)
        vis = [False] * n
        counter = [0] * n 
        father = list(range(n))
        for i in range(n):
            if not vis[i]:
                vis[i] = True
                dfs(i, i)
        mx = 0
        res = 0
        for i in initial:
            f = father[i]
            if counter[f] > mx or (counter[f] == mx and i < res):
                mx = counter[f]
                res = i
        return res
```