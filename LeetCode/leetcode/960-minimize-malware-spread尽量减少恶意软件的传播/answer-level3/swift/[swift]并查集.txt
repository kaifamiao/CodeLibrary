### 解题思路
1. 建立并查集
2. 根据根节点获取并查集中每个根节点的联通节点数目
3. 把恶意感染的节点根据其根节点不同分组
4. 当并查集中的一个连通部分包含两个及以上的感染节点时，任意移除一个都是无效的，不会减少最终的感染节点数目
5. 当连通部分中只包含一个感染节点时，移除该感染节点会保护这个联通部分不受感染。

### 代码

```swift
class Solution {
    class UnionFind {
        var parent: [Int]
        init(_ size: Int) {
            parent = Array<Int>(0..<size)
        }
        func find(_ node: Int) -> Int {
            guard parent[node] != node else {
                return node
            }
            var current = node
            while parent[current] != current {
                current = parent[current]
            }
            var temp = node
            while parent[temp] != current {
                (parent[temp],temp) = (current,parent[temp])
            }
            return current
        }
        func connected(_ node1: Int, _ node2: Int) -> Bool {
            return find(node1) == find(node2)
        }
        func join(_ node1: Int, _ node2: Int)  {
            let p1 = find(node1)
            let p2 = find(node2)
            guard p1 != p2 else {
                return
            }
            parent[p1] = p2
        }
    }
    func minMalwareSpread(_ graph: [[Int]], _ initial: [Int]) -> Int {
        let size = graph.count
        let uf = UnionFind(size)
        for r in 0..<size {
            for c in (r + 1)..<size {
                if graph[r][c] == 1 {
                    uf.join(r, c)
                }
            }
        }
        var compoments = Array<Int>(repeating: 0, count: size)
        for node in 0..<size {
            compoments[uf.find(node)] += 1
        }
        var map = [Int: Set<Int>]()
        for node in initial {
            let p = uf.find(node)
            if nil == map[p] {
                map[p] = []
            }
            map[p]?.insert(node)
        }
        let sortedMap = map.sorted { (argv1, argv2) -> Bool in
            argv1.value.count < argv2.value.count
        }
        guard sortedMap[0].value.count == 1 else {
            return initial.min()!
        }
        
        
        var ans = (compomentSize: -1,node: -1)
        for (p,nodes) in sortedMap {
            if nodes.count > 1 {
                break
            }
            let c = compoments[p]
            if c > ans.compomentSize {
                ans = (c,nodes.first!)
            } else if c == ans.compomentSize , ans.node > nodes.first!{
                ans.node = nodes.first!
            }
        }
        return ans.node
    }
 }
```