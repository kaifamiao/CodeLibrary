1. 首先将图分成几个连通分量，如果每个连通分量中有超过两个以上的节点在初始化列表中，则该连通分量一定会全部被传播，因为去掉任何一个点，都不能避免。
2. 找到连通分量后，统计每个连通分量中含有初始化节点的个数，尽量找到只含有一个初始化节点的连通分量，同时满足连通分量包含的节点数最多，因为此时如果将该初始化节点去掉，则该连通分量就不会被感染。
3. 如果未找到如2所示的节点，则直接返回initial列表中最小的值即可。
```
class Solution {
public:    
    int find(vector<int> & f,int x){
        while(x != f[x]){
            x = f[x];
        }
        return x;
    }
    
    bool uni(vector<int> & f,int x,int y){
        int x1 = find(f,x);
        int y1 = find(f,y);
        f[x1] = y1;
        return true;
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        int ans = INT_MAX;
        int maxCnt = 0;
        vector<int> f(n,0);
        map<int,int> count;
        map<int,int> bads;
        
        for(int i = 0;i < n; ++i){
            f[i] = i;
        }
       
        for(int i = 0;i < n; ++i){
            for(int j = 0; j < n; ++j){
                if(graph[i][j]){
                    uni(f,i,j);
                }
            }
        }
        
        for(int i = 0;i < n; ++i){
            count[find(f,i)]++;
        }
        for(auto p : initial){
            bads[find(f,p)]++;
        }
        for(auto p : initial){
            if(bads[find(f,p)] == 1){
                if(count[find(f,p)] == maxCnt){
                    ans = min(ans,p);
                }else if(count[find(f,p)] > maxCnt){
                    maxCnt = count[find(f,p)];
                    ans = p;
                }
            }                
        }
        
        if(ans == INT_MAX){
            for(auto p : initial){
                ans = min(ans,p);
            }
        }
               
        return ans;
    }   
};
```
