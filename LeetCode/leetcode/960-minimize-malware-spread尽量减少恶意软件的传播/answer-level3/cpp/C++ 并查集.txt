```
class Solution {
public:
    vector<int> F;
    int father(int x) {
        if (x != F[x]) F[x] = father(F[x]);
        return F[x];
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        sort(initial.begin(), initial.end());
        int N = graph.size();
        F.resize(N);
        for (int i = 0; i < N; ++i) F[i] = i;
        for (int i = 0; i < graph.size(); ++i) {
            for (int j = 0; j < graph[i].size(); ++j) {
                if (graph[i][j] == 1) {
                    F[father(i)] = father(j);
                }
            }
        }
        map<int, int> groups;
        for (int i = 0; i < N; ++i) {
            ++groups[father(i)];
        }
        map<int, int> black_groups;
        for (auto i : initial) {
            ++black_groups[father(i)];
        }
        int max_group = -1;
        int max_count = -1;
        for (auto& p : black_groups) {
            if (p.second == 1 && groups[p.first] > max_count) {
                max_count = groups[p.first];
                max_group = p.first;
            }
        }
        if (max_group == -1) return initial[0];
        for (auto& i : initial) {
            if (father(i) == max_group) return i;
        }
        return 0;
    }
};
```
![image.png](https://pic.leetcode-cn.com/44e0b443619d326a93a90b4ef079ee545f2ae0b2c9daea88c38ae34901a2bf0c-image.png)
