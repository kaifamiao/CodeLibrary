利用一个二维的整数vector装长度为A.size()，宽度为20001的空间。\
其中vector[ x ][ y ], x是A元素的指针位置，y是则两数的差值（差值0是10001，而差值-10000是0），而其值是这条线目前的长度。

这里就好比穿针引线的思路。\
当两点间没有线时，连上一条线。接着看到有线时，把这条线延长连到下一个点。

先求出最开始的0号数字和之后数字的差值，然后把长度（也就是2）存入后一个数的号数位置。\
比如：A中0号位5，3号位9. 差值是4，就存入vector[3][4]=2。\
然后以此类推，重复的去弄1号2号3号……

比如[5，1，3，9，7，13，17，12]。\
开始分析0号位的5和3号位的9时，得到4的差值，9-5=4,存入vector[3][4]=2，\
随后分析3号位的9和5号位的13时，找到差值[4]，13-9=4，存入vector[5][4]=3，\
之后分析5号位的13和6号位的17时，找到差值[4]，17-13=4，存入vector[6][4]=4，

类似这样的线很多，最后打印出最大值就好。


```
class Solution {
public:
    int longestArithSeqLength(vector<int>& A) {
        vector<vector<int>> different(A.size());
        //最大值至少有2.
        int longest = 2;

        for(int i = 0; i < A.size(); i += 1){
            for(int i2 = i+1; i2 < A.size(); i2 += 1){
                //开始分析i号位和i2号位的差值。

                if(i > 0){
                    if (different[i][A[i2]-A[i]+10000] >= 2){
                        //存入[i2位][差值]，长度+1.
                        different[i2][A[i2]-A[i]+10000] = different[i][A[i2]-A[i]+10000] + 1;
                        
                        //直接在这里记录最大值好了，免得最后还要例遍整个n*20001大小的向量。
                        if(longest < different[i2][A[i2]-A[i]+10000]) longest = different[i2][A[i2]-A[i]+10000];
                    }else{
                        //如果是0就赋予2.
                        different[i2][A[i2]-A[i]+10000] = 2;
                    }
                }else {
                    //如果目前在分析0号位，那就顺手给后面的值先铺20001宽度的路。
                    vector<int> newint(20001);
                    newint[A[i2]-A[i]+10000] = 2;
                    different[i2] = newint;
                }
            }
        }
        
        return longest;
    }
};
```
——————————————————\
碎碎念(我居然不知道怎么在这里打空格)\
——————————————————\

这道题最让人印象深刻的当然是无比开心的 __超时__ 啦~\
一开始十分暴力的例遍用了o(n^3)的时间。\
然后用了一层的vector,给他20001个空位放差值，时间变成了o(n^3)……其实还是下降了一半(n^3/2)。\
于是又用了两层的vector，给他o(n^2)的空位放各种东西，结果时间依旧是o(n^3)……具体来说也就优化到四分之一(n^3/4)。\

但还是 __超时__ 啊！

想着豁出去了，于是两层的固定o(n*20001)的vector放差值和连接点，居然过了。虽然这么说……

`执行用时 : 556 ms, 在Longest Arithmetic Sequence的C++提交中击败了85.23% 的用户`
`内存消耗 : 516.4 MB, 在Longest Arithmetic Sequence的C++提交中击败了100.00% 的用户`

先不说556ms依旧打败了85%的朋友。瞧瞧这__半GB__的内存消耗却打败了100%？\
结果我换的空间结果还是 __最少__ 的吗？这鬼算法还能用 __更多的空间__ 换 __更少的时间__ 吗？