解题思路:
假定给a、b两个字符串，**a、b长度不确定**。a、b字符串的长度决定了最终返回数值的长度，也决定了循环计算的次数。
关于字符串长度可能出现3种情况，a.length>b.length，a.length==b.length，a.length<b.length。其中不等于的两种情况可以等价考虑。
最终和的长度应该在**{max(a.length,b.length),max(a.length,b.length)+1}**这两个数之中。
决定是否加1取决于位数（即题中的长度）相同的两个二进制字符串最高位相加后是否产生进位。这一点我通过最后的进位判断做到。

循环次数按结果数值的最终位数，即max(a.length,b.length)。（是否加1通过判断进位完成）。
在循环过程中，通过异或（进位数也要纳入计算）来进行逐位的取值，若产生进位，则记录进位，并在下一位的取值计算中纳入进位。
循环超过较短字符串的长度时，对这个字符串的取值按0计算。
需要注意不产生进位时，需要将进位置0。
利用array.push方法进行逐位保存，res[0....n]从0到n依次是和的最低位到最高位，需要reverse后再join('')。


题外话：尝试过先将字符串转为数字，求和后转为对应的二进制形式返回，然后被超长字符串教育了，会出现超过数字范围的情况。