其实看到这个题，让我想起有点类似第二题，两数相加那道，都有种思想，就是需要同位相加，看是否有进位，再进行相应处理，只是这道相对简单些，这道题主要是两个字符串的话，可以直接对某个字符串进行改造就行了。我会把注释加在代码里，方便阅读者理解，代码如下：
```php []
/**
     * @param String $a
     * @param String $b
     * @return String
     */
    function addBinary($a, $b) {
        $aSize = strlen($a);
        $bSize = strlen($b);
        //Step 1:计算出每个字符串的长度后，进行比较，以0来填充字符串确保两个字符串位数相同
        while ($aSize > $bSize) {
            $b = '0' . $b;
            ++$bSize;
        }
        while ($aSize < $bSize) {
            $a = '0' . $a;
            ++$aSize;
        }
        for ($i = $aSize - 1; $i >= 0; $i--) {
            //Step 2: 经Step 1后，两字符串位数已经相同，$aSize-1后的下标即为最后一位数的下标，即从末位开始进行相加
            $a[$i] = $a[$i] + $b[$i];
            if ($i != 0) {
                //当下标没有到第一个字符的时候，判断相加之和是否大于1，大于1则需要进位
                if ($a[$i] > 1) {
                    //把相加之和取模2后的值赋值给当前下标对应值
                    $a[$i] = $a[$i] % 2;
                    //顺便把前一个下标对应值先加一个进位，这样在下一轮循环的时候，该值已为最新值了
                    $a[$i - 1] = $a[$i - 1] + 1;
                }
            } else {
                //由于下标0比较特殊，可能两数相加后，会产生一个位数大1的数，则需要再连接一个字符1在字符串前，最后才是正确结果。
                if ($a[$i] > 1) {
                    $a[$i] = $a[$i] % 2;
                    $a = '1' . $a;
                }
            }
        }
        return $a;
    }
```
