看代码之前我们首先需要搞清楚 &，|，^这三个符号的运算规则
    下面我说的第一位都是从左到右开始算的，左边的第一个为第一位。
# &运算的规则
    &运算二进制的规则是只有当都为1的时候，结果为1，其他都为0
    例如 100 & 110的结果，第一位都是1，所以为1，第二位0和1结果为0，第三位0和0结果为0；
    所以100&110的结果为100。
    利用&运算的这个性质我们可以判断两个二进制相加需要进位的位置，然后<<1（左移一位）就可以知道二进制的那一位需要加1。
# |运算的规则
    |运算的规则也很简单，只有两个0的结果是0，其他都为1，100|110的结果为110。
    这次代码没有用到|运算。
# ^运算的规则
    ^运算的规则 相同为0，不同为1。^运算的用途很广，大家可以去看看其他资料，我在这里只讲二进制的运算。   100^110=010，看到这里你有没有什么感觉，是的，你的感觉是对的，二进制的^运算就相当于没有进位的加法。我们可以用&运算知道二进制加法的进位位置，^运算得到二进制的加法，那二进制的加法岂不是就迎刃而解了呢？



现在我们用刚才所学的知识来计算一个二进制的加法
a = "1010", b = "1011"
第一步： a^b来计算没有进位的加法 第一位相同为0，第二位相同为0，第三位相同为0，第四位不同为1。a^b = 0001
第二步：a&b,第一位都为1结果为1，第二位都为0结果为0，第三位都为1结果为1，第四位不同，结果0 a&b = 1010,这个结果告诉我们需要进位的是第1位和第3位，然后我们把（a&b)<<1向左移动一位，相当于把1移动到了需要加1的位置上。
第三步：接下把第一位和第二位的结果相加，我们都应该记得^运算是没有进位的二进制加法，（a^b)^(a&b) = 10101

这个例子只需要一次进位就够了，但是实际中可能需要多次进位，第三步的相加可能还会产生进位，重复第一步和第二步就可以了。下面我们来看代码
```
 public String addBinary(String a, String b) {
        //把字符转转化为2进制的数字
        BigInteger x = new BigInteger(a, 2);
        BigInteger y = new BigInteger(b, 2);
        //二进制的0
        BigInteger zero = new BigInteger("0", 2);
        BigInteger carry, answer;
        //判断y是否为0，因为y为&运算的结果。可能出现连续进位的情况，不为0就是存在进位。
        while (y.compareTo(zero) != 0) {
            //异或运算 ^，相同为0，不同为1
            answer = x.xor(y);
            // & 运算然后 向左移动一个单位
            carry = x.and(y).shiftLeft(1);
            x = answer;
            y = carry;
        }
        //返回计算结果的2进制表现形式
        return x.toString(2);
    }
```
因为在题解里没有发现异或运算比较好的题解，所以写了这一份题解，里面都是自己的一些理解，可能废话比较多，期望能给需要的人一些帮助。





