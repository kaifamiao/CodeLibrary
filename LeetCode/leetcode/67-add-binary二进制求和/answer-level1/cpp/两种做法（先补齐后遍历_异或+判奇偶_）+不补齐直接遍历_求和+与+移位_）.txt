两种做法，第一种是自己费死牛劲想出来的，代码量较大，运行效率还算不错。第二种是去题解中参考的代码量较少的做题思路。接下来对两种思路简单记录说明和附上源代码。
异曲同工，但第二种方法要简练的多。
**第一种 先补齐后遍历<异或+判奇偶>**

一开始没有补齐做的，各种判断分支云里雾里，代码量上百，最后过了部分用例，继续修修补补的时候，把自己绕晕了，才想到补齐后会简洁许多。
短string前面补“0”，使其与长string看起来长得一样，虽然有点“秃顶”，但“身材”看起来一样高大，哈哈。
1、首先定义一个长度为补齐后长度、内容为全“0”的用于返回的结果字符串res（为后面异或操作和判奇偶做准备）；
2、按照“屁股”到“颈部”（即正向第二个元素）的顺序遍历；
3、a、b、res三个当前遍历值异或
    如果异或结果为1，则说明三个值中‘1’的个数为奇数1或3个
        如果是3个就需要进一位，即把下一个需要遍历的res数组元素置为‘1’；
    否则三个值中‘1’的个数就是偶数0或2个
        如果是2个就需要进一位，即把下一个需要遍历的res数组元素置为‘1’；
4、最后头部判断；
    同样类似第3步中的异或、求和判断，只不过不是【下一个需要遍历的res数组元素置为‘1’】而是res数组前插不插、插‘0’还是插‘1’的区别。
5、返回结果数组res;
**************************************************************************************************************************
```
class Solution {
public:
    string addBinary(string a, string b) {
        int len = (a.length() > b.length()) ? a.length() : b.length();
        int slen = (a.length() > b.length()) ? b.length() : a.length();
		string res(len, '0');
		string bb(len-slen, '0');
        
        string aa;
		if(a.length() > b.length())
		{
		     aa = a;
			 bb+=b;
		}
		else{
			 aa = b;
			 bb+=a;
		}
    
        for(int i = 0; i < len-1; i++)
        {
            if((res[len-1-i]-48) ^ (aa[len-1-i] - 48)^(bb[len-1-i] - 48))
			{
				if(((res[len-1-i]-48) + (aa[len-1-i] - 48)+(bb[len-1-i] - 48)) == 3)
				{
					res[len- 1-i-1]  = '1';
				}
				res[len-1-i] = '1';
				
			}
			else
			{
				if(((res[len-1-i]-48) + (aa[len-1-i] - 48)+(bb[len-1-i] - 48)) == 2)
				{
					res[len-1-i-1]  = '1';
				}
				res[len-1-i] = '0';
				
			}
        }
		
		if((res[0]-48) ^ (aa[0] - 48)^(bb[0] - 48))
			{
				if(((res[0]-48) + (a[0] - 48)+(b[0] - 48)) == 3)
				{
					res.insert(res.begin(),'1');
                    res[1] = '1';
				}
            else
            {
                res[0] = '1';
            }
				
				
			}
			else
			{
				if(((res[0]-48) + (aa[0] - 48)+(bb[0] - 48)) == 2)
				{
					res.insert(res.begin(),'1');
                    res[1] = '0';
				}
                else
                {
                    res[0] = '0';
                }					
			}
	
        return res;
    }
};
```
**第一种 不补齐直接遍历<求和+与+移位>**
这个大牛的思路很巧妙
思路：直接对目标两个数组进行求和操作，然后再“&1”，即取求和后结果的最低位保存到结果数组；之后再右移取高位进入下一次遍历。
注意事项：
1、定义结果返回数组的时候使用reserve预留足够空间，避免重新分配，增加消耗；
2、循环过程中注意判断两个数组是否已经遍历完；
```
class Solution {
public:
    string addBinary(string a, string b) {
        
        int i = a.size()-1;
        int j = b.size()-1;
        string res;
        res.reserve(i + j);
        
        int m = 0;
        while(i >= 0 || j >= 0 || m == 1)
        {
            m += i>=0 ? a[i--]-'0' : 0;
            m += j>=0 ? b[j--]-'0' : 0;
            res.push_back((m & 1) +'0');
            m >>=1;
        }
        reverse(res.begin(), res.end());
        
        return res;
        
    }
};
```

