
个人感觉，二维dp数组和一维dp数组的思维差别还是挺大的。
首先假设A为列，B为行。
### 对于二维的dp数组
我们直接创建一个大小为`A.size()*B.size()`的dp数组，然后对第一行和第一列进行很显然的初始化，如果`A[0]`和`B[j]`相等，那么`dp[0][j]`就是1，对于列也是一样。然后就可以很明显的从左到右，从上到下计算dp的每个元素了，这里就不贴代码了。

算了还是贴一下吧。

```
class Solution {
public:
    // 双5%的丑陋代码
    int findLength(vector<int>& A, vector<int>& B){
        vector<vector<int>> dp(A.size(),vector<int>(B.size(),0));
        int res = 0;
        for(int i=0; i<B.size(); i++){ // 对第0行初始化
            if(B[0] == A[i]){
                dp[0][i] = 1;
                res = max(res,dp[0][i]);
            }
        }
        for(int i=1; i<B.size(); i++){ // 对第0列初始化
            if(A[0] == B[i]){
                dp[i][0] = 1;
                res = max(res,dp[i][0]);
            }
        }
        for(int i=1; i<dp.size(); i++){  // 然后进行很显然的计算。
            for(int j=1; j<dp[0].size(); j++){
                if(B[i] == A[j]){  // 如果当前位相等，那么匹配长度就是上一位匹配长度+1
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                // 如果当前位不等，那就是0，不用写了。
                res = max(res,dp[i][j]);
            }
        }
        return res;
    }      
};
```

### 而如果采用一维dp数组
我们需要将整个dp数组后移，也就是说声明的数组长度必须是size()+1的。
那么A的第`0`位和B的第 `j` 位的最长匹配值，实际上是记录在`dp[j+1]`中的。而不是`dp[j]`.
而关于倒序计算的问题，其实大家都能理解。
就是说，只要我们能够把dp当中的`j+1`就当成`j`，那么当然可以根据A[0]和B[j]是否相等来算出"`dp[j]`"了（其实是`dp[j+1]`）。
- 有人说这不就是下标挪一位吗？为什么一定要这样呢？

首先，我试过了，真的一定要这样。（狗头）


仔细思考一下，是因为挪一位可以腾出一个`dp[0]`来，这个`dp[0]`照理说是没有意义的，(dp[1]才有明显的意义，它表示A的某个字符与B[0]的最长匹配值，要么是1，要么是0)，但是，这里的`dp[0]`永远是0，而他起到了**在二维dp数组中给第0列**初始化的作用。在这里就是给`dp[1]`初始化。


再次注意，二维数组的第0列和这里的第0列是完全不同的概念，二维数组的第0列的值是我们手动给的，可能是0，可能是1.而这里的第0列，是更加底层的逻辑，永远是0，表示“A的任意一个字符和**空字符**（B的第-1个字符的空字符）的最长匹配是0”。


当然，如果你在二维dp数组中就用到了这种想法的话，当我没说，我承认我的二维dp写得比较原始，牛逼点的写法可以不用手动初始化的，直接**挪一位+倒序**，那样的话，这个二维到一维的优化就很顺畅了。 嗯，不错嘛~

### 代码

```cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<int> dp(B.size()+1, 0); // 必须要加1
        int result = 0;
        for (int i = 0; i < A.size(); ++i) { // 行，指向A的每个字符
            for (int j = B.size()-1; j >= 0; --j) { // 列，指向B的每个字符，注意先与B的最后一个字符比较
                if(A[i] == B[j]){
                    dp[j+1] = dp[j]+1;// 看，比较的是B[j],但是记录在dp[i+1],永远是这样。
                }else{
                    dp[j+1] = 0;
                }
                result = max(result, dp[j+1]);
            }
        }
        return result;
    }
};
```

感觉有东西的话求个赞。。
