### 解题思路
大概思想就是将除数一直翻倍，直到比被除数大后再去计算最近一次翻倍后的数与被除数之间还有多少个除数。
此题不能被除数一直减去除数来判断最后的值，如果两数绝对值相差较大则肯定会超时，我开始就是用这个方法入坑的，希望大家能注意，详细的思路在代码里面都有注释，由于我是新手，大佬看见了希望能指点一下。

### 代码

```c
int divide(int a, int b)
{
	if(a == 0 || b == 0)//若两数当中有个为零则立马返回0（虽然题目给出了b（除数）不会为零）
	{
		return 0;
	}
    if(a == b) //若两数相等则立马返回1
    {
        return 1;
    }

	int x = a^b;//两数相与，若为负数，则两数异号
	int sum = -1; //存储翻了多少倍
	int tmp = 0; //将所有翻倍的累加(也就是答案)
	if(a > 0) //由于使用正数计算可能会溢出，所以我将数据都转为负数计算
	{
        a = -a;
	}
	if(b > 0)
	{
		b = -b;
	}
    if(a > b)
	{
		return 0;
	}
    if(a == b) //转为负数后若两数相等，则肯定互为相反数（如果相同前面已经return了）
    {
        return -1;
    }
	int tb = b;//记录除数翻倍后的值
	while(a <= b)//如果除数还能继续翻倍就继续循环
	{
		while(tb >= (a - tb))//判断除数翻倍后的值是否比被除数大
		{
			sum += sum;
			tb += tb;
		}
		a -= tb; //tb+tb大于a，则判断a与tb间还有多少个b
		tb = b;
		tmp += sum;
		sum = -1;//重新初始化a,tb,sum,并将sum的累加值赋给tmp
	}
	if(x > 0) //若两数同号，则结果需要取正数
	{
        if(tmp == INT_MIN)//若结果为最小值，直接转正数则会溢出，所以就直接返回最大值了
        {
            return INT_MAX;
        }
		tmp = -tmp;
	}
	return tmp;
}
![两数相除.png](https://pic.leetcode-cn.com/b7f588cf24ee2cc8625dc04e7b4c982eac5d892840de673a7ca19808b63c06c5-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4.png)
