
#### 方法：筛选合数

##### 问题分析

暴力的方式就是对每一个小于目标`n`的数字依次的检查是不是素数。这种方法的时间复杂度很高，为$O(n^2)$。优化的方式为：

一个合数必然能够拆成两个正整数的乘积。最终，一个合数必然能拆分成多个素数的积累。
但是通过素数求素数并不是很好操作，所以可以通过逆否命题的方式计算答案。如果我们能够将小于`n`的所有合数全部通过上面这种性质筛选出来，素数的个数就显而易见了。

##### 算法

+ 从小到大按顺序访问小于`n`的元素。在访问第`i`个元素时，将所有`i`的整倍数的元素全部标记为合数
+ 继续按顺序访问：
    + 如果此时该元素`i`已经被标记为合数，则跳过该元素。
    + 如果此时该元素`i`未被标记为素数，则进行第一步描述的过程。


```java []
class Solution {
    public int countPrimes_a(int n) {
        if(n <= 2) return 0;

        boolean[] composites = new boolean[n];
        int count = n - 2;
        for (int i = 2; i <= (int) Math.sqrt(n); i++) {
            if(composites[i]) continue;
            for (int j = i; j * i < n; j++) {
                if(!composites[i * j]) count--;
                composites[i * j] = true;
            }
        }

        return count;
    }
}
```

在这里还有一些问题要注意。由于每次在执行第一步操作时，倍数无需从0开始。而是从自己开始，即第`i`个元素从自己的第`i`倍开始。这么做的原因是所有小于`i`的`i`倍的合数已经在之前的过程中全部被标记出来了。所以，外层循环的上限不大于$\sqrt{n}$。而且内层循环的种植条件为$i \times j \lt n$。

