先说明一下。这个题目只有按照官方题解，dp[][][]的形式解题，才不会有对结果取余的问题，但是因为取余操作已经破坏了结果的准确性。因此官方的测试用例，是针对题解的形式得出的不准确的匹配结果。（个人理解）

如对于第36个用例
36
"sngdmqatjfksenidrvprcbefgytikdhypsyk"
"yspvjpkmagzzkgvmlryhxcfrikqlkjtwerdb"
"cmzeekdtszmcsrhsciljsrdoidz"

用直接暴力动态规划的思路，测试用例不过，但是对过程的dp进行取余操作就会没问题。
本人的测试用例到36个就挂了，感觉是由于测试用例对结果取余引起的，建议官方用unsigned long long



    输入:s1, s2, n, evil 其中strlen(s1) == strlen(s2) == n 且s1 <= s2，evil最少一个字符
    求s的个数，其中s1 <= s <= S2 且 s不包含evil子字符串
    思路：硬解直接构造字符串然后判断合法性，然后在计数，很快就会超时了，因此不能通过构造所有字符的方式，只能通过计算的方式
    定义evil的长度为m，strlen(evil) == m
    我们考虑减而治之的思想，不妨设dp[i]表示前i个字符可以构成的合法字符串s[0~i-1]的数目, i <= n, dp[0]不用
    s[0~i-1]应该满足条件 s1[0~i-1] <= s[0~i-1] <= s1[0~i-1] 且 s[0~i-1] 不包含evil字符串，注意这里是不包含完整的evil字符串,

    两个思路（1）从前往后看，即从dp[1]开始 （2）从后往前看，即从dp[n]开始
    分别来看这两种方式
    （1）从前往后看，即从dp[1]开始
    dp[0]: 设dp[0]=1 （可以先不用关心）
    dp[1]:
        我们先来构造第一个字符，很简单
        s[0]: s1[0] <= s[0] <= s2[0]
        dp[1] = s2[0] - s1[0] + 1
        写成另一种形式(和后面递推公式保持一致，可以先不管)：
        dp[1] = 26 - (s1[0] - 'a' + 'z' - s2[0])
        注意，这里dp[1]是没有考虑evil的，如果m>1，则不需要考虑，一个字符肯定不包含evil，如果m==1，则就需要看evil是否落在合法范围，
        我们用y[1]表示y[1] = 1 < m ? 0 : ((evil < s1[0] || s2[0] < evil) ? 0 : 1)
        不妨设x[1] = s1[0] - 'a' + 'z' - s2[0]
        所以可以得到：
        dp[1] = 26 - x[1] - y[1]

    dp[2]:
        s[0]s[1] = s[0]*: s1[0]s2[0] <= s[0]* < s2[0]s2[1]
        经过了dp[1]，s[0]的取值已经确定下来了
        不妨设第二个字符可以去任意的'a'~'z'：
        则dp[2] = dp[1] * 26
        再考虑当前的dp[2]中，有一些字符串不满足条件，有哪些不满足条件呢？
        首先，s[0] == s1[0]与s[0] == s2[0]的两个边界值时，第二个字符不可以任意取，
        因此dp[2] = dp[1] * 26 - (s1[0] == s2[0] ? s2[1] - s1[1] + 1 : ((s1[1] - 'a') + ('z' - s2[1])))
        我们让减去的边界字符为x[2] = (s1[0] == s2[0] ? s2[1] - s1[1] + 1 : ((s1[1] - 'a') + ('z' - s2[1])))
        则dp[2] = dp[1] * 26 - x[2]
        (因此，我们可以回去将dp[1]也写成这种形式，dp[1] = dp[0]*26 - x[1] - y[1]， 其中x[1] = (s1[0] - 'a') + ('z' - s2[0]))
        其次，还会有包含evil子字符串的不合法，我们在去除边界非法的的基础上继续去除非法的evil字符串
        dp[2] = dp[1] * 26 - x[2] - y[2]
        我们来求y[2]:
        考虑m==1时，只需要看evil是否在s[0]*中：
            又分两种情况，s[0]在边界上，s[0]不在边界上
            s[0]在边界的情况：
                边界不重叠s1[0] != s2[0]：
                s1[1] <= evil ? 1 : 0
                evil <= s2[1] ? 1 : 0
                边界重叠s1[0] == s2[0]：
                (s1[1] <= evil && evil <= s2[1]) ? 1 : 0
                因此可以得到这种情况下的y[2]
                y[2] = (s1[0] == s2[0]) ? ((s1[1] <= evil && evil <= s2[1]) ? 1 : 0) :
                                          ((s1[1] <= evil ? 1 : 0) + (evil <= s2[1] ? 1 : 0))
            s[0]不在边界的情况：
                s2[0] - s1[0] > 1 ? (s2[0] - s1[0] - 1) : 0
            因此可以得到：
            y[2] = (s1[0] == s2[0]) ? ((s1[1] <= evil && evil <= s2[1]) ? 1 : 0) :
                                      ((s1[1] <= evil ? 1 : 0) + (evil <= s2[1] ? 1 : 0))
                  +(s2[0] - s1[0] > 1 ? (s2[0] - s1[0] - 1) : 0)
        考虑m==2时：就是看evil是否在s[0]*内
            也分为两种情况，s[0]在边界上，s[0]不在边界上
            s[0]在边界上：
                边界不重叠：
                (s1[0] == evil[0] && s1[1] <= evil[1]) ? 1 : 0
                (s2[0] == evil[0] && evil[1] <= s2[1]) ? 1 : 0
                边界重叠：
                s1[0] == evil[0] ? (s1[1] <= evil[1] && evil[1] <= s2[1] ? 1: 0) : 0
            s[0]不在边界上:
                s1[0] < evil[0] < s2[0]:
                s2[0] - s1[0] > 1 ? (s2[0] - s1[0] - 1) : 0
                否则：0
            由此也可以得到y[2]
    通过对dp[2]的分析，我们可以看到，难点主要在于计算x[2]和y[2], 其中y[2]的情况更复杂，但仔细观察可以看到，
    其实y[2]主要考虑在x[1]的基础上，当前构造前i个字符，与需要排除的m个字符的关系

    下面我来根据dp[2]分析的思路，来进行更一般的分析dp[i+1]:
    dp[i+1]:
    先写出递推公式的形式：
        dp[i+1] = dp[i] * 26 - x[i+1] - y[i+1]
    先分析x[i]: 
        前i个字符构成的字符串都确定了为s[0]~s[i-1]
        构造第i+1个字符s[i]='a'~'z'
        考虑前i个字符构成的字符串，s[0]~s[i-1]中，肯定会有落在边界上s1[0]~s1[i-1]和s2[0]~s2[i-1]的，
        s1[0]~s1[i-1]和s2[0]~s2[i-1]也可能相等，即有相同的前缀，因此如果相等，则落在边界上只有一个，否则为两个，
        可以这样来表示：
            strncmp(s1, s2, i) == 0 ? 1 : 2
        当只有一个时：
            多算的边界为： s1[0]~s1[i-1]a    到s1[0]~s1[i-1]s1[i] 共s1[i] - 'a'个
                          s2[0]~s2[i-1]s2[i]到s2[0]~s2[i-1]z     共'z' - s2[i]个
        当落在边界上有两个时，多算的边界个数为：
            s1边界：s1[i] - 'a'
            s2边界：'z' - s2[i]
         因此，不管是一个边界还是两个边界，多算的个数为：x[i+1] = s1[i] - 'a' + 'z' - s2[i]

    在来分析y[i+1]:
        参考dp[2]时的分析，y[i+1]需要根据m的长度以及i+1的长度分别进行分析，分为i+1 < m, i+1 == m, i+1 > m
        i+1 < m的情况：
            y[i+1] = 0;
        i+1 ==m的情况:
            也比较简单，直接比较evil是否在s1[0]~s1[i-1]s1[i]与s2[0]~s2[i-1]s2[i]之间
            y[i+1] = strncmp(s1, evil, i+1) <= 0 && strncmp(evil, s2, i+1) <= 0 ? 0 : 1;
        i+1 > m的情况：
            比较直观，我们构造i+1是根据前i个字符已经构造完成的基础上进行的，如果前i个字符中的最后m-1个字符，刚好与evil的前m-1个
            字符相同，那么，我们在构造第i+1个字符时，就有可能刚好使i+1个字符的最后m个字符与evil字符串相等，相等的这部分个数，
            正式我们需要计算出来的。怎么呢求取呢？
            就是按照这个直观的想法，我们先不考虑第i+1个字符，只考虑前i个。这个地方比较难想
                先考虑个例子 s1=abcde
                            s2=fghij
                          evil1=aaaa  需要排除的有  [b|c|d|e|f]aaaa
                          evil2=zzzz  需要排除的有[a|b|c|d|e|]zzzz
                可见我们没法通过比较s1[i-m]~s1[i]和evil[0]~evil[m-1]来进行，当然s2[i-m]~s2[i]也没办法比。
                通过观察上面的这个例子，我们可以看到，这个个数应该是和前i-m-1个字符串的个数有关系，怎么理解呢?
                需要仔细看了：
                 ：     |-----------------dp,x,y的1到i是确定的-------------------|  ?  |
                dp：| 0 |  1  | ... |i-(m+1)|  i-m  |i-(m-1)|  ...  | i-1 |  i  | i+1 |
                x： | 0 |  1  | ... |i-(m+1)|  i-m  |i-(m-1)|  ...  | i-1 |  i  | i+1 |
                y： | 0 |  1  | ... |i-(m+1)|  i-m  |i-(m-1)|  ...  | i-1 |  i  | i+1 |

                s1：    |  0  |  1  |  ...  |i-(m+1)|  i-m  |i-(m-1)| ... | i-1 |  i  |
                evil：                                      |   0   | ... | m-2 | m-1 | 
                s2：    |  0  |  1  |  ...  |i-(m+1)|  i-m  |i-(m-1)| ... | i-1 |  i  |

                在我们构造的i+1个字符串集合中，我们前面分析知道，可能有最后m个字符构成的串等于evil，
                因此我们现在就是让最后m个字符为evil，是一个唯一确定的
                我们还知道，我们构造的这i+1个字符构成的字符串集合中，前i+1-m个字符肯定在dp[i+1-m]中
                因此我们知道我们构造的i+1个字符中，最后m个为evil的所有字符串，共有dp[i+1-m]个
                在这dp[i+1-m]个字符串中，都是不符合条件的，但是再考虑一下边界，我们在前面先计算x[i+1]时，
                已经将不符合边界条件的字符串踢出了，这里如果有字符串刚好在边界外，再踢出一次，就会重复了，
                因此我们要找出这dp[i+1-m]个字符串中，有几个是在边界外的？
                还是直观的考虑，前i+1-m个字符中，可能会包含边界s1[0]~s1[i-m]或s2[0]~s2[i-m]，也可能不包含，
                    包含边界的条件很直观s1[0]~s1[i-m]不包含evil子串，s2[0]~s2[i-m]不包含evil子串
                因此我们还需要记录前dp[i]中是否会包含边界，不妨用全局变量e1[i], e2[i]来表示，0为不包含，1为包含。
                因此可以有如下边界判断逻辑
                    y[i+1] = dp[i+1-m];
                    if (e1[i+1-m] == 1) {
                        //为边界，则继续看前i个字符的最后m-1个，是否和evil的前m-1个一致
                        if (strncmp(&s1[i+1-m], evil, m-1) == 0) {
                            //进入这里表示s1边界的前i个字符中，最后m-1个与evi的前m-1个相同，需要进一步比较第i+1个字符
                            if (evil[m-1] < s1[i]) {
                                //进入这里表示， s1的边界前i个字符的最后m个字符，加上evil最后一个字符，构成的i+1个字符，在边界外
                                //因此i+1个字符构成的字符串，让然包括边界s1
                                es1[i+1] = 1;
                                //说明dp[i+1-m]个字符串中多计算了一个边界外的字符串，需要补偿回来
                                y[i+1] -= 1;
                            } else {
                                //说明dp[i+1-m]个字符串在s1边界内，不需要补偿
                                y[i+1] += 0;
                                if (evil[m-1] == s1[i]) {
                                    // i+1个字符的边界值非法
                                    es1[i+1] = 0;
                                }
                            }
                        }
                    }
                    判断s2边界也是一样的计算
                
    （2）从后往前看，即从dp[n]开始，直接参考dp[n]



```http
#define LOGS printf
int findGoodStrings(int n, char * s1, char * s2, char * evil){
    unsigned int *pool = NULL;
    unsigned long long *dp = NULL;
    unsigned int x;
    unsigned int y;
    unsigned int *e1 = NULL;
    unsigned int *e2 = NULL;
    int step = n + 1; /* dp[i+1]表示第i个字符的dp */
    int i;
    int m;
    int ret;

    /* 合法性入参保证 */
    dp = (unsigned long long *)malloc(sizeof(unsigned long long) * step);
    if (dp == NULL) {
        LOGS("mallco error!\n");
        return -1;
    }

    pool = (unsigned int *)malloc(sizeof(unsigned int) * step * 2);
    if (pool == NULL) {
        LOGS("mallco error!\n");
        free(dp);
        return -1;
    }
    e1 = &pool[0];
    e2 = &e1[step];

    for (i = 0; i < step; i++) {
        dp[i] = 0;
        e1[i] = 0;
        e2[i] = 0;
    }

    /* 递推公式 dp[i+1] = dp[i] * 26 - x[i+1] - y[i+1] */
    dp[0] = 1;
    e1[0] = 1;
    e2[0] = 1;
    m = strlen(evil);
    for (i = 1; i <= n; i++) {
        e1[i] = e1[i-1];
        e2[i] = e2[i-1];
        /* 计算x */
        x = 0;
        if(e1[i-1] == 1) {
            /* i-1个字符构成的字符串，包含s1边界 */
            x += s1[i-1] - 'a';
        }
        if(e2[i-1] == 1) {
            /* i-1个字符构成的字符串，包含s2边界 */
            x += 'z' - s2[i-1];
        }

        /* 计算y */
        if (i >= m) {
            y = dp[i-m];
            if (m > 1) {
                if (e1[i-m] == 1) {
                    if (strncmp(&s1[i-m], evil, m-1) > 0) {
                        y -= 1;
                    } else {
                        if (strncmp(&s1[i-m], evil, m-1) == 0) {
                            if (s1[i-1] < evil[m-1]) {
                                y -= 1;
                            } else {
                                if (s1[i-1] == evil[m-1]) {
                                    e1[i] = 0;
                                }
                            }
                        }
                    }
                }
                if (e2[i-m] == 1) {
                    if (strncmp(&s2[i-m], evil, m-1) < 0) {
                        y -= 1;
                    } else {
                        if (strncmp(&s2[i-m], evil, m-1) == 0) {
                            if (s2[i-1] < evil[m-1] ) {
                                y -= 1;
                            } else {
                                if (evil[m-1] == s2[i-1]) {
                                    e2[i] = 0;
                                }
                            }
                        }
                    }

                }
                if (y < 0) {
                    y = 0;
                }
            } else {
                /* evil为单字符 */
                if (s1[i-1] > evil[0] || evil[0] > s2[i-1]) {
                    y -= 1;
                }
            }
        } else {
            y = 0;;
        }

        /* 计算dp[i] */
        dp[i] = dp[i-1] * 26 - x - y;
        LOGS("dp[%d] = %llu = %llu * 26 - %d - %d\n", i, dp[i], dp[i-1], x, y);
        ***dp[i] = dp[i] % 1000000007;  /* 为了配合用例，这里进行了取余操作，其实真实个数不应该取余，只有最后dp[n]取余即可。由于这里取余，导致后续递推的乘法操作有误差累计，因此和官方测试用例不匹配。至少在不越界时是ok的 */***
    }

    ret = dp[n] % 1000000007;

    free(dp);
    free(pool);
    return ret;
}
```