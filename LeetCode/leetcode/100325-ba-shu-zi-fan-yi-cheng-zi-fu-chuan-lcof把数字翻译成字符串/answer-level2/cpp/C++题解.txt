### 动态规划
```cpp
执行用时 :4 ms, 在所有 C++ 提交中击败了55.77%的用户
内存消耗 :7.2 MB, 在所有 C++ 提交中击败了100.00%的用户
```
首先，我们从简单到复杂逐步思考这个问题：

1. n为一位数，如n=1，这时候只有一种翻译方式：{1}

2. n为两位数：
    * 当n=12，这是时候翻译方式有两种：{1，2}，{12}

    * 当n=26，由于26大于25，翻译方式有一种：{2，6}

    * 当n=02，由于02和2实际上应该是同一种翻译方式，因此结果只有一种：{0，2}

3. 当n为3位数：
    * 如n=122，这时候翻译方式有三种：{1，2，2}，{12，2}，{1，22}

    * 当n=126，翻译方式有两种：{1，2，6}，{12，6}

    * 当其中有0出现时我们稍后考虑

4. 观察上面的翻译方式，假设我们有一个数组dp来记录当前位置处的总翻译的方式，那么我们可以发现在第i个位置的翻译方式和i-1，i两个位置组成的数字是否在0到25的区间有关。如果它属于[0,25]（没考虑有0的情况）的话就可以单独成为一种翻译方式，因此i位置的总翻译次数应该加上dp[i-2]，否则只能分开翻译，等于dp[i-1]的翻译总数。因此，在不考虑
0 的情况下我们可以得到下面的公式：
```cpp
dp[i]=1, i=0
dp[i]=dp[i-1], i!=0, str(i-1,i)>25
dp[i]=dp[i-2]+dp[i-1], i!=0, 0=< str(i-1,i) <=25
```
但是，当有0出现的时候，str(i-1,i)就可能没办法组成一个有效的翻译数字，因此当str(i-1，i)组成的数字小于10的时候，也应该等于dp[i-1]，因此公式应该为：
```cpp
dp[i]=1, i=0
dp[i]=dp[i-1], i!=0, str(i-1,i)>25 ||  0=< str(i-1,i) <10
dp[i]=dp[i-2]+dp[i-1], i!=0, 10=< str(i-1,i) <=25
```
##时间/空间复杂度
时间复杂度：O(n)

空间复杂度：O(n)

### 代码

```cpp
class Solution {
public:
    int translateNum(int num) {
        string str=to_string(num);
        string tps;
        int tpi;
        vector<int> dp(str.size(),0);
        for(int i=0;i<str.size();++i){
            if(i==0){
                dp[i]=1;
            }else if(i==1){
                tps=str.substr(0,2);
                tpi=stoi(tps);
                if(tpi>=10&&tpi<=25) dp[i]=2;
                else dp[i]=1;
            }else{
                tps=str.substr(i-1,2);
                tpi=stoi(tps);
                if(tpi>=10&&tpi<=25){
                    dp[i]=dp[i-1]+dp[i-2];
                }else{
                    dp[i]=dp[i-1];
                }
            }          
        }
        return dp[dp.size()-1];    
    }
};
```