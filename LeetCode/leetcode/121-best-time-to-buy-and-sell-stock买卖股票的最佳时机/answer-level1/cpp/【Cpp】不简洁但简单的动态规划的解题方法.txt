### 解题思路

动态规划的核心三步是，定义子问题，定义状态数组和定义转移方程。

定义子问题的关键在于找到问题中的自变量和因变量。

该问题受到三个因素影响，时间和操作和操作次数，因变量是利润。因此需要用**三个变量**来描述状态。

DP[i][j][k] 表示 第i天状态为j(0持有,1不持有),且操作次数为k(k=0,1)的情况下最大利润

因此总计有i \* j \* k = i \* 2 \* 2  = 4i 种状态

- DP[i][0][0] = DP[i-1][0][0] ; //之前没有操作
- DP[i][0][1] = max(DP[i-1][0][1] + DP[i-1][1][0] + a[i]); // 不操作, 或者之前持有后卖出构成一次完成操作
- DP[i][1][0] = max(DP[i-1][1][0] + DP[i-1][0][0] - a[i]); //不操作，或者之前不持有，现在持有，形成一半操作
- DP[i][1][1] ;// 不存在,因为一次完整的操作后，最终一定不持有。

代码如下

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0 ) return 0;
        int DP[prices.size()][2][2];
        for (int i = 0 ; i < prices.size(); i++ ){
            for (int j = 0; j < 2; j++){
                for (int k = 0; k < 2; k++ )
                DP[i][j][k] = 0;
            }
        }
        DP[0][0][0] = 0;
        DP[0][1][0] = -prices[0]; //买入
        
        for (int i = 1 ; i < prices.size(); i++ ){
            DP[i][0][0] = DP[i-1][0][0];
            DP[i][1][0] = max(DP[i-1][1][0], DP[i-1][0][0] - prices[i]);
            DP[i][0][1] = max(DP[i-1][0][1], DP[i-1][1][0] + prices[i]);
        }
        return DP[prices.size()-1][0][1];

    }
};

```

代码分为三个部分

- 创建数组并初始化
- 定义基本状态
- 递推
