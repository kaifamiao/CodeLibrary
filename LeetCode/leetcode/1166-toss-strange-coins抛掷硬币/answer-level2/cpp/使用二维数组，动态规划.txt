- 使用dp[i][j] 表示投掷出的i枚硬币中有j枚朝上
- 初始化 dp[0][0]=1 表示投掷零枚硬币，有零枚朝上的概率为1
- 动态规划要遍历每种状态，从第一次投递开始到第n次投掷
- 每次投掷时，先初始化零次正面朝上为  dp[i][0] = dp[i-1][0]*(背面朝上的概率)
- 在每次投掷中，可能为正面，也可能为背面。
    1. dp[i][j] = dp[i-1][j]\*(1-prob[i-1]) + dp[i-1][j-1]*prob[i-1];
    2. dp[i-1][j]*(1-prob[i-1]) 代表上次投掷出j枚朝上这次投出背面朝上
    3. dp[i-1][j-1]*(prob[i-1])代表上次投掷出j-1枚朝上这次投出正面朝上
    4. 2，3两种情况都会产生dp[i][j] 所以要把这两种情况加起来 
```
double dp[1001][1001];
// dp[i][j] 抛掷i枚硬币，里面有j枚正面朝上
class Solution {
public:
    double probabilityOfHeads(vector<double>& prob, int target) {
        int n = prob.size();
        memset(dp,0,sizeof(dp));
        
        dp[0][0]=1.0;  //抛掷零枚硬币，有零枚正面朝上的概率为1
        
        //从第一次抛硬币开始
        for(int i=1;i<=n;i++){
            //先初始化零次 正面朝上， 上一次零次正面朝上 × 这次零次正面朝上（背面朝上）
            dp[i][0] = dp[i-1][0]*(1-prob[i-1]);
            //j代表正面朝上的次数，从1次开始，一直可以到i次，所以范围是0-i
            for(int j=1;j<=i;j++){
//                         ☟ 抛出硬币为背面（上次抛硬币为j次，此时还是j次）  ☟ 抛出硬币为正面（上次抛出正面为j-1次，这次抛出j次）
                dp[i][j] = dp[i-1][j]*(1-prob[i-1])           +           dp[i-1][j-1]*prob[i-1];
            }
        }
        
        return dp[n][target];
    }
};
```
dp数组的格式如下 从零开始一直到n
```

1           0           0           0           0           0           
0.5         0.5         0           0           0           0           
0.25        0.5         0.25        0           0           0           
0.125       0.375       0.375       0.125       0           0           
0.0625      0.25        0.375       0.25        0.0625      0           
0.03125     0.15625     0.3125      0.3125      0.15625     0.03125    
```