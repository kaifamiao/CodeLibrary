## 解题思路
解答用的正则为：
> ^\s*[+-]?(?:\d+|(?=\.\d))(?:\.\d*)?(?:e[+-]?\d+)?\s*$

大概分一下，可以分成以下几个部分：
1. ^\s*
2. [+-]?
3. (?:\d+|(?=\.\d))
4. (?:\.\d*)?
5. (?:e[+-]?\d+)?
6. \s*$

### 1.^\s* and 6. \s*$

匹配开头结尾位置来达到全字符串匹配的效果。因为题目描述的case里就有带空格的，所以用\s*去匹配可能的空格（或者把输入trim了也行）。

### 2.[+-]?

用一个字符class去表达可能存在的符号位，加上一个?让其变成可选。

### 3.(?:\d+|(?=\.\d))
即正文的整数部分，由两个子句组成。

一种是\d+的正常整数。其实这里吐槽一句，本来我是考虑了首位不能为0的，写出来就是(?!0)\d+|0。结果case里判01是通过的，所以直接\d+就行了。

另一种是针对无整数部分的.123这种的，整数部分为空，但是后面必须有小数，这种情况下小数部分至少需要一位数字（因为case判"."为false）。所以用环视(?=\.\d)来表达这种情况。

### 4.(?:\.\d*)?

小数部分，整体加上?来使其可选。数字部分用*是因为case判123.这种通过。上一节中的(?=\.\d)可以否定"."的情况，其实也可以在这里使用一个逆向环视。

### 5.(?:e[+-]?\d+)?
指数部分。像3.里说的那样，其实应该要考虑首位不能为0，这里我不知道他定义到底能不能为0,3里改了这里也就改了吧。

分析完了正则，其实代码就没啥好说的了。


## 代码

```csharp
using System.Text.RegularExpressions;
public class Solution {
    private static Regex pattern = new Regex(@"^\s*[+-]?(?:\d+|(?=\.\d))(?:\.\d*)?(?:e[+-]?\d+)?\s*$");
    public bool IsNumber(string s) {
        return pattern.IsMatch(s);
    }
}
```