现在我们都知道这道题的初级版本中 ，只有一个数出现一次，xor 一遍即可得到答案。为什么呢，原因有三：
1. A xor A=0
2. 0 xor A=A
3.  并且 xor 满足交换律和结合律。

比如对于 `2 2 3 1 3`，
```
2 xor 2 xor 3 xor 1 xor 3 
= 2 xor 2 xor 3 xor 3 xor 1
=(2 xor 2) xor (3 xor 3) xor 1 
= 0 xor 0 xor 1 
= 1
```

在这道加强版的题目里，也会很自然的想到 xor 一遍，那结果是什么呢？假设只出现一次的两个数是 A、B，那我们最后只能得到一个值 ： `A xor B`，**但没有办法知道 A 是多少，B 是多少。**

那得到的这个值是不是没有用呢？不是，`xor` 是按位比较的，相同为 0，不同为 1，也就是说得到的这个值的二进制里，**所有的1都代表了：在这一位上，A 和 B 是不同的**，这给我们区分 A B 提供了一个方法：

我们在这个值里随便找是1的一位（**也就是 A 和 B 在这一位上的值反正有一个是0 有一个是1**），再次遍历一遍数组，**按照每个数这一位上是0还是1分成两组，那么 A 和 B 一定会被分开**。而对于其他的数字，无论他们在这个位置上是 0 还是 1，**总之他们会两两一对一起分到其中一个组里去**。

这就转化成了初级版本的问题了，每个组中都只有一个数只出现了 1 次，对两个组分别做一次`xor` ，得到两个数就是 A 和 B了。
