### 解题思路
#### 预备知识
- 异或操作的定义：如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。
因此
- n^0 = n;
- n^n = 0;
- n^n^m = n^(n^m) 满足交换律
#### 然后分析思路：
- 如果这个题是，只有一个数字时出现一次的，找出它。
那么解法就是，把这个数组从第一个开始异或一遍，具体解释如下：
    比如`[1,2,2]`,定义`num = 0`
    1. 一开始`num = 1^num = 1`；
    2. 然后`num=2^num`；
    3. 再然后`num=2^num`，这个时候注意，由于满足交换律，两个2在异或的过程中变为了0；
    4. 所以最后等价于`num = 1^num =1`。得到了此数字。

- 回到本题：
本题有两个这样的数字，因此自然想到，把数组变为两个都只有一个数字出现一次的数组，然后用上面的方法解决。
- 关键在于：如何把这两个数分到两个数组里？
- 预备知识：相反数的定义是取反加一
1. 由于这两个数只出现一次，因此异或这个数组到最后就等于这两个数的异或，假设结果为`number`。这个number的二进制数字必然包含一个1（不然就等于0了，而这两个数不相等，所以是不能为0的）。因此找到number最右边第一个1的位置，方法是`int pos =  number&(-number);`比如`pos=(010&(110))=010`这样就找到了右边第一个1。
1. 以这个pos作为标准，这个位置是1的数字，放到第一个数组里做异或运算，不是1的放到第二组。其中不用管那些出现两次的数字，因为不管这些数字pos位置是不是1，都会存在两个，异或两次就变为0不会产生影响。

### 代码

```cpp
class Solution {
public:
    vector<int> singleNumbers(vector<int>& nums) {
        vector<int> res(2,0);
        int number = 0;
        for(int num:nums)
            number ^= num;
        int pos =  number&(-number);
        for(int num:nums)
        {
            if((num & pos)==pos) //这个位置是1的数字，放到第一个数组里做异或运算
            {
                res[0] ^=num;
            }
            else 
            {
                res[1] ^=num;
            }
        }
        return res;
    }
};
```