以示例为例：

示例：

输入: `["t","h","e"," ","s","k","y"," ","i","s"," ","b","l","u","e"]`

输出: `["b","l","u","e"," ","i","s"," ","s","k","y"," ","t","h","e"]`

我想到如果全部翻转会变成什么样

输出: `["e","u","l","b"," ","s","i"," ","y","k","s"," ","e","h","t"]`

这样离要求的答案看起来只差一点点了，只要把每个单词都翻转一遍就好了

比如说第一个单词，从index 0开始，读到空格的时候，计数发现这个单词长度为4

那么要交换的为（str[0]和str[3]），（str[1]和str[2]），如果单词长度为3，那就交换一次就好了。

于是使用临时变量存储下标与单词开始的地方下标，然后将单词全部翻转即可。

但是到最后没有空格了，就会出现特殊情况，于是分类讨论，if (i == n - 1)时，如何处理。

使用了5个int的额外空间，但不与题目数据数量相关，所以空间复杂度是大O(1)的，符合题目。

代码是先交换后翻转，其实先后都一样的。。。

```
class Solution {
 public:
  void reverseWords(vector<char>& str) {
    int n = str.size();
    for (int i = 0, j = 0, p, tmp; i < n; ++i) { //j为存储单词开始的地方的下标
      if (str[i] == ' ') {
        tmp = (i - j) / 2; //tmp为交换次数，后面while循环用于交换
        p = i;
        while (tmp--) swap(str[j++], str[--p]);
        j = i + 1; //将j改为下个单词开始的地方
      }
      if (i == n - 1) { //分类讨论
        tmp = (i - j + 1) / 2; //这时候因为没遇到空格，i比上一种情况少1，于是这边+1
        p = i;
        while (tmp--) swap(str[j++], str[p--]); //这边要用p--
      }
    }
    for (int i = 0; i < n / 2; ++i) swap(str[i], str[n - i - 1]); //最后全部翻转即可，也可以先翻转后交换
    return;
  }
};

```