对于 length >= 2*k 的情况，可以按以下方式理解：
每一次交换前k %= length，交换头部 [0, k - 1] 和尾部 [length - k , length -k + k -1] 区域的数据，相当于把尾部作为交换缓存区。
在下一次交换前，将头部的位置向后移动 k，待交换的长度缩减k，继续头部和尾部的交换, 直到k==0

关键的逻辑是：上一次交换至尾部的数据，是下一次头部需要交换的数据，因此可以实现交替循环。

但对于 length < 2*k，交换区存在重叠，部分元素会被交换多次的情况。
假设长度为n，右侧移动长度为k，n < 2* k的情况：
对于末尾k个元素会被逐个交换至[0,k-1]的位置，问题在于前n-k个元素的情况。
首先，前n-k个元素不会丢失，因为我们只交换，所有的元素都会原样保留，前n-k个元素只是被移动到最后的[n-k-1, n-1]的位置了，但次序可能有变化。
按从零开始的索引值记录前n-k个元素为i，i在前k次交换后移动的位置记为 ki , 另外设 k=x(n-k)+m，即x=k/(n-k)取整的值，m=k % (n-k)取余数的值。
i每次被交换时，索引值增加n-k，最终 ki >= k 时交换停止，所以
当 i < m时，ki = x（n-k）+ i + (n-k)
当 i >= m时， ki = x (n-k) + i
由上述表达式，可以得到 n > ki >= k
在下一个循环的交换中，基础长度变更为n-k，向右位移距离为m= k % (n-k)。原前n-k元素 i 在新的一轮循环交换后的位置记录为kki 。

当 ki - k + m > n-k 时，即 ki  > n-k + x(n-k) 仅当 ki = x（n-k）+ i + (n-k)成立，因为i < n - k对于 ki = x (n-k) + i 的情况，ki = x (n-k) + i  <  x (n-k) + (n-k) 
所以当 ki - k + m > n-k 时，一定是 i < m时，那么
kki = ki + m - (n - k) =  x（n-k）+ i + (n-k) + m - (n - k) =  x（n-k）+ i + m = k + i
同理可得，
当 ki - k + m <= n - k时，kki = ki + m = x (n-k) + i + m = k + i
因此，同样的交换模式可以得到 元素 i 向右移动 k 距离的效果。

最终前后两种情况下，交换的逻辑一致，我们可以用简洁的代码做到不引入外部临时存储，只内部交换最多 n-1次，实现数组旋转效果。
需要提醒的是，所谓的第二次循环可以完成k的位移是目标，实际上这个第二次循环的目标，也可能分多次循环完成。并不是第二次循环完成了，就结束了。
但终归循环的的逻辑是一致的。

代码如下：


``` cpp
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k %= nums.size();
        int baseIndex = 0;
        while (k)
        {
            for (int j = 0; j < k; j++)
                swap(nums[baseIndex + j], nums[nums.size() - k + j]);
            baseIndex += k;            
            k %= nums.size() - baseIndex;
        }
    }
};
```
