# Rust 动态规划 4ms
![图片.png](https://pic.leetcode-cn.com/7ca3eafbce3e3ff5994cf1165e033aab505a0f1601773cacfd81ad94887d7bca-%E5%9B%BE%E7%89%87.png)

# 本文结构
- 如何把问题转化为经典动态规划
- 自底向上 求“双指位置确定”模型 g( x , y )
- 自底向上 求“单指位置确定”模型 f( i )
- 完整Rust代码
- 时间复杂度和空间复杂度
# 1. 如何把问题转化为经典动态规划
仔细分析这道题：对于给定的一个word，其实我们的按字母的顺序是确定的，例如 word="abcd", 我们就要按照 a->b->c->d 的顺序按字母。又因为我们有两个手指，于是需要按第i个字母的时候，我们有两种选择，手指1还是手指2？我们应该都尝试一遍，然后选择花费最小的。在我们这次选择完之后呢？之后就变成了子问题又要按第i+1个字母了。这就是动态规划的最佳子结构。
**注意:** 显然，第一个手指放在第一个字母的位置最好（因为这样按第一个字母的花费为0），即手指1的初始位置是word[0]。而手指2的初始位置不确定,有可能我先用第一个手指按了几个字母，然后再用第二个手指按第一下。为了方便描述，我么先讨论“双指位置确定模型”，然后再讨论“单指位置确定模型”。
先考虑**手指位置**的表示方法，可以用字母A-Z来表示。当然也可以用键盘坐标 (x,y) 来表示。其实还有一种巧妙的表示方法：使用word的下标来表示。
**位置变换：** i => word[i] => (x,y)。可见这三种方法是等价的。
我们用：
- distance( i , j )  表示位置i和位置j的距离。

# 2. 自底向上 求“双指位置确定”模型 g( i , j )
我们用：
- g[i,j] 表示 按完word[i..n] 的花费，此时的n表示word的长度，i 和 j 表示两个手指的位置，i同时还表示word中的第i个字母。

那么，题目中描述一开始的时候手指位置可以任意设定，花费为0。显然，手指1放在第一个字母的位置最好，即手指1的初始位置是0。而手指2的初始位置不确定，为了便于描述"双手指确定位置模型"，我么先假设手指2的初始位置也是0。于是我们的目的就是求出g[0,0]，即按完字母word[0..n]的花费。

**注意**，如果两个手指的位置是i和j，其实我们并不关心那个手指是i，那个手指是j。不妨我们设置 ** i > j ** (为什么不是>=？因为两个手指不会同时按一个位置的字母，word[i]和word[j]是不同位置的字母，所以不取等号)。
**注意**，g[i,j]的表达含义：i，j表示两个手指的位置，同时i还表示目前起始位置是word中的第i个字母。

好的，现在我们先给出动态规划的**递推表达式**：
```
let a = g[i+1][j] + distance(i+1,i);
let b = g[i+1][i] + distance(i+1,j);
g[i][j] = min(a,b);
```
其中 a 表示用手指i去按word[i+1]的花费，b表示用手指j去按word[i+1]的花费，g[i][j]取这两种方法中更小的那个花费。
读者可能有疑问：为什么不按word[i]呢？因为有一个手指已经在i位置上了，按word[i]的花费为0。

再具体解释一下递推表达式的含义。
```
let a = g[i+1][j] + distance(i+1,i);
```
当前手指位置是i和j，如果用手指i去按word[i+1]，那么手指位置变成了i+1和j，这次移动手指的花费为distance(i+1,i)(即位置i和位置i+1的距离)，再加上此后的花费g[i+1][j]就是A方案的总花费了。同理，B方案也是类似的。
到这里，基本上就可以用经典的动态规划算法搞定了。

接下来，我们来讨论一下如何**自底向上**地去求g[i][j]。
仔细看公式：
```
g( i , j ) = min ( g(i+1,j) + d(i+1,i) , g(i+1,i) + dis(i+1,j) );
```
发现求g( i , j ) 依赖于g(i+1,j) 和 g(i+1,i)
 ```
      g( i , j )   
    /        \
g(i+1,j)   g(i+1,i)
 
```
注意 i > j （前面讨论了），仔细看g[x,y]的坐标变化
```
x       x'      单调性
i       i+1     递增

y       y'      单调性
j       j       不变
j       i     递增
```
于是我们知道了g(x,y) 依赖于g(x',y'),其中x' 比 x 大，y'比y 大。也就是说小的依赖于大的。
哪么我们应该先求大的再求小的。求值顺序如下图(注意 g( i , j ) 的 i > j ,但为了更简单的理解，我们暂时先允许 i>=j )：
```
g(n,n)      -> g(n,n-1)     -> g(n,n-2)  ->  ...  -> g(n,0)   ->
g(n-1,n-1)  -> g(n-1,n-3)   ->   ... ->  g(n-1,0) ->
... ->
g(0,0)
```
好，看看g(x,y)的**自底向上代码：**
```
for j in (0..n-1).rev(){
    g[n-1][j] = 0;  //已经按倒最后一个字母word[n-1]，花费为0.
}
for i in (0..n-1).rev(){
    for j in (0..i).rev(){
        let a = g[i+1][j] + distance(&word, i+1,i);
        let b = g[i+1][i] + distance(&word, i+1,j);
        g[i][j] = i32::min(a,b);
    }
}
```
至此，我们可以求出g(0,0)。但是g(0,0)真的是正确答案吗？显然不是，我们之前已经强调了，为了简化问题，我们假设第二根手指的初始位置也是0。现在我们要去掉这个不正确的假设，请看下面。
# 3. 自底向上 求“单指位置确定”模型 f(i)
### 重点：第二根手指的初始位置
我们之前假设第二根手指的初始位置为 0 。但是，事实上第二根手指的初始位置没那么简单，而且 i > j 是我们之前讨论的，所以不可能出现 ( i , j )  = (0,0) 的情况。那么正确答案，便不再是 g( 0 , 0 )了。
我们可以先引入**问题**：只确定了第一根手指的位置为 i ，求 word[i..n] 的花费。
我们假设 f ( i ) 是该问题的解。那么我们有两种方案来按字母word[i+1],第一种是用手指i去按，第二种是用第二根未确定位置的手指去按。所以，
```
let a = f[i+1]+distance(i,i+1);   //Plan A: 手指i去按word[i+1]，此步操作花费为d(i,i+1),
                                  //        按完后还是"单指位置确定"模型，使用f(i+1)j 来解决
let b = g[i+1][i];                //Plan B: 第二根手指去按word[i+1]，此步操作花费为0，
                                  //        按完后就变成了"双指位置确定"模型，使用g(i+1,i)来解决
f[i] = i32::min(a,b);             //A or B? 取较小者为最优方案
```
f[i] 也要**自底向上**求值，即：
```
f[n] -> f[n-1] -> ... -> f[0]
```
看看 f[i] 的**自底向上代码**：
```
f[n-1] = 0;     //已经到了最后一个字母word[n-1]，所以花费为 0 。
for i in (0..n-1).rev(){    
    let a = f[i+1]+distance(&word, i,i+1); 
    let b = g[i+1][i];
    f[i] = i32::min(a,b);
}
```
我们的目标是求 f[0]，即 word[0..n]的花费
至此，我们已经用动态规划完美解决了该问题。总结一下，我们实际操作是先**单指**按字母，然后**双指**按字母，但是为了**自底向上**，我们代码中要先求出所有的 g(x,y)，再求 f(i)，最后求出我们的目标f[0]。

# 4. 附上完整代码(Rust)：
```
impl Solution {
    pub fn minimum_distance(word: String) -> i32 {
        let word:Vec<char> = word.chars().collect();
        let n = word.len();
        if n == 0 { return 0;   }
        let mut f = vec![0;n];
        let mut g = vec![vec![0;n];n];

        //自底向上 求“双指位置确定”模型 g( i , j )
        for j in (0..n-1).rev(){
            g[n-1][j] = 0;
        }
        for i in (0..n-1).rev(){
            for j in (0..i).rev(){
                let a = g[i+1][j] + distance(&word, i+1,i);
                let b = g[i+1][i] + distance(&word, i+1,j);
                g[i][j] = i32::min(a,b);
            }
        }

        //自底向上 求“单指位置确定”模型 f(i)
        f[n-1] = 0;
        for i in (0..n-1).rev(){    
            let a = f[i+1]+distance(&word, i,i+1); 
            let b = g[i+1][i];
            f[i] = i32::min(a,b);
        }

        f[0]
    }
}

#[inline]
fn distance2(i: i32, j: i32) -> i32{
    (i/6-j/6).abs() + (i%6 - j%6).abs()
}

#[inline]
fn distance1(a: char, b: char) -> i32{
    let i = (a as u8 - 'A' as u8) as i32;
    let j = (b as u8 - 'A' as u8) as i32;
    distance2( i , j ) 
}

#[inline]
fn distance(word: &Vec<char>, i: usize, j: usize) -> i32{
    distance1(word[i],word[j])
}
```

# 5. 时间复杂度和空间复杂度 O(n^2)
这是典型的二维动态规划，采用了一个N*N二维矩阵,时间复杂度和空间复杂度都是**O(N^2)**

谢谢你的耐心观看。为了更好的分享知识，我们一起努力。
如果觉得不错的，可以赞一下我，谢谢。
如果有任何的错误或纰漏，谢谢指正。
如果有看不懂的，可以留言问我，我会尽力回答。