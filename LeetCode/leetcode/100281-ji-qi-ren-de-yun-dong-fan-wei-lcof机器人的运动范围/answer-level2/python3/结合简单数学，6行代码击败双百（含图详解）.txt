
力扣新人，第一次写题解，请多指教。

机器人可以行动的范围取决于“行坐标和列坐标的数位之和”

首先，不妨将位置矩阵分割为以 10 为边长的子矩阵，且每个“子矩阵”内，坐标的十位数均相同。
![image.png](https://pic.leetcode-cn.com/69a927d29276e174d4e1742829ac719b1515c0c2c743cace70dd064035597499-image.png)

容易证明：
1. 对于每个“子矩阵”，如果机器人不能到达子矩阵左上角的位置，则必然无法到达子矩阵的其余位置。
    例如，只有能够到达 (20, 10) ，才有可能到达上图中浅黄色子矩阵的其它位置
2. 对于每个“子矩阵”的左上角位置，其能够到达的充要条件是：其左侧或上方的位置可以到达。
    例如，当且仅当机器人能到达 (19,10) 或者 (20,9) ，则可以到达 (20,10)。
    容易发现，无论是 (19,10) 还是 (20,9)，其“数位之和”均等于 11，即 20, 10 的十位之和再加 8。
    （当坐标的个位数为 9 时，坐标每增加 1 则数位之和减少 8）

因此，机器人能否到达位置 (i, j) 取决于以下两个条件：
1. 行列坐标 i, j 的“数位和”不大于 k，即  `i//10 + i%10 + j//10 + j%10 <= k`
2. 对于 (i, j) 所位于的子矩阵的左上角元素，其左侧或上方的元素是能达到的，
    即 `i//10 + j//10 + 8 <= k`
    **这里需要额外注意，包含 (0, 0) 的子矩阵是必然能够达到的。**

最后上一下代码和结果：

```python
class Solution:
    def movingCount(self, m: int, n: int, k: int) -> int:
        count = 0
        for i in range(min(m, max(0,(k - 8)) * 10 + 10)):
            for j in range(min(n, max(0,(k - 8 - i//10)) * 10 + 10)):
                if i//10 + i%10 + j//10 + j%10 <= k : count += 1
        return count
```
![image.png](https://pic.leetcode-cn.com/dcb9f37f255e6a3cf6d88430972706030e58d944fca11e3e6b3b5b48faeddae3-image.png)