### 解题思路
思路：首先找到机器人最大可能的活动范围，然后定义一个这个最大可能活动返回的一维数组，
当纵坐标为0时能得到这个最大范围，使用这个一维数组来保存是否可达，一维数组中0表示可达，1表示不可达
初始时纵坐标为0，一维数组都是0，表示都可达，从纵坐标为1开始，如果横坐标等于0，判断纵坐标值是否大于最大活动范围，没有则表示可达，
如果横坐标大于0，计算此点数位之和是否大于k，没有再判断左边是否等于0或下方是否等于0，如果是，则此出也等于0，遍历完成后，计算得到的所有0值
### 代码

```java
class Solution {
    public int movingCount(int m, int n, int k) {
        int t;
        // 确保m为两者中的最大值
        if(m<n) {
            t=m;
            m=n;
            n=t;
        }
        // 如果k大于8，那么假设纵轴为0，找到机器人纵坐标从零往右能达到的最后一个位置，以后的位置都是不可达的，
        // 因为机器人从左边来不了，只能考虑上面，但是纵坐标大于0后，机器人到不了上面的位置
        if(k>8) {
            t=(k-8)*10+8;
        } else {
            t=k;
        }
        // 当t大于横坐标时，取m-1
        if(t>m-1) {
            t=m-1;
        }
        int[] temp=new int[t+1];
        // 纵坐标为t和n-1间的最小值
        int y=t>n-1?n-1:t;
        // 计算纵坐标为0时的可达数目
        int sum=t+1;
        // 遍历纵坐标每一行
        for(int i=1;i<=y;i++) {
            // 遍历横坐标
            for(int j=0;j<=t;j++) {
                if((k-i/10-i%10-j/10-j%10)>=0 && (j==0 || temp[j-1]==0 || temp[j]==0)) {
                    sum++;
                    temp[j]=0;
                } else {
                    temp[j]=1;
                }
            }
        }
        return sum;
    }
}
```