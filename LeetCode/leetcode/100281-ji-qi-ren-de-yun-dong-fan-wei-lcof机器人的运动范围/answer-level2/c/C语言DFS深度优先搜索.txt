### 解题思路
//DFS深度优先搜索
暴力双百
![1.png](https://pic.leetcode-cn.com/127ab9de45662bf52a98775800649bc79589c86dbd1e50a0349442be7172623a-1.png)

/**
*思路是这样的
*深度优先搜索就是沿着路径暴力搜索
*我们可以知道从0,0开始有两条搜索路径，向上或者是向右
*一条条搜索，也就是说最后的结果就是0,0本身加上向下搜索的全部，再加上向右搜索的全部
*先搜索向下的1，0，向下又有两条路径，向下或者向右，这一条路径的总个数是它本身，
*加上向下搜索的全部，再加上向右搜索的全部
*依次递归，每次都有两条路
*什么时候结束呢？当向右或者向下搜索的时候，会越过数组边界，
*或者是会访问到以前访问过的东西，或者是搜索到不满足k这个条件则这一个小方向返回0，
*为什么返回0，不返回1呢，注意，我们返回的是它的下一条路径的两条分路径的总和，
*而现在它的下一条路径索性就没有了，当然是0呀，
*当然，为了表示元素是否已经被访问，需要一个标记数组，
*但是，在标记数组用变量声明长度的时候，不能够赋值，所以要声明之后再赋值
*对于i,j的向下个和向右两个元素的下标和，有这样一种求法(i + 1)%10 == 0 ? (sumi - 8) : (sumi + 1)
*在代码中已经写的很明显了
*/

### 代码

```c
int movingCount(int m, int n, int k)
{
    int hasVisited[m][n];
    for(int i = 0; i < m; i++)
    {
        for(int j = 0; j < n; j++)
        {
            hasVisited[i][j] = 0;
        }
    }
    int dfs(int i, int j, int sumi, int sumj)
    {
        if(i >= m || j >= n || (sumi + sumj) > k || hasVisited[i][j] == 1)
        return 0;
        hasVisited[i][j] = 1;
        return 1 + dfs(i, j + 1, sumi, (j + 1)%10 == 0 ? (sumj - 8) : (sumj + 1)) + dfs(i + 1, j, (i + 1)%10 == 0 ? (sumi - 8) : (sumi + 1), sumj);
    }
    return dfs(0, 0, 0, 0);
}


```