C++，0ms，6.6MB，思路：剥洋葱，逐层旋转

外侧循环（i循环）：图像的层数。如果是3x3矩阵，就是一层，因为中心元素无需旋转；如果是4x4矩阵，就是二层，没有中心元素。完成一层的旋转，再完成下一层的旋转，逐层向里递进。

中间循环（k循环）：此时外层元素已经全部旋转完毕，待旋转的矩阵变成了比原先少一层的矩阵，对此时的矩阵进行考察。从左上角点开始遍历第一排（除了第一排的最右），具体操作见内侧循环。

内侧循环（m循环）：0<=m<4，循环四次，因为存在上-右、右-下、下-左、左-上，共四次操作。在m循环内部，基于当前所在的坐标，计算目标点的坐标，有了两个坐标，就可以实际地移动元素了。本例中，计算坐标的方式为：所有点绕右下角点旋转，然后向左平移。

k循环与m循环结合起来的含义就是对矩形的四条边操作，上-右、右-下、下-左、左-上。再结合i循环，就把边操作堆砌成实心矩形了。

```
void rotate(vector<vector<int>>& matrix) 
    {
        //方法：基于右下角点旋转
        //旋转完成之后再平移
        //分层处理
        int siz=matrix.size();
        if (siz==0||siz==1)
        {
            return;
        }
        //开始分层
        int flr=siz/2;
        //定义桥接变量
        int brd1,brd2;
        //定义该层处理数量
        int unit=siz-1;
        //当前发出坐标
        int exh,exw;
        //当前接收坐标
        int rch,rcw;
        //旋转中心的坐标
        int ct=siz-1;
        //开始旋转
        for (int i=0;i<flr;i++)
        {
            exh=i;
            exw=i;
            for (int k=0;k<unit;k++)
            {
                for (int m=0;m<4;m++)
                {
                    //计算接受点坐标
                    rch=ct-(ct-exw);
                    rcw=ct-exh;
                    //这样就算出了对应ex的rc坐标
                    //再用ex覆盖rc之前应将rc保存起来
                    brd2=matrix[rch][rcw];
                    if (m==0)
                    {
                        matrix[rch][rcw]=matrix[exh][exw];
                    }
                    else
                    {
                        matrix[rch][rcw]=brd1;
                    }
                    brd1=brd2;
                    //旋转完成，现在的接收点
                    //变成下次循环的发射点
                    exh=rch;
                    exw=rcw;
                }
                //旋转完成之后出发点坐标才向右移动一位
                exw=exw+1;
            }
            unit=unit-2;
        }
    }
```


