# 写在前面：
    - 整体思路：先解决好外圈的一种情况，再将其放入循环中利用数理逻辑推理内圈情况，逐步渐进解决问题
    - 外圈解决思路：对矩阵外圈分块，及[0,0][0,1][0,2]为一个块，[0,3][1,3][2,3]为一个块，以此类推（画图理解更形象更易懂）
    - 内圈解决思路：
        1.将外圈解决方案放入循环后，在循环出整天一个变量表示由外而内的第几圈r
        2.设置好跳出外层循环的条件，即要限制r的取值范围，推出一个通式：r<=(length-1)/2
        3.内层每一个块具体情况见代码分析

# 代码分析：
```
/*将举证旋转90度的方法：
	 * 矩阵例子：
	  [ 5, 1, 9, 11],
	  [ 2, 4, 8, 10],
	  [13, 3, 6,  7],
	  [15,14,12, 16]
*/

int length = matrix.length;// 给定的矩阵的边长
int lengthend = matrix.length;// 每一圈中分好的块的末尾元素的行或者列的下标（具体圈具体分析）

/* 由外而内，逐个圈进行旋转 */
for (int r = 0; r <= (length - 1) / 2; r++) {
    /*
        * 创建一个临时数组作为中转站，存放每一个块的数据，注意由外而内每一个圈的块的元素数量不同，
        * 故临时数组长度不一样，用数理逻辑推出长度公式：length-2*r-1
    */
    int[] temp = new int[length-2*r-1];
    
    /*举例：（外圈情况）把第一个块元素放进临时数组temp中
        [ 5, 1, 9,  ], ==> temp[]
        [           ],
        [           ],
        [           ]                    
    */
    for (int i = 0; i < temp.length; i++) { // 这个i是临时数组的下标
        temp[i] = matrix[r][i + r];
    }
    
    /*举例：（外圈情况）块[2,13,15]换到[5,1,9]的位置
        [ 5, 1, 9,  ],
        [ 2,        ],
        [13,        ],
        [15,        ]                     
    */
    for (int i = 1 + r; i < lengthend; i++) {
        matrix[r][length - 1 - i] = matrix[i][r];
    }
    
    /*举例：（外圈情况）块[14,12,16]换到[2,13,15]的位置
        [           ],
        [ 2,        ],
        [13,        ],
        [15,14,12,16]                      
    */
    for (int i = 1 + r; i < lengthend; i++) {
        matrix[i][r] = matrix[length - 1 - r][i];
    }
    
    /*举例：（外圈情况）块[11,10,7]换到[14,12,16]的位置
        [        ,11],
        [        ,10],
        [        , 7],
        [  ,14,12,16]                       
    */
    for (int i = 1 + r; i < lengthend; i++) {
        matrix[length - 1 - r][i] = matrix[length - 1 - i][length - 1 - r];
    }
    
    /*举例：（外圈情况）把临时数组temp中的元素放进第一个块中
        * 
        temp[] ==> [            ],
                    [            ],
                    [            ],
                    [            ]            
    */
    for (int i = 1; i <= temp.length; i++) {
        matrix[length - i - 1 - r][length - 1 - r] = temp[temp.length - i];
    }
    
    /*进入下一圈之前，这一圈中分好的块的末尾元素的行或者列的下标缩小一位*/
    lengthend -= 1;
}

```
