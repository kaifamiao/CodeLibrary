记录一下思路：
遇到这种问数求数字1的题目其实可以统一看成按位来做循环，例如求4321，从个位1开始循环到千位4，那么每一位的循环该如何操作？

可以把数按位分，即4321 = 1+20+300+4000，分布在[1,9],[10,99],[100,999],[1000,9999]...

这个时候只计算
        *    1.[0-4000]有多少个1 ----------------------------> 4* [个位十位百位是1的1的个数] + 1 * 10 * 10 * 10
            2. [4000-4300]有多少个1 ---> [1,299] 有多少个1 ---> 3* [个位十位是1的1的个数] + 1 * 10 * 10
            3. [4300-4320]有多少个1 ---> [1,19] 有多少个1 --->  2* [个位是1的1的个数] + 1 * 10
            4. [4320-4321]有多少个1 ---> [1,1]有多少个1  ---> 1*[0] + 1 
            5. 然后全部加起来*


计算113：
这个时候只计算
            1.[0-100]有多少个1 -----------------------------> 1*[个位十位] 
            此时注意因为百位以1开头，所以还要加上多出来的数[即100,101,102...,112,113],这个时候我们只算百位为1的1个数
            (113-100)+1 = 13+1 (加1是因为要算上0)
            2. [100-110]有多少个1--->[1，9]有多少个1-----------> 1* [个位]
            此时注意因为十位以1开头，所以还要加上多出来的数[110,111,112,113]，这个时候只算十位为1的1个数
            (13-10)+1 = 3+1
            3. [110-113]有多少个1 --->[1,3]有多少个1----------> 3* [0] + 1*1
            4.  然后全部加起来
以此类推


因此可以知道如果位数不为1的话，在当前计算位n的循环里面是这么计算的：
```
res += n*(个位百位直到前一位里包含1的个数) + 10^幂次
```
类比35计算3的时候就是3*(个位包含1的个数) + 10 = 3*1 + 10， 305就是3*([1,99]中包含1的个数) + 10^2 = 3*20+100

而如果数位为1的话，此时就说明1开头的数还没有走完，当前计算位n的循环是这么计算的：
```
res += 1*(个位百位直到前一位包含1的个数) + (从0开始到前一位的数的个数)[这一项可以看成位数为1的个数]
```
类比14的计算1的时候是 1*(个位包含1的个数) + (0,1,2,3,4一共有多少个数) = 1*1 + 5, 而156就是1*(个位百位包含1的个数)+(0,1,2,..,55,56包含1为开头的数的个数) = 1*20 + 56 + 1

python代码如下：
```
class Solution(object):
    def countDigitOne(self, n):
        base = 1
        before = 0
        cur = n
        res = 0
        while cur:
            key = int(cur % 10)
            if key == 1:
               res += before + (n - base*cur+1)
            if key > 1:
                res += before*key + base
            before = before*10 + base
            base *= 10
            cur = cur//10
        return res
```
所以最终的复杂度为O(log(n))
空间复杂度为O(1)



