> 看到国际友人的漂亮代码，加上自己的理解，分享一波

### 解题思路

从个位到最高位，判断某一位为1时，其他位可能的情况。假设n = 3101592，假设现在判断个位为1，其他位可以出现的情况为{1,11,21,31·····3101591}

当在其他位时，情况为：

- 当1在百位时: 5 (> 1): [0~3100]1[0~99] + [3101]1[0~99]. 出现的次数 # = 3101 * 100 + 100
- 当1在千位时: 1 (= 1): [0~309]1[0~592] + [310]1[0~592]. 出现的次数 # = 310 * 1000 + (592 + 1)
- 当1在万位时: 0 (< 1): [0~30]1[0~9999]. 出现的次数 # = 31 * 10000

如果看的不是很懂，可以先看下代码，代码也有详细的例子，再回来看应该就会很清楚了。

### 代码

```java
class Solution {
    //假设n = 3101592,当1在百位时，我们要将3101592分成 3101 5 92
    public int countDigitOne(int n) {
        if(n <= 0) return 0;

        //结果
        int ret = 0;  
        //【i * head = n】从个位到最高位，假设n = 3101592
        for(long i = 1, head = n; i <= n; i *= 10, head /= 10){
            //n截断i，前面的数值是多少。假设i = 100, 3101592截断后面的3位592， pre = 3101 （3101 5 92）
            long pre = n / (i * 10);
            //当前位的数值。 cur = 5. （3101 5 92）
            long cur = head % 10;
            //tail = 92 （3101 5 92）
            long tail = n % i;
            //cur这一位固定，cur这一位前面的数变化，排列组合：[0 ~ 3100] 1 [0 ~ 99] ==> 3101 * 100
            ret += pre * i;
            //cur这一位后面数的变化。
            //如果cur的数值大于1(2~9),那么可取的数组为i个(i = 100，即0~99)。
            //如果cur的数值等于1，那么可取的数值为tail + 1个[0 ~ tail]。
            //如果为0，则为0
            ret += (cur > 1) ? i : ((cur == 1) ? (tail + 1) : 0);
        }
        return ret;
    }
}
```
