### 解题思路
通过分析各个数位的1的数量，举例子然后找到规律。

以214为例。
+ **个位** 个位的1很简单，1、11、21....211，一共有22个1。
+ **十位** 十位的1在每100中有不同数，每个范围内有，10~19，110~119，210~214，一共有10+10+5=25个1。
+ **百位** 百位的1，100~199，一共有100个1。

发现，个位上的数字可以通过n/10得到，但是n/10的时候我们不知道个位的数字和1的大小，*如果是210，那么个位1的数量就是21（n/10）个，如果是例子上的214，个位上的1的数量就是22个，也就是n/10 + 1个。*
同理，十位上的1，通过n/100得到两个范围，分别是10~19，110~119，这两个范围分别有10个1。但是和个位上的1一样，n/100之后，我们损失了十位上的精度，所以还需要判断损失的部分十位上有多少个1。所以我们n%100来获取十位上的数字，然后比较这个数字和10，20的大小。*如果小于10，则这部分十位上没有1，如果大于19，则这部分十位上有10个1，如果在10和19区间内，这部分十位上的1就等于这个数减去10再加1。*

所以基本的思想出来了：
首先统计个位上的1的个数，然后计算损失的部分的个位是否有1。
然后统计十位上的1的个数，然后计算损失的部分的十位是否有1。

+ **个位** n / 10 + res res = (n % 10) >= 2 ? 1 : 0
+ **十位** (n / 100) * 10 + res 
    if((n % 100) > 20) res = 10;
    else if((n % 100) < 20) res = 0;
    else res = (n % 100) - 10 + 1;

最后把每个数位的1加起来，就可以获得答案。
### 代码

```java
class Solution {
    public int countDigitOne(int n) {
        long k = 1;
        int sum = 0;
        long res = 0;
        while(n / k != 0){
            if(n % (10 * k) >= 2 * k){
                res = k;
            }else if(n % (10 * k) < k){
                res = 0;
            }else{
                res = n % (10 * k) - k + 1;
            }
            sum += (n / (10 * k)) * k + res;
            k *= 10;
        }

        return sum;
    }
}
```