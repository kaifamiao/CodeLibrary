### 解题思路
归纳法，效率双100，适于用所有数字。
思路很简单，分别归纳个位上1的个数，十位上1的个数，百位上1的个数等等，找出规律，我总结的规律如下：

假如计算1～n中1出现的个数：
变量说明：
    j为10的倍数，j大小依据位数，比如个位时，j=10,十位j=100 等等。
    y=n%j的余数；这里我们计算1的出现次数，所以w=1+1,如果计算的是2出现的次数，可以改为2+1，等等诸如此类。
核心要点：计算某位上是1的数字个数时，可以先取整的，再处理剩余的，比如计算n=118时，计算十位上1的个数，我们可以先计算100以内十位上1的个数（10，11，...,18,19），我们看到有10个，再计算100-118十位上为1的数字，即8+1=9个。

第一步：首先我们知道，个位数字为1的数字有：1, 11, 21, 31, ...,个位1的个数和n/10密切相关，也就是说有几个10，就有几个个位上是1的数字，则必然有(n/j)*(j/10)个1，比如11/10=1， 则必然有1个1在个位（数字1个位上的1），21/10=2，则必然有2个1在个位（1，11两个数个位上的1)，118/100=1， 则必然有(n/100)*(100/10)个十位上为1的数字（10，11，...,18,19）等等注入此类；

第二步：对于118这个数字，假如我们计算十位上1的个数，我们算完第一步，已经知道了0～100区间，十位上是1的数字个数为10，并不知道100～118区间十位上是1的数字个数，所以我们只需计算110～118之间个位上是1的数字个数。余数y=118%j=18，j=100，首先18要大于等于10这个区间才会有符合要求的数字，否则没有，再者，如果18大于20，则有10，小于20，则有8+1=9个，即余数在j/10 <= y <j/10*w，这个区间十位上是1的数字个数为y%(j/10)+1个，如118，余数区间：100/10 <= 18 < 100/10*2,则100-118区间十位为1的数字个数18%(100/10) + 1=9;如果y>= j/10*2，则这个区间十位上是1的数字个数为j/10个，如数字为128时，100~128这个区间十位上是1的数字个数为100/10=10个。


### 代码

```java

public int countDigitOne(int n) {
   int result = 0;
   long temp = n, j = 10;
   while (temp * 10 >= j) {
       long y = temp % j;
       long z = temp / j;
       result += (z * j / 10);
       if (y >= (j / 10)) {
           if (y < (j * 2 / 10)) {
               y = y % (j / 10);
               result += y + 1;
           } else {
               result += (j / 10);
           }
       }
       j *= 10;
   }
   return result; 
}

```