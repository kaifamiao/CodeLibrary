首先我们将这个整数逐位存入一个数组中,由于题目给定的n大小最大是2^31,大概10多位,我们开一个大小20的数组就可以了,为方便计算,这里省略0号位不用
我们遍历时,假设这一位是1,然后算出这一位是1时的个数.拿32104举例
1. 首先遍历第一位3,假如这一位是1,那么后面的4位无论是什么都会32104小,因此后面那4位可以从0000到9999,即有10000种情况
2. 然后看第二位2,当这位是1时,第一位有4种情况(0,1,2,3),后面3位无论是什么都不会超过32104这个数,因为第2位是1,它们最大也只有31999,31999<32000<32104,所以后面那三位可以s从000到999,共1000种情况,左右相乘,就是第二位为1时的情况了,有4*1000=4000种
3. 再看第3位,如果第3位为1,前面两位可以从00-32,有33种情况
- 当前面两位为00-31时,后面两位可以从00-99,共100种情况,共32*100=3200种
- 当前面两位为32时,由于不能超过32104,所以后面两位只能从00到04,共5种情况
所以第三位为1的情况有3200+5=3205
4. 再看第4位,当第4位为1时,它前面的3位只能从000到320,共321种情况,为什么不能到321呢,因为如果是321,3211x>32104,超过最大,因此只能到320,由于3201x<32104恒成立,所以最后那一位可以从0到9,共10种情况,所以共有321*10=3210种情况
5. 最后1位和第一位第二位的分析类似,当这一位为1时,前面4位可以从0000到3210,共3211种情况
所以总共有10000+4000+3205+3211=20416个1

```
class Solution {
    public int countDigitOne(int n) {
        int[] dp=new int[20];
        int top=1,temp=n;
        double left=0,right=0,res=0;
        while(temp>0){
            dp[top]=temp%10;
            top++;
            temp/=10;
        }
        for(int i=top-1;i>=1;i--){
            left=left*10+dp[i];
            right=Math.pow(10,i-1);
            if(dp[i]>1){    
                res+=(1+(int)(left/10))*right;
            }
            else if(dp[i]==1){
                res+=((int)(left/10))*right+n-left*Math.pow(10,i-1)+1;
            }
            else{
                res+=((int)(left/10))*right;
            }
        }
        return (int)res;
    }
}
```
