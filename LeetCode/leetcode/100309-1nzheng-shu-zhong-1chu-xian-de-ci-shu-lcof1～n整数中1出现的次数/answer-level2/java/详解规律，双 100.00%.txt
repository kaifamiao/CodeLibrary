![image.png](https://pic.leetcode-cn.com/ce0276cd3ac0a532b6d71f129bda1402282827a08bbc205a49a503c2ae756eec-image.png)

### 解题思路
该题是可以通过找到数字的规律进行解答的，个人认为属于 [困难](https://leetcode-cn.com/problems/number-of-digit-one/) 级别的题目。别担心，通过下面的分析之后，该题思考起来还是比较容易理解的。

> 这里不再提供暴力的方法，原因是因为暴力容易超时。

既然是求 1 到 N 中，1 所出现的次数。那么我们可以利用`1`、`10`、`100`、`1000`、... 这样的数作为输入数字 N 划分的依据。例如输入的数字是`21396`，我们可以考虑`个位`、`十位`、`百位`、`千位`、`万位`上的划分情况。

这里以`百位`为例，由于`百位`上的数字所能取到的值只能是从`0`到`9`，我们可以将其分为以下三种情况：

- 情况一：**百位数字大于等于 2**
- 情况二：**百位数字等于 1**
- 情况三：**百位数字等于 0**

下面分别对着三种情况进行讨论。

### 情况一：百位数字大于等于 2
例如数字`21396`，百位数字是`3`，属于大于等于`2`的情况，则有以下对应的分布：

![image.png](https://pic.leetcode-cn.com/d30162237dde3ba370e9c36868bb128e0654018df5dea46922864f3f300386c1-image.png)

> 令`a = 21396 / 100 = 213`，`b = 21396 % 100 = 96`。

注意观察百位为`1`所出现的次数，其出现的次数一共是`22`次，即`a / 10 + 1 = 213 / 10 + 1 = 22`。即对应`21396`中的最高两位 0~21。每次都含有 100 个连续的数（100~199），所以总共有`(a / 10 + 1) * 100 = 2200`个数是含有`1`的。

也就是说，对于百位数字大于等于`2`的情况，我们求得了其所对应的`1`的数量。

### 情况二：百位数字等于 1
对于百位数字等于`1`的情况，例如数字`21196`，则有以下对应分布：

![image.png](https://pic.leetcode-cn.com/09159e80b58d38d4c0bb6ff8a599c089686de202649c9dff3efe0d66e7483d8a-image.png)

> 令`a = 21196 / 100 = 211`，`b = 21196 % 100 = 96`。

注意序号`22`所取到的范围：`21100~21196`，只能取到`21196`。百位为`1`所出现的次数一共是`22`次，**但是，第 22 次的 1 的数量需要单独计算**。前 21 次出现`1`的个数为`(a / 10) * 100 = 2100`个，第 22 次的`1`的数量为`b + 1 = 97`个。

所以，在百位数字等于`1`的情况下，`1`出现的总数为`(a / 10) * 100 + (b + 1) = 2197`。

### 情况三：百位数字等于 0
例如数字`21096`，百位数字是`0`，属于等于`0`的情况，则有以下对应的分布：

![image.png](https://pic.leetcode-cn.com/fb6f0f9cdcde8007b447dbeb4c2728b6816da797fa03ccdebf9aa2cb94ece5ea-image.png)

> 令`a = 21096 / 100 = 210`，`b = 21096 % 100 = 96`。

注意序号`22`，该情况大于了给定的数字`21096`，所以不考虑，将其划掉。

则出现`1`的次数有`(a / 10) * 100 = 2100`。即对应的最高位是从 0 到 20。

### 情况汇总
对于`百位数字大于等于 2`和`百位数字等于 0`这两种情况，可以将它们结合起来，即`(a + 8) / 10 * 100`；而对于`百位数字等于 1`的情况，可以用`(a + 8) / 10 * 100 + (b + 1)`表示。

这里的`+ 8`是因为当百位为`0`的时候，存在`a / 10 == (a + 8) / 10`；当百位大于等于`2`时，补`8`操作会产生进位，等价于`a / 10 + 1`。

### 代码

```java
class Solution {
    public int countDigitOne(int n) {
        int res = 0;
        for (long m = 1; m <= n; m *= 10) {
            long a = n / m;
            long b = n % m;
            res += (a + 8) / 10 * m + (a % 10 == 1 ? b + 1 : 0);
        }
        return res;
    }
}
```

### 全部题解
《剑指Offer》的全部题解与 LeetCode 的部分题解在此下方，其中还包含**基础算法**与**进阶算法**，欢迎查看~
[LeetCode、SwordToOffer and other algorithms in Java.](https://github.com/dyfloveslife/LeetCodeAndSwordToOffer)

### 参考
[4+ lines, O(log n), C++/Java/Python](https://leetcode.com/problems/number-of-digit-one/discuss/64381/4%2B-lines-O(log-n)-C%2B%2BJavaPython)
[从1到n整数中1出现的次数](https://www.***.com/questionTerminal/bd7f978302044eee894445e244c7eee6?f=discussion)