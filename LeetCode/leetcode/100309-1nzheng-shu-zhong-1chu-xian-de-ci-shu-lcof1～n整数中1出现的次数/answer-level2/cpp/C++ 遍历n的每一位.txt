序列中1出现的总数可以看作每一个10位上的1出现的次数的综合。

对于其中的一位，1的次数可理解为当该位为1的时候的数一共出现了几次，主要需要考虑3个因素：

 1. 低于该位的数的大小，即n与当前位权的求余，假设记为ai-1 = n % 10^i，记当前位为第i位（i>=0）。这个数关系着当该位为1的时候共重复了多少次，但要考虑当前位是否为1，又分为三种情况；

 2. 当前位是否为1：
	    2.1. 若当前位大于1，则当该位为1的时候ai-1的取值范围为[0, 10^i)，共10^i个，故当前1的个数为10^i个；
	    2.2. 若当前位等于1，则该位1的个数为(ai-1)+1个；
	    2.3. 若当前位小于1，即0，则1的个数为0；

 3. 高于该位的数的大小，记为bi+1 = n / 10^(i+1)。这个数关系着上一步计算出来的1的出现次数会重复几次，分两种情况：
	    3.1. 若该数大于0，则高位数在[0, (bi+1))中共bi+1个数的时候当前位的1被充分计算了，即2.1的情况，故这部分1的总数为bi+1，需要在总数中额外加上这一部分；
	    3.2. 若该数为0，则这一部分1的总数为0，故不需要考虑。


```
class Solution {
public:
    int countDigitOne(int n) {
        if(n == 0)
            return 0;
        int base = (int)pow(10, (int)log10(n));
        int count = 0;
        while(base > 0)
        {
            count += (n / base / 10) * base;
            if(n / base % 10 > 1)
                count += base;
            else if(n / base % 10 == 1)
                count += n % base + 1;
            base /= 10;
        }
        return count;
    }
};
```
