这种题目显然是不会列举去数的，你无法知道题目输入数字有多大，但我们可以手动数小数字的A(n)，这里就记最后结果为A(n)。
比如从1到12：
1
10
11
12
我们觉得11后面那个1是不寻常的，他是最后一位为1引入的；十位上的许多“1”是引入新一位之后产生的扩倍。那么可以推出一种通用思路，把数字分为ij , j是最后一位数字，i是前面几位构成的数字。比如1234，i=123，j=4。

再试试更大的数字，比如从11到113：
按照以上的思路归类，那么：
①引入新位之后的数字是（注意这里括号不是序号）：
（1）1
（2）1
（3）1
（4）1
（5）1
（6）1
（7）1
（8）1
（9）1
（10）1
（11）1
括号里就是上面我们提到的不大于i的数，这里数量就是i，注意如果最后一位是0的话，(i)1 这个数是多算的，因此分类时要减1，为什么只减1呢？因为这里我们只计算新引入的1，不计算i里面的1.


②扩倍数字是：
（1）0
（1）1（注意后面的1之前已经算过了！）
（1）2
...
(11)0
(11)1（注意后面的1之前已经算过了）
(11)2
(11)3
【(11)4,(11)5,...,(11),9】
所有不大于11、且含1的数字，都可以在添一位之后变成10个新的含1的数字！

根据扩倍的原理，这里原本有10A(i)个数字，对应后面添0~9，但是要注意，这么算多算了中括号里
面的数字，他们已经比ij大了，要去掉，者很容易计算，公式为：

(9-k)B(i)

其中k是最后一位数字，B(i)为i中1的个数，这里就把多算的1去掉了。

最后注意还有一个数字1不在以上情况，单独列出来。

代码
```
class Solution {
public:
    int countOne(int n){
        int res=0;
        while(n)
        {
            if(n%10==1)res++;
            n/=10;
        }
        return res;
    }
    int countDigitOne(int n) {
        if(n==0)return 0;
        if(n<=9)return 1;
        if(n%10>=1)return n/10-(9-n%10)*countOne(n/10)+10*countDigitOne(n/10)+1;
        return n/10-(9-n%10)*countOne(n/10)+10*countDigitOne(n/10);
    }
};
```
