### 解题思路
本题在求解时有点动态规划的思想，即利用小规模的问题去迭代求解大规模的问题，我们首先来看：
1、`0-9`中**1**的个数是`1`；
2、`0-99`中**1**的个数是`9*1+10+1   = 20`
对于`0-99`来说，我们可以将其拆`0-89`+`90-99`，对于`0-89`，可分开求**十位上的1**和和**非十位上的1** 的情况，**非十位上的1**（1,11,21,.....,81）的情况`9*1`种,**十位上的1**（10,11,...,19）情况有`10`种；对于`90-99`（其实就是我们求得0-9的情况）只有`1`种，故加起来就是`9*1+10+1`。
3、`0-999`中**1**的个数是`9*20+100+20 = 300`
同样的，对于`0-999`来说，我们在上述的基础上进行拆分，可以分为`0-899`+`900-999`，对于`0-899`的情况，可分开求**百位上的1**和**非百位上的1**的情况，**非百位上的1**就是`9*20`种，**百位上的1**就是`100`种。对于`900-999`（其实就是我们求得0-9的情况）有`20`种。故加起来就是`9*20+100+20`

从上述案例来说，即是**先算个位有1的情况，然后利用低位依次去计算高位**。

例如：**321**，求1的个数？

对于个位*1*来说，1的个数是`1`；
对于十位*21*来说，1的个数是`2*1+10+1=13`；
对于百位*321*来说，1的个数是`3*20+100+13=173`;

——3 * 20 表示的是，0 - 99 、100 - 199、中，三段0-99的1总和  
——100 表示对于最高位为1的情况，也就是100-199，最高位有100个1  
——13 表示300-321中，00-21的1总和，其实就是上一次的运算结果

需要注意的是，如果行号高位为1的话，例如**121**，此时高位就没有100-199，只有100-121，那么1的个数就是22，此时就是`1*20+22+13`；

针对题目中数字最大为2^31次方，最多只有10位数。所以综上所述我们可以列出f(n)即，0-9；0-99；0-999；..........
f(1) = 1;
f(2) = 20;
f(3) = 300;
f(4) = 4000;
f(5) = 50000;
f(6) = 600000;
f(7) = 7000000;
f(8) = 80000000;
f(9) = 900000000;
f(10) = ‭10,000,000,000‬;

### 代码

```c
int countDigitOne(int n){
	int record[] = {0, 1, 20, 300, 4000, 50000, 600000, 7000000, 80000000, 900000000};
    int count = 0;
    int res = 0;
    long flag = 1;
    int tmp = n;
    while(tmp != 0){
       int num = tmp % 10;
       tmp /= 10;
       res = res + record[count] * num;
       if(num > 1){
           res += flag;
       }else if(num == 1){
           res += n % flag + 1;
       }
       count++;
       flag *= 10;
    }
    return res;
}
```