# 1. 解题思路
题目中有两个关键点值得注意：

**1. 利用三位数表示节点的深度、位置和具体值**

**2. 求根到所有叶节点的路径之和**

一个很直接的思路是先**重构树**，然后利用**深度遍历**求解。

但是这样的操作会**引入不必要的成本**，即对树进行重构的开销。

由于题目中给定了节点的深度、位置和具体值，不难想到可以将其转化为二维数组，其中：

**1. 行数代表节点的深度**

**2. 列数代表节点的位置**

**3. 数值代表节点的值**

不难想象，**当一个节点对应的两个子节点都没有值或者该节点达到最大深度时**，节点为叶节点，以此开始回溯到根节点即可。

# 2. 具体细节

由于题目中限定了节点的最大深度、最大宽度和权值范围，我们可以构造一个4行8列的数组，其中所有数的初始值为None。

由于数组是从0开始的，节点的深度和位置也就需要对应减去1，接下来我们需要讨论数组中数字的位置和节点的关系：

对于任意一棵树而言，如：
![树.png](https://pic.leetcode-cn.com/c330cd4f0a0c480c56c98502d01067386fdefe3906a0039943ce6b48051cc3c1-%E6%A0%91.png)


题目中输入值可以被描述为 [113, 213, 314, 322, 437, 449]

而依照我们填入数组的逻辑，它可以被表示为如下数组：

[3, None, None, None, None, None, None, None]
[3, None, None, None, None, None, None, None]
[4, 2, None, None, None, None, None, None]
[None, None, 7, 9, None, None, None, None]

对于第3层第2个的节点2而言，它的坐标为 [2, 1]，而它所对应的子节点坐标为 [3, 2]和 [3, 3]

**不难看出，对于第 i 行的第 j 个节点，它所对应的子节点是第 i+1 行的 j×2 和 j×2+1 节点**

而反过来，**对于第 i 行的第 j 个节点，它所对应的父节点是第 i-1 行的 j%2 节点**。

# 3. 解题步骤

1. 将输入的数组转换为能表示树结构的数组

2. 对数组中的每个值（即节点）进行遍历，如果节点值非空，且节点是最后一行或者节点对应的子节点都为空时，该节点为叶节点。

3. 针对每个叶节点，自下而上回溯其父节点，直到到达根节点，即数组的[0,0]位置

# 4. 具体代码

```
def pathSum(self, nums: List[int]) -> int:
    node = [[None]*8 for _ in range(4)]                # 初始化数组

    for n in nums:
        node[n//100-1][(n-n//100*100)//10-1] = n%10    # 将三位整数所携带的节点信息按规则填入数组
                                                       # 百位 n//100 为层数
                                                       # 十位 (n-n//100*100)//10 为所处位置
                                                       # 个位 n%10 为携带值
    #print(*node,sep='\n')                             # 用于检验所得数组是否正确

    res = 0
    
    for i in range(4):                                 # 对数组进行遍历
        for j in range(2**i):                          # 第i层最多包含2^i个节点 
                                 
            if node[i][j] != None and (i==3 or (node[i+1][j*2]==None and node[i+1][j*2+1]==None)):                                                      # 判断是否为叶节点，条件：
                                                       # 1. 节点值非空
                                                       # 2. 节点是否为最底层节点，或者子节点为空
                res += node[i][j]
                ii,jj = i,j
                while ii>0:                            #如果节点为子节点，自下至上回溯直到根节点
                    ii -= 1
                    jj >>= 1
                    res += node[ii][jj]
    
    return res
```

![运行结果.png](https://pic.leetcode-cn.com/b68005e64f3eaba2c6d83d7975387ed8fbb9dc4509225f6f06d7978e6f33337a-%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png)
