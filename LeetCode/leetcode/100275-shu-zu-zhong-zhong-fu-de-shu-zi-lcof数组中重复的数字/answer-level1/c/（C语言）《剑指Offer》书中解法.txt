### 时间复杂度O(n)，空间复杂度O(1)
**（以下是书中原文）** 从头到尾依次扫描这个数组中的每个数字。当扫描到下标为 **i** 的数字时，首先比较这个数字（用**m**表示）是不是等于**i**。如果是，则接着扫描下一个数字；如果不是，则再拿它和第**m**个数字进行比较。如果它和第**m**个数字相等，就找到了一个重复的数字（该数字在下标为**i**和**m**的位置都出现了）；如果它和第**m**个数字不相等，就把第**i**个数字和第**m**个数字交换，把**m**放到属于它的位置。接下来再重复这个比较、交换的过程，直到我们发现一个重复的数字。

### 代码

```c
int findRepeatNumber(int* nums, int numsSize){
    for(int i = 0; i < numsSize;) {
        if(nums[i] == i) {
            i++;
        }
        else {
            int m = nums[i];
            if(m == nums[m]) {
                return m;
            }
            else {
                nums[i] = nums[m];
                nums[m] = m;
            }
        }
    }
    // 必须有一个一定能执行的返回语句，不然会报错
    return -1;
}
```