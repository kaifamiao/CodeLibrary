`剑指offer---P39-44`
方法1. 先把输入的数组排序，从头到尾扫描排序后的数组。排序一个长度为n的数组需要O(*n*logn)的时间。

方法2. 利用哈希表解决。从头到尾按顺序扫描数组中的每个数字，每扫描到一个数字，都可以用O(1)的时间来判断哈希表里是否已经包含了该数字。如果没有包含，就把他加入哈希表。如果已经包含，就返回该数字。时间复杂度为O(n)。

方法3. 数组里的所有数字都在 0～n-1 的范围内，如果数组中没有重复数字，那么排序之后数字i会出现在下标为i的位置。从头到尾依次扫描数组中的每个数字，当扫描到下标为i的数字m时，首先比较m是否等于i。如果是，则接着扫描下一个数字，如果不是，则拿m与第m个数字进行比较。如果相等，则返回m，如果不相等，就把第i个数字和第m个数字进行交换。继续进行比较、交换，直到找到重复的数字。

```
class Solution {
public:
    int findRepeatNumber(vector<int>& nums) {
        int len=nums.size();
        if(!len)return -1;
        int i=0;
        while(i<len)
        {
            int m=nums[i];
            if(i==m)
            {
                i++;
                continue;
            }
            else
            {
                if(m==nums[m])return m;
                else
                    swap(nums[i],nums[m]);
            }
        }
        return -1;
    }
};
```
![image.png](https://pic.leetcode-cn.com/3b375afa94bae0746663364cb14eb756b3e201f6042af08a5f8048f372a59356-image.png)


`剑指offer---P41-43`

>不修改数组找出重复的数字
>在一个长度为 n+1 的数组 nums 里的所有数字都在 1～n 的范围内。请找出数组中任意一个重复的数字。

方法1. 创建一个长度n+1的辅助数组，如果原数组中被复制的数字是m，则把他复制到辅助数组中下标为m的位置。空间复杂度O(n)。

方法2. 按照二分查找的思路，把1～n从中间的数字m分开，前面一半是1～m，后面一半是m+1～n。如果1～m范围的数字个数超过m，则这一半的区间里一定存在重复的数字，否则，m+1～n的区间里一定存在重复的数字。时间复杂度为O(nlogn)，空间复杂度O(1)，相对于方法一来说是以时间换空间。