### 解题思路
该方法是剑指Offer上的解释，空间复杂度是 O(1) 的，它是通过值与索引的对应（调整）关系来进行解决的，因此会修改数组中元素的位置。

举个栗子：
　元素　[2,　3,　1,　0,　2,　5,　3]
　索引　  0　 1　 2　 3　 4　 5　 6

整体思路是：
　　我们要做到让索引为 i 的值是 i，例如：要做到让索引为 0 的值是 0，让索引为 1 的值是 1，让索引为 2 的值是 2。

步骤 1. 假如当前遍历到的索引是 0，由于 0 上面的数不是 0，所以将 0 上面的 2 与索引为 2 上面的 1 交换。
**但在交换之前**，需要判断一下元素 2 是否与元素 1 相等，如果相等，则找到了重复值，直接返回即可，**但此时不等**，所以进行交换，如下所示：
　元素　[1,　3,　**2**,　0,　2,　5,　3]
　索引　  0　 1　 **2**　 3　 4　 5　 6

步骤 2. 此时，2 已经来到了索引为 2 的位置，而索引为 0 的位置还是不满足条件，因此，再将索引为 0 位置上面的 1 与索引为 1 上面的值 3 进行交换。
**但是在交换之前**，需要进行判断两个元素是否相等。**此时不等**，所以进行交换，如下所示：
　元素　[3,　**1**,　**2**,　0,　2,　5,　3]
　索引　  0　 **1**　 **2**　 3　 4　 5　 6

步骤 3. 此时，1 又来到了索引为 1 的位置，而索引为 0 的位置还是不满足条件，因此，再将索引为 0 位置上面的 3 与索引为 3 上面的值 0 进行交换。
**但是在交换之前**，需要进行判断两个元素是否相等。**此时不等**，所以进行交换，如下所示：
　元素　[0,　**1**,　**2**,　**3**,　2,　5,　3]
　索引　  0　 **1**　 **2**　 **3**　 4　 5　 6

步骤 4. 此时，索引为 0 位置、1 位 置、2 位置、3 位置上的数已经对应起来了，接下来，来到了索引为 4 的位置。**在比较的时候，由于索引为 4 位置上的 2 与索引为 2 上面的 2 相等了，此时我们找到了重复的元素，直接返回即可**。

### 代码

```
public int duplicate(int[] nums) {
   if (nums == null || nums.length == 0) {
         return -1;
   }

   for (int i = 0; i < nums.length; i++) {
      // 索引为 i 的值与 i 不相等的话，则执行循环；相同的话，则继续比较 i+1 位置。
      while (nums[i] != i) {
            // 步骤 4，发现了相等的情况，则直接返回。
            if (nums[i] == nums[nums[i]]) {
               return nums[i];
            }
            // 步骤 1、步骤 2、步骤 3，没有发现相等的情况，则交换元素。
            swap(nums, nums[i], nums[nums[i]]);
      }
   }
   return -1;
}

public void swap(int[] nums, int i, int j) {
   int temp = nums[i];
   nums[i] = nums[j];
   nums[j] = temp;
} 
```
### 全部题解
《剑指Offer》的全部题解与 LeetCode 的部分题解在此下方，其中还包含**基础算法**与**进阶算法**，欢迎查看~
[LeetCode、SwordToOffer and other algorithms in Java.](https://github.com/dyfloveslife/LeetCodeAndSwordToOffer)