按照官方题解, 这道题首先建图, 然后在图中找欧拉回路. 
一开始我看到题解很懵逼, 为啥要这么建图?为啥能够想到建图?为啥能够想到欧拉回路?为啥这个简单的递归能找到欧拉回路? 全都是知识点啊我的亲娘舅诶... 没办法,遇到一个学一个吧.

这里说说我对建图的理解. 由于密码是n位数字, 假设我们一开始输入了n-1位数, 接下来一个数就很关键了, 它决定了我们是否可能蒙对密码. 假如我们先输入的前n-1位数是s, 那么最后一位数(第n位)有0..k-1一共k种可能. 如果我们把n-1为字符串s看成一个节点, 那么相当于它有k条边可以走到别的节点. 别的节点是啥呢? 比如 n是4, 那么s可能是"000", 它后面可以输入0..3, 因此由"000"可以扩展出 "0000 0001 0002 0003", 这4个可能的密码. 这里需要注意, "0000"只是一个可能的密码, 它并不是一个节点. 因为一个节点只有n-1位数, 然后这个节点加上它的一条边共同构成一个可能的密码.
因此 "000" 可以构成 "(0)000 (0)001 (0)002 (0)003"这4个密码, 也就是说它可以走到 "001 002 003"这3个节点(000是它自己, 就不连边了). 这3个节点每个自己后面加一位又能走到新的节点...

通过这种方式构图我们可以看出, 这个图一共有`k^(n-1)`个节点. 每个节点代表一个可能的密码, 从节点A走到与之相连的节点B, 相当于在当前输入的字符串后面新增一个字符构成新的密码. 所以, 如果要满足所有可能性, 且字符串尽可能短, 相当于从某个点出发, 遍历所有的点, 每个边只能走一次. 这其实就是欧拉回路.

那么根据欧拉回路的判定定理, 一个有向图如果存在欧拉回路, 当且仅当:
* 它是连通图
* 所有顶点的入度和出度相同

根据我们构图方式可以发现, 每个点都有k条出边, 且每个点都有k个入边. 因此图中必然存在欧拉回路. 剩下的方法就是如何找出这条欧拉回路了.

寻找欧拉回路的算法就是 `Hierholzer算法`, 具体就不多说了, 证明什么的可以自己查查文档. 这里说一说优化.

前面也提到了, 我们建图时, 是以长度为n-1的字符串为顶点(比如官方题解的示例代码), 因此在每次寻找当前点能走到的下一个节点时, 我们都需要
```
for i in 0..k {
    next = current + i; // 字符串加法 (malloc + copy)
    if !visited.has(next) { // 字符串hash
        visited.insert(next);
        dfs(next.substring(1), ...) // 字符串切片 (malloc + copy)
    }
}
```

用字符串表示节点本质上有两个目的:
* 唯一地表示一个节点
* 利用节点自身信息就能方便地找到下一个可以走到的节点而不需要额外空间来存储边

既然这样的话, 我们也可以把字符串看成n-1位k进制数,因此我想到了利用位运算进行优化
. 假如当前节点为x, 那么它能走到的节点就是:
```
for i in 0..k {
    next = (x << 1) | i; // 注意: !!!!!!!!!!! 这里的左移是k进制下的左移 !!!!!!!!!!!!!!
    if !visited.has(next) { 
        visited.insert(next);
        dfs(next & mask, ...) // mask用于把next在k进制下的最高位置0
    }
}
```

因此我们需要设计一个方便的k进制下的位运算, 能够实现左移和把最高位置零

在网上搜了一下, 并没有发现相关的文章, 因此自己想了个办法:

对于k进制, 每个位置可以是0..k-1, 因此, 我们可以用log(k)个bit来存一个k进制位(这样会比较浪费, but who cares?).

比如对于k=8的8进制, 单个位可以是0..7, 因此我们用log(8)=3个bits来存. 但是对于k=9的9进制, 每个位是0..8, 这时候我们就必须用4个bits来存.

我用m(k)来表示用一个k进制位需要m(k)个bits,那么:
* 对于k进制的x左移一位, 相当于就是2进制下左移m(k)
* 对最高位置零, 相当于`x &  ((1 << (n-1)*m(k))-1)`

因此最后代码:
```rust
use std::collections::HashSet;

impl Solution {
    pub fn crack_safe(n: i32, k: i32) -> String {
        if n == 1 && k == 1 {
            return "0".to_string();
        }
        let mut ans = vec![];
        let mut hash = HashSet::new();
        let mut m = 1;
        while 2i32.pow(m) < k { m+=1;} // 寻找mk
        let w = 2i32.pow(m)-1; // mk个1, 0b1111...
        let mut mask = 0;
        for _ in 0..n-1 {
            mask = (mask << m) | w;   // mask用于把最高位置零
        }
        Self::dfs(0, k, mask, m, &mut hash, &mut ans);
        for _ in 0..n-1 {
            ans.push(b'0');
        }
        unsafe {std::str::from_utf8_unchecked(&ans).to_string()}
    }

    // Hierholzer 算法寻找欧拉回路
    fn dfs(node: i32, k: i32, mask: i32, m: u32, hash: &mut HashSet<i32>, ans: &mut Vec<u8>) {
        for i in 0..k {
            let w = (node << m) | i;
            if !hash.contains(&w) {
                hash.insert(w);
                Self::dfs(w & mask, k, mask, m, hash, ans);
                ans.push(b'0'+i as u8);
            }
        }
    }
}
```