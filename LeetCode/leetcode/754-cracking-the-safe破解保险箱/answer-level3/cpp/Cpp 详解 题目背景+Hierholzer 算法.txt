# 解题思路
## 题意：
有个保险箱，然后这个箱子的密码是n位，每一位都是k进制数。
举个例子，如果**n=3，k=2**，那么可能的密码是101
题目所说的，会记忆后n位输入，就是说如果密码3位，我们可以输入10位甚至20位，
只要把我们的输入当成一个队列，每次弹出队首数字，然后核验现在的前n位是否符合。
依旧是**n=3，k=2**
我们可以输入 000 001 010 100 011 101 110 111 (为了好看每三位隔开了)
显然这串数其中必定含有密码。因为我们枚举了所有可能串。
但是也显然，这绝对不是**最短的**那个数字串。
因为没有利用这个保险箱的特性——记忆n位。
就像是 000 001 这一串，其实就可以简化成 0001，效果是一样的。
所以这个问题就变成了：
### 如何在一个最短的串内枚举所有的n位k进制数排列
其实这个问题是一个在数学中早已被研究透彻的问题了。
这种序列称之为 **de Bruijn序列**。
## 解答
这里首先需要你去学习 Hierholzer 算法，这是预备知识。
这个算法用于求解欧拉路径，略去细节后，简单地说，算法实现过程如下：
1. 先选择起点，然后出发进行DFS，把走过的边都删掉。
2. 无路可走的点压进栈内。
3. 把栈里的点都pop出来，就是一条欧拉路径。
具体证明可看：https://taodaling.github.io/blog/2019/04/25/Hierholzer%E7%AE%97%E6%B3%95/
当然了上面这篇博文也有点小错误，不过那两个性质的叙述是对的。

好了现在会了 Hierholzer 算法后，就可以来看看这个题目。
这题的难点在于如何构建出图来求解。
其实构思的方向不过几种：
1. 用单个数字为顶点，用数字串为边
2. 用数字串为顶点，用数字为边
3. 用数字串为顶点和边
4. 用数字为顶点和边

显然第四种方向是不行的。
第一种方向的问题就在于，两个顶点之间有巨多边，难以枚举，更难以储存(或者说难以判断是否遍历过)。
第二种方向其实是有一定可行性的，但是比不上第三种方向好写代码，问题也是类似的，就是边的储存。
我个人就是在第二和第三种方向中挣扎了好久。

现在说说，第三种方向具体要怎么实现。
抽象地来说，以所有 n-1位k进制数字串 为顶点，然后符合要求的 n为k进制数字串 为边。
具体说说，例如 n=5,k=7
其中的一个顶点可以是 2233,然后和这个顶点相连的七条边分别是：
22330 22331 22332 22333 22334 22335 22336
然后 2233 这个顶点可以通过 22330 这条边连到 2330 顶点。
大概就是这个意思。
也就是说每条边所代表的数字串都是可能的密码。
那么，在这个基础上，如果我们找到一条欧拉路径，
也就是说这条路径囊括了**所有数字串的组合**，并且是最短的。
(因为数字串中任意连续n位组成的数字串都可能是密码，并且只出现一次)
也就是题目要我们求的答案。

再具体的操作上，这种构思有着非常妙的实现方式。
首先，根据性质，这个图中每个顶点都必定是入度为k出度为k。
所以任选一个顶点为起点即可，那为了方便就选**n位零串**为起点。
然后你会发现一件事，就是处理这幅图，并不需要储存顶点和边。
**因为和当前顶点相连的边以及顶点，可以通过当前顶点代表的数字串推断出来。**

唯一比较麻烦的就是，在实现 Hierholzer 算法 的时候，要删边。
也就是我们需要判断边有没有走过。
这里采用的方法就是直接哈希，因为题目中说明了n最大为4，
所以只要将对应数字串映射到对应的数就好了，“1234”就对应1234，
如此一来，只需要开一个$10^5$的vis数组即可。

这个题大体上就是如此了。

# 代码

```cpp
class Solution {
    bool vis[10010];
    int Top=1;
    string Ans="0";
public:
void DFS(int k,string s,int num){
    vis[num]=false;
    num-=(s[0]-'0')*Top;
    num*=10;
    for(int i=0;i<k;i++){
        int temp=num+i;
        char c='0'+i;
        string s0=s+c;
        if(vis[temp]){
            DFS(k,s0.substr(1),temp);
            Ans+=c;
        }
    }
    return;
}

    string crackSafe(int n, int k) {
        for(int i=1;i<n;i++)
        Top*=10;
        string st="";
        for(int i=0;i<n;i++)
        st+='0';
        memset(vis,true,sizeof(vis));
        DFS(k,st,0);
        return Ans+st.substr(1);
    }
};
```