### 题目描述
在 `N * N` 的网格上，我们放置一些 `1 * 1 * 1`  的立方体。

每个值 `v = grid[i][j]` 表示 `v` 个正方体叠放在对应单元格 `(i, j)` 上。

请你返回最终形体的表面积。

### 样例

```
示例1：
输入：[[2]]
输出：10

示例2：
输入：[[1,2],[3,4]]
输出：34

示例 3：
输入：[[1,0],[0,2]]
输出：16

示例 4：
输入：[[1,1,1],[1,0,1],[1,1,1]]
输出：32

示例 5：
输入：[[2,2,2],[2,1,2],[2,2,2]]
输出：46
 
提示：
1 <= N <= 50
0 <= grid[i][j] <= 50
```

### 解题思路
首先解释一下题意：给定一个二维数组，二维数组中每一个元素值（记为`v`）表示在该位置（`v`在数组中的位置）上放`v`个小方块，求这一堆小方块组成的形体的表面积。比如给定`[[2]]`，这是一个`1x1`的二维数组，在`(0,0)`处的值为`2`，就表示`(0, 0)`处放两个小方块叠一起，总面积容易求得为`10`。

那么具体该怎么求呢？乍一看好像要讨论非常多的情况，不知道从哪里下手。我们可以先考虑简单情况，就比如上面的那种，两个小方块叠在一起，计算表面积有两种方法：
- 把整体看成一个长方体，`2 * 4`（四个侧面）+`1 * 2`（上下底面）=`10`
- 每个单独的小方块表面积是6，两个就是`6 * 2 = 12`，减去重叠部分`2`，结果为`10`

上面两种方法，方法一明显没有普适性，所以不考虑。对于第二种方法，看起来是可行的，对于一个三维形体，总面积好求，关键在于重叠部分的计算。我们可以分两个来考虑，垂直方向上的重叠和水平方向上的重叠。
- **垂直方向上的重叠**
![7_9LNUUF~C5)\](4FP\]\[RSTI.jpg](https://pic.leetcode-cn.com/5a18bdecb0833a3f88339ef82721c2c574441a534f4788a2c5b43ea9c6bdedeb-7_9LNUUF~C5\)%5D\(4FP%5D%5BRSTI.jpg)
垂直方向上的重叠很好计算，我们知道：
`2`个小方块垂直叠在一起，重叠面积就是`2`，即`1 * 2`；
`3`个小方块垂直叠在一块，重叠面积就是`2 + 2`，即`2 * 2`；
`4`个小方块垂直叠在一块，重叠面积就是`2 + 2 + 2`，即`2 * 3`；
...
那么`n`个小方块垂直叠在一块，重叠面积就是`2 * (n - 1)`。
因此整个形体**垂直重叠部分**的面积应该是$2 * \sum_{i=0}^{N-1}\sum_{j=0}^{N-1}(grid[i][j]-1)$
- **水平方向上的重叠**

![51SM@{Y(N@A2A(90KOE\[~QE.jpg](https://pic.leetcode-cn.com/1b6120b325b9231fd6217cf7cef3c41c3c570a54deac5b00ee49d603ed7bcc74-51SM@%7BY\(N@A2A\(90KOE%5B~QE.jpg)

考虑水平方向时，将每个位置上放的方块看成一堆，而我们知道，两堆方块紧靠在一起，那么重叠面积应该是较“矮”的那一堆的侧面积（重叠的那个侧面）。为了不计算重复，我们两两比较，对于给定位置`(i,j)`上的方块堆，与其前一个位置`(i-1,j)`和左边位置`(i, j-1)`相比较，重叠面积应该是
$Math.min(grid[i][j], grid[i - 1][j]) * 2 \ +\ Math.min(grid[i][j], grid[i][j - 1]) * 2$
  
### 代码

```java
class Solution {
    public int surfaceArea(int[][] grid) {
        int ans = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                ans += grid[i][j] * 6; // 累加总面积
                
                // 减去水平重叠面积
                if (i > 0) {
                    ans -= Math.min(grid[i][j], grid[i - 1][j]) * 2;
                }
                if (j > 0) {
                    ans -= Math.min(grid[i][j], grid[i][j - 1]) * 2;
                }
                
                // 减去垂直重叠面积
                if (grid[i][j] != 0) {
                    ans -= (grid[i][j] - 1) * 2;
                }
            }
        }
        return ans;
    }
}
```