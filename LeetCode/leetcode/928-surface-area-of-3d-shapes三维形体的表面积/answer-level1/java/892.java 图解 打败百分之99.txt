### 解法

```java
public int surfaceArea(int[][] grid) {
        int sum = 0; // 用来记录几个格子上有放立方体
        int n = grid.length;
        for(int i = 0; i < n; i++){
            if(grid[i][0] != 0) sum += 2;
            for(int j = 1; j < n; j++){
                if(grid[i][j] != 0) sum += 2;
                sum += Math.abs(grid[i][j] - grid[i][j - 1]) + Math.abs(grid[j][i] - grid[j - 1][i]);
            }
            sum += grid[i][n - 1] + grid[i][0] + grid[0][i] + grid[n - 1][i];
        }
        return sum;
    }
```

思路分析：

* 这个题明首先，上下底面的表面积就是2乘以放了方块的格子数量。侧面积会比较麻烦，但是对于N*N的矩形区域，行列式等价的。
* 从空间几何体描述的角度来看，左右侧面的处理方式与前后面的方式一样。因为旋转90度，左右就变成前后，前后就变成左右了。所以，可以由图示来看一下，侧面表面积的处理方式。
* 图示展示的是一行（左右侧面）的处理方式，该行的主视图，计算该行的侧面积。
    * 
![surfaceArea图示.png](https://pic.leetcode-cn.com/467b236b88e182139f53703f1a43283ac238220c8f822f16c7fc57b168d524f7-surfaceArea%E5%9B%BE%E7%A4%BA.png)
    * 由图可以看到，分两个部分计算，最外侧两个面，及中间的面。
    * 中间的面由于会有遮盖，所以要计算露出的面积。
    * 对于列（前后面）也是一样的处理方式，从侧视图看过去，视图一样。
* 对于每一行，每一列都进行相同处理即可。同时，记录有多少个格子放了立方体，以便得到上下底面积。
* 所以这是一个遍历，时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。

代码解释：

* 代码解释，第5及第7行，是用于统计有多少个格子放置了立方体，放置了立方体的单个格子，上下底面对表面积的贡献为2。
* 在图示中，进行内部侧面积计算时，使用了`grid[i][j - 1]`（针对行），或者`gird[j -1][i]`（针对列），所以第6行的内循环从`j = 1`开始。
* 第8行，针对内部会被遮盖的立方体贡献的表面积的计算。第十行则是最外侧没有遮盖的表面的面积贡献（前后左右四个方向，所以会有四个加数）。

运行结果：

* 执行用时 :3 ms, 在所有 Java 提交中击败了98.69%的用户
* 内存消耗 :41 MB, 在所有 Java 提交中击败了90.44%的用户

更多LeetCode题解请看我的[github](https://github.com/ustcyyw/yyw_algorithm)，地址https://github.com/ustcyyw/yyw_algorithm。还有别的小项目也很好玩~卑微求个小星星💖