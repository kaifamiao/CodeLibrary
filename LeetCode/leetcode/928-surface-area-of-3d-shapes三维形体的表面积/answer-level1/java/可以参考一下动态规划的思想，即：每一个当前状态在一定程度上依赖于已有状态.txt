### 解题思路

1. 三维形体的表面积是由每个柱体的表面积叠加得来，类似于动态规划中的当前解与已有解之间的关系
2. 因此先考虑单个柱体的表面积计算：如果立方体个数为0，则面积为0，否则柱体表面积=2个上下底面积+4*立方体个数；
3. 计算柱体表面积时已经考虑了上下的重叠面积，后面只需要考虑横向和纵向的重叠面积
3. 依次叠加每个柱体贡献的表面积=当前柱体表面积-减去柱体间重叠掉的面积（被减掉的重叠面积只由当前柱体提供）
4. 叠加过程可以参考一下动态规划的思想，即：每一个当前状态在一定程度上依赖于已有状态
5. 那么，顺序叠加时，纵向第一排（i==0）及横向第一排（j==0）：重叠掉的面积=横向（或纵向）最小高度\*2；其它柱体：重叠掉的面积=横向最小高度\*2+纵向最小高度*2
6. 纵向最小高度 = Math.min(grid[i][j], grid[i-1][j])； 横向最小高度 = Math.min(grid[i][j], grid[i][j-1])

### 代码

```java
class Solution {
    public int surfaceArea(int[][] grid) {
        //三维形体的表面积是由每个柱体的表面积叠加得来

        int n = grid.length;
        //总面积
        int sum = 0;
        //单个柱体面积
        int single_area;
        for(int i = 0;i < n;i++) {
            for(int j = 0;j < n;j++) {
                //计算当前柱体面积
                single_area = grid[i][j] > 0 ? 2 + 4*grid[i][j] : 0;
                //非纵向第一排的柱体需要减去纵向的重叠面积
                if(i > 0) single_area -= Math.min(grid[i][j], grid[i-1][j])*2;
                //非横向第一排的柱体需要减去横向重叠的面积
                if(j > 0) single_area -= Math.min(grid[i][j], grid[i][j-1])*2;
                //累计每个柱体贡献的面积，可以参考动态规划中dp[][]数组的当前最优解
                sum += single_area;
            }
        }
        return sum;
    }
}
```

* 首先，叠加柱体表面积的过程中依赖于已经得到的柱体总表面积，其次，当前柱体贡献的表面积的计算依赖于已经叠加过了的相邻的柱体
* 可以把当前柱体贡献的表面积当成一个被优化过的二维dp_1[][]数组，计算得到的柱体总表面积当成一个被优化过的二维dp_2[][]数组
* 通过题目所给二维数组计算得到当前柱体贡献的表面积数组dp_1，通过dp_2以及dp_1计算得到当前的三维形体的表面积