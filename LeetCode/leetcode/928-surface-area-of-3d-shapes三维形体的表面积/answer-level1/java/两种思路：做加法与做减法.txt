#### 解题思路：
这道题需要注意的难点是：立方体中间可能有 “空洞”，如下图：

![hole](https://pic.leetcode-cn.com/4df7bc0dec9a9c8cbfb42ac905753cbbc91ef7d718eb7f84c71f15f745468f34.jpg)

所以用侧视图来解题是行不通的。

不过，我们仍然有两种比较好的思路。我把它叫做 “做加法” 与 “做减法”。做加法的方法是把三维形体看成很多个柱子，把所有柱子的表面积累加起来；做减法的方法是计算全部的表面积，再减去重叠的部分。

下面分别介绍两种方法。

#### 方法一：做加法的思路

我们可以将单元格 `(i, j)` 上堆叠的 v 个正方体看成一个高度为 v 的柱子，然后分别计算每个柱子的表面积。

首先，v > 0 的话，柱子顶部、底部的表面积都是 1。

然后是上、下、左、右四个侧面的表面积。以左侧的表面积为例：

+ 如果柱子位于网格左边缘，左侧没有其他柱子，那么左侧表面积为 v；
+ 如果柱子比左边的柱子矮，那么左侧露不出来，表面积为 0；
+ 如果柱子比左边的柱子高，假设左边柱子高度为 `v'`，那么左边露出来的表面积为 `v - v'`。

我们可以把三种情况合并成一个表达式：`j-1 >= 0 ? Math.max(grid[i][j] - grid[i][j-1], 0) : grid[i][j]`。

其余的三个侧面以此类推。这样写出题解代码：

```Java []
public int surfaceArea(int[][] grid) {
    int N = grid.length;
    int res = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            // 上边露出的表面积
            res += i-1 >= 0 ? Math.max(grid[i][j] - grid[i-1][j], 0) : grid[i][j];
            // 下边露出的表面积
            res += i+1 < N ? Math.max(grid[i][j] - grid[i+1][j], 0) : grid[i][j];
            // 左边露出的表面积
            res += j-1 >= 0 ? Math.max(grid[i][j] - grid[i][j-1], 0) : grid[i][j];
            // 右边露出的表面积
            res += j+1 < N ? Math.max(grid[i][j] - grid[i][j+1], 0) : grid[i][j];
            // 顶部、底部的表面积
            res += 2 * (grid[i][j] > 0 ? 1 : 0);
        }
    }
    return res;
}
```

#### 方法二：做减法的思路

我认为这个方法更加巧妙，我们先计算全部的表面积，然后再减去重叠的部分。

假设一共有 $n$ 个立方体，每个立方体都有六个面，那么总的表面积应该是 $6n$。但是这些正方体堆叠在了一起，需要减掉一些因为堆叠而露不出来的表面积。每一对相邻的立方体接触在一起，都会让表面积减少 2。假设一共有 $e$ 对相接触的立方体，即有 $e$ 个接触面，表面积就会减少 $2e$。那么，最终的表面积就应该是 $6n - 2e$。

那么如何计算立方体的接触面呢？很简单，我们还是把每个单元格上堆叠的 v 个立方体看成一个柱子。立方体的接触面可以分为柱子内部和柱子之间的接触面：

+ v 个立方体的柱子内部，有 v - 1 个接触面
+ 高度分别为 v、w 的两个立方体之间的接触面为 `min(v, w)`

我们可以按这个思路写出题解代码：

```Java []
public int surfaceArea(int[][] grid) {
    int N = grid.length;
    int cubes = 0; // 记录立方体的数量
    int faces = 0; // 记录立方体接触面的数量
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cubes += grid[i][j];
            if (grid[i][j] > 0) {
                // 叠起来的 v 个立方体有 v-1 个接触面
                faces += grid[i][j] - 1;
            }
            if (i > 0) {
                // 当前柱子与上边柱子的接触面数量
                faces += Math.min(grid[i-1][j], grid[i][j]);
            }
            if (j > 0) {
                // 当前柱子与左边柱子的接触面数量
                faces += Math.min(grid[i][j-1], grid[i][j]);
            }
        }
    }
    return 6 * cubes - 2 * faces;
}
```

---

本文作者 nettee。如果你觉得本文对你有帮助，欢迎在力扣[关注我](https://leetcode-cn.com/u/nettee/)，目前已经有题解20余篇~最近的 “每日打卡” 系列也会经常参加~（点进我的个人资料，可以看往期题解哦）