# 解题思路说明



## 代码的git地址
[三维形体的表面积 (surface-area-of-3d-shapes)](https://github.com/Zhao233/LeetCodeRecord/tree/master/892.%20%E4%B8%89%E7%BB%B4%E5%BD%A2%E4%BD%93%E7%9A%84%E8%A1%A8%E9%9D%A2%E7%A7%AF)
“里面还有其它的题解哈哈哈哈”

## 题目解析
题目要求输入一个Int类型的二维数组，这个二维数组可以想象为一个n*n的地砖，然后二维数组中的数字表示在对应的地砖上堆砌的转的数目。然后求该三维体的表面积，应为存在遮挡，所以要去除那些遮挡掉的面积。

## 关键步骤
1. 因为题目已经说明正方体的边长为1，所以正方体的每一面的边长就为1
2. 因为是三维物体，所以，一定有上下表面积，而且上下表面积更好求，所以先计算上下面积（上面积*2）
3. 求解完上下面积之后，再求解周围四面的面积。在求解时，先假设这个位置四周没有被遮挡，然后再减去周围遮挡的面积即可

## 解题过程
遍历这个二维数组，然后先求解，该位置的上下面积，再求解四周未遮挡的面积

### 状态
1. 求解上下面积       
    当该位置的数字不为0时，则上下总面积为1+1
2. 求解周围面积     
    num为二维数组中的元素   
    sum为总面积

    * 先求出没有被遮挡的面积surface（surface = 4 * num）
    * 然后获取该元素上下左右元素的值
    * 通过上下左右元素的值，依次判断周围元素遮挡状态，再对surface进行减去遮挡面积的操作，从而获得该"地砖"上所堆砌的立方体的表面积

    判断遮挡状态：

    序号 | 当前元素 | 四周元素 | 大小判定 | 操作
    --- | ------- | ------ | ------- | ---- 
    0   |   num   |  index |num=index|   surface -= index
    1   |   num   |  index |num>index|   surface -= index
    2   |   num   |  index |num<index|   surface -= num

    遮挡状态说明：  

    0. 当上下左右中的一个元素（简写为四周元素，之后同理）的数值与该元素相同时，说明四周元素与“地砖”上堆砌的立方体同高，该面完全遮挡，所以要减去对应高度的面积（surface-=index 或者 surface-=num）；   
    1. 当四周元素比该元素小时，说明四周元素在“地砖”上堆砌的高度比该元素的高度要矮，只遮挡了一部分，所以只需减去四周元素的高度的表面积即可（surface-=index）;     
    2. 当四周元素比该元素大时，说明四周元素在“地砖”上堆砌的高度比该元素的高度要高，将该元素对应的面完全遮挡，所以减去对应高度的面积（surface-=num)

3. 将该元素对应的上下面积和周围面积叠加，并与总面积叠加

### 举例说明
    目标数据：[[1,2],[3,4]],
    
    示例元素坐标：0，1
    示例元素：2
    
    上下面积 = 1*2 = 2
    surface = 4*2 + 上下面积 = 10   

序号| 当前数字 | 四周元素 | 大小判定 | 操作 | 表面积
-- | ---------------- | ------ | ----  | ------------ | ---
0  | 2                | 左：1   | 2 > 1 | surface -= 1 | surface:9 
0  | 2                | 下：4   | 2 > 4 | surface -= 2 | surface:7

所以(0,1)节点的表面积为7 

## 注意
1. 求取四周元素时，注意数组越界的问题

## 其它
1. 所以2ms的是真的牛皮........
2. 等以后有空加图示吧

## 优化思路
1. 不用每一个元素都去查找上下左右元素，并计算遮挡面积。当计算一个元素的上下左右遮挡面积时，其实对应的上下左右元素的的遮挡面积也是相同的，当遍历到达上下左右元素时，就可以少计算一些     
例：采用举例说明中的例子，当2计算完，与4的遮挡面积为2，其实4与2的遮挡面积也为2，当遍历到4的时候就不用再计算与2的遮挡面积
2. 当遍历到的元素为0时，直接跳过，不必搜索四周元素