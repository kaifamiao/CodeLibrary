### 解题思路
**整体思路：减法--所有正方体的表面积-粘合重复的表面积**
    **1.题目理解：**
    - 一个N*N的网格，相当于一个二维数组，在C++里相当于二维vector,每个元素的数值相当于那个立方体，元素值为2，相当于2个立方体。
    - 相当于平铺的网格上，堆放着很多个立方体。[[2]]为一行一列的位置上叠放了2个立方体。[1,2][3.4]为两行两列的网格上，第一列第一行叠放1个立方体，第一列第二行叠放2个立方体，第二列第一行叠放3个立方体，第二列第二行叠放4个立方体。
    **2.求解思路细分：**
    - 如何算这些立方体的表面积？那就用所有立方体的表面积-立方体粘合一起的重复表面积。
    - 每个立方体的表面积为1*6.
    - 立方体粘合一起的重复表面积包括两部分，上下立方体粘合的表面积和侧边表面积。
    上下立方体粘合的面积由二维数组里的值可以求得，比如a[0,0]=2,那相当于一行一列的位置上放了叠起来的两个立方体，两个立方体上下粘合的面积为（2-1）*2。
    侧边表面积，那本题是从后往前求减。当前累加的面积减去与左边立方体的粘合面积，减去与前面立方体粘合的面积。
### 代码

```cpp
class Solution {
public:
    int surfaceArea(vector<vector<int>>& grid) {
        //减法：所有正方体的表面积-粘合重复的表面积 
        if (grid.size() == 0) return 0;
        int area = 0;
        for (int i = grid.size()-1; i >=0; i--)
        {
            for (int j = grid[i].size()-1; j >=0; j--)
            {
                if (grid[i][j] != 0)
                {
                    //累加每个正方体的表面积，每个立方体6革面
                    area += grid[i][j] * 6;
                    //求出粘合的面积，减去。
                    //减去上下立方体粘合的面积
                    area -= (grid[i][j] - 1) * 2;
                    //判断不是第一排，如果是第一排，前边是没有立方体的
                    if (i > 0)
                    {
                        //减去与前面一个正方体粘合的表面积，是最矮的那栋立方体的表面积
                        area -= min(grid[i][j], grid[i - 1][j])*2;
                    }
                    //判断不是第一列，如果是第一列，左边是没有立方体的
                    if (j > 0)
                    {
                        //减去与左边一个正方体粘合的表面积，是最矮的那栋立方体的表面积
                        area -= min(grid[i][j],grid[i][j-1])*2;
                    }
                }
            }
        }
        return area;
        }
};
```
执行结果：
    通过    显示详情
执行用时 :
    16 ms, 在所有 C++ 提交中击败了15.45%的用户
内存消耗 :
    8.8 MB, 在所有 C++ 提交中击败了100.00%的用户