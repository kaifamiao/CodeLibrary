### 解题思路
看了大佬得思路和代码，然后自己在思考总结写了下代码，记录一下思路：
1、只要当前格子有立方体，就先把总面积求出来，也就是：面积=个数*6，一个立方体6个面
2、当前格子得立方体个数>1时，是有重叠得，重叠得面积就是：（个数-1）*2，一次接触就少2个面
3、判断一下当前格子得位置，加入是（0.0），那么它就没有左边格子和上面得格子；
如果位置在中间某个位置，就要判断一下有没有和它相邻得格子，高度最矮得那个就是两个格子得接触高度，一个接触高度减少2个面积，所以两个格子之间减少得面积就是：最矮高度*2。就算当前格子的左边和上面没有立方体，也没关系，因为去的min,此时的min就是0.所以整个算法能走通。开始的时候不理解为什么要判断i和j的位置，后来思考了一下才发现


### 代码

```

class Solution:
    def surfaceArea(self, grid: List[List[int]]) -> int:
        m = len(grid) ##行数
        n = len(grid[0]) ##列数
        res = 0
        for i in range(0,m):
            for j in range(0,n):
                res+=grid[i][j]*6 ##只要当前这一个格子中有立方体就先全部算上面积
                if grid[i][j]>1:
                    res-=(grid[i][j]-1)*2 ##再判断当前这个格子中有多少个，2个格子重叠要减去（2-1）*2=2大的面积，3个格子重叠要减去（3-1）*2=4大的面积
                if i>=1:   ##i和j大于等于1的情况其实就是看看当前格子的位置，当前格子的左和后的接触面，减去这个接触面得面积即可
                    res-=min(grid[i][j],grid[i-1][j])*2
                if j>=1:
                    res-=min(grid[i][j],grid[i][j-1])*2
                
        return res

```