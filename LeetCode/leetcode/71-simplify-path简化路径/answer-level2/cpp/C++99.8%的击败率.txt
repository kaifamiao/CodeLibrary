# 直接进行匹配即可
本题直接进行匹配就行，但是要注意的是，匹配的是“.”或“./”或“..”或“../”，其他的任意字符，都应当认为是目录，如“.a”、“..a”、“...”。

先找一个字符串result记录当前绝对路径的位置，开始遍历时，首先判断是否是重复的“/”字符，若是，跳过本次循环即可，即重复的“/”字符不加入到result记录的当前绝对路径中；然后判断是否为特殊字符“.”，若不是，则当前字符视为目录的一部分，加入result，若是，则分为以下情况：

1. 当前字符为“.”，没有下一字符。此时即匹配到了“.”，表示当前路径，由于result已经表示当前路径了，那么我们不加入result即可，因此可以直接跳过。

2.当前字符为“.”，下一字符为“/”，此时匹配到了“./”，同情况1。

3.当前字符为“.”，下一字符也为“.”，而下下个字符不存在，此时匹配到了“..”，应当返回上一级目录，result返回到倒数第二个“/”即可。

4.当前字符为“.”，下一字符也为“.”，而下下个字符为“/”,此时匹配到了“../”,同情况3。

5.其他情况，即出现“.a”、“..a”、“...”这些情况，此时应当视为是目录，要加入result。

当全部字符遍历结束后，result中即为最短的绝对路径，但是要注意，其末尾可能包含“/”，应当去掉，去掉的时候要考虑仅有一个“/”，也就是根目录的情况，若是根目录，则不能去掉。

```
string simplifyPath(string path) 
{
	string result;
	for (int i = 0; i < path.size(); i++)
	{
		if (i > 0 && path[i] == path[i - 1]&&path[i]=='/')			//若有重复的/就跳过
		{
			continue;
		}
		else if (path[i] == '.')							//若出现.，则有以下匹配情况。1.没有下一个了，此时和./一样，要略去。2.下一个为'/'，省略，3.下一个为仍为.但是下下个不存在了，此时和../一样，返回上一级，4.下一个为仍为.下下个为'/'，返回上一级，5.出现.a或者..a，表示这是个目录，全部都要加入
		{
			if (i + 1 >= path.size() || path[i + 1] == '/')	//应当略去的情况
			{
				i++;
			}
			else if (path[i + 1] == '.')
			{
				if (i + 2 >= path.size() || path[i + 2] == '/')		//应当返回上一级的情况
				{
					if (result.size() == 1)			//根目录，不可能再返回上一级了。
					{
						i++;
						i++;
						continue;
					}
					result.pop_back();
					while (result[result.size() - 1] != '/')
					{
						result.pop_back();
					}
					i++;
					i++;
				}
				else                                        //视为目录的情况
				{
					result.push_back(path[i]);
					result.push_back(path[i + 1]);
					result.push_back(path[i + 2]);
					i += 2;
				}

			}
			else                                            //视为目录的情况
			{
				result.push_back(path[i]);
			}
		}
		else
		{
			result.push_back(path[i]);
		}
	}
	if (result.size()>1 && result[result.size() - 1] == '/') //最终结果要去除末尾的/，当且仅当在根目录时除外。
	{
		result.pop_back();
	}
	return result;
}
```