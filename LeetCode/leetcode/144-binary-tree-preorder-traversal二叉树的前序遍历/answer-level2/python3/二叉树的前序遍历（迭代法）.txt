### 解题思路
我们需要一个栈，用来保存树尚未访问过部分的信息。
1. 基本思想：
     **·** 因为是前序遍历，遇到节点就应该访问，下一步应该沿着树的左子树下行；
     **·** 但是节点的右子树还没有访问，因此需要记录，将右子节点入栈；
     **·** 遍历到叶子节点就要开始回溯了，取出栈中保存的一个右分支，像一棵二叉树一样去遍历它。
2. 每次遇到空树的时候，代表遍历一棵子树的工作已经完成。若这是一棵左子树，对应的右子树应该是当时的栈顶元素；若这是一棵右子树，则说明以它为右子树的更大子树已经完成遍历，下一步应该处理更上一层的右子树。
3. 循环中要维持一种不变的关系：变量node一直取值为当前待遍历子树的根，栈中保存着前面遇到但尚未遍历的右子树。如此一来，只要当前树非空（没有到叶子节点）或栈不为空（还有未遍历的部分），就应该继续循环，这是外层循环的条件。
4. 循环体内部应该先处理当前节点的数据，然后沿着树的左分支下行，一路把经过节点的右分支压入栈，故还需要一个循环。内部循环直到遇到空树时回溯，弹出栈顶元素（最近的一棵右子树），要做的也是遍历二叉树。

### 代码

```python3
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def preorderTraversal(self, root: TreeNode) -> List[int]:
        stack = []  # 用来保存一路遇到的节点未遍历的右分支
        res = []  # 用来存储前序遍历的节点的值
        node = root
        while stack or node: # 当栈不为空或者节点不为空时说明还需要遍历，进入循环
            while node: # 当前节点不为空时，就沿着左分支下行
                res.append(node.val) # 先将当前节点的值添加到res储存起来（即处理根节点数据）
                stack.append(node.right) # 将当前节点的右分支入栈
                node = node.left  # 沿着左分支下行
            node = stack.pop() # 遇到空树，回溯
        return res
                
```