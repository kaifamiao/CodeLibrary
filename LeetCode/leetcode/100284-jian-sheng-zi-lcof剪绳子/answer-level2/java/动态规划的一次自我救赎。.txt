
> 动态规划的题目已经做了好多题了，但是就跟众多同学一样，看到答案时才会恍然大悟 “我怎么会没想到这个呢？”。至此这种类型的题目在我这里就落下了，好理解，但不好破解的尴尬地步。

<br/>
### 心路历程

读完题目后，所谓的“直觉”告诉我，这题是个DP问题，为什么呢？因为长度为n的绳子，需要求最大乘积。那n-1长绳子的最大乘积是不是也可以求，n-2是不是也可以？“子问题”的解推导出原问题的解。不管是自顶向下还是自底向上，最重要的还是要知道问题的解的规律。开始动手，在纸上求出n=1到10之间的最大乘积解。
N | 最优解 | 最大乘积  
-|-|-
1 | 1 | 1 |
2 | 1 + 1 | 1 |
3 | 1 + 2 | 2 |
4 | 2 + 2 | 4 |
5 | 2 + 3 | 6 |
6 | 3 + 3 | 9 |
7 | 3 + 2 + 2 | 12 |
8 | 3 + 3 + 2 | 18 |
9 | 3 + 3 + 3 | 27 |
10 | 3 + 3 + 2 + 2 | 36 |

当然这个最优解，我也是自己纸上通过暴力枚举得到的。好，接下来，开始找规律：
第一个可以看出来的是，只要能分解出一个`3`，那么最终的乘积会比其他分解的值乘积更大。如果分解出`1`来，比如5举例子，`1+4=1x4=4`，这个乘积明显不是最大的，感觉这个`1`拖累了最大乘积，如果分解出`2`，还是`5`举例子，`2+2+1=2x2x1=4`，由于最后有一个`1`还是拖累了整个乘积，所以换一种`2+3=2x3=6`，ok，这个应该是可以枚举出来的最大乘积了。其实这个规律也很好理解嘛。任何数字乘`1`等于没乘，这个`1`分解出来毫无意义。那任何数字分解出`2`来，乘积就是double翻倍了，是不是最优呢？比如`6`举例子，`2+2+2=2x2x2=8`，但是我们通过枚举后知道`6`应该分解为`3+3=3x3=9`才是最大的乘积。至此，感觉再一个个举例子分解下去太费时间了，从目前来看`3`是最合理的一个分解乘积最优解的因子。

开始套用DP的常规模版，设置出一个`dp[n]`的数组，其中`dp[i]`表示`i`长度的绳子被剪成m段后的最大乘积值。
然后开始找初始状态和转移方程。
初始状态，第一感觉应该是`dp[1] = 1, dp[2] = 1`，然后剩下的通过转移方程来得到值。这个想法基本面是对的，但是找转移方程时，卡住了！哎，尼玛。一般写动态规划不都卡在这里吗，有什么办法呢。思考许久。没办法，实在想不出来。由于我是知道了3是最优解因子，所以我打算用“暴力”写一段程序来求解，因为，动态规划不就是把之前计算过的解都预存下来，然后再复用嘛。好，说干就干。吭哧吭哧，写了一段代码出来：

```java
public int cuttingRope(int n /* 2 <= n <= 58 **/) {
    int maxProduct = 1;
    while (n > 0) {
        if (n <= 2) {
            return maxProduct == 1 ? 1 : maxProduct * n;
        } else if (n == 3 && maxProduct > 1) {
            return maxProduct * 3;
        } else if (n <= 4) {
            n = n - 2;
            maxProduct = maxProduct * 2;
        } else { // n > 4
            n = n - 3;
            maxProduct = maxProduct * 3;
        }
    }
    return maxProduct;
}
```

感觉这段代码很trick，就是把各种分析后的情况枚举出来，然后每次减一个数字，然后乘上一个数字。提交代码后，居然通过了，- -！。好吧。只能说，上面的分析是对的。以及n的取值范围实在是太小了才到58，根本触发不了 “超时” 。

但是，这段代码却给了我重新回想起dp的转移方程该怎么写了。上面代码中当n>4时，最大乘积就是上一次的最大乘积*3。
回过来看dp[i]的定义，其中i表示绳子长度，那么转移方程应该是：`dp[i] = dp[i-3] * 3;`, `i - 3 > 3 => i > 6`
也就是说当绳子长度大于6后，可以直接套用 `dp[i-3] x 3` 这个公式。代入到最开始的那个表格中，惊喜的发现，没问题。
那初始状态就是是 i从1到6之间。代码如下：

```java
class Solution {
    /** time: O(n) space: O(n) **/
    public int cuttingRope(int n /* 2 <= n <= 58 **/) {
        if (n == 1) return 1;
        if (n == 2) return 1;
        if (n == 3) return 2;
        if (n == 4) return 4;
        if (n == 5) return 6;
        if (n == 6) return 9;

        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 1;
        dp[3] = 2;
        dp[4] = 4;
        dp[5] = 6;
        dp[6] = 9;

        for (int i = 7; i <= n; i++) {
            dp[i] = dp[i - 3] * 3;
        }
        return dp[n];
    }
}
```

其中还思考过，这个初始状态是不是太多了点，找了一下n在1-6之间的规律，发现在3-5之间，都是可以通过分解2等等，最后还是总结失败，算了吧。这题耗时太久。
还有一个动态规划的经典套路模版，状态压缩。思考后，很快就可以想到，状态只需要依赖于前3个。直接从O(n)的空间复杂度变成O(1)的时间复杂度。

```java
/** time: O(n) space: O(1) **/
public int cuttingRope0(int n /* 2 <= n <= 58 **/) {
    if (n == 1) return 1;
    if (n == 2) return 1;
    if (n == 3) return 2;
    if (n == 4) return 4;
    if (n == 5) return 6;
    if (n == 6) return 9;

    int pre3 = 4, pre2 = 6, pre1 = 9, cur = 0;
    for (int i = 7; i <= n; i++) {
        cur = pre3 * 3;
        pre3 = pre2;
        pre2 = pre1;
        pre1 = cur;
    }
    return cur;
}
```

但是，这个压缩状态空间没什么大的意思，除非n取值可以高达 10^5 这种级别。

### 总结
有点啰里八嗦的写完解答，对于从看到题目，且不知道题目属于哪种“套路”时，通过自己分析第一直觉出是DP问题，以及在解决DP问题时中间坎坷许多，还是需要把原问题通过暴力枚举以及正常解题出来后，再回来过看DP解法，就会清晰了很多。不然直接假设一个dp[i]一维或二维的状态空间，然后找状态，找转移方程，找初始状态等等都会像是本末倒置。
先解决题目 再优化题目 找到不管是备忘录模式还是DP模式，再剪枝优化DP。
