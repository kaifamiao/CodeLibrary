#### 14-剪绳子
***
<br>
##### 动态规划

* 动态规划特点
  * 最优子结构性质
    * 对绳子A，假设其最优解为A~1~A~2~...A~m-1~A~m~，若在A~i-1~和A~i~之间剪开绳子，则A~1~A~1~...A~i-1~和A~i~...A~m~也一定是对应绳子段的最优解
    * 证明：可用反证法，若A~1~A~1~...A~i-1~不是最优解，那一定有其他解使得乘积大于A~1~A~1~...A~i-1~，乘上A~i~...A~m~则会大于A~1~A~2~...A~m-1~A~m~，与A~1~A~2~...A~m-1~A~m~是最优解矛盾。
  * Overlapping subproblem性质
    * 易知

* 动态规划解法

  * 依据上述特点，可以用动态规划求解
    * 每根绳子都可以被划分为两段（存在多种可能），然后每段继续划分
    * 设两个一维数组p、s ，p[i]为一根长度为 i 米的绳子的最优解的值，s[i]为二分的划分位置，即在第i-1米和第i米之间划分
    * p[i] = min{ p[k] * p[i-k] } (k = 2, 3,...i / 2)与i的较小值，s[i] = k，之所以到 i / 2为止，是因为前后两部分是对称的
    * 易知s[1] = 0，s[2] = 1，s[3] = 2，分别令i = 4,5...n，即可初始化整个p数组和s数组，最后用s数组回溯一下，即可构造出完整的划分
  * 算法分析
    * 时间复杂度
      * 第３步的时间复杂度为O(n)
      * 求p[i, j]和s[i, j] 的代码要执行O(n)次
      * 回溯的时间复杂度不超过O(n)
      * 总的时间复杂度为O(n^２^)
    * 空间复杂度
      * 存储数组 p和s的开销为O(n)

* 动态规划实现

  ```java
  public int cuttingRope2(int n) {
      if(n <= 1)
          return 0;
      if(n == 2)
          return 1;
      if(n == 3)
          return 2;
  
      int[] p = new int[n+1];  //用于记录数据的表
      //初始化
      p[2] = 2;
      p[3] = 3;
  
      int index = 4;
      while (index <= n){
          //从第一段两米段开始划分
          p[index] = p[2] * p[index-2];  //初始化
          for(int i = 3; i <= index/2; i++){
              int temp = p[i] * p[index-i];
              if(temp > p[index]){
                  p[index] = temp;  //遇到更好的划分，更新
                  //如果需要返回划分方式，可以在这里记录
              }
          }
          index++;
      }
  
      return p[n];
  }
  ```

  

##### 贪心算法

* 贪心特点

  * 如果n大于3，则n划分之后的乘积一定大于等于n
  * n=2时，最优解为1，n=3时最优解为2
  * 由性质一二可知，绳子应该尽可能多地划分为长度为3的绳段。因为对于长度大于3的绳段，继续划分会使最后乘积更大（性质一）。而绳段３比绳段２更有优势，所以应该更多地划分长度为３的绳段

* 贪心算法解决

  * n不一定能整除３，此时我们可以分类讨论，假设 n / 3 = a
    * 当 n % 3 == 0，返回 3 ^a^
    * 当 n % 3 == 1，因为２＋２比３＋１更有优势（２×２ > １×３ ），所以抽出一个３和１组合成２＋２，返回 3^a-1^ * 2 * 2
    * 当 n % 3 == 2，返回3 ^a^ * 2
  * 算法分析
    * 除了乘方运算都是常数次的，乘方运算的时间复杂度为O(log (log n))，所以T(n) = O(log (log n))
    * 空间复杂度为O(1)

* 贪心算法实现

  ```java
  public int cuttingRope(int n){
      if(n <= 1)
          return 0;
      if(n <= 3)
          return n-1;
  
      int timesOf3 = n / 3;  //n / 3的整数部分
      if(n - timesOf3 * 3 == 1)
          timesOf3 -= 1;  //如果除法的余数为1，则将3+1转成2+2
      int timesOf2 = (n - timesOf3 * 3) / 2;  //若之前余1，2的个数为2；若之前余2,2的个数为1
  
      return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2));
  }
  ```

  



