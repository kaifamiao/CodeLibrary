### 解题思路
此处撰写解题思路

### 代码

```java
class Solution {
    ////动态规划 自低向上的解法
    public int cuttingRope(int n) {
        //声明DP数组 dp[i]表示绳子长度为i，剪绳子得到的最大乘积，因此数组长度n+1
        int[] dp = new int[n + 1];
        //因为求最大乘积，因此初始化为0，代表极小值
        for(int i = 0; i < n + 1; i++){
            dp[i] = 0;
        }
        //因为m大于1，所以绳子至少剪两段，当绳子为1的时候，显然dp[1] = 1,进行初始化
        dp[0] = dp[1] = 1;
        for(int i = 1; i < n + 1; i++){//依次计算绳子长度为dp[1] - dp[n]
            //假如绳子长度为6，则可以剪成1+dp[5] 2+dp[4] 3+dp[3] 4+dp[2] 5+dp[1]
            //显然对称了，因此j<=i/2即可
            for(int j = 1; j <= i/2; j++){
                //表示长度为i的绳子可以一次减1到i这么长，即j
                //状态转移方程显然为：dp[i] = Math.max(j * dp[i - j], j * (i - j));
                //即假设绳子长度为4,第一刀减去1，剩余3，则dp[4] = max(1*dp[3],1*3)
                //即假设绳子长度为4,第二刀减去2，剩余2，则dp[4] = max(上一步的dp[4],2*dp[2], 2*2)
                //因此写成如下两步！！！！！
                dp[i] = Math.max(j * dp[i - j], dp[i]);
                dp[i] = Math.max(j * (i - j), dp[i]);
            }
        }
        return dp[n];
    }
}
```