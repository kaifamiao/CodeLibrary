### 解题思路
使用动态规划的思想，如果按天迭代状态，直到最后一天，查看最后一天所有状态的最大值即可。
问题的关键在于怎样表示某一天的状态Si
用一个集合来表示第i天的状态
```
比如这样
Si1 = {第i天所有情况}
或者
Si2 = {第i天持有，第i天未持有}
再或者
Si3 = {第i-1天未持有第i天持有，第i-1天持有第i天持有，第i天未持有}
再或者
Si4 = {第i天持有，第i-1天持有第i天未持有，第i-1天未持有第i天未持有}
再或者
Si5 = {第i-1天未持有第i天持有，第i-1天持有第i天持有，第i-1天持有第i天未持有，第i-1天未持有第i天未持有}
......
注：为了表述清晰，以上集合中的每个元素都省略了“获得的最大收益”，比如Si2的第一个元素应该是：“第i天持有获得的最大收益”
```
可以看到，我们有很多形式来表示当天的状态，究竟选哪一个好呢？
结论就是：
如果第i天的状态集合中的每一个元素都可以由第i天之前的的状态集合中的元素表示，那么这个状态集合就是一个可用的状态集合。翻译成数学语言就是：
```
    对于任意s属于Si, 存在一个函数f属于F，使得 s = f(x1, x2, ... , xn), 其中，xk 属于 Union(S1, S2, ..., S(i-1))
```
这里的f本质上就是一个状态转移方程，F是必要的状态转移方程的集合，在很多时候，比如本题，一个状态转移方程是不够的，所以需要一个集合，这里之所以需要一个并集，在有些时候，当前状态不能仅仅用前一个状态得出，而需要用前面的很多状态得出，比如01背包问题。

如果我们找到了这个状态集合，那就代表我们已经搞定了状态和状态转移，个人认为到这一步，已经完成了80%，剩下的19%是处理边界条件，1%是写代码

下面就本题而言，我们尝试找到这样的一个状态集合，如果本题没有冷冻期，那么选用Si2作为状态集合就可以了
```
Si = {第i天持有，第i天未持有}
S[i][0] = max(S[i-1][0], S[i-1][1] - prices[i])
S[i][1] = max(S[i-1][0] + prices[i], S[i-1][1])
```
这就是两个状态转移方程
但是有了冷冻期之后，就不能用一个状态来表示未持有了，因为你不能用昨天的状态计算出今天的状态了，这时候需要用上面的Si4来作为状态集合，对应的状态转移方程是：
```
Si = {第i天持有，第i-1天持有第i天未持有，第i-1天未持有第i天未持有}
S[i][0] = max(S[i-1][0], S[i-1][2] - prices[i])
S[i][1] = S[i-1][0] + prices[i]
S[i][2] = max(S[i-1][1], S[i-1][2])
```

其实我们也可以使用`Si5 = {第i-1天未持有第i天持有，第i-1天持有第i天持有，第i-1天持有第i天未持有，第i-1天未持有第i天未持有}`，这样的话就会有4个状态转移方程，一样能再同样的复杂度下计算出正确结果。这也给大家一个提示，如果一时不容易找到合适的状态集合，可以把状态分的细一些，比如像Si5这样，当写出状态转移方程以后，会很容易发现哪些状态是多余的，再把多余的状态删去即可。

具体些代码的时候，把状态集合中的每一个结果都保存下来，然后从头算到尾，得到最终结果


### 代码

```python3
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        # 每天有持有，卖了未持有，保持未持有三种状态，计算出这三种状态下的最大值，就是最终结果
        # 如果今天持有，那么昨天有两种情况：
        #       1. 昨天持有，今天没有操作
        #       2. 昨天保持未持有，今天买了
        #       不存在昨天卖了未持有，今天买了的情况，因为是冷冻期
        # 在这两种情况下，取最大值，就是今天持有的最大值
        #
        # 如果今天卖了未持有，那么昨天一定是持有状态
        #
        # 如果今天保持未持有，那么昨天有两种情况
        #       1. 昨天卖了未持有，今天没操作
        #       2. 昨天本来未持有，今天没操作
        # 在这两种情况下，取最大值，就是今天未持有的最大值
        # 
        # 定义变量p1: 昨天持有的最大收益，p2: 昨天卖了未持有获取的最大收益
        # p3: 昨天保持未持有获得的最大收益
        # 今天持有的最大收益：p1 = max(p1, p3 - prices[i])
        # 今天卖了未持有的最大收益：p2 = p1 + prices[i]
        # 今天保持未持有的最大收益：p3 = max(p2, p3)
        # 
        n = len(prices)
        if n < 2:
            return 0

        p1, p2, p3 = -prices[0], 0, 0
        for i in range(1, n):
            p1, p2, p3 = max(p1, p3 - prices[i]), p1 + prices[i], max(p2, p3)

        return max(p1, p2, p3)
          
```