**从简单的问题说起~~**
首先我们考虑简单的情况

**给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格，**
**每天你可以买入股票，不参与交易或者卖出当前的股票，计算出**
**你可以获得的最大利润。**

这是这个问题的简单版本，最大的简化在于**不考虑之前买卖股票状态
对后面状态的影响**,这里我们使用dp[i][0]表示第i天不持有股票的最大利润，
dp[i][1]表示第i天持有股票的最大利润，可以很方便的列出方程式

`dp[i][0] = max(dp[i-1][0],dp[i-1][1]+prices[i]);`
**第i天不持有股票时的最大利润为，第i-1天不操作或第i-1天卖出股票中
的最大值**
`dp[i][1] = max(dp[i-1][0]-prices[i],dp[i-1][1]);`
**第i天持有股票时的最大利润为，第i-1天不操作或第i-1天买入股票中的
最大值**

思考：如何由简化版本解法升级为简化版本解法2.0?
**原问题与简化问题最大的区别在于，买入股票之后冷冻期为一天，也就是**
**说，加入了对先前买，不操作，卖这三种具体操作的讨论，而不是仅仅**
**考虑当前有没有持有物品**
所以问题的升级在于加入对于之前状况的考虑，我们加入数字k，**k = 0时
表示不进行操作，k = 1时表示卖出物品，k = 2表示买入物品。
原数组变为dp[i][k][0]或dp[i][k][1],注意这里[k]后面的0或1表示
当天操作完之后是否持有物品**
此时可能的情况总共有四种(有两种情况不可能出现，读者可以自行推导)
**第一种状态：当天不操作并且无物品**
![图片.png](https://pic.leetcode-cn.com/973d15d9fbe1df572e0b9c3b2742ccf9cb7c4876da51a6ce7bf84798899b8de0-%E5%9B%BE%E7%89%87.png)
`dp[i][0][0] = max(dp[i-1][0][0],dp[i-1][1][0])`
**第二种状态：当天不操作并且有物品**
![图片.png](https://pic.leetcode-cn.com/878523d8a8a3b785f6127e662bde02caeb637bd6ffa27dff4e753123e4d2f2a6-%E5%9B%BE%E7%89%87.png)
`dp[i][0][1] = max(dp[i-1][0][1],dp[i-1][2][1])`
**第三种状况：当天卖出后无物品**
![图片.png](https://pic.leetcode-cn.com/ff34952af2214cdb6078c7af852e8f208db4234d16066918483224a0b50bb2b5-%E5%9B%BE%E7%89%87.png)
`dp[i][1][0] = max(dp[i-1][2][1]+prices[i],dp[i-1][0][1]+prices[i])`
**第四种状况：当天买入后有物品**
![图片.png](https://pic.leetcode-cn.com/32163d4a7eb3f4941fab0afd3f895f785f36320e6defa64f89a7f31cb826839f-%E5%9B%BE%E7%89%87.png)
`dp[i][2][1] = dp[i-1][0][0]-prices[i]`

**状态的初始化**
对于第一天的物品，我们只有两种操作：买入物品，或者不操作
所以dp[0][0][0] = 0,dp[0][2][1] = -prices[i],
将其他状态以一个很小的负数标注，表示状态不可达
```
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int  dp[prices.size()+1][3][2];
        if(prices.size() == 0)
        {
            return  0;
        }
        int  INF = 0xffffff;
        dp[0][0][0] = 0;
        dp[0][2][1] = (-1)*prices[0];
        dp[0][0][1] = (-1)*INF;
        dp[0][1][0] = (-1)*INF;
        dp[0][1][1] = (-1)*INF;
        dp[0][2][0] = (-1)*INF;
        //初始化状态，只有dp[0][0][0]与dp[0][2][1]可达
        for(int  i=1;i<prices.size();i++)
        {
            dp[i][0][0] = max(dp[i-1][0][0],dp[i-1][1][0]);
            dp[i][0][1] = max(dp[i-1][0][1],dp[i-1][2][1]);
            dp[i][1][0] = max(dp[i-1][2][1],dp[i-1][0][1])+prices[i];
            dp[i][2][1] = dp[i-1][0][0]-prices[i];
        }
        return   max(dp[prices.size()-1][0][0],
        dp[prices.size()-1][1][0]);
        //最后利润最大的情况肯定为当前手上的物品全卖出的情况
        //所以最后一天取不操作无物品或者卖出物品后的最大值
    }
};
```
**最后，写了这么多也不容易，喜欢的小伙伴，麻烦左下角点个赞呗~~~~**
**希望可以帮助到你呀**

