### 解题思路
  最简单的是暴力，两个for搞定。但是这样遇上题目要求高点的就超时了。
  思路是这样的：用一个数组 **d** 去维护最长的长度，至于这里面的数字是怎么什么数字其实不用关心。因为你肯定是能够存在最长的上升序列。
  比如：[10,9,2,5,3,7,101,18]  它的最长上升子序列就是 [2,3,7,101] , [2,3,7,18] , [2,5,7,18] , [2,5,7,101] 这四种。虽然它里面的数字可能会发生变化，但是它整体的长度是不会发生变化的。因此我利用这个特性适用数组**d**来存放上升的数字，但是不论你数组里的数字是什么，你最长存在过的长度就是**d**的长度。
  而剩下唯一要做的就是去看每个数字在这个数组中的位子在哪里就可以了。比如一开始的数组里存放的就是: [10] , 那么后一个数字9就只需要看是否比数组中的最大值大就行，大就延长数组长度，小的话就找到9应该在的位置就行，那么很明显就是变成 [9] 这样子了。
  其他同理是这样，比如接着下去会出现这样的： [2,5] 。接下去的数字是 3 ，那么 3 的位置明显就是 5 所在的位置 ， 就替换为 [2 , 3] 。因为我是不用关心里面的数字，当前最大的长度还是2。
  现在，找到这个思路，实现起来就更加方便了。因为这个思路是能够保证这个数组**d**是有序的。而对于有序的数组，来查找位置就很明显用二分了。就可以减少时间复杂度。
### 代码

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        if(n <= 1)return n;
        vector<int> d;
        d.push_back(nums[0]);
        for(int i = 1 ; i < n ; i++){
            int l = 0 , r = d.size() - 1;
            if(nums[i] > d[r])d.push_back(nums[i]);
            else{
                while(l < r){
                    int mid = (l + r) / 2;
                    if(d[mid] < nums[i])l = mid + 1;
                    //碰上小于 d[mid] 的， r 的赋值一定是 mid  ， 而不是 mid + 1 ， 因为需要保证边界。
                    else r = mid;
                }
                d[l] = nums[i];
            }
            
        }
        return d.size();
    }
};
```