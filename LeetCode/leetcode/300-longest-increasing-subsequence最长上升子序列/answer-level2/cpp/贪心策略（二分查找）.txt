### 解题思路
   上半年就见过类该类型，dp最基本题型之一.这学期系统的学习dp后觉得...
    `O(n2)`;
    至于出题者 “你能将算法的时间复杂度降低到 `O(n log n)` 吗”，我是没有思路，就翻看了官方的解答，
    “**上升的尽可能慢**”给了我启发：
    举例：`2,5,9,6`
    容易得到 `2,5,9`和`2,5,6`是两个解。在扩展下：倘若后面还有序列，就要用前面的结果，这时候的最长数为`3`，但有两个序列，选择哪个为**基准**呢（都选就没有意义了）
    这么看：`2,5,6`上升更小，比`2,5,9`更能容纳后面可能的数，比如下一个数是 `8`，则看出`2,5,9`，是不容纳的；
    这一步中`2,5,9`变成`2,5,6`，**不仅个数没有变，且是正确的序列**；既遍历的数`[i]`在当前最优序列中（相对小于首和大于尾）
    在看另一种情况：`10,11,1,2,3`  
    得到序列 `10,11 `后遍历到`1` 时，怎么做？
    按前面的解法，`1` 不在序列 `10,11 `之中，且是小于首个数值的。这里就得**抛弃“正确序列”**（题设就是求个数）了：
    用` 1` 取代首个数，既 `10` ，此时个数还是`2`，但序列` 1,11`不是正确的子序列了；

综上，总结如下：
    `nums[i]`,`cnt[j]//后者是自己维护的`
    遍历序列数组，维持目标数组上升最小：
    若  `nums[i]>cnt[j]`(`j`为序列最后一个数值下标），直接加入；
    若  `nums[i]<cnt[0]`(既`cnt[]`第一个数值),`cnt[0]=nums[i]`;**此时正确子序列破坏**；
    若  `cnt[0]<nums[i]<cnt[j]`(相等跳过)，可以使用二分法找到`cnt[]`数组中第一个大于`nums[i]`的下标，直接取代；

    只不过个人在二分查找第一个大于nums[i]的下标时，犯了严重错误，结果改了半天！
         int m=(l+r)/2;
            if(nums[i]<cnt[m])
                 r=m;//就是这里注意！
1 分钟前	通过	4 ms	9.1 MB	Cpp
19 分钟前	通过	0 ms	8.9 MB  Cpp
### 代码

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size()<=1)
            return nums.size();
        vector<int>cnt(nums.size(),0);
        int len=0;
        cnt[0]=nums[0];
        for(int i=1;i<nums.size();i++)
            if(nums[i]>cnt[len])
                cnt[++len]=nums[i];
            else{
                if(nums[i]==cnt[0]||nums[i]==cnt[len])
                    continue;
                if(nums[i]<cnt[0])
                    cnt[0]=nums[i];
                else{
                    int l=0,r=len;
                    while(l<r){
                        int m=(l+r)/2;
                        if(nums[i]<cnt[m])
                            r=m;//就是这里注意！
                        else if(nums[i]>cnt[m])
                            l=m+1;
                        else break;
                    } 
                    if(l==r)
                        cnt[l]=nums[i];
                }          
            }
        return len+1;
    }
};
```