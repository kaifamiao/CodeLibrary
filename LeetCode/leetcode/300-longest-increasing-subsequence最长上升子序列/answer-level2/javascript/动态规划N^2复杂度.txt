### 解题思路
动态规划dp[]存数组每个值的状态: dp[1,1,1,2,2,3,4,4]
dp[0] = 1，意思是nums[0]之前比他小的数字有0个，所以此时最长子序长度是1
dp[1] = 1，意思是nums[1]之前比他小的数字有0个，所以此时最长子序长度是1
dp[2] = 1，意思是nums[2]之前比他小的数字有0个，所以此时最长子序长度是1
dp[3] = 2，意思是nums[3]之前比他小的数字对应的子序长度是1（2<5），所以此时最长子序长度是dp[2]+1
dp[4] = 2，意思是nums[4]之前比他小的数字对应的子序长度是1（2<3），所以此时最长子序长度是dp[2]+1
dp[5] = 3，意思是nums[5]之前比他小的数字对应的子序长度是2（2<5<7 或者 2<3<7 ），所以此时最长子序长度是dp[3]+1
dp[6] = 4，意思是nums[6]之前比他小的数字对应的子序长度是3（2<5<7<101 或者 2<3<7<101 ），所以此时最长子序长度是dp[3]+1
dp[7] = 4，意思是nums[7]之前比他小的数字对应的子序长度是3（2<5<7<18 或者 2<3<7<18 ），所以此时最长子序长度是dp[3]+1

最后从dp中找最大的就是解

### 代码

```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var lengthOfLIS = function(nums) {
    if(!nums.length) return 0
    let dp=[]
    for(let i=0;i<nums.length;i++){
        let max = 0;
        for(let j=0;j<i;j++){
            if(nums[j]<nums[i]){
                max = Math.max(dp[j],max)
            }
        }
        dp[i] = max+1
    }
    return Math.max(...dp)
};
```