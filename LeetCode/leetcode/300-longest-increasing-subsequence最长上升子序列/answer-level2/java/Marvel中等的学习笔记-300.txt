### 解法一：动态规划
我们知道，在最大连续子列和问题中，dp[i]表示下标为i的元素作为序列末尾时能得到的最大子列和，dp[i]也是问题的状态。
本题也一样，用**dp[i]表示下标为i的元素nums[i]作为序列末尾时能得到的最长上升子列的长度**，并将dp[i]作为本题的状态。然后将面临两种情况：
1. nums[i]前面的元素都更大或者与之相等。
2. nums[i]前面有更小的元素。

第一种情况好办，这说明以nums[i]为序列末尾时能得到的最长上升子列的长度dp[i]为1，因为前面的元素都更大，它们和nums[i]组合，无法形成上升子列。
第二种情况下，我们需要找出前面所有比nums[i]更小的元素nums[j]（其中，j = 0, 1, 2...i-1），并获得它们的dp[j]，而后，dp[i] = max{dp[j] + 1}（j = 0, 1, 2...i-1，且nums[j] < nums[i]）。

至此，状态转移方程就出来了：
dp[i] = max{dp[j] + 1, 1}，其中j = 0,1,2,...,i-1且nums[j] < nums[i]。
边界：
dp[0] = 1。以nums[0]为末尾时能得到的最长上升子列的长度肯定为1，因为该子列就只有一个元素nums[0]。
之后，从边界出发，通过状态转移方程，不断计算dp[]数组，dp[]数组中的最大值就是最长上升子列的长度。

代码：
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len == 0)    return 0;
        int ans = 1;
        int[] dp = new int[len];
        for(int i = 0; i < len; i++)
        {
            int temp = 1;
            for(int j = 0; j < i; j++)
                if(nums[j] < nums[i])  
                    temp = Math.max(temp, dp[j] + 1);
            dp[i] = temp;
            ans = Math.max(ans, dp[i]);
        }
        return ans;
    }
}
```
时间复杂度：$O(n^2)$，用于计算dp[]数组的两重循环。
空间复杂度：$O(n)$，dp[]数组需要的空间。

### 解法二：动态规划+二分查找
解法一之所以需要平方级别的时间复杂度，正是因为在计算dp[]数组的每个值dp[i]时，都需要再遍历dp[0]~dp[i-1]。这就是解法二要优化的地方，把这个线性级别的查找过程通过二分法降低为对数级别。

首先明确一点，若想让上升子列尽可能长，我们要让这个子列上升得尽可能慢，即子列元素在上升的过程中要尽可能小。这是自然的，否则如果子列元素上升得很快，元素都特别大甚至已达到全列最大值，那就没有上升的空间了，上升子列就没办法变长。
所以这次使用的dp[]数组的含义将与解法一的不同，**dp[i]表示的是长度为i的最长上升子列的末尾元素的最小值**。
这里有一个隐藏信息：dp[]数组的值随着i单调递增。这个很好理解，下面给一个不严谨的证明但思路正确：想象一下，i是指上升子列的长度，dp[i]是长度为i的上升子列的末尾元素的最小值。i增加了，上升子列变长了，那既然是上升子列，那末尾的元素的最小值自然要变大。

dp[]数组是递增的，即有序，可用二分法。

接下来遍历nums[]每一个元素，目的是完善dp[]数组的值，并根据dp[]数组的值，不断求出最长上升子列的长度。
解法一中，每访问一个元素，就要遍历它之前的所有元素，为的是找到末尾为比它小的元素的最长的上升子列；那么解法二中要找什么呢？
要找的是它在dp[]数组中的位置，即遍历nums[]每个元素，并通过二分法找每个元素nums[i]在dp[]中的位置，上面提到了，dp[i]表示的是长度为i的最长上升子列的末尾元素的最小值。dp[]数组的查找范围为[1,ans]。
通俗地说，要找的是，nums[i]要是放进dp数组中，能成为哪个长度的上升子列的末尾的最小值，即**找的是dp数组中第一个大于等于nums[i]的值的位置**。
令答案ans初始为0，代表目前找到的最长上升子列长度为0。
举个例子，若此时遍历到数组的第一个元素即nums[0]，dp数组此时没有元素，那nums[0]在dp数组的位置显然应该是下标1，表示第一次找到长度为1的上升子列，末尾元素就是nums[0]。

接下来对于nums[i]，二分法返回的结果idx也面临两种情况：
1. idx > ans，超过了查找范围[1,ans]，说明该元素为目前遍历到的最大元素，还没有大于等于它的元素，所以它在dp数组中的位置为idx > ans，说明首次发现长度为idx的上升子列，末尾元素就是nums[i]。更新dp[idx] = nums[i]以及ans的值。
2. idx <= ans，找到了第一个大于等于nums[i]的元素，位置为idx，说明长度为idx的上升子列的末尾元素现在有了更小的值，即nums[i]，更新dp[idx] = nums[i]。

由于找到的是第一个大于等于nums[i]的值的位置，那这个位置原来的元素必然大于等于nums[i]，通过dp[idx] = nums[i]替换后，长度为idx的上升子列的末尾元素变小了，正好符合上面的说法：子列要上升得尽可能慢。
遍历完成后得到的最终ans就是最长上升子列的长度。

提示：如果没有理解，在纸上多比划模拟算法的过程。

代码：
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if(len == 0)    return 0;
        int ans = 0;
        int[] dp = new int[len + 1];
        for(int i : nums)
        {
            int idx = binarySearch(dp, ans, i);
            if(idx > ans)   ans = idx;
            dp[idx] = i;
        }
        return ans;
    }
    private int binarySearch(int[] a, int ans, int k) {
        int lo = 1, hi = ans + 1;
        while(lo < hi)
        {
            int mid = lo + (hi - lo) / 2;
            if(a[mid] >= k) hi = mid;
            else            lo = mid + 1;
        }
        return lo;
    }
}
```

时间复杂度：$O(nlogn)$，查找过程由线性级别降低为对数级别。
空间复杂度：$O(n)$。