### 解题思路
最直觉的办法是把所有的子序列找出来，然后一个一个比较

其实不需要找所有的，假设`i...j`这段数组里有上升子序列，把左端范围扩大到`0`，`0...j`里一定有长度不小于`i...j`里的的上升子序列
（有点绕。。可以这么理解：扩大的范围中如果有比`i`还小的数，则上升子序列可以更长，即便没有，长度也可以保持和`i...j`里的一样长）
所以可以忽略`i...j`，直接计算`0...j`的最长上升子序列的长度即可（`j`是从`0`到`n-1`，一共有`n`个）

至于`0...j`的最长上升子序列如何求解，可以看`j`之前的每一项`i`，如果`i`比`j`小，那么从`0...j`的最长上升子序列就是在`0...i`的最长上升子序列基础上再`+1`，
当然比`j`小的`i`可能不止一个，选其中长度最大的一个来保证得到的也是`0...j`范围内的最大长度

在求解`0...j`的过程中，我们需要先知道`0...i`的结果（`i<j`），在求解`0...i`的过程中，我们又需要先知道比`i`更之前结果，发现了吗，这又是动态规划的套路
于是我们从左至右依次求解`0...j`的最长上升子序列并保存在`dp[]`中，其中最大的便是整个数组的最长上升子序列长度

### 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int maxLenJ = 0;
        for(int j=0; j<nums.length; j++) {
            int maxLenI = 0;
            for(int i=0; i<j; i++) {
                if(nums[i] < nums[j]) {
                    maxLenI = Math.max(maxLenI, dp[i]);
                }
            }
            dp[j] = maxLenI + 1;
            maxLenJ = Math.max(maxLenJ, dp[j]);
        }
        return maxLenJ;
    }
}
```