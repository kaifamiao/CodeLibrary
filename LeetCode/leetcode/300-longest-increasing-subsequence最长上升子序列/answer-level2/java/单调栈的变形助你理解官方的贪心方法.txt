我们首先想到的是贪心算法：
   **让序列上升的尽可能慢**
   也就是说，当我们遇到更慢的上升时候，就会淘汰更快的上升。
   **上升越小越好。**

比如: 
序列2 5 3 7 4
我们首先记录2，把2进栈，此时栈中是【2】
然后扫描到5，5比栈顶大，满足上升序列，5进栈，此时栈中是【2，5】
然后扫描到3
注意此时栈顶的5比3大，要一直出栈，直到找到一个比3小的停止，此时栈中是【2，3】
7直接入栈
4淘汰掉7，此时栈中是【2，3，4】

算法时间复杂度是n^2,能不能更快呢？我们发现不需要出栈，只要找到对应的位置并且替换就行了，和出栈的结果一样！
比如: 
序列2 5 3 7 4
我们首先记录2，把2进栈，此时栈中是【2】
我们扫描整个栈，找到5应该的位置，此时栈中是【2，5】
然后扫描到3
我们扫描整个栈，找到3应该的位置，替换掉原来的5此时栈中是【2，3】
7直接入栈
4淘汰掉7，此时栈中是【2，3，4】
由于这个栈是单调的，所以寻找应该的位置这个操作我们可以用二分查找，把时间降低到nlogn
到这里，我们惊讶的发现和官方一摸一样，但是官方的定义：**a[i]表示长度为 i 的最长上升子序列的末尾元素的最小值**可能难以理解。
