### 解题思路
纪念一下自己第一次靠自己想出解法，刷了几天题的小白感动哭了。

成功通过所有测试用例后以为自己的思路没问题了，结果写了半天题解感觉解法有bug（ORZ），根据bug点自己写了个测试用例那自己的代码和评论区大佬的代码比对了一下，还真是有问题……就又申请了空间把漏洞补上了，下面记录一下我的全部心历路程，顺便也请教评论区的各位大佬我这个方法还有没有待优化的地方，不胜感激。

最开始的思路是用一个数组记录各个位置之前最近的一个比他小的数，找不到的用-1标记，最后拿着这个数组从后往前串出来一个答案，结果被某个用例打脸了，只记录最近的一个数容易串歪来……

然后又开始换思路，这个题只要求最长的方案长度，没有要求把最长的方案输出出来，所以试图去找到最长序列后数一下长度的想法可能会耗费更多的时间和空间，又写了几个例子发现我只要关注两个东西好像就可以实现了。
1. 最长上升子序列的最后一个元素位置，变量记为maxLastIndex
2. 从数组中某一个位置算起，从数组开始到该元素可以构成的最长上升子序列的长度（我说的可能有点绕，实际上就在在遍历过程中维护每一个元素的当前上升子序列的长度），变量记为currentLength

具体做法如下：

1. 如果数组长度为0或1，直接返回0或1
2. 数组长度大于2的话最长上升子序列至少也有一个元素，我们将maxLength和currentLength初始值设置为1，将maxLastIndex设置为0（即我们假设第一个元素就是最长上升子序列的全部）
3. 从数组第二个元素开始往后遍历，每次比较当前元素是不是比前一个元素大
- 如果在上升：
1. currentLength加1（相当于在以遍历的元素的前提下，该元素纳入包含当前元素的最长上升子序列）
2. 考虑当前元素是否可以纳入我们已知的最长上升子序列，这里就要用到我们开始设定的maxLastIndex这个值，如果该元素比我们已知的最长上升子序列的尾元素还要大，当然这个元素可以纳入进来，同时maxLength加一，maxLastIndex更新位置
3. 考虑如果包含当前元素的最长上升子序列长度经过加1后超过了我们已知的最长上升子序列，看来有了更加有潜力的序列来竞争最长上升子序列，那我们就将该序列作为新的最长上升子序列（这个更换是在想象中，落实到具体我们还是只更新序列长度和末尾元素位置两个参数）
**这里需要证明的是第3点的想法为什么是正确的，即后面新出现的元素会不会纳入被抛弃的子序列组合从而完成“逆袭”，其实由于第2点的存在是不可能的，我们将目光聚焦在当前子序列长度超过已知最长子序列的那一刻，必然是新出现的元素纳入了当前元素子序列而没有纳入已知的最长子序列，即该元素不满足第2点中的“比我们已知的最长上升子序列的尾元素还要大”这一个条件，因此在新出现的元素中，但凡能够进入到最长子序列中，就一定能进入当前子序列中，这一点很关键，写个例子就能想明白。**
- 如果在下降：
1. 说明该元素无法纳入当前子序列（这个说法有点问题，因为该元素本来都没有纳入，何来当前子序列一说，但是这个概念说起来有点绕，就沿用之前的说法了……），此时我们就得去找包含当前元素的上升子序列。具体方法为从后往前比对当前子序列中元素和该元素的大小，找到合适的位置，使得该元素与当前子序列中的部分元素组成新的当前子序列（这其中就可能出现极端情况，即该元素比当前子序列中的所有元素都要小，那么只能从该元素位置重新开始计当前元素子序列）
2. 上面分析了出现非上升元素的处理思路，落实到具体代码上我们可以在向前比对的过程中每遇到一个比该元素大的元素，当前子序列的长度就减1，说明合适的位置还没有找到，继续向前，直到找到第一个比他小的元素，那么新的当前子序列就是该元素拼接在上一次的当前子序列中的合适位置之后
**这里就遇到了我前面说的被打脸的地方，因为自己写的例子不完善，有一定误导性，所以我粗暴的认为这个向前比对的过程，只要currentLength减到0，就没有必要再往前比对了，直接尽早结束循环重置变量更能节省时间。但是！我们在向前比对的过程中，有可能与当前元素比对的元素并不在之前的当前子序列中（这里又有点绕……），回忆我们在设想中找寻新的当前子序列的过程，如果出现下降后该元素与部分之前的当前子序列中的元素组成了新的当前子序列，其实是说明有一些当前子序列中靠后位置的元素是被舍弃的，即当前子序列中的元素是跳跃的，如果我们只是按数组中的顺序向前比对，就可能因为比较错了对象而多减去currentLength的长度**
3. 我开始的粗暴想法就是设定一个bool类型的开关，currentLength一旦减到0就跳出循环，然后重置为1，这样写出来的代码竟然通过了所有测试用例（-_-||），后来自己编了个[10, 30, 60, 70, 90, 80, 100, 51, 52, 53, 54, 55, 56, 57]用例，果然有问题。后来想了想，只能申请一个O(N)的空间维护一组bool类型的变量，标记一下每个位置上的元素还在不在当前子序列中，如果不在了就跳过这次比对和currentLength处理。
4. 剩下的就是对边界值的一些处理，这个算法只能通过遍历数组去维护包含每一位置上的最长上升子序列元素，从而记录下序列长度的最大值，如果要求出最长子序列，就得在长度最大值出现改变时同步当前子序列中的元素，当存在多种方案的最长子序列时这种方式就显得力不从心了。

有了前面的打脸用例，我也不敢说自己的算法完全没有问题了（￣□￣｜｜），还请各位大佬看一下有没有什么漏洞和待优化之处，另外我也就申请了O(N)的额外空间啊，为啥内存消耗这么大nie……
![1584240874(1).jpg](https://pic.leetcode-cn.com/77a033bf7961df030398e75ac1484d0f357355a3f1d9e0ba2a4f2bff3f825be2-1584240874\(1\).jpg)


以下是代码：

### 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length < 2)
            return nums.length;
        int maxLength = 1, currentLength = 1, maxLastIndex = 0;
        boolean[] remove = new boolean[nums.length];
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                currentLength++;
                if (nums[i] > nums[maxLastIndex]) {
                    maxLength++;
                    maxLastIndex = i;
                }
                if (currentLength > maxLength) {
                    maxLastIndex = i;
                    maxLength = currentLength;
                }
            } else {
                for (int j = i - 1; j >= 0; j--) {
                    if (remove[j])
                        continue;
                    if (nums[j] >= nums[i]) {
                        remove[j] = true;
                        currentLength--;
                        if (currentLength < 1){
                            currentLength = 1;
                            break;
                        }
                    } else {
                        currentLength++;
                        break;
                    }
                }
            }
        }
        return maxLength;
    }
}
```