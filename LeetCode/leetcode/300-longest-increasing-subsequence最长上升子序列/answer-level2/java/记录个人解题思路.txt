暂时只能想到O(n^2)的动态规划解法。在这里详细记录下个人的推导过程。
我习惯用递归+备忘录的思路来写动态规划，最关键的是找到递归表达式
按照例子[10, 9, 2, 5, 3, 7, 101, 18]，我们先暴力循环
如果 10，那么答案是1
如果 10，9，由于9<10，所以答案还是1
如果 10，9，2，由于2比10和9都要小，所以答案还是1
如果 10，9，2，5，由于5比10和9都要小，但比2要大，所以答案变成2，从这里可以看到，新加入的值需要和前面的值进行比较，所以这里会引入一个循环
如果 10，9，2，5，3，由于3只比2要大，所以3只能和2组成上升子序列，长度为2，并不比2和5组成的子序列长度长，因此答案还是2
如果 10，9，2，5，3，7，同上，试找下规律
每次加入一个新值，都要和前面的每一个值进行比较，如果大于它，则可以组成上升子序列，其长度等于所比较的值可以组成的上升子序列的长度+1。这里可以提炼出一个递归表达式if num[i]>num[j](0<j<i) then f(i) = f(j)+1，f(i)等于i位置的值的最长上升子序列的长度，然后循环后，找出所有0至num.length的所有长度，然后求最大值即可。
提炼出来后，再加上备忘录完成剪枝即可。