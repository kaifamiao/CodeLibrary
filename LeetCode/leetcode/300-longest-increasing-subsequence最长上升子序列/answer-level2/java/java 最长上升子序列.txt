动态规划+二分查找

设计思路：

新的状态定义：
我们考虑维护一个列表 tailstails，其中每个元素 tails[k]tails[k] 的值代表 长度为 k+1k+1 的子序列尾部元素的值。
如 [1,4,6][1,4,6] 序列，长度为 1,2,31,2,3 的子序列尾部元素值分别为 tails = [1,4,6]tails=[1,4,6]。
状态转移设计：
设常量数字 NN，和随机数字 xx，我们可以容易推出：当 NN 越小时，N<xN<x 的几率越大。例如： N=0N=0 肯定比 N=1000N=1000 更可能满足 N<xN<x。
在遍历计算每个 tails[k]tails[k]，不断更新长度为 [1,k][1,k] 的子序列尾部元素值，始终保持每个尾部元素值最小 （例如 [1,5,3]][1,5,3]]， 遍历到元素 55 时，长度为 22 的子序列尾部元素值为 55；当遍历到元素 33 时，尾部元素值应更新至 33，因为 33 遇到比它大的数字的几率更大）。
tailstails 列表一定是严格递增的： 即当尽可能使每个子序列尾部元素值最小的前提下，子序列越长，其序列尾部元素值一定更大。
反证法证明： 当 k < ik<i，若 tails[k] >= tails[i]tails[k]>=tails[i]，代表较短子序列的尾部元素的值 >> 较长子序列的尾部元素的值。这是不可能的，因为从长度为 ii 的子序列尾部倒序删除 i-1i−1 个元素，剩下的为长度为 kk 的子序列，设此序列尾部元素值为 vv，则一定有 v<tails[i]v<tails[i] （即长度为 kk 的子序列尾部元素值一定更小）， 这和 tails[k]>=tails[i]tails[k]>=tails[i] 矛盾。
既然严格递增，每轮计算 tails[k]tails[k] 时就可以使用二分法查找需要更新的尾部元素值的对应索引 ii。