

```
    /**
     * 构造法。找出一个一定能构造成功的方法。 存在一个"周期": 每进一位,比如 1位 进 2位, 把以前所有位的值加上2^n 然后倒序过来。
     * 因为从 n 进 n+1, 是相当于最后一个grey码的后n 位不变, 然后第 n+1 位从 0 变成 1，而这样的数要添加 2^n 个。
     * 由于前 2^n 个数已经被证明是能 构成 greyCode 的。
     * 那么只需让这些新的数的 n+1位保持为1, 并将后n位的值照着之前的 2^n的历史倒叙一遍即可。
     * 初始 1 个数 0
     * 比如 0 进 1, 要多 1 个数。而到此已经有1个数[0], 所以接下来的1个数就是 map (+1) [0]
     * 比如 1 进 2, 要多 2 个数。而到此已经有2个数[0, 1], 所以接下来的2个数就是 map (+2) [1, 0]
     * 比如 2 进 3, 要多 4 个数。而到此已经有4个数[0,1,3,2], 所以接下来的4个数就是 map (+4) [2,3,1,0]
     *    0  0           0
     *    1  1   1 + 0   1
     *   11  3   2 + 1   3
     *   10  2   2 + 0   2
     *  110  6   4 + 2   6
     *  111  7   4 + 3   7
     *  110  5   4 + 1   5
     *  100  4   4 + 0   4
     * 1100      8 + 4
     * 1110      8 + 5
     * 1111      8 + 7
     * 1110      8 + 6
     * 1010      8 + 2
     * 1011      8 + 3
     * 1001      8 + 1
     * 1000      8 + 0
     * @param n  n 位 grey 码
     * @return
     */
    public List<Integer> grayCode(int n) {
        List<Integer> ans = new ArrayList<>();
        ans.add(0);
        for (int i = 0; i < n; i++)
        {
            //count of new nums to be added: 1<<i
            int count = 1 << i;
            int offset = 1 << i;
            for (int j = count - 1; j >= 0 ;j--)
            {
                ans.add(offset + ans.get(j));
            }
        }
        return ans;
    }
```