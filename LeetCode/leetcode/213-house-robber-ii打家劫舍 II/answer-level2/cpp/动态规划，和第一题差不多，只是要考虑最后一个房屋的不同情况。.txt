先放一下我 [第一题题解](https://leetcode-cn.com/problems/house-robber/solution/dong-tai-gui-hua-by-njucly/)

最后一个房屋的情况由于和第0个房屋还有关联，所以我们在计算时必须把第0个房屋偷和不偷两种情况分开。
我们用dp[i][0]表示第0个房屋不偷的情况下前i个房屋能偷到的最大值，dp[i][1]表示第0个房屋偷的情况下前i个房屋能偷到的最大值。
有了第一题的思路，只要考虑清楚，转移方程就不是很难。

当然和第一题一样，由于状态方程计算后一个值时只用了前面有限个值，所以也可以用常数的变量替代dp数组来减少内存消耗。

PS:又去看了一下别人的解答，好多人把情况分成**第0个房屋偷且最后一个房屋不偷和第0个房屋不偷且最后一个房屋偷**这两种情况。这样做是不对的，因为它**没有考虑第0个房屋和最后一个房屋都不偷**的情况。那这些分成这样情况的人为什么还是能做对呢？看一下他们实际写的代码就知道，他们先去掉了第0个房屋，或者去掉最后一个房屋，这样做的**实质是分成了第0个房屋不偷和最后一个房屋不偷**两种情况，这两种情况中**存在对于两个房屋都不偷的情况的重复**，但由于最后求的是各种情况的最大值，**而求最大值在多加一种重复的情况下结果是不变的**，因此他们这样也能做对。

```C++ []
class Solution {
public:
	int rob(vector<int>& nums) {
		int n = nums.size();
		int** dp = new int*[n];
		for (int i = 0; i < n; i++) {
			dp[i] = new int[2];
		}
		//dp[i][0]表示第0个房屋不偷的情况下前i个房屋能偷到的最大值。
		//dp[i][1]表示第0个房屋偷的情况下前i个房屋能偷到的最大值。

		if (n == 0)
			return 0;
		if (n == 1)
			return nums[0];
		if (n == 2)
			return max(nums[0], nums[1]);

		dp[0][0] = 0;
		dp[0][1] = nums[0];
		dp[1][0] = nums[1];
		dp[1][1] = nums[0];
		for (int i = 2; i < n-1; i++) {
			dp[i][0] = max(dp[i - 1][0], dp[i - 2][0] + nums[i]);
			dp[i][1] = max(dp[i - 1][1], dp[i - 2][1] + nums[i]);
		}
		dp[n-1][0] = max(dp[n - 2][0], dp[n - 3][0] + nums[n-1]); //第0个房屋不偷时，最后一个房屋计算公式和前面的房屋一样。
		dp[n - 1][1] = dp[n - 2][1];	//第0个房屋偷时，最后一个房屋只能不偷，所以偷到的最大值为第0个房屋偷时前n-1个房屋能偷到的最大值。
		return max(dp[n - 1][0],dp[n-1][1]);	//总的最大值为第0个房屋偷或不偷时较大的那个。
	}
};
```
