### 解题思路
如果我们的思路是把当前某一个气球戳破算出其与相邻两个气球的乘积，因为戳破当前气球后，相邻的两个气球会合并到一起，造成下标的偏差，无法用同样的状态转移方程计算下一步的最优解。陷入重叠子问题的思维陷阱。

需要逆向思维把状态方程从最后的状态开始想，即我们要求x-y下标范围的气球的最大得分：假设这个范围内除了k下标这个气球其他气球全部被戳完了，戳破最后K位置的气球时，那么得分就与其他气球的位置无关了，只需要nums[k]乘以两个边缘(给定范围外临界坐标)的值。因为其他气球都被戳完了。

由上可以补充定义`边缘`：在给定范围外的最近边界值，比如在2-4下标的气球范围，边缘就是1和5.

那我会问，其他气球在k之前戳破的气球不会影响最后的k的结果吗？不会，看状态转移方程：

这里把dp[start][end]定义为**坐标之间正确策略下得到的最大分数**。那我们要求x和y之间气球的最大分数的状态方程如下。聚焦最后一个戳破气球的状态（从底向上）
`dp[x][y] = coins[k]*coins[x-1]*coins[y+1] + dp[x][k] + dp[k][y]`

翻译：x到y的气球的最大得分等于最后戳破k气球与x-y范围外边界的值的乘积（因为x-y中除k都被戳完了）加上以x和k为边缘的最大得分，和k到y的最大得分。**因为k是我们为了得到最大得分需要戳破的最后一个气球，说明之前有两个最大得分段分别在k气球的两边。**

### 代码

```python
class Solution(object):
    def maxCoins(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if not nums:
            return 0
        n = len(nums) + 2 #coins长度
        coins = [1]
        for num in nums:
            coins.append(num)
        coins.append(1)
        #dp表示从a到b坐标最大的得分
        dp = [[0 for x in range(n)] for y in range(n)]
        
        for i in range(2, n): #从起始边缘位置起有i个气球
            for j in range(n-i): #起始边缘位置j
                for k in range(j+1, j+i): #起始边缘位置开始中间的某个K为最后戳破的气球
                    dp[j][j+i] = max(dp[j][j+i], coins[k]*coins[j]*coins[j+i] + dp[j][k] + dp[k][j+i])
        return dp[0][n-1]
        
```

补充：
- 为什么是n = len(nums) + 2：
需要在原数组nums的基础上增加两个值为1的边缘气球

- 为什么要用coins数组代替nums：
我们需要在原数组的基础上两端加1，保证在处理边界时得到正确结果。

- 为什么i是range(2,n)，j是range(n-i)：
j下标的气球就是边缘气球，i表示从j开始有i个气球，最少需要有2个气球，因为j是左边缘，j+i就是右边缘，中间至少还要有一个k下标的气球(j<k<j+i)。同时j+i作为右边缘要小于n。因为coins是0~(n-1)

- 为什么是return dp[0][n-1]
0到n-1也就是0到len(nums)+1，0和len(nums)+1分别是nums所有气球的左右边缘。对应dp数组的定义，就是求下标为1到len(nums)气球的最大得分

..........................................................
=。= 发现题解陷入了写少了不够详细写多了又绕的窘境