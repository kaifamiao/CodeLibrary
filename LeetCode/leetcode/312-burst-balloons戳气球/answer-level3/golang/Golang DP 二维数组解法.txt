### è§£é¢˜æ€è·¯

è¿™æ˜¯æ ¹æ®ä¼Ÿå¤§çš„[ğŸ’–ğŸ’–ğŸ’–ğŸ’–ğŸ’–èŠ±èŠ±é…±è§†é¢‘è§£è¯´](http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-312-burst-balloons/)çš„æ€è·¯å’Œä»£ç æ”¹å†™çš„Golangä»£ç ã€‚

**ä¾µåˆ **

æˆ‘ä»¬åˆ†è§£è¿™ä¸ªå¤§çš„é—®é¢˜ä¸ºå°é—®é¢˜ã€‚
ç”¨ä¸€ä¸ª2Dæ•°ç»„æ¥`c`æ¥è®°å½•ç­”æ¡ˆï¼Œ`c[i][j]`è¡¨ç¤ºä»iåˆ°jçš„æœ€ä½³æ”¶ç›Šã€‚

ä¸ºäº†æ–¹ä¾¿ï¼Œå¯ä»¥å…ˆå¯¹è¾“å…¥`nums`å‰åpadding`1`ã€‚

DPçŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„å¡«å……è¿‡ç¨‹ï¼š

1.  æˆ‘ä»¬çš„ä»”é—®é¢˜çš„é•¿åº¦ä»`1`å¼€å§‹ï¼Œé€æ¸å¯»æ‰¾é•¿åº¦ä¸º`n`çš„å­é—®é¢˜çš„ç­”æ¡ˆã€‚
2.  å­é—®é¢˜å¼€å§‹çš„ä½ç½®æ˜¯`i=1`, ç»“æŸçš„ä½ç½®`j=i+l-1`ã€‚
3.  åœ¨å­é—®é¢˜ä¸­ï¼Œæˆ‘ä»¬ä»ç¬¬ä¸€ä¸ªä½ç½®å¼€å§‹é€æ¸æ‰“ç ´æ¯ä¸€ä¸ª`k`ã€‚
4.  å› æ­¤`c[i][j]`å°±å¯ä»¥é€šè¿‡`c[i][j] = max(c[i][j], c[i][k-1]+nums[i-1]*nums[k]*nums[j+1]+c[k+1][j])`è¿™ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹æ±‚å¾—ã€‚

### ä»£ç 

```golang
func maxCoins(nums []int) int {
	// Store the input's length.
	n := len(nums)
	// Padding 1s to head and tail of nums.
	nums = append(nums, 1)
	nums = append([]int{1}, nums...)

	// Create 2D-DP with n+2 width and height.
	// c[i][j] represents the max coins from i to j.
	c := make([][]int, n+2)
	for i := range c {
		c[i] = make([]int, n+2)
	}

	// l is the length of subarray. We start with l= 1, end with l = n.
	for l := 1; l <= n; l++ {
        // i is the start point in this subarray.
		for i := 1; i <= n-l+1; i++ {
            // j is the subarray's end.
            j := i + l - 1
            // k is the break point to separate.
			for k := i; k <= j; k++ {
				c[i][j] = max(c[i][j], c[i][k-1]+nums[i-1]*nums[k]*nums[j+1]+c[k+1][j])
			}
		}
	}

	return c[1][n]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

```