【基本原理】
本题的旋转排序数组的操作实质是将排序数组的前一部分拽到后边去。
例如: [1,2,3|4|,5,6,7],中点是4
(1) 4前旋转（如2前）==> 3,4,5,|6|,7,1,2 可知前半有序
(2) 4中点旋转 ==> 5,6,7,|1|,2,3,4 可知前半和后半都有序
(3) 4后旋转(如6前) ==> 7,1,2,|3|,4,5,6 可知后半有序
则很容易得到 经过旋转后的数组必定存在一半有序，**因为原数组不重复且有序，则查找数如果存在的话不是在有序（前或后）中就是在另一半无序中**。【偶数同样受用】

【具体实现】
1.要求O(lgn)的算法，很容易想到的是二分查找，但是此题并不需要两遍二分（先去查找旋转点，后找数），可以整体二分边判断边查找。重点是在于二分查找的实质是淘汰掉一部分数，在可能于查找，本题同样思路。
2.目前我们知道不管是旋转数组中点分界存在三种情况：
  2.1 左有序旋转点在右
  2.2 右有序旋转点在左
  2.3 左右都有序
**注意旋转点在不管在左还是在右，旋转点所在的一边肯定是两个有序的拼接**
3.根据l,r,mid判断两边有序无序，无序是直接可以判断出来的，如果左边无序则 nums[l] > nums[mid],右同理

**代码没有特殊处理，原始逻辑代码，可直接看出逻辑。**

```cpp
int search(vector<int>& nums, int target) 
{
    //边界条件
    if(nums.empty())
    {
        return -1;
    }
    
    //正常二分框架
    int l = 0;
    int r = nums.size() - 1;
    int mid = l + (r - l) / 2; //防止溢出
    while(l <= r)
    {
        mid = l + (r - l) / 2;
        if(nums[mid] == target)
        {
            return mid;
        };
        if(nums[mid] < nums[l])  //前半部分无序
        {
            //现在后半有序查找，后半有序查找不存在，前半查找
            //nums[mid] > target ? r = mid - 1 :  l = mid + 1;
            //先在后半部分查找
            if(nums[mid] <= target && target <= nums[r])  //肯定在后半部分
            {
                l = mid + 1;
            }
            else //有可能在前部分
            {
                r = mid - 1;
            }
            
        }
        else if(nums[mid] > nums[r]) // 后半部分无序
        {
            //现在前半有序查找，前半有序查找不存在, 后半查找
            //nums[mid] < target ?  l = mid + 1 : r = mid - 1;
            //先在前半部分查找
            if(nums[l] <= target && target <= nums[mid]) //肯定在前半部分
            {
                r = mid - 1;
            }
            else  //有可能在后半部分
            {
                l = mid + 1;
            }
        }
        else //整体有序
        {
            if(target < nums[mid]) //有可能在前半部分
            {
                r = mid - 1;
            }
            else  //有可能在后半部分
            {
                l = mid + 1;
            }
        };
    };
    return -1;
};
```


