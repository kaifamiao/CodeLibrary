### 解题思路
本来想写题解，结果被我家大金毛进被窝抱着我打了个滚... 写不下去了.. 呜呜呜呜..

题解二的思路就是 假设初始的所有橘子都是-1时间的一个橘子感染的，为第0轮的结果。
那么第1轮的结果就是第0轮感染的橘子。
然后我们在找被感染烂橘子的时候，如果使用递归广度优先遍历，不递归到最后一个烂橘子它不回来.. 如果在遍历的过程中把已经感染的烂橘子标记为已感染过，你不能确保你这个烂橘子就是感染它最快的！如果不标记，就要用二维表来记录你感染它是在第几轮，就和解法一，一个烂橘子一个烂橘子进行广度优先遍历，是一样的了。
所以，解法二的妙处就在于，用队列把每一轮的烂橘子放进去。这样队列入栈顺序就是，第0轮烂橘子，第1轮烂橘子，第2轮烂橘子。为什么这样就不需要二维数组保存状态了呢？因为，第二轮的烂橘子，无论是第一轮谁感染的，它都会是第二轮！能明白不？（也不知道会不会有人看..）那再举个例子，如果一个橘子能被第一轮就感染，那么就会被感染不会等到第二轮，所以如果是第二轮被感染的橘子，就一定是第二轮.. 
然后用time变量在遍历的过程中记录最大轮就可以了..

看得懂就是我的说法适合你，看不懂就说明看看其他题解.. 哈哈哈




### 代码

```javascript
/**
 * @param {number[][]} grid
 * @return {number}
 */
var orangesRotting = function (grid) {
    let count = 0, //好橘子数量
        queue = [], //队列
        time = 0 //最大时间

    R = grid.length
    C = grid[0].length

    for (let i = 0; i < R; i++) { //行
        for (let j = 0; j < C; j++) { //列
            if (grid[i][j] == 1) {
                count++ //记录好橘子的数量

            } else if (grid[i][j] == 2) {
                queue.unshift([i, j, 0]) //坏橘子放进感染源列表
            }
        }
    }

    while (queue.length != 0) { //队列不为空
        let bad = queue.pop() //拿出一个坏橘子 看能感染到好橘子不

        let x = bad[0], //行
            y = bad[1], //列
            dep = bad[2] //腐烂时间

        time = Math.max(time, dep) //记录最大的时间

        infect(x - 1, y, dep) //上
        infect(x, y + 1, dep) //右
        infect(x + 1, y, dep) //下
        infect(x, y - 1, dep) //左
    }

    function infect(x, y, dep) {
        if (x >= 0 && y >= 0 && x < R && y < C) { //判断越界
            if (grid[x][y] == 1) { //如果是好橘子 
                grid[x][y] = 2 //感染为坏橘子
                count-- //好橘子数量变少
                queue.unshift([x, y, dep + 1]) //添加到感染源队列
            }
        }
    }
    // 没有好橘子了 返回最大time  还有好橘子 说明感染失败
    return count == 0 ? time : -1
};
```