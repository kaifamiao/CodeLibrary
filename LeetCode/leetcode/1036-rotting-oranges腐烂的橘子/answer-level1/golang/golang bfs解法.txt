### è§£é¢˜æ€è·¯
bfsè§£æ³•
å…ˆå°†åğŸŠåæ ‡å¡åˆ°é˜Ÿåˆ—ï¼Œå†ä¼ æŸ“å…¶ä»–ğŸŠï¼Œç»§ç»­åŠ å…¥é˜Ÿåˆ—ã€‚
æ³¨æ„æ–¹æ ¼è¾¹ç•Œ

### ä»£ç 

```golang
func orangesRotting(grid [][]int) int {
	//ç©ºæ–¹æ ¼ï¼Œè¿”å›0
	if len(grid) == 0 {
		return 0
	}

	w, h := len(grid), len(grid[0]) 
	queue := [][]int{} //åğŸŠé˜Ÿåˆ—
	healthyCount := 0 //å¥åº·ğŸŠæ€»æ•°

	for i := 0; i < w; i++ {
		for j := 0; j < h; j++ {
			if grid[i][j] == 2 {
				queue = append(queue, []int{i, j}) //å¡é˜Ÿåˆ—
			} else if grid[i][j] == 1 {
				healthyCount++ //å¥åº·ğŸŠæ•°ç´¯åŠ 
			}
		}
	}

	var t = 0 //å¾ªç¯æ¬¡æ•°æˆ–å±‚æ•°æˆ–åˆ†é’Ÿæ•°
	for healthyCount > 0 && len(queue) > 0 { //æ— å¥åº·ğŸŠæˆ–é˜Ÿåˆ—ä¸ºç©ºï¼Œ è·³å‡ºå¾ªç¯
		t++ //å¾ªç¯æ¬¡æ•°åŠ 1
		ql := len(queue) //æœ¬æ¬¡å¾ªç¯è¦æ¶ˆè´¹çš„é˜Ÿåˆ—æ•°ï¼Œå› ä¸ºé˜Ÿåˆ—åé¢ä¼šç»§ç»­å¡ï¼Œæ‰€ä»¥è¿™é‡Œå…ˆç®—å‡ºé•¿åº¦
		for i := 0; i < ql; i++ { //å°†æœ¬åœ°çš„é˜Ÿåˆ—æ¶ˆè´¹å®Œ 
			one := queue[0] //æ¯æ¬¡éƒ½æ˜¯å–å‡ºç¬¬ä¸€ä¸ªï¼Œç›¸å½“äºé˜Ÿåˆ—å¤´
			x, y := one[0], one[1] //åğŸŠåæ ‡
			queue = queue[1:] //é˜Ÿåˆ—å¤´åˆ æ‰ï¼Œç›¸å½“äºå‡ºé˜Ÿåˆ—äº†

			if y-1 >= 0 && grid[x][y-1] == 1 { //ä¸Šè¾¹çš„å¥åº·ğŸŠ
				grid[x][y-1] = 2 //æ„ŸæŸ“
				healthyCount-- //å¥åº·ğŸŠæ•°å‡1
				queue = append(queue, []int{x, y - 1}) //è¢«æ„ŸæŸ“çš„ğŸŠåæ ‡å¡å…¥é˜Ÿåˆ—
			}

			if y+1 < h && grid[x][y+1] == 1 { //ä¸‹è¾¹çš„å¥åº·ğŸŠ
				grid[x][y+1] = 2
				healthyCount--
				queue = append(queue, []int{x, y + 1})
			}

			if x-1 >= 0 && grid[x-1][y] == 1 { //å·¦è¾¹çš„
				grid[x-1][y] = 2
				healthyCount--
				queue = append(queue, []int{x - 1, y})
			}

			if x+1 < w && grid[x+1][y] == 1 { //å³è¾¹çš„
				grid[x+1][y] = 2
				healthyCount--
				queue = append(queue, []int{x + 1, y})
			}
		}
	}

	if healthyCount > 0 { //è¿˜æœ‰å¥åº·ğŸŠï¼Œè¯´æ˜æ„ŸæŸ“ä¸å®Œï¼Œè¿”å›-1
		return -1
	} else {
		return t
	}
}

```