### è§£é¢˜æ€è·¯
åº”è¯¥æ˜¯æœ€åŸºæœ¬çš„æ–¹æ³•äº†ã€‚ã€‚ã€‚ã€‚
å†™çš„æœ‰ç‚¹ä¹±ï¼Œæ”¹äº†åŠå¤©ï¼Œå¥½å¤šå°bug

### ä»£ç 

```cpp
class Solution {
    
    // ä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘
    int dir[4][2] = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};
    // å®šä¹‰æ•°æ®ç»“æ„ï¼šğŸŠçš„çŠ¶æ€ï¼Œè¡Œã€åˆ—ã€è…çƒ‚æ—¶é—´
    struct Oranges{
        int row;    
        int col;
        int time=0;
    }orange_tmp, orange_new;
public:
    
    int orangesRotting(vector<vector<int>>& grid) {
        //ç½‘æ ¼ä¸ºç©ºï¼Œç›´æ¥è¿”å›
        if(grid.empty() || grid[0].empty()) {
            return -1;
        }
        int m = grid.size(), n = grid[0].size();  //ç½‘æ ¼çš„è¡Œåˆ—æ•°ç›®
        // if()
        int cnt = 0;
        queue<Oranges> Q;  //è…çƒ‚ğŸŠçš„é˜Ÿåˆ—

        // éå†ç½‘æ ¼ï¼Œå°†è…çƒ‚ğŸŠæ”¾å…¥é˜Ÿåˆ—
        for(int i=0; i<m; i++){
            for(int j=0; j<n; j++){
                if(grid[i][j]==2){
                    orange_tmp.row = i;
                    orange_tmp.col = j;
                    Q.push(orange_tmp);
                    // cout<<orange_tmp.row<<'\t'<<orange_tmp.col<<'\t'<<orange_tmp.time<<endl;
                }
                if(grid[i][j]==1){
                    cnt++;
                }
            }
        }
        //æ²¡æœ‰æ–°é²œğŸŠï¼Œç›´æ¥è¿”å›0
        if(cnt==0)
            return 0;
        // cout<<"total:"<<cnt<<endl;

        //BFSï¼Œä¼ æ’­ğŸŠè…çƒ‚ç—…æ¯’
        int row_tmp, col_tmp, time_tmp=0;
        while(!Q.empty()){
            orange_tmp = Q.front();   //å–å‡ºé˜Ÿåˆ—ä¸­ç¬¬ä¸€ä¸ªè…çƒ‚ğŸŠ
            //æ„ŸæŸ“å‘¨å›´ğŸŠ
            for(int i = 0; i<4; i++){
                // cout<<"i:"<<i<<'\t';
                // cout<<"direction: "<<dir[i][0]<<'\t'<<dir[i][1]<<endl;
                row_tmp = orange_tmp.row + dir[i][0];
                col_tmp = orange_tmp.col + dir[i][1];
                time_tmp = orange_tmp.time;
                // cout<<row_tmp<<'\t'<<col_tmp<<'\t'<<time_tmp<<endl;
                if((row_tmp>=0)&&(row_tmp<m)&&(col_tmp>=0)&&(col_tmp<n)&&(grid[row_tmp][col_tmp]==1)){
                    grid[row_tmp][col_tmp]=2;
                    orange_new.row = row_tmp, orange_new.col = col_tmp, orange_new.time = time_tmp+1;
                    Q.push(orange_new);
                    // cout<<orange_tmp.time<<endl;
                    cnt--;
                }
            }
            Q.pop();
        }
        if(cnt==0)
            return time_tmp;
        return -1;
    }
};
```