### 解题思路
此处撰写解题思路
首先这题有一个比较简单，但是却很糟糕的解题思路
即从数组头部开始，不断比较前后两个数字是否相同（nums[i] vs nums[i+1]），
如果不同，继续比较下一组；
如果相同，从相同的两个数字的后一个数字开始，直到numsSize-1（即数组末尾）的所有数字都前移一位，
覆盖掉前一个元素；同时numsSize--;i--;（i--是为了避免连续2个以上相同，执行一次前移之后，原位置两数字仍然相同的情况）；
当比较结束后，字符串的个数即为numsSize。

显然，这种方法的时间复杂度是O(n^2) 最坏情况即所有元素都相同。

因此，考虑改进，即考虑利用一个游标j对数组进行扫描，同时另一个游标(i)在数组头部待命；
如果j在扫描中，发现其位置的数字与i所在位置不同，则证明其是新出现的数字，不与i以及i之前位置的数字重复，因此，可以令i++（后移一位）；
并将j所在位置的数字放入i此时的位置中，然后继续扫描，直到数组末尾。

显然，当j扫描完毕后，i停留的位置，就是去重后数组的最后一个元素位置，因此，去重后数组长度就是i+1；
这种实现方法的时间复杂度是O(n);

需要注意特殊情况的预处理。
### 代码

```c
int removeDuplicates(int* nums, int numsSize){
    if(numsSize==0||numsSize==1) return numsSize;
    int i=0;
    for(int j=1;j<numsSize;j++)
    {
        if(nums[i]!=nums[j])
        {
            i++;
            nums[i]=nums[j];
        }
    }
    return i+1;
}
```