一. 解题思路
    数组排序的结果一定是[连续的0，连续的1，连续的2]这样的形式。关键在于只有3种颜色，只要把0全部丢到前面去，把2全部丢到后面去，数组就有序了。左右分别用一个指针标识0可以丢到的位置和2可以丢到的位置。
    当遇到nums[i]==2，将nums[0]和nums[r]交换，右指针往左移，表示下一次遇到2只能丢到后一个2的前面。数组的有序性是从两边向中间延伸的，我们遍历数组的终止条件是i<=r，因为已经处理过的2不用再处理了。注意，i不能自增，因为交换后nums[i]可能是0或者1，我们要再次处理一下。
    当遇到nums[i]==1，不用处理它，1是“被动有序的”。
    当遇到nums[i]==0，将nums[0]和nums[l]交换，左指针往右移，表示下一次遇到0只能丢到前一个0的后面。注意，i要自增，因为在遇到0之前，所有的2都被丢到后面去了，此时这个0只可能和前面的1交换，或者和自身交换（左指针在自己身上）。如果是和1交换，nums[i]==1是不用处理的，而和自身交换自然也是不用处理的，所以++i。

二. 代码
```
class Solution {
	
	public void sortColors(int[] nums) {
		if(nums.length == 0)
			return;
		
		int l = 0;
		int r = nums.length - 1;
		
		for(int i = 0; i <= r;) {
			if(nums[i] == 0) {
				int tmp = nums[l];
				nums[l] = nums[i];
				nums[i] = tmp;
				++l;
				++i;
			} else if(nums[i] == 2) {
				int tmp = nums[r];
				nums[r] = nums[i];
				nums[i] = tmp;
				--r;
			} else {
				++i;
			}
		}
		
    }
}
```
