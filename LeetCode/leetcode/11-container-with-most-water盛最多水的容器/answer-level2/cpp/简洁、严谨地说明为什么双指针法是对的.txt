这里双指针法不再赘述，这里只讨论为什么很多人觉得难以百分之百地被双指针法说服。

首先有几种说法是非常有歧义或者是错的：

1. “挪动较短板的指针肯定不会让你错过最优解”：
说不定你现在的两个指针已经形成最优解，你挪动较短板使得容器宽度变小，岂不丢失了最优解？见过最优解再放过去算是“错过”么？

1. “挪动较长板肯定就错过了最优解”
那可不一定，说不定当前区间内藏了两个非常高的板子在等你，最优解就轮不到当前的较长板了，你挪了也不会有事情。

所以你的目的就是在挪动过全过程里，让你至少见过一次最优解。双指针法之所以是正确的，是因为它保证了，在每次挪动操作前：
(a) 要么当前双指针代表的的区间，就是这个区间内的最优解
(b) 否则挪动短板一定不会让**区间内的最优解**逃出你挪动后的区间范围，因为无论短板再怎么努力挑选当前区间内的其他板，它形成的容积也无法比当前双指针形成的容积更大，因为宽只能变小，高无法变大。

而双指针从左右端点出发，所以在一开始全局最优解就是区间内的最优解。你的每一次挪动都不会让全局最优解逃出你的区间范围，直到你碰到最优解为止。但是你却并不知道到底在哪一次会碰上最优解，所以每一次挪动前你都需要用当前容积去尝试更新最大容积。

```
class Solution {
public:
    int maxArea(vector<int>& height) {
        int max_volume = 0;
        int left = 0, right = height.size() - 1;
        while(left < right){
            const int smaller = std::min(height[left], height[right]);
            max_volume = std::max(max_volume, (right - left)*smaller);
            if (smaller == height[left]){
                left++;
            } else {
                right--;
            }
        }
        return max_volume;
    }
};
```
