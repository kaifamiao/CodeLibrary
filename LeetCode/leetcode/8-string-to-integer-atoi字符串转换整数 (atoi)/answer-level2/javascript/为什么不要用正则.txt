初看本题，很自然会想到用正则表达式，刷一下正则，再判断边界即可得出答案。题解里很多提交的代码都是这样做的，看上去很完美。

但这里的问题正是在“判断边界”这里。

首先，题目要求是32位整数，作为有符号数，其存储方式为：
1. 长度32位，即32bit=4byte
2. 最高位为符号位，符号位为1，表示负数，为0则表示正数
3. 一个32位整数表示的最大正数为: 0x7FFFFFFF, 即最高位为0，其余31位全部为1，即2^31-1 
4. 一个32位整数表示的最小负数为: 0x80000000,即最高位为1，其余31位全部为0，即-2^31 (这里要了解所谓的“负权”)

所以题目给的上下边界值实际上是因为32位整数的存储方式而自然产生的。

现在假设原字符串 S 通过正则匹配后得出的结果 X 已经超出了Int32的范围，则将X强行转为Int32之后，必然导致X被截断（不考虑强转时程序报错的情况），从而会丢失X的高位部分。因为此时的X只有32位，它将必然位于上面提到的32位整数的上下限之间。换句话说，如果对正则的结果使用Int32类型进行强转，其边界校验实际上是无效的。

而之所以很多提交的代码有效，恰恰是因为编译环境使用了超过Int32的整数类型来保存类型转换的结果，譬如Int64。此时存储结果的空间足够大，不会有精度丢失。但问题是，无论有心还是无意，我们使用了超过Int32大小的数据类型来解决问题。而题目中有这样的限制条件：

`假设我们的环境只能存储 32 位大小的有符号整数`

而在没有更大的整数类型辅助的限制条件下，我们无法对string到int32的强制转换进行边界判断，意味着正则解法是存在严重瑕疵的。

__明确说明一下：我认为只要是直接通过比较result与int_max,int_min大小的都是有问题的，比如max(min)这种，或者result>int_max, result<int_min 这种。因为题目要求只能使用32位整数类型，result只要是32位整数，那么它就不可能比int_max还大，比int_min还小，这时的校验就是失效的。__


因此保险的方法还是老老实实遍历字符串，根据前一题即第七题的解法，我们可以找到校验整数是否越界溢出的解决方案。下面是一个javascript实现：


```javascript []
var myAtoi2 = function (str) {
    var symbol = 1;
    var num = 0;
    var accepted = 0;

    for (var i = 0; i < str.length; i++) {
        if (/\d/.test(str[i])) {
            //数字
            accepted = 1;

            var tmp = Number(str[i]);

            if (num > 0x0CCCCCCC || (num === 0x0CCCCCCC && tmp > 7)) {
                //正溢出
                return 0x7FFFFFFF;
            }

            if (num < -0x0CCCCCCC || (num === -0x0CCCCCCC && tmp > 8)) {
                //负溢出
                return -0x80000000;
            }

            num = (num << 3) + (num << 1) + symbol * tmp;
            continue;
        } else if (accepted) {
            //其他字符，一旦开始接收，则全部停止
            break;
        }

        //初次遇到各种字符
        if (str[i] === ' ') {
            //空格，不理会
            continue;
        } else if (str[i] === '+') {
            //+号，开始接收
            accepted = 1;
            continue;
        } else if (str[i] === "-") {
            //-号，开始接收
            accepted = 1;
            symbol = -1;
            continue;
        }
        //其他任意字符第一次遇到直接返回
        return 0;
    }
    return num;
};
```




