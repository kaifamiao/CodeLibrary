### 解题思路
1. 第一点在于识别第一个字符，我们使用一个for循环即可，非空即停。指针会停在第一个字符处。
2. 识别到第一个如果是'+'，不管它；如果是'-'，将tag标记置为负**，注意：此时由于指针向前移动，判断完第i个位置正负之后，到i+1的地方不能再判断正负了，再"+-2"，这个样例里面就会出错。**
3. 此时进入循环转换，如果字符串空了，或者不符合0~9，那么跳出循环。
4. 最后进行溢出判断。我用的是double转int：由于精度不同，两者相等那么此时int没有溢出,否则溢出。
5. 此处有一个关于溢出判断的问题，如果你懂，可不可以教我一下。已写在溢出判断代码处。

### 代码

```c
int myAtoi(char * str){
    int i = 0;
    int tag = 1;
    double sum = 0;
    while (str[i] == ' '){
        i++;
    }
    /*判断正负*/
    if (str[i] == '+'){
        i++;
    }
    else if (str[i] == '-'){//细节：两个判断只会进入一个
        tag = -1;
        i++;
    }
    /*转换*/
    while (str[i] != '\0' && str[i] >= '0' && str[i] <= '9'){
            sum = sum*10 + (str[i] - '0');
            i++;
    }

    if (sum != (int)sum){//溢出判断
        return tag == 1? INT_MAX : INT_MIN;
    }
    /*1.为了进行溢出判断，我选了double作为sum的类型，此时是可以成功的。同样占八个字节，我将sum定义成long类型，就会出现数字溢出，这是为啥？
    2.如果还是把sum定义成long类型，把这个判断放while里面，仍然不会报错？如下：
    while (str[i] != '\0' && str[i] >= '0' && str[i] <= '9'){
            sum = sum*10 + (str[i] - '0');
            i++;
        if (sum != (int)sum){//溢出判断
        return tag == 1? INT_MAX : INT_MIN;
    }
    }
*/

    sum *= tag;
    return sum;
    
}
```