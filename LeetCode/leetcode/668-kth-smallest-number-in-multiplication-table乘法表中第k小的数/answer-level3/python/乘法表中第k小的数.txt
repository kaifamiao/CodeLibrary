####  方法一：暴力法 [超过内存限制] 
**算法：**
创建乘法表并对其排序，然后获取 $k^{th}$ 的元素。 

**复杂度分析**

* 时间复杂度：$O\big((mn))$ 创建表，然后 $O(mn\log(mn))$ 对其进行排序。 
* 空间复杂度：$O(mn)$ 存储乘法表。

####  方法二：Next Heap [超过时间限制] 
**算法：**
- 维护每行中最小的未使用的元素堆。然后，在堆上查找到下一个元素是一个 pop 操作。 
- 我们的堆将由 $\text{(val, root)}$ 组成，其中，$\text{val}$ 是该行的下一个未使用的值，而 $\text{root}$ 是该行的起始值。 
- 我们将在表中重复查找下一个最低的元素，若有则堆做一个 pop 弹出一个元素，然后再把表中查到的元素插入堆中。

**复杂度分析**

* 时间复杂度：$O(k * m \log m) = O(m^2 n \log m)$。我们最初的操作是 $O(m)$。然后，每个 pop 和 push 都是 $O(m \log m)$，并且我们的外循环是 $O(k) = O(mn)$
* 空间复杂度：$O(m)$，我们的堆被实现为一个包含 $m$ 元素的数组 。

####  方法三：二分搜索[通过]
由于 $\text{k}$ 和 $\text{m*n}$ 最多为 $9 * 10^8$，线性解将不起作用。这将激发具有 $\log$ 复杂性的解决方案，例如二分搜索。 

**算法：**
让我们用二分搜索答案 $\text{A}$。 

- 当且仅当乘法表中存在小于或等于 $\text{k}$，`enough(x)` 才为真。通俗地说，`enough(x)` 描述了 $\text{x}$ 是否足够大可以成为乘法表中的 $k^{th}$ 值。 
- 然后（对于我们的答案 $\text{A}$），每当 $\text{x ≥ A}$，`enough(x)` 为 `True`；每当 $\text{x < A}$，`enough(x)` 为 `False`。 
- 在二分搜索中，循环不变量 `enough(hi) = True`。在开始时，`enough(m*n) = True`，并且每当设置 `hi`时，都将其设置为“enough”（`enough(mi) = True`）的值。这意味着 `hi` 将是二分搜索结束时的最小值。 
- 这样我们就可以计算出有多少值小于或等于 $\text{x}$。对于 $\text{m}$ 行中的每一行，$i^{th}$ 行看起来像是 $\text{[i, 2i, 3i, ..., ni]}$。可能出现的最大的 $\text{ki ≤ x}$ 是 $\text{k = x // i}$。但是，如果 $\text{x}$ 真的很大，那么可能是$\text{k > n}$，那么在该行中总共有 $\text{min(k, n) = min(x // i, n)}$ 值小于或等于 $\text{x}$。 


**复杂度分析**

* 时间复杂度：$O(m * \log (mn))$。我们的二分搜索在每一步将间隔 $\text{[lo, hi]}$ 分为两部分。在每个步骤中，我们都调用了 `enough`，这需要$O(m)$ 时间。 
* 空间复杂度：$O(1)$ ,我们只在中间计算期间将整数保存在内存中。