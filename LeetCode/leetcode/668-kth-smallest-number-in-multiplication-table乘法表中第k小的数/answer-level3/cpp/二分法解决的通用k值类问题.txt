### 解题思路
二分法，对于第k值的问题，一般情况下都可以用二分来解
关键点在于找到二分的目标，思路见代码注释。

[719. 找出第 k 小的距离对](https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/)
[786. 第 K 个最小的素数分数](https://leetcode-cn.com/problems/k-th-smallest-prime-fraction/)

上面两题其实是同样的思路
  > 素数分数稍微多一点处理，就是找到的最合适的分数值d可能不是我们表里面能够构成的分数值，那就需要在原列表里面找到最接近的数据对
  > 可以遍历数据A[i]，通过A[i]/d去查找该数据在原列表中的插入位置，该位置即为分子为i时的最接近数据，找到所有i的最接近d的数据即是答案

28ms 8.3M
--- wangtao HW-2020/2/27
### 代码

```cpp
class Solution {
public:
    /*
    思路：二分法
    1、找第k小，第k大一类的问题，一般情况下都是用二分来解决，那么二分法就需要找到二分的数据点以及比较方式
    2、当前乘法表中最小值肯定是1，最大值为m*n，也就是我们这张表的最小和最大值，数据点找到
    3、比较方式，要找到第k小，那么我们在拿到mid数据点的时候，去看当前mid的位置，如果mid位置大于k，说明mid值太大，需要再次进行二分求解
    4、问题来了，这个位置怎么找呢，假设mid位于指定行i，那么mid/i也就是mid元素的列的位置，如果列的位置大于列最大长度n，那么说明该行所有数据都小于mid，累加n即可
       如果不是呢，说明找到了正确的行，只需要mid/i列的位置也就是这一行小于mid的元素个数
    5、边界条件的处理是二分法中比较重要的，我们要找第k小，那么可以理解为假设当mid处于某个值时，满足了条件，我们需要锁定大值，也就是count>=k，去调整l的值不断逼近
       当l的值逼近到某个数据，使得条件再次满足时，就是循环条件结束的时候，这样可以保证l的值一定是在原列表中的，因为+1或-1都会导致条件不满足
       当然我们的>=条件也是不允许的，因为满足之后l值就被锁定了
    */

    int findKthNumber(int m, int n, int k) {
        int l = 1;
        int h = m * n;

        while(l < h) {
            int mid = l + (h - l) / 2;
            // 查找比mid小的元素个数
            int count = 0;
            for (int i = 1; i <= m; i++) {
                count += (mid / i > n ? n : mid / i);
            }
            if (count >= k) {
                h = mid;
            } else {
                l = mid + 1;
            }
        }
        return l;
    }
};
```