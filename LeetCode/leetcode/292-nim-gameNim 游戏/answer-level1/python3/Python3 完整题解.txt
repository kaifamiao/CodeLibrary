自己总结的，希望能帮到大家，大佬不要喷我谢谢,博文地址在这里：[https://blog.csdn.net/weixin_43071838/article/details/104533872](https://blog.csdn.net/weixin_43071838/article/details/104533872)![image.png](https://pic.leetcode-cn.com/ba1487532b919ce9d2149c750dcabc13816bbb19cc00db7a7c213dd1cedff6b4-image.png)
**【292】Nim游戏**
题目要求：你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。
题目解析：说句实话，看到这个题我在那一顿写呀。跟大部分评论的人一样，又是贪心算法又是动态排序。写了一大顿还没调过，后来看了官方答案，dog太阳的。侮辱智商呀，这里就直接讲官方的解法。首先题目的要求是什么情况下我们能赢，我们这个时候就要反着想，什么情况我们会输？这个不难想，就是在你的回合有4块石头你肯定输。为啥？因为你每次能拿1-3块，4块你拿几块你都输。所以总的石头数量绝对不能是4的倍数。这里我要借鉴一个大佬的评论十分精辟

> 面对4的整数倍的人永远无法翻身，你拿N根对手就会拿4-N根，保证每回合共减4根，你永远对面4倍数，直到4. 相反，如果最开始不是4倍数，你可以拿掉刚好剩下4倍数根，让他永远对面4倍数

然后我们就来将这个代码，首先官方的代码极其简单，不赘述：

```python
    def canWinNim(self, n: int) -> bool:
        return (n % 4) != 0
```
【下面这个代码是错的！！！】
【下面这个代码是错的！！！】
【下面这个代码是错的！！！】
还有一种形式，我看到采用位运算去进行运算，代码如下：

```python
    def canWinNim2(self, n: int) -> bool:
        return (n & 3) != 0
```
本文第【342】题有一个结论大家去看一下，那地方讲的很详细。一个数的的n次方减一 一定能整除这个数减一，但是8不是4的幂次方这个要明白，他是整除不了3的。但是这道题像我上面这么写居然可以通过。一定要理解，因为里面有些人写的评论不一定是对的，因为测试用例不全面所以测不出来，我已经补提了这个测试用例。

