lz和zyq是两个算法爱好者，有一天他们一起做Nim Game

lz:读了这道题， 我感觉有裴波那契数列内味了,后面的答案需要前面的结果嘛，
> 比如场上有5个石头,开局前我偷偷藏了一颗。这样下来，相当于场上只有4个石头，当你得意洋洋的取完最后一个石头的时候，这时~两级反转，实则是我赢了。

lz接着说：所以我只需要看你在我前面的三位是否成功，只要你能成功那么这次我必能赢。具体的我去调试一下。
```
v1[i]=(v2[i-3]||v2[i-2]||v2[i-1]);
v2[i]=!v1[i]
```
五分钟后.....
lz:上当了!上当了!上当了!出题人不当人啊！这么大的数肯定超时啊

zyq: 你这个动态规划可真有够好笑的呢！起开!我来！你去把10以内的结果列出来看看
| |1|2|3|4|5|6|7|8|9||
|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|:--|
|lz|√|√|√|×|√|√|√|×|√|···|
|zyq|×|×|×|√|×|×|×|√|×|···|
zyq:你发现没有，遇到4的倍数你都赢不了。
> 这也很理解，4就不用说了，我肯定赢。按照你刚才的理论，4+1,4+2,4+3，你都会赢。到了8因为我8-1,8-2,8-3都输了所以你在8处也会输。如此反复,只消满足``` nums%4!=0```你就肯定能赢。

zyq：你刚才走的时候我已经试过了，已经AC了，菜鸡
8ms 15.17%
```
class Solution {
public:
    bool canWinNim(int n) {
        return n%4;
    }
};
```
lz: 虽然AC了，性能不好，我来改改吧，这不就是求一个数是否是4的倍数吗,我们可以利用除法的截取下限来做
4ms 71,16%
```c++
class Solution {
public:
    bool canWinNim(int n) {
        int k=n>>2;
        return k<<2!=n;
    }
};
```
zyq:你这么一操作我懂了，我们可以只看它二进制的后两位，只要是有1，就不是4的倍数
0ms 100%
```c++
class Solution {
public:
    bool canWinNim(int n) {
        bitset<32> b(n);
        return (b[0]==1||b[1]==1);
    }
};
```
