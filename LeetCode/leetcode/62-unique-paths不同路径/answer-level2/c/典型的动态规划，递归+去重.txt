### 解题思路
典型的动态规划问题。
考察到任意点的路径，有：
要么向右到达
要么向下到达
路径总和=向右到达路径总数 + 向下到达的路径树
对任意位置有f(i,j)=f(i-1,j) + f(i,j-1)

并且有初始值
f(m,1)=1，只有一列的情况
f(1,n)=1，只有一行的情况

再考虑递归中重复计算的情况，因为已知m,n的最大值100，因此可以使用a[100][100]来记录每个到达每个位置的不同路径数量。这样计算过的值直接使用即可，不必重复计算，时间复杂度从O(2^n) 降低到O(n).

### 代码

```c
int a[100][100]={0};
int uniquePaths(int m, int n){

    if(m==1){
        return 1;
    }
    if(n==1){
        return 1;
    }
    if(a[m-1][n-1] == 0){
        a[m-1][n-1]=uniquePaths(m-1,n) + uniquePaths(m,n-1);
    }
    
    return a[m-1][n-1];

}
```