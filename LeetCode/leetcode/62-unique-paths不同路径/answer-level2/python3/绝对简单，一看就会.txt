# Solution 1: 用遞歸
思路:先假定一個比較小的m和n值,比如m=3,n=2
自行畫出一個3X2的表格,定義(0,0)是起始表格,現在自己手工算一下(1,1)這個方格的路徑是多少?
再算一下(1,2)這個表格呢?再算一下(2,1)這個表格呢?有沒有發現規律?
規律:按照題目的定義,實際上表格的第一橫行和第一豎列全部都是1,這個實際上就是我們遞歸的終止條件;
  接下來,(1,1)這個方格的路徑數是(1,0)方格和(0,1)方格的路徑和,這個實際上就是我們遞歸的遞推公式
有終止條件和遞推公式了,那遞歸的代碼就出來了

```
def uniquePaths(m, n):
    def helper(i, j):
        if i==0 or j==0:
            return 1

        return helper(i-1,j) + helper(i, j-1)

    return helper(m-1, n-1)


```
# Solution1-1: 遞歸優化
如果大家都學過遞歸,就知道遞歸有重複計算的問題,我們上面寫的遞歸在遇到m和n比較大的時候,同樣會超過限制時間
那我們可以加一個備忘錄,把已經計算出來的結果保存起來,下次需要計算同樣的遞歸時,直接從備忘錄中取出使用

```
def uniquePaths(m, n):
    def helper(i, j):
        if i==0 or j==0:
            return 1

        if cache[j][i]: return cache[j][i]
        cache[j][i] = helper(i-1,j) + helper(i,j-1)
        return cache[j][i]

    cache = [[None for _ in range(m)] for _ in range(n)]
    return helper(m-1, n-1)
```



# Solution2: 動態規劃
首先需要確認該問題是否符合動態規劃解題要求
動態規劃適合解決的問題模型符合"一個模型三個特性"
一個模型可以概括為:多階段決策最優解模型; 本題目第一行是已經定好了都是1,在第二行的時候,每個方格的值都是該方格左邊的格和該方格上邊的格的總和,以此類推,滿足.
特性1:最優子結構;每個階段的狀態或值都是通過前面階段的狀態或值推導出來的,滿足.
特性2:無後效性;每個階段的狀態值一旦確定之後,是不受後面階段狀態值所影響的,滿足.
特性3:重複子問題;從遞歸解法中就能看出來有重複子問題的計算,滿足.
接下來,該分析如何套用動態規劃解題步驟
首先,定義二維數組保存路徑條數,按照遞歸中分析得出第一行和第一列都是1,所以二維數組直接定義成如此
然後分階段階段,每一橫行的處理就是一個階段,通過上一行就能推導出下一行的狀態值
  在每一個階段中,同一行中的方格,是其左邊方格的值加上一行方格的總和
最後返回二維數組最後一個元素的值即可.
```
def uniqePaths(m, n):
    cache = [ [1 for _ in range(m)] if j==0 else [1 if i==0 else None for i in range(m)] for j in range(n)]

    for x in range(1, n):  # 每一行就是一個階段,因為第一行已經知道結果了,所以從第二行開始
        for y in range(1, m):  # 每一個階段內部,因为第一列已经知道了,从第二列开始
            cache[x][y] = cache[x-1][y] + cache[x][y-1]

    return cache[n-1][m-1]
```
