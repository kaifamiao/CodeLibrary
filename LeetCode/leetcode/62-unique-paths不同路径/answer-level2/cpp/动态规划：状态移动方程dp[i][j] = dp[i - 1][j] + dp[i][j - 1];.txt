### 解题思路
推理：
一行两列矩形dp[1][2]，只有一种走法，直接右走--dp[1*2]=1;
两行两列矩形dp[2][2]，从左上到右下，它可以一行两列矩形的右下角（此时走到这的方法数为dp[1][2]）再往下走一步，也可以从两行一列矩形的右下角（此时走到这的方法数为dp[2][1]]）往右走一步。因此总方法数为：dp[1][2]+dp[2][1];
两行三列矩形dp[2][3]的方法和：两行两列矩形dp[2][2]的方法+一行三类矩形dp[1][3]的方法，即dp[2][2]+dp[1][3]
不好理解，就画个图最好
以此类推，dp[m][n]=dp[m-1]dp[n]+dp[m][n-1];
先一个个算出前面的矩形方法，用vector二维数组进行存储，最后就可以求得dp[m][n]。
### 代码

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        //定义二维数组存储m*n矩形的方法和。
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int i = 1; i < n + 1; i++)
        {
            dp[1][i] = 1;
        }
        for (int i = 1; i < m + 1; i++)
        {
            dp[i][1] = 1;
        }
        for (int i = 2; i < m + 1; i++)
        {
            for (int j = 2; j < n + 1; j++)
            {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m][n];
    }
};
```
执行结果：
    通过 显示详情
执行用时 :
    0 ms, 在所有 C++ 提交中击败了100.00%的用户
内存消耗 :
    7.9 MB, 在所有 C++ 提交中击败了99.11%的用户
