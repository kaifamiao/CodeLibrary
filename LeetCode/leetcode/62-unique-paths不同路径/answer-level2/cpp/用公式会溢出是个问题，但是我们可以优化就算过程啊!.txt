这个问题用公式解决很简单明了，即C(m+n-2,m-1),但是用一些无法处理大数的语言实现就会遇见溢出的问题。
这个时候我们要微笑着面对他，加油奥里给
emmmm跑题了。
————————————————————————————————————————分割线————————————————————————————————————————————
我们可以通过两步优化来解决溢出问题。
第一步：由公式 C(m,n) = C(m,m-n)
我们可以挑出小的一方放在公式中，即
求C(m,min(n,m - n)) 这样可以一定程度的减少计算数值的大小
第二步：我们还可以在乘的途中就除那么可以极大的减少数值大小。理论上只要此时最总答案不超过MAX_INT32
我们用INT_64存就不会溢出。

给一个已经AC的代码，如下：

```
class Solution {
public:
    int uniquePaths(int m, int n) {
        long long ans = 1;
        int j = 1;
        if(m > n) swap(m,n);
        for(int i = n; i <= m + n - 2;i++)
        {
            ans = ans * i / j;
            j++;
        }
        return ans;
    }
};
```



ps：如果真的要卡死你，我们照样可以GCD慢慢约，但是就会很慢不推荐了。
