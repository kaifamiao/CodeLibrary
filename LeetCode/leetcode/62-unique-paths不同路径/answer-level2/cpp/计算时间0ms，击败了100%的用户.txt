这道题可以看作是一个简单的排列组合问题
以题目中的m=3，n=2为例：
不管你的路径如何，最后的结果一定是：向右走了两步，向下走了一步
走几步不好表示，那我们就换种方法
**假设：向右走是1，向下走是2
可行的方案就变成了：112 121 211
到这里是不是就有点儿眼熟了？这不就是一串数字的排列组合问题吗！**
m是多少，就有m-1个数字1；n是多少，就有n-1个数字2
所以，我们就用这样的方式，把一个虚假的路径问题转化成了一串只有1和2的数字排列组合问题

面对这个问题，我们可能有不同的思路：
我首先想到的是用next_permutation求这串数字的所有排列情况
可惜的是，这种方法是超出时间限制的
那我们换个思路，想想高中时期做过的数学概率题：
**有5个不同的抽屉，要求3个抽屉里有钥匙（钥匙都相同），总共有多少种情况？
答案是：C35（3在上，5在下，这里不知道怎么打出这种公式来。。）**
这时候思路就很清晰了，原来我们要做的其实就是在（m-1）+（n-1）个位置中给（m-1）个1分配座位！
还是以5个位置3个1为例：我们要得到的结果就是（5*4*3）/（3*2*1）呀

思路明确了，但是这里还有两个小坑需要大家注意：
1.我们先求分子的阶乘再求分母的阶乘然后相除，看似简单，但是分子可能会超过int类型的最大值
2.我们分别求每项的分子除分母再累乘，比如：5/1 * 4/2 * 3/3，可能会出现小数

代码如下：
```
class Solution {
public:
    int uniquePaths(int m, int n)
    {
        double ans = 1;     //当前结果
        int trouble = 1;    //暂时除不尽的数先存起来
        int min = (m-1)<(n-1)?(m-1):(n-1);  //取较小值作为分子分母包含的项数
        for(int i = 0 ; i < min ; i ++)
        {
            if((m+n-2-i)%(i+1) == 0)    //分子项可以整除分母项
                ans *= ((m+n-2-i)/(i+1));
            else
            {
                if(ans / (i+1) >  int(ans / (i+1))) //如果已有的结果可以整除除不尽的分母
                    ans /= (i+1);
                else
                    trouble *= (i+1);   //如果如果已有的结果不能整除除不尽的分母，就把它存起来
                ans *= (m+n-2-i);
            }
        }
        return ans/trouble; //最后把除不尽的分母项一块处理
    }
};
```
![屏幕快照 2019-10-22 下午3.44.11.png](https://pic.leetcode-cn.com/afcdb32ebd059e7b8012a08b39490325cda5a6ba150707d80134dddbdff44744-%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-10-22%20%E4%B8%8B%E5%8D%883.44.11.png)
