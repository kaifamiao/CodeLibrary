通过对题目的简单分析，不难发现该题目可以使用动态规划的求解思路。

当机器人向右或下前进一步，可以将问题化为可能已经得到解决的子问题。将前若干项简单列表如下（为了方便下面的推到，这里从0开始标记行列，即0，0对应一行一列）
   | 0 | 1 | 2 | 3 | 4 |
-|-|-|-|-
0 | 1 | 1 | 1 | 1 |...|
1 | 1 | 2 | 3 | 4 |...|
2 | 1 | 3 | 6 | 10 |...|
3 | 1 | 4 | 10 | 20 |...|
### 1.通项公式的求解
不难发现，该规律满足
$$f(x,y) = f(x-1) + f(y-1)$$
也即为一个二元线性差分方程，且其初始状态
$$f(x,0) = 1, f(0,y) = 1$$
该差分方程可解

由数学知识可知，形如
$$f(x,y) = au(x,y-1) + bu(x-1,y) + cu(x-1,y-1) + d(x,y)$$
$$f(x,0) = F(x), f(0,y) = E(y)$$
的二元线性差分方程的解为
$$f(x,y) = \sum^{x - 1}_{k=0}{R(y,k)F(x-k)} + \sum^{x - 1}_{k=0}\sum^{y - 1}_{j=0}R(j,k)M(x-k,y-j)$$
式中
$$R(n,k) = \sum^{ir\in N+}_{\sum^{}_{}{ir} = k,r=1,2..,n}{\prod_{r=0}^n{H*b^{ir-1}}}$$

$$R(0,k) = \left\{
\begin{aligned}
0 , k > 0 \\
1 , k = 0 \\ 
\end{aligned}
\right. , H = ab+c, 
H*b^{ir-1} = \left\{
\begin{aligned}
a , m = 0 \\
Hb^{ir-1} , m > 0 \\ 
\end{aligned}
\right.$$
式中
$$M(x,y) = b^{x-1}[cE(y-1)+bE(y)] + \sum^{x-1}_{i=0}{b^id(x-i,y)}$$

代入 $a = 1, b = 1, c = 0, d(x,y) = 0, f(x,0) = 1, f(0,y) = 1$
则可得式中$F(x-k) = 1,M(x-k,y-k) = 1$可化简为
$$f(x,y) = \sum^{x - 1}_{k=0}{R(y,k)} + \sum^{x - 1}_{k=0}\sum^{y - 1}_{j=0}R(j,k)$$
右可知$x_1 + x_2 + ... + X_n = k$的自然数解有$C^{n-1}_{k-1}$个
则上式最终可继续化简为
$$f(x,y) = \sum^{max(x,y)}_{k=0}{C^{k}_{x}C^{k}_{y}}$$
我们最终可以得到f(x,y)的通项公式。

### 2.程序实现
到此处仍然存在一个问题，即组合数的求解。
考虑到 
$$C^{n}_{m} = C^{n-1}_{m}\frac{m-n-1}{n}$$
也即可以通过第推得到组合数的表达式。
```c++
class Solution {
public:
    int uniquePaths(int m, int n) 
    {
        m--; n--;    //我们最开始假设从0开始编号，此处修正
        int acc_n = min<int>(m, n);
        long long x = 1, y = 1; 
        int s = 0;
        for(int i = 0; i <= acc_n; i++)
        {
            s += x*y;
            x = x * (n - i) / (i + 1); //不难证明，该式的结果一定为整数
            y = y * (m - i) / (i + 1);
        }
        return s;
    }
};
```
时间复杂度O(min(n,m))
空间复杂度O(1)




