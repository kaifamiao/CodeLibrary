### 解题思路一 动态规划
    /*
     * 方法1 动态规划法
     *
     * 不同路径问题是动态规划系列中的常规题目，
     * 思路是当前状态的值由前面状态的值决定，
     *
     * 机器人只能向右和向下走，那么当前点的路径数，
     * 就由当前点的上面点和左边点的路径数决定，
     * 即 dp[i][j] = d[i-1][j] + d[i][j-1]
     *
     * 动态规划需要初始值，而矩阵边上的行和列的点的路径均为1,
     * 所以将dp[i][0]和dp[0][j]均初始化为1，为后面计算做好准备。
     * */
### 代码
```cpp
int uniquePaths(int m, int n) {
    // 存储矩阵每个点的路径数
    std::vector<std::vector<int>> dp(m, std::vector<int>(n, 0));

    // 初始化第一行和第一列的值为1
    // 因为矩阵边上的点的路径都只有一种
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }

    for (int j = 0; j < n; j++) {
        dp[0][j] = 1;
    }

    // 当前点的路径由前面点的路径决定
    // dp[i][j] = dp[i-1][j] + dp[i][j-1]
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }

    return dp[m - 1][n - 1];
}
```

### 优化
    /*
     * 动态规划空间压缩优化
     *
     * 根据动态规划方法，当前点的路径数由上面的点和左边的点的路径数决定，
     * 而当前点的路径数在更新前，其在数组中的表示值dp[j]仍然是上面的点的路径数，
     * 所以只需要加上左边的点的路径数dp[j-1]，就能更新当前点的路径数，
     * 即 dp[j] = dp[j] + dp[j-1]
     *
     * 这样做就能将结果矩阵压缩为一维数组。
     * */
### 代码
```cpp
int uniquePaths2(int m, int n) {
    // 压缩存储每个点的路径数的数组
    std::vector<int> dp(n, 0);

    // 初始化第一列的值为1
    for (int j = 0; j < n; j++) {
        dp[j] = 1;
    }

    // 因为每个点的路径数都是它上面点的路径数加上左边点的路径数，
    // 而当前点的路径数未更新前，dp[j]表示的就是上面点的路径数，
    // 所以只需要加上左边的点的路径数，即更新当前点的路径数
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j - 1];
        }
    }

    return dp[n - 1];
}
```

### 解题思路二 组合数学
    /*
     * 方法2 组合数学方法
     *
     * 机器人只能向右和下走，从(1, 1)走到(m, n)，
     * 无论是向下还是向右走，它走的步数总和肯定为(m-1 + n-1),
     * 这样路径数就取决于向下走了多少步，什么时候走的，
     * 可以发现这是一道组合数学的题目，
     * 公式是: C(m+n-2, m-1) = (m+n-2)*(m+n-3)*...*(m+n-2-m+1+1) / (m-1)*(m-2)*...*2*1
     *         = (n/1)*((n+1)/2)*...*((m+n-3)/(m-2))*((m+n-2)/(m-1))
     *
     * 由于数值可能过大导致溢出，需要做一些计算处理，
     * 比如先比较m和n的大小，使用较小的值进行计算，
     * 比如在计算阶乘时，同时计算上阶乘除以下阶乘。
     *
     * 组合数学的公式方法能够将时间复杂度降为O(n)，空间复杂度降为O(1)
     * */
### 代码
```cpp
int uniquePaths3(int m, int n) {
    long long ans = 1;
    int j = 1;

    // 比较行数和列数，较小的数计算组合计算量较小
    if (m > n) {
        std::swap(m, n);
    }

    // 使用公式计算组合值，
    // 每次都除能够减小计算量
    for (int i = n; i <= m + n - 2; i++) {
        ans = ans * i / j;
        j++;
    }

    return ans;
}
```