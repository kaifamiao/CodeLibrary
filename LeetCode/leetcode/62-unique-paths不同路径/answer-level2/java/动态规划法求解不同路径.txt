# 动态规划法求解不同路径
## 递归法尝试
### 思路解析
无论是动态规划还是递归思路关键都在于寻找不同递推关系，由题目限制每次只能向下或者向右移动，很自然想到是通过向下和向右两种操作进行分解，得出递推关系。
即**f(m,n) = f(m - 1,n) + f(n,m-1)**
当然，当m或者n为1的时候函数值为1
#### 代码
```java
public int uniquePaths(int m, int n) {
        if(m == 1 || n == 1)
            return 1;
        return uniquePaths(m - 1,n) + uniquePaths(m,n - 1);
}
```
然而运行超时，显然优化时间就要考虑动态规划的解法啦
## 动态规划法
### 思路解析
递归法超时的原因在于重复计算太多，因此我们要考虑通过保留前期的计算结果来计算后面的解。而我们又可以发现，在常见的两层循环的结构下，无论是在计算f(m,n)时要用到的f(m - 1,n)还是f(n,m-1)都已经在之前的计算过程中计算出来了，因此我们决定使用一个二维数组来存储每一次的计算结果。至此，动态规划的思路便有了，代码如下。
### 代码
```java
public int uniquePaths(int m, int n) {
        int[][] num = new int[m + 1][n + 1];
        for(int i = 1;i <= m;i++){
            for(int j = 1;j <= n;j++){
                if(i == 1|| j == 1)
                    num[i][j] = 1;
                else
                    num[i][j] = num[i - 1][j] + num[i][j - 1];
            }
        }
        return num[m][n];
}
```
