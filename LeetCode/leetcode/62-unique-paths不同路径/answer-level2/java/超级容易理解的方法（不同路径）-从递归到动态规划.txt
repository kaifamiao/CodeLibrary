## 解题思路
### 递归
思路：先假定一个比较小的m和n值,比如m=3,n=2
自行画出一个3X2的表格,定义(0,0)是起始表格,现在自己手工算一下(1,1)这个方格的路径是多少?
再算一下(1,2)这个表格呢?再算一下(2,1)这个表格呢?有没有发现规律?
规律:按照题目的定义,实际上表格的第一横行和第一竖列全部都是1,这个实际上就是我们递归的终止条件;
接下来,(1,1)这个方格的路径数是(1,0)方格和(0,1)方格的路径和,这个实际上就是我们递归的递推公式
有终止条件和递推公式了,递归的代码如下：
### 代码
```java
class Solution {
    public int uniquePaths(int m, int n) {
        return cycle(m-1,n-1);
    }
    public int cycle(int i,int j){
        if(i == 0 || j == 0) return 1;
        return cycle(i-1,j)+cycle(i,j-1);
    } 
}
```

### 带数组递归
思路：如果大家都学过递归,就知道递归有重复计算的问题,我们上面写的递归在遇到m和n比较大的时候,
同样会超过限制时间。那我们可以加一个备忘录,把已经计算出来的结果保存起来,
下次需要计算同样的递归时,直接从备忘录中取出使用
### 代码
```java
class Solution {
    int[][] dp = new int[100][100];
    public int uniquePaths(int m, int n) {
        return cycle(m-1,n-1);
    }
    public int cycle(int i,int j){
        if(i == 0 || j == 0) return 1;
        if(dp[i][j] != 0) return dp[i][j];
        dp[i][j] = cycle(i-1,j)+cycle(i,j-1);
        return dp[i][j];
    }
}
```

### 动态规划
首先需要确认该问题是否符合动态规划解题要求
动态规划适合解决的问题模型符合"一个模型三个特性"
一个模型可以概括为:多阶段决策最优解模型; 本题目第一行是已经定好了都是1,
在第二行的时候,每个方格的值都是该方格左边的格和该方格上边的格的总和,以此类推,满足.
特性1:最优子结构;每个阶段的状态或值都是通过前面阶段的状态或值推导出来的,满足.
特性2:无后效性;每个阶段的状态值一旦确定之后,是不受后面阶段状态值所影响的,满足.
特性3:重复子问题;从递归解法中就能看出来有重复子问题的计算,满足.
接下来,该分析如何套用动态规划解题步骤
首先,定义二维数组保存路径条数,按照递归中分析得出第一行和第一列都是1,所以二维数组直接定义成如此
然后分阶段阶段,每一横行的处理就是一个阶段,通过上一行就能推导出下一行的状态值
在每一个阶段中,同一行中的方格,是其左边方格的值加上一行方格的总和
最后返回二维数组最后一个元素的值即可.
### 代码
```java
class Solution {
    public int uniquePaths(int m, int n) {
        int [][] dp = new int[m+1][n+1];
        //列
        for(int i = 1;i<m+1;i++){
            //行
            for(int j = 1;j<n+1;j++){
                if(i == 1 && j == 1){
                    dp[1][1] = 1;
                }else{
                    //状态转移方程
                    dp[i][j] = dp[i-1][j] + dp[i][j-1];
                }
            }
        }
        return dp[m][n];
    }
}
```

