### 解题思路
这道题是动态规划中比较常见的计数问题
解题思路如下：
第一步：确定状态
    最后一步：最后一步一定是右下角最后一个了，即f[m-1][n-1]
    子问题：我们只能通过f[m-1][n-1]上面或者左边的格子走到终点，所以其实子问题就是从f[0][0]到f               [m-2][n-1]的路线数量 + 从f[0][0]到f[m-1][n-2]的路线数量
第二步：列出转换方程
    根据得出的子问题很容易就写出转换方程了，其实从f[0][0]到f[i][j]的路线数量就是到f[i-1][j]和到f [i][j-1]的路线数量之和，所以转换方程：f[i][j]=f[i-1][j]+f[i][j-1]
第三步：初始条件和边界情况
    初始条件就是：f[0][0]=1
    边界情况就是：在第一列和第一行的时候，因为此时不能用转换方程，所以需要特殊处理一下，即当i=0或者         j=0时，f[i][j]=1
第四步：确定计算顺序
    外层从上向下，内层从左到右，为什么这样呢？因为正常思维都这样，反转下思维也是可以的，因为只要保证，当前格子的上边和左边各自是遍历过的就可以了
最后返回f[m-1][n-1]就可以了

### 代码

```java
class Solution {
    public static int uniquePaths(int m, int n) {
        int[][] f=new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(i==0||j==0){
                    f[i][j]=1;
                }
                else{
                    f[i][j]=f[i-1][j]+f[i][j-1];
                }
            }
        }
        return f[m-1][n-1];
    }
}
```