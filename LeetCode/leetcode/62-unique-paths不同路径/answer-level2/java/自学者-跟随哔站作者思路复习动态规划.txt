### 解题思路
* 确定初始状体和边界情况
* 根据常识明确第一行和第一列只有一条路径到达。
* 最后目的地的路径数就是上边和左边格子最多路径相加的结果，这应该是数学组合的基础知识

### 代码

```java
class Solution {
    public int uniquePaths(int m, int n) {
        //到达指定节点的路径条数
        int[][] dp = new int[m][n];
        // Step1. 定义初始条件
        // dp[0][0] = 1,因为机器人只有一种方式到左上角就是待着不动
        //第一行的格子没有向上移动的可能，指定节点的路径条数全部为1
        for (int i = 0; i < n; i++) {
            dp[0][i] = 1;
        }
        //第一列的格子，无法通过其他格子移动过来，因为机器人不能向左移动，所以机器人只有一种方式就是往下移动
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp [i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```