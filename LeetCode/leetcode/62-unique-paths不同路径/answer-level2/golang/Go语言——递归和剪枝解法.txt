### 解题思路
本题提供一种递归的解题思路，设终点坐标为(m,n),则到(m,n)的走法的会有两种：一、从(m-1,n)到(m,n);二、从(m,n-1)到(m,n)。到(m-1,n)的走法有两种:一、从(m-2,n)到(m-1,n);二、从(m-1,n-1)到(m-1,n)。到(m,n-1)的走法有两种....。即到每一个坐标的走法都可以从正上方或左方到达，并且没一点的走法规则相同。可以用递归思路来解答。
下面先看一种不带剪枝操作的递归解法：
    算法思路：
        1. 定义递归结束条件
        2. 一此函数运算相当于求得到达此点的路径总和。
            2.1 先求(m-1,n)到(m,n)的路径和
            2.2 再求(m,n-1)到(m,n)的路径和
```
    func uniquePaths(m int, n int) int {
        //1.定义递归结束条件
        if m<=0 || n<=0{
            return 0
        }else if m==1 || n==1{
            return 1
        }
        //2 开始求到达点(m,n)的路径总和
        paths:=0
        //2.1 先求(m-1,n)到(m,n)的路径和
        paths+=uniquePaths(m-1,n)
        //2.2 先求(m,n-1)到(m,n)的路径和
        paths+=uniquePaths(m,n-1)
        return paths
    }
```
上面这种递归解法是对每一个点都要查找从此点到起点的所有路径，不管以前有没有查找过。比如对点(3,4)，一次计算(2,4)-(1,4)-(2,3)-(1,3)-(2,2)-(1,2)->(2,1);再计算(3,3)-(2,3)-(1,3)-(2,2)-(1,2)-(2,1);显然对于后者,(2,3),(2,3)等点前面已经计算过，这里无需重复计算。这里就需要一种空间换时间的剪枝操作，使用一个数组记录每个走完的点的路径总和，若已走完没直接返回即可。

### 代码

```golang
//3 剪枝用的数组
var arr [101][101]int

func uniquePaths(m int, n int) int {
    if m<=0 || n<=0{
        return 0
    }else if m==1 || n==1{
        return 1
    }
    //3.1 接上面代码，如果已经走过，直接返回路径总和
    if arr[m][n]>0{
        return arr[m][n]
    }
    paths:=0
    paths+=uniquePaths(m-1,n)
    paths+=uniquePaths(m,n-1)
    //3.2 对于刚走过的此点，记录下所有路径总和，后续无需重复搜索
    arr[m][n]=paths
    return arr[m][n]
}
```