### 题解:

- m x n 的格子,如果是个数组(切片),那么m就是x轴,n就是y轴, 申明的时候应该是  `[n][m]int`,可千万别搞错了
- 起点是左上角,也就是坐标 `0,0`的地方!终点是右下角坐标是 `m,n`的地方!
- 只能往右和往下移动,不能左转,也不能斜着对角走

### 思路:

- 写了几次动归,知道这题肯定是动归解决了!
- 从终点看,到`m,n`的路径要么从 `m-1,n`(假设为A点),要么从 `m,n-1`(假设为B点)这两个地方来(暂时不考虑就一层的情况)
  - 那么到终点可能的路径就是 起点到A点的路径 + 起点到B点的路径
  - 那么A点路径的个数是多少呢,是它左边的路径 + 它上面的路径
  - ... 
  - 一直拆分到 原点
- 思路出来了,代码该如何呢,已知原点的路径是 1,原点右边只可能是原点来,所以原点右边也是1,同理原理下面的格子也都是1,即边界条件,如果x轴为零或者y轴为零,那么这两条轴上的格子路径都是1
- 非x,y轴上的点,都是它上面和左边的路径之和!
- 代码就很简单了,定义一个二维切片保存每个格子的路径可能性条数
- 循环每个格子,返回最后一个格子的!

### 代码:

 ```go
func uniquePaths(m int, n int) int {

	if n == 0 || m == 0{
		return 1
	}

	dp := make([][]int,n)

	for i:=0;i<n;i++ {
		dps := make([]int,m)
		for j:=0;j<m;j++ {
			if i == 0 || j == 0 {
				dps[j] = 1
			} else {
				dps[j] = dp[i-1][j] + dp[i][j-1]
			}
			dp[i] = dps
		}

	}

	return dp[n-1][m-1]
}
 ```


### 已将做过的一些题和基础知识(面试题)整理，有Golang或者相关技术面试的，可自取测试，地址： [interview](http://interview.wzcu.com/)