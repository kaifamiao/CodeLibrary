
### 思路：
有下图 4*2 的网格

    X X X X 
    X X X X
问从 `[0]``[0] `走到 `[1]``[3]` 共有几种走法？走的方向只能向下或向右。

首先创建一个二维数组 `nums[n][m]`, 
然后我们可以从终点`[1][3]`开始看。`[1][0]`至`[1][2]`都只能向右, 所以`nums[n-1]`中的所有元素都是同一个值, 就是 1。

    X X X X
    1 1 1 O
    
然后我们来看`[0][m-1]`, 也就是位于终点上方的元素, 他们也无法向右走, 只能向下, 所以也都是 1。

    X X X 1
    1 1 1 O
    
接着看`[0][2]`这个元素, 该元素有向下与向右两种走法, 所以他的值为`[0+1][2]`与`[0][2+1]`的值相加得出来的。同理可得, `[n][m]`元素的值为`[n+1][m]`+`[n][m+1]`两处的值相加得来的。
从终点行的第 `m-2` 个元素开始, 从右往左, 从下往上一直遍历到`[0][0]`。 `[0][0]`的值为`[0][1]`+`[1][0]`得到。

最后 `return nums[0][0]`即可


### 代码：


``` [-Go]
func uniquePaths(m int, n int) int {
    if m == 0 || n == 0 {
        return 0
    } else if m == 1 || n == 1 {
        return 1
    }
    nums := make([][]int, n)
    for i := 0; i < n; i++ {
        t := make([]int, m)
        t[m-1] = 1
        nums[n-i-1] = t
        for j := m-2; j >= 0; j-- {
            dofunc(n-i-1, j, nums)
        }
    }
    return nums[0][0]
}

func dofunc(n, m int, nums [][]int) {
    i, j := 0, nums[n][m+1]
    if n < len(nums)-1 {
        i = nums[n+1][m]
    }
    nums[n][m] = i+j
}