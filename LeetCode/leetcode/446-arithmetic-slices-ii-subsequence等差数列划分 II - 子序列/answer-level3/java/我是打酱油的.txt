算了半天 发现题目意思理解错了
嗯 这个是计算当 A是等差的时候的最后结果
等差数列求和公式 (n*(a0+an))/2  a0首项 ,an第n项
思想 (找了半天的规律)
当A的公差是0的时候 最后结果就是 C(i/j) 表示从 j 里面选 i个的选法 就是排列组合的那个C
C(3/n) + C(4/n) + ... + C(n/n) = C(0/n) + C(1/n) + C(2/n) +...+ C((n-3)/n)
当A的公差不是0的时候
(n - 1)>>1 表示 可组成的最大能形成几倍公差 刚好3个的时候认为是 1 被公差
eg: 1,2,3,4,5,6,7 最大能形成(7-1)>>1 = 3 被公差的数列
A能组成1倍公差数列的数量很容易看出来就是 对(n-2)求和

先看一个例子: (能成3倍公差的数量)
1,2,3,4+1,5+2,6+3,7+4+1,8+5+2,....
上面个数列
分为3个数列 
1,4+1,...是首项1公差3的等差数列求和
2,5+2,...是首项2公差3的等差数列求和
最后的求和公式 (((n+2)/3) * (3 * (n+2)/3 - 1 + ((n+2)%3)*2 ))/2
注意(n+2)/3 只是取整
cal(int n, int j) 的公式就是和这个差不多 就是那个n直接指A.length 做了转换

public int numberOfArithmeticSlices(int[] A) {
        int n = A.length;
        if (n <= 2) {return 0;}
        if (A[0] - A[1] == 0) {
            return cal(n);//直接计算排列组合
        }
        int j = (n - 1)>>1;//最大能成几倍公差
        int all = 0;
        while (j >= 1) {
            all += cal(n, j);
            j--;
        }
        return all;
    }
    //相当于一个公式吧 但是用数学的方式的就第几倍公差就要写几个公式
    //第一倍公差有一个, 第二倍分奇,偶两个 第三倍分余0,1,2要3个
    public int cal(int n, int j) {
        int a = n-1-j;
        int b = a/j;
        int c = a%j;
        return (b*(b*j + 2 - j + (c<<1)))>>1;
    }
    public int cal(int n) {
        int c = n - 3, t = 1;
        int all = 1;
        int pre = 1;
        while (t <= c) {
            pre = pre*(n-t+1)/t;
            all += pre;
            t++;
        }
        return all;
    }