### 解题思路
此处撰写解题思路
### 原始思考：
从1对括号开始，没增加一对，就在先前基础上加上一对，而左括号"("加入的位置，则可以为[0, len(str)]个位置，右括号")"加入的位置则可以为[左括号位置 + 1, len(str) + 1]个位置，此时，每次新加入一对括号的时间复杂度近似为O(n^2)
### 总共3次个优化：
### 1. 在加入时，可以认为加入的左右括号必相邻，则每次加入可选的位置仅有[0, len(str)]个，因此每加入一对括号的时间复杂度近似为O(n)
  证明: 当加入到n+1对括号时，假设加入一对括号是随机分布，加入后有n+1对括号，此时必有一对括号是相邻的，**因此，此时的状态同样可以由除去该相邻状态下的括号的状态（n对括号）+ 该处相邻括号得到**
### 2. 在加入时，可以只加到前一半，即[0, len(str) // 2]，因此每加入一对括号的时间复杂度为O(n / 2)
  证明：参见第三次优化。
### 3. 在加入时，可以只加到第一个左右相邻的括号，即[0, 第一个左右相邻括号]，复杂度。。。不会算
  证明：括号序列中至少有一对括号是相邻的，当第n+1对括号向n对括号序列中添加后，n+1对括号中同样至少有一对括号相邻：
       （1）只有一对相邻：
        只有一种情况，n对括号序列为((...()...))，第n+1对括号加在中间，即第一个左右相邻的括号
       （2）多于一对相邻：
        当n+1对括号序列为(...()...()...)时，其中的一对相邻括号必为新加入括号，新加入括号为第1对相邻，第2对相邻，第3对相邻均是等价的，所以新加入的括号仅为第一对相邻括号即可，**即新加入的一对括号的搜索位置必在n对括号序列中第一个左右相邻括号的前面（如果在后面，则新加入的一对括号在n+1序列中不会是第1对相邻），且第一对左右相邻括号的右括号必是第一个右括号。**
        第2次优化中的条件，**是因为n序列中第一对相邻括号位置必小于等于len(str)//2**（反证法：若第一对相邻括号位置大于len(str)//2，则表明序列中尚未出现第一个右括号，**即左括号的数量大于len(str)//2，**，与题目矛盾）

### 总结：
整体思路类似于广度优先搜索+动态规划，主要优化在于去掉无需搜索的位置 


### 代码

```python3
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:

        results_set = {""}
        for l in range(n):
            results_new_set = set()
            while(results_set):
                r_str = results_set.pop()
                for i in range(len(r_str) + 1):
                    r_str_new = r_str[:i] + "()" + r_str[i:]
                    results_new_set.add(r_str_new)
                    if l > 0 and r_str[i] == ')':
                        break
            results_set = results_new_set
        
        return list(results_set)
```