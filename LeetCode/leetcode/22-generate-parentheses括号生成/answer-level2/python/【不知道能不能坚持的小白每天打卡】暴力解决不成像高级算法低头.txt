### 解题思路
更详细的看这个大佬的解答
https://leetcode-cn.com/problems/generate-parentheses/solution/ru-men-ji-bie-de-hui-su-fa-xue-hui-tao-lu-miao-don/

在此我就记录一下自己的学习过程。
刚拿到这题我有个大胆的想法，就是把所有可能枚举出来之后，再判断是否是正确的括号用法。有这个想法是因为我练习过一道题是关于判断括号是否正确的。然而第一回合，枚举失败。后来经提醒，知道可以用itertools的permutation，枚举成功但是超时。最后迫不得已向回溯低头。当然也是很兴奋可以学习新知识。

P.S. 看了一下题解，暴力解决可以不超时，前提是只枚举出不重复的所有可能，而不是直接枚举出所有包括重复的可能。

回溯的思路主要是如果这条路不通，那就回到上一个路口尝试另外一个分叉，如果又不通那就再往上走。而要实现回溯，我的理解是需要用递归而且是连续调用（一般可能是两次吧）。原因是，当第一次递归触碰到边界条件时，才能跳出当前递归的层级，进行下一行代码的运行，然后再进行下一个递归层级。这个跳出当前递归层级，就是实现了所谓的回溯了。当然，对于不同题目，回溯的实现方式肯定还是会有点区别的。我感觉大概套路就是搭起一个两行迭代的框架，然后很可能有4、5个入参。然后顺便再说一下，上面提到分叉，所以像链接的作者说的，其实回溯法就是一个剪枝的二叉树，这一点也许在以后思考回溯问题的时候，有很大帮助。

### 代码

```python3
class Solution:
    def generateParenthesis(self, n: int) -> List[str]:
        # 回溯主体
        def dfs(res, left, right, path):
            # 当左括号和右括号都能够正常用完，也就是保证了括号使用正确，就添加到代表正确的stack里
            if left == 0 and right == 0:
                res.append(path)
                return
            # 要确保括号正确，左括号必定在最左出现，添加左括号知道不能再添加
            if left > 0:
                dfs(res, left - 1, right, path + '(')
            # 然后就会进入这行代码，开始添加右括号到不能添加，然后如果满足最上面的边界
            if left < right:
                dfs(res, left, right - 1, path + ')')
            # 把迭代看成是一个while，并且是有直接出口的while，就会更容易理解一些
            # 实在不行就写print，或者手动一步一步把path的结果写下来，对应print结果，就能理清
        res = []
        dfs(res, n, n, '')
        return res
        
        
```