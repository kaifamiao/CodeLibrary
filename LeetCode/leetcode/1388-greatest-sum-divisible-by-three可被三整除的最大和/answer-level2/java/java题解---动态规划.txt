1.动态规划最重要的就是找到状态转移方程，基本上我们用矩阵 ： dp[动态规划阶段数][约束状态数]基本上可以描述此类01背包问题的状态转移问题。
2.动态规划阶段数：简单理解就是动态规划分几步。以此题示例1为例：nums=[3,6,5,1,8], 在决策取不取3的时候是动态规划的第一个阶段，在决策取不取6的时候是动态规划的第二个阶段，依次类推，有5个阶段
3.结束状态数：类比01倍背包问题，比如背包容量为10，我们的约束状态数就是10（或者11，加上初始状态）。此题的约束是被3整除，一个数被3整除，有三种状况：分别是对3取模等于0、对3取模等于1，对3取模等于2。
4.动态规划每个状态的决策目标：元素和最大。 
   当前状态：dp[动态规划阶段][约束状态]
   该题中每个状态下的决策只有两种：取不取，一般此时对应函数为，当前状态最大元素和 = max（前一阶段某约束下最大元素和加上该数（取），前一阶段同样约束下最大元素和（不取））
5.以示例1为例：
nums=[3,6,5,1,8]
第一步：建立状态矩阵dp = new int[6][3],这个6对应阶段数，用dp[0]标识初始阶段,dp[1][0]表示在第一阶段对3取模等于0的最大元素和，其余同理
第二部：确定目标为每各状态的元素和最大，每个状态下的决策有两种取该阶段的数或者不取该阶段的数
第三步：状态转移方程，以第5阶段动态规划为例：
    dp[5][0] = max(dp[4][0],dp[4]的某一个状态+8)，我们要在第五阶段使得被3整除的元素和最大，我们有两种决策对8加或者不加，然后取两者的最优解。因为8%3=2，我们要在+8后被3整除余数为0，即要使得（dp[4][x]+8）%3=0，则dp[4][x]%3肯定等于1,对应约束状态1，即：dp[5][0] = max(dp[4][0],dp[4][1]+8)
    同理：dp[5][1] = max(dp[4][1],dp[4][2]+8),dp[5][2] = max(dp[4][2],dp[4][0]+8);
6.对于初始状态dp[0]={0,-1,-1}的问题，为什么是0，-1，-1，不是-1，-1，0或者-1，0，-1。
   示例nums=[1,2],令状态转移方程dp=int[3][3]；
   第一阶段状态转移方程dp[1][0] = max(dp[0][0],dp[0][2]+1)，实际上对于决策dp[0][2]+1不可能成立，在第一阶段取1,dp[1][0]的元素和为1，dp[1][0]%3 = 1,不满足dp[1][0]%3=0的前提状态条件。所以如果dp[0][2]=-1,我们直接取dp[1][0]=dp[0][0]

7.最后空间优化：
    01背包问题状态矩阵dp[x][y]，，因为各阶段的决策都满足无后效性，空间上实际可以优化为一维数组dp[y]。
```
    public int maxSumDivThree(int[] nums) {
        int[][] dp = new int[nums.length+1][3];
        dp[0][1]=-1;
        dp[0][2]=-1;
        for(int i=1;i<dp.length;++i){
            for(int j=0;j<3;++j){
                if(dp[i-1][(3+j-nums[i-1]%3)%3]!=-1) 
                    dp[i][j] = Math.max(dp[i-1][j],dp[i-1][(3+j-nums[i-1]%3)%3] + nums[i-1]);
                else 
                    dp[i][j] = dp[i-1][j];
            }
        }
        return dp[nums.length][0];
    }
}
```
