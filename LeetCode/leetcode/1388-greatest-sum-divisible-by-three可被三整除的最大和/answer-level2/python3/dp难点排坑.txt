这题在我看来有三难

首先，dp的状态设计，这里考虑当前取得数字的和除3余0，1，2来建立dp表，然后逐个考虑nums中的数字

其次难在应该要新建变量来存储上一轮的dp值，因为这一轮新来一个数字之后，dp三个值的更新应该是同步的，如果不新建的话会发生轮内自更新的情况

最后难在初始状态的设定，在我这个思路下dp[0]可以直接设0，表示假设我列表里有一个数字0（这么假设并不会改变结果），那么0%3 = 0
dp[1]和[2]应该设为未知,我用一个非常小的值标记，表示在他未知的时候（一般是第一步跳转的时候），想要从他跳转是不可能的。

c0,1,2表示考虑三个状态假如包含当前遍历的数，那么他的上一步跳转dp值
c_dp0，1,2表示上一轮的dp情况
然后去考虑到底要不要在当步纳入当前数字
最后返回dp[0]就可以了

```
class Solution:
    def maxSumDivThree(self, nums: List[int]) -> int:
        dp = [0,-10005,-10005]
        for i in range(len(nums)):
            mod = nums[i]%3
            
            c0 = dp[(0-mod + 3)%3]
            c1 = dp[(1-mod + 3)%3]
            c2 = dp[(2-mod + 3)%3]
            
            c_dp0 = dp[0]
            c_dp1 = dp[1]
            c_dp2 = dp[2]
            
            dp[0] = max(c_dp0,c0+nums[i])
            dp[1] = max(c_dp1,c1+nums[i])
            dp[2] = max(c_dp2,c2+nums[i])
            
                
        return dp[0]
```
