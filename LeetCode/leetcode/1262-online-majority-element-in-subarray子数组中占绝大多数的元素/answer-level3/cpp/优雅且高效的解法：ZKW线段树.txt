**先说结论: 20余行c++有效代码解决这个问题，比一些暴力搜索还短，低复杂度低常数，还是非递归！**

执行用时 :164 ms, 在所有 cpp 提交中击败了99.66%的用户
内存消耗 :53.5 MB, 在所有 cpp 提交中击败了100.00%的用户

一开始是用传统的自顶向下递归线段树尝试解决，代码越写越长。然后无意中发现了这么个神器（没搞过OI，dalao们见笑了）瞬间为优雅的写法与极高的效率所折服。接下来尝试着讲解一下这种方法（顺便加深记忆），如果感觉看不懂，推荐扩展阅读[原作者的讲解ppt](https://wenku.baidu.com/view/f27db60ee87101f69e319544.html)。
<br />
### - **摩尔投票法**
本题的目标是寻找数组在某个区间内的**绝对众数**，即**出现频次 > 区间长度/2**的数值。摩尔投票法可以在`O(n)`复杂度内找出唯一可能成为绝对众数的数值（注: 这个值不一定是绝对众数。）,具体分析可以查看[求众数](https://leetcode-cn.com/problems/majority-element/)中的相关题解，此处略过。

### - **下标索引**
找到可能的绝对众数以后，需要验证其是否是真正的绝对众数。假设对每次查询都进行一次摩尔投票的遍历，总的时间复杂度会达到`O(NM)`，超出了题目要求。 ~~(P.S.: 实际上能过，而且目前有一个160ms的解就是这种写法...再次吐槽下缩水的数据规模和谜一般的计时...)~~ 
如何优化？遍历一遍数组之后我们可以得到每个值在数组中依次出现的位置集合；而对于每次查询，我们需要知道这个值在该区间`[left, right]`内出现的次数，就可以判断是否满足大于`threshold`的条件了。如果在初始化时为每个值建立了有序的下标索引，再在这个索引列表中用二分法查询区间内第一次和最后一次出现的位置，对每次查询就能在`O(1) + O(logK) + O(logK)`内求得前述的出现次数，其中K是该元素的总出现次数。这一步的总时间复杂度可以按`O(MlogN)`计。
那么，能不能将摩尔投票的操作结果也复用，使其复杂度降到`O(MlogN)`或更低？答案是肯定的，使用树状数组，或者线段树。嗯，来到正题了。

### - **ZKW线段树**
什么是线段树？想象一下二叉搜索树：将一个有序的离散数列平衡地放置在二叉树的节点上，使其中序遍历是升序的。它可以使查找某个元素的时间复杂度降到`O(logN)`。同理，线段树是将一个连续的区间平衡地放置在二叉树的节点上，使每个非根节点所表示的区间都是它左右子节点的并。朴素的线段树每个节点需要存储对应区间的左右界，以及对应的用于复用的计算结果（本题中，就是摩尔投票法求出的在这个区间内的疑似绝对众数，及其出现次数）。遍历时采用自顶向下遍历，找到和目标区间等价的所有节点为止。具体代码略，可以参考本题下其他朋友的题解。

那么什么是ZKW线段树？和普通线段树有什么区别？请再想象一下在有序数组中进行的普通的二分法，它和二叉搜索树的逻辑是类似的，但是不是只要指定左右端点就能开始搜索而不需要建立一棵树呢？原因就是，数组的下标天然地起到了树结构的作用，`(L+R)/2`这个位置就标识了左子树和右子树的分界点。这里引出了ZKW线段树的第一个特性: 从下向上开始建树，依赖数组下标进行树结构查找。以本题为例：
```cpp
    int segmentTree[65536] = {0}; //ZKW树规模为2^(log(N+2)上界 + 1)，即大于N的最小的2的幂再*2。本题N<20000, 为65536
    num = arr.size() + 2;	//zkw 线段树的查询需要按开区间，故需要在原数组两端各扩充一个元素, 具体待会讲
    while(treeSize < num)
        treeSize <<= 1;
    for(int i = 0; i < arr.size(); i++)
        segmentTree[treeSize + i + 1] = (1 << 16) + arr[i];	//所有输入的arr[i] <= 20000, 数组大小 <= 20000 用一个int的高低16位分别表示绝对众数的值和绝对出现次数
    for(int i = treeSize - 1; i >= 1; i--)
        segmentTree[i] = merge(segmentTree[2 * i], segmentTree[2 * i + 1]); //下标为 i 的节点的左右子节点为 2 * i 和 2 * i + 1
```
树建好了。它的根节点为`segmentTree[1]`，最下一层为所有的原始节点；取1开始是为了方便下标计算，0开始也是可以的。最下一层的左右端点需要是空节点，所以原始的数组`arr[i]`是从`treeSize + 1`开始排列的。填不满怎么办？用空节点塞满右侧。当然你需要用一种方法来确保空节点和其他节点合并计算父节点时不出问题，对于本题来说还是比较好解决的。merge()就是从子节点计算父节点的函数。

### - **查询**
那么如何快速按左右下标来查询区间呢？这就是ZKW线段树的第二个(优异)特性：自底向上查找区间，在每层最多检查两个区间，不需要递归。
介绍一下这个让我长跪不起的语句：
```cpp
    for(int s = left + treeSize, t = right + treeSize + 2; s^t^1; s >>= 1, t >>= 1){
        if(~s & 1)
            //合并segmentTree[s + 1]
        if(t & 1)
            //合并segmentTree[t - 1]
    }
```
完了。这不是查询某一层，也不是递归的函数体，这个for循环已经完成了对指定区间的合并。
我相信如果你之前对线段树不太了解，会是和我一样懵逼的。它干了什么？
首先，初始的s和t分别是给定区间左侧和右侧的端点，即`(s, t) == [left, right]`。为什么得是开区间？往下看。
结束条件`s^t^1` 熟悉按位异或可以知道这里表示s和t只有最后一位不同，即它们是同一个父节点的左右子节点。
右移一位表示上移s和t。
(~s & 1)表示s二进制末位0, 它是父节点的左子节点。这时我们需要合并它的右兄弟到目标集合。
同理(t & 1)表示它是右子节点。
于是当s和t相遇时，我们已经遍历了所有在s右侧的区间和t左侧的区间；它等价于我们要合并的[left, right]。是不是有种恍然大悟的感觉？不是的话说明我的描述太辣鸡了。
ZKW线段树的区间修改也很精妙，没什么时间先不写了，这题用不上。有兴趣的看看原文吧~

### - **区间合并**
如果了解摩尔投票，这里就比较容易理解。考虑到数据规模和值的范围都在(0,20000)之间，这里就用一个int来表示每个区间的疑似绝对众数了，初始化比较好看。高16位为其出现次数与区间一半的差值，低16位为数值。合并两个区间时，如果值相同，则累计出现次数；如果值不同则保留出现次数大的，出现次数减去另一个数的次数。易知与空节点合并时，值不会变动，不需要特殊处理。
```cpp
inline int merge(const int l, const int r){
        return (l >> 16 > r >> 16 ? l % 65536 : r % 65536) + ((l % 65536 == r % 65536 ? (l >> 16) + (r >> 16) : abs((l >> 16) - (r >> 16))) << 16);
    }
```

### - **得出结果**
得到了目标区间的值，再查找一次下标索引，就能得出这个区间有没有真正的绝对众数了。总的时间复杂度为`O(MlogN)`。附完整代码如下：
```cpp
class MajorityChecker {
public:
    MajorityChecker(vector<int>& arr) {
        num = arr.size() + 2;	//zkw线段树的查询需要按开区间，故需要在原数组两端各扩充一个元素
		while(treeSize < num)
			treeSize <<= 1;
		for(int i = 0; i < arr.size(); i++){
			segmentTree[treeSize + i + 1] = (1 << 16) + arr[i];	//所有输入的arr[i] <= 20000, 数组大小 <= 20000 用一个int的高低16位分别表示绝对众数的值和绝对出现次数
            numindex[arr[i]].push_back(i);
        }
		for(int i = treeSize - 1; i >= 1; i--)
            segmentTree[i] = merge(segmentTree[2 * i], segmentTree[2 * i + 1]);
    }    
    int query(int left, int right, int threshold) {
		int result = 0;
        for(int s = left + treeSize, t = right + treeSize + 2; s^t^1; s >>= 1, t >>= 1){
			if(~s & 1)
				result = merge(result, segmentTree[s + 1]);
			if(t & 1)
				result = merge(result, segmentTree[t - 1]);
		}
        if(result >> 16 > 0){
            auto it_left = lower_bound(numindex[result % 65536].begin(),numindex[result % 65536].end(), left);
            auto it_right = upper_bound(numindex[result % 65536].begin(),numindex[result % 65536].end(), right);
            if(it_right - it_left >= threshold)
                return result % 65536;
        }
		return -1;
    }	
private:
    inline int merge(const int l, const int r){
        return (l >> 16 > r >> 16 ? l % 65536 : r % 65536) + ((l % 65536 == r % 65536 ? (l >> 16) + (r >> 16) : abs((l >> 16) - (r >> 16))) << 16);
    }
	int treeSize = 1;
	int num = 0;
	int segmentTree[65536] = {0};
    unordered_map<int, vector<int>> numindex;
};
```
不算单独的右括号的话不到30行。




