## 解题分析
要做这道题，首先我们得十分了解二叉搜索树这个数据结构；

---
二叉查找树（英语：Binary Search Tree），也称为 二叉搜索树、有序二叉树（Ordered Binary Tree）或排序二叉树（Sorted Binary Tree），是指一棵空树或者具有下列性质的二叉树：

若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；
若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；
任意节点的左、右子树也分别为二叉查找树；
没有键值相等的节点。
二叉查找树相比于其他数据结构的优势在于查找、插入的时间复杂度较低。为 O(\log n)O(logn)。二叉查找树是基础性数据结构，用于构建更为抽象的数据结构，如集合、多重集、关联数组等。

二叉查找树的查找过程和次优二叉树类似，通常采取二叉链表作为二叉查找树的存储结构。中序遍历二叉查找树可得到一个关键字的有序序列，一个无序序列可以通过构造一棵二叉查找树变成一个有序序列，构造树的过程即为对无序序列进行查找的过程。每次插入的新的结点都是二叉查找树上新的叶子结点，在进行插入操作时，不必移动其它结点，只需改动某个结点的指针，由空变为非空即可。搜索、插入、删除的复杂度等于树高，期望 O(\log n)O(logn)，最坏 O(n)O(n)（数列有序，树退化成线性表）。



虽然二叉查找树的最坏效率是 O(n)O(n)，但它支持动态查询，且有很多改进版的二叉查找树可以使树高为 O(\log n)O(logn)，从而将最坏效率降至 O(\log n)O(logn)，如 AVL 树、红黑树等。

**横线中来源于leetcode**

----

二叉搜索树，自然是二叉树的一种，而它最主要的特点就是，要不是一棵空树，要不**这棵树上所有的节点的右边的所有节点以及子节点都比这个节点要大，并且这棵树上所有的节点的左边的所有节点以及子节点都比这个节点要小；**，所以通过这一点来说的话，我们给定了两个节点，这两个节点的“公共祖先”一定值在这两个节点的值之间，因为两个节点一定会一个在“公共祖先”的左子树上，一个在公共祖先的右子树上，或者有一个就是“公共祖先”；

所以，我们的做法就是，从根节点开始遍历，如果找到了一个节点恰好就是两个节点中的一个，那么我们就可以得出结论，这个节点就是两个节点公共祖先，另外一个节点就在这个节点的左子树或者右子树上，直接返回这个节点即可；

如果当前递归的节点比两个目标节点都要小，那么我们需要往右递归，因为比这个节点大的节点都在右子树上；

同理，如果当前递归的节点比两个目标节点都要大，那么我们需要往左递归，因为比这个节点小的节点都在左子树上；

如果当前递归的节点正好在两个节点中中间，那么当前递归节点就是我们要找的最近“公共祖先”；

有的小伙伴可能会想，题目要求的是尽可能深，那有没有可能再往下递归有更深的“公共祖先”呢?答案是没有可能；

我总结的是，如果两个节点在一棵二叉搜索树的一个节点的左右子树上，那么这个节点就是这个两个节点“公共祖先”；而且只有这么一个“公共祖先”能把这两个节点分配在左右子树上；

![image.png](https://pic.leetcode-cn.com/d7003e31851d62e31fb21dd885a86b499064d3653c20f64ed0d4a93a5e4145fc-image.png)


说可能说不明白，我们以示例图为例，一看就懂了；
1）节点2和节点9的“公共祖先”是节点6，节点2和节点9在节点6的左右子树上；
2）节点5和节点0的“公共祖先”是节点2，节点5和节点0在节点2的左右子树上；

多验证几个，就知道我所言非虚；
## 代码（JAVA实现）
ps：这里笔者使用的jdk为1.8版本

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (Objects.isNull(root) || Objects.isNull(p) || Objects.isNull(q)) {
            return null;
        }
        if (root.val < p.val && root.val < q.val) {
            return lowestCommonAncestor(root.right, p, q);
        } else if (root.val > p.val && root.val > q.val) {
            return lowestCommonAncestor(root.left, p, q);
        } else {
            return root;
        }
    }
}
```
