本题不能忽视的一点就是两个数组都是**已经排序**过的数组，如果利用好这一点就可以大大减少计算量。并且如果我们利用 **A 中已经有的剩余空间**，也可以减少内存的使用。

这道题，我探索出来较优的解决方案就是从两个数组的尾端开始比较，也就是**从大到小排序**，并且将两个数组中较大的一项放入到 A 的末端，这样即利用了「已排序」也利用了 A 中的剩余空间。

还有一个小的注意事项，如果最后假如 B 已经排序完毕，那么 A 也已经排序完毕，因为所有的B已经插入到 A 中，而 A 本就是预先排序的数组。

```py
class Solution:
    def merge(self, A: List[int], m: int, B: List[int], n: int) -> None:
        # A的最后一个待排序元素
        endA = m - 1
        # A的最后一个可用位置
        end = m + n -1
        # B的最后一个待排序元素
        endB = n - 1
        #当没有遍历完所有元素的时候就表明还没有排序结束
        while endA >= 0 or endB >= 0:
            #如果 B 还没有完全插入 A，则需要元素两两比较选择较大的元素占据末端
            if endA >= 0 and endB >= 0:
                if A[endA] > B[endB]:
                    A[end] = A[endA]
                    endA = endA - 1
                else:
                    A[end] = B[endB]
                    endB = endB - 1
            # 如果 A 原有元素已经排序完毕，则表示需要将 B 中所有元素继续插入
            elif endA == -1:
                A[end] = B[endB]
                endB = endB - 1
            # 如果 B 已经完全插入，则表示排序完毕，可以推出循环
            else:
                return
```
第三天打卡，若有错误，还请指正。