![image.png](https://pic.leetcode-cn.com/6aba880cfb601052f183cb0ed4ea764842a1c4dcfc43a336eb4f9bdbd608aa7b-image.png)

最开始思路是从最小值开始比较，但是感觉涉及到元素的搬运比较难实现，所以换了种思路，从最大值开始比较着来吧
# 
#### 思想很简单
##### 1、直接看两个数组的最后一个元素谁大，谁就放到A数组的最后位置，然后再更新A数组的下标往前一位，以此类推。
##### 2、不过要堤防极端情况（B数组中的所有元素都小于A数组的最小元素）
##### 3、由于是原地操作，空间复杂度是O(1)，时间复杂度是O(m+n)
```python 
def merge_array(A, B, m, n):
    i = len(A) - 1  # 从A数组里最后一个元素（最大的元素）开始比较
    while n > 0 and m > 0:
        if B[n - 1] > A[m - 1]:  # 如果B的最后一个元素（B的最大值）大于A的最大值，则把B的这个值放到A的当前位置
            A[i] = B[n - 1]  # 更新B的最最大值索引
            n -= 1
        else:
            A[i] = A[m - 1]  # 反之，把A的最大值放到该位置
            m -= 1  # 更新A的最大值索引
        i -= 1
    for j in range(n):  # 要注意，如果上述循环完后，B里面还有数据，或者B还没有遍历到0，则说明B里面剩下的元素都小于A的最小元素，需要把这些元素放到A
        A[j] = B[j]
    return A
```

