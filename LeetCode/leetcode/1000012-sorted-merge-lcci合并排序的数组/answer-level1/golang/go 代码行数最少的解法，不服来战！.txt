话不多说，直接上代码：
```
func merge(A []int, m int, B []int, n int)  {
    copy(A[m:], B[:])
    sort.Ints(A)
}
```
就两行，骚不骚
可能有点不要脸了😂
-----------------------------------------------------华丽的分割线------------------------------------------------------------
那来个正经的吧。
题目看过一遍，最先想到的是，从前往后处理，这样的话，如果不借助第三个数组就会有大量的移动数据，
借助第三个数组又会有额外空间的开销。
再读两遍题目：
题目中已明确告诉数组A的大小可以容纳A和B中的元素，而数组都是由小到大排序的。
那么最终结果，最大的数据一定排在A的最后，它的位置是确定的，而且，此时它的位置是空闲的，
也就是说不需要数据移动，就可以直接存入。
那么从后往前处理，这个题就解决了。
上代码：
```
func merge(A []int, m int, B []int, n int)  {
    i, j, index := m - 1, n - 1, len(A) - 1
    for i >= 0 && j >= 0 {
        if A[i] >= B[j] {
            A[index] = A[i]
            i--
        } else {
            A[index] = B[j]
            j--
        }
        index--
    }
    if j >= 0 {
        copy(A[:j+1], B[:j+1])
    }
}
```
注意第一个循环结束后，如果B中的数据没处理完，还要继续处理，而A就不需要了

