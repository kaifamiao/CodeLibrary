$A$ 和 $B$ 两个数组都是排序过的，因此可以通过一次扫描实现 $O(n)$ 的时间复杂度，无需合并完再排序，因为排序的最小时间复杂度为 $O(nlogn)$，一定是比一次扫描慢的

我们设置三个指针，两个 $a,b$ 分别指向 $A$ 和 $B$ 两个数组的最后一个未插入元素（最大未插入元素），另一个指针 $res$ 指向数组 $A$ 的末尾

每次比较 $a,b$ 所指向的元素大小，将较大的元素放到 $res$ 处，指针地址 $--$，重复直到一个数组插入完成

此时有两种状态，若数组 $B$ 插入完成而数组 $A$ 有剩余，无需处理，因为未插入的元素实际上已经在相应位置了

若数组 $A$ 插入完成而数组 $B$ 有剩余，通过 $b$ 和 $res$ 两个指针直接完成数组 $B$ 中剩余元素的插入即可

```cpp
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int a = m - 1, b = n - 1, res = m + n - 1;
        while(res > -1 && a > -1&& a > -1 && b > -1){
            if(A[a] > B[b]){
                A[res] = A[a];
                res--;
                a--;
            }
            else{
                A[res] = B[b];
                res--;
                b--;
            }
        }
        if(a == -1){
            while(b > -1){
                A[res] = B[b];
                res--;
                b--;
            }
        }
    }
};
```
