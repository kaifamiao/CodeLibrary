首先，我们对题目进行分析。
*给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。*
数组A和B已经排好序，意味着我们可以利用这个基础。将B合并入A，所以A是主体，要动大刀子。
A = [1,2,3,0,0,0], B = [2,5,6]
我们倒着看这个例子，A的最后元素3比B的6小，因为是两个排好序的数组，所以A中所有元素均小于B的6，没必要再去比较A中的1，2是不是比B中的6小。此时A,B两数组中的最大元素便浮出水面了，我们把B6放到A新数组的末尾。
我们接着比较A最大的3和B第二大的5，以此类推。比较结束后，要考虑有一个数组他的元素没有全部参与比较的情况。如果A有剩余，反正B已经全插进A了，所以新A整体有序。如果B有剩余，意味着B中的剩余元素比新A数组元素都要小，顺次逆序将B剩的元素放在新数组头部即可。
值得注意的是，整个过程中，A,B的元素在进入新A数组时，会对原A数组进行覆盖。
```
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int i = m-1, j = n-1, k = m+n-1;
        while(i>=0 && j>=0){
            if(A[i] > B[j]){
                A[k--] = A[i--];
            }else{
                A[k--] = B[j--];
            }
        }
        while(j>=0){
            A[k--] = B[j--];
        }
    }
};
```
