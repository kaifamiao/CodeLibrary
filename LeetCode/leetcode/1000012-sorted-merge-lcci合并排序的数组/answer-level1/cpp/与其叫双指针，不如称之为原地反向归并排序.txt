一开始看到这题就想到了归并排序，因为两个数组是已经排序好的。
但是传统的归并排序需要额外的空间存储答案，所以我们需要想点办法。
第一次尝试：
以为A数组后面空间是无限的，比2m+n要大，所以就原地正向归并排序，发现overflow报错了。
原地正向归并排序的思路比较简单：
把A[m]及其之后的空间视为一个新数组来存储归并排序的结果，其他与归并排序一致
```
    int i = 0, j = 0, pos = m;
    while (i < m && j < n)
    {
        if (A[i] < B[j])
        {
            A[pos++] = A[i++];
        }
        else
        {
            A[pos++] = B[j++];
        }
    }
    while (i < m)
    {
        A[pos++] = A[i++];
    }
    while (j < n)
    {
        A[pos++] = B[j++];
    }
```
第二次尝试：
偷瞄了一眼隐藏提示：尝试从数组的末端向前端移动。
如果这样改的话，就等于新数组是一个从A[m+n-1]开始，到A[0]结束的数组。
不仅方向变了，而且排序方式也变了。
应该要从大到小找数，因为如果先找小的数，大的数在A数组的中间可能会被新数组覆盖。
反向寻找，所以所有的指针都是递减的。
```
    int i = m - 1, j = n - 1, pos = m + n - 1;
    while (i >= 0 && j >= 0)
    {
        if (A[i] > B[j])
        {
            A[pos--] = A[i--];
        }
        else
        {
            A[pos--] = B[j--];
        }
    }
    while (i >= 0)
    {
        A[pos--] = A[i--];
    }
    while (j >= 0)
    {
        A[pos--] = B[j--];
    }
```
虽然代码量看起来有点多，但是思路很清晰，特别是对于了解过归并排序的同学来说。