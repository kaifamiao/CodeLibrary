### 解题思路
这题的关键是在于A数组中多了一半的空间可以利用, 既然是题目中条件假设所预设好了的，就该充分利用起来，利用好了这部分的空间可以提升算法的执行时间和效率。
具体的做法是：分别设置两个指针变量i, j指向数组A, B的最后一个下标索引位置, 通过一次扫描遍历原始数组, 其中i和j指向的元素谁大就放在原始数组的最后末尾。然后，让滑动指针变量i(或者j)和指向原始数组的k。这里应该可以想明白，那个元素大那么就让指向这个元素变量的指向向前滑动一次。最后，还需要判断下指向数组B的指针索引变量是否还有剩余元素值，如果还有那么继续做一个元素值的覆盖至原始数组。

时间复杂度: O(N), 一次扫描原始数组，所以是线性复杂度;
空间复杂度: O(1)，原地赋值和元素值的覆盖，所以不占用额外空间;

### 代码

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {

        int i = m - 1;
        int j = n - 1;
        int k = m + n  - 1;
        while (i >= 0 && j >= 0) {
            A[k--] = (A[i] < B[j]) ? B[j--] : A[i--];
        }

        while (j >= 0) {
            A[k--] = B[j--];
        }
    }
}
```