### 解题思路
按照归并排序的思路，合并两个有序数组从前往后，如果谁小，就移动该数组的指针，并且移动新数组的指针。
问题在于，这道题没有新数组，只有A的后半是空的。如果按照原来的方法，则B的值会覆盖A后面的值，这样的话需要把A的所有数字都移动到后面，然后A和B按照归并排序来选择，就不用担心被覆盖。时间复杂度是O(M+N+M)。

把上面的解题方法换个角度，上面是A的数据全在后面，有序的元素从前面开始，换个角度可以把A的数据保留在前面，有序的元素从后面开始。也就是从A和B的后面选取最大值，放到A的数组最后。这样时间复杂度O(N+M).

### 代码

```java
class Solution {
    public void merge(int[] A, int m, int[] B, int n) {
        int i=m-1;
        int j=n-1;
        for(int k=m+n-1;k>=0;k--){
            if(j==-1||(i>=0&&A[i]>=B[j])){
                A[k]=A[i--];
            }else{
                A[k]=B[j--];
            }
        }
    }
}
```