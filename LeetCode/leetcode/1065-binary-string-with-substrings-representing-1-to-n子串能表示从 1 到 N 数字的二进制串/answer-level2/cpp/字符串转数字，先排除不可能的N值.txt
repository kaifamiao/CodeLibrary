### 解题思路
S的长度最大为1000，每个整数的二进制位在这里最长为31，所以S能表示的数字是有限的，假设S的长度为n，那么粗略估计能表示的数的数量最多为31*n，所以这里可以肯定N大于31*1000肯定返回false。但这个数对于我们来说还是太大了，可以继续缩小。
用二进制数列来考虑，假设首位为1，那么它能表示的所有数字跟数列的长度有关，也就是说假设为长度为n，那么能表示的最大值为2的n次方-1，最小值为2的n-1次方，而除去首位1的序列覆盖了小于2的n-1次方的所有数字，也就是说只要S覆盖了长度为n，首位为1的所有二进制序列，也就能包含了1到2的n次方-1的所有数字的二进制序列。
而在这里每个首位为1，长度为n代表数字不同，序列也就不同，这样的数字总共有2的n次方-1个，每个长度为n，所以需要的S的最小长度为n*pow(2,n-1);
S的长度最大为1000，可以计算出n最大为7，所以N最大为127，这个范围够小了；
接下来有两种方案，一种是数字转字符串，然后在S种查找；一种是字符串转数字，子字符串最长为7位，可以根据N计算合适的长度，看得到的数字集合是否覆盖1到N；

### 代码

```cpp
class Solution {
public:
    bool queryString(string S, int N) {
        //所以我们考察二进制首位为1，如果它表示的数字覆盖它所能表示的连续数字的情况，那么去掉1的连续子数列也覆盖减去首位1的数字的所有情况
        //比如二进制位总共4位，首位为1，那么后面三位能代表的数字都要有，也就是{000,001,010,011,100,101,110,111};
        //而在这里，3位能代表的所有连续数字已经覆盖了，同理更少位也是如此
        //同时在这里我们发现，每个数字都是不同的，意味二进制连续数列都不同
        //综上，我们只需要考察最长位的情况
        //比如最长4位，首位为1，那么总共8种情况，覆盖这8种情况，那么需要32位
        //也就是长度n，数字最大是2的n次方-1，需要的数组长度位n*2的n-1次方
        //所以根据数组长度最大位1000，可以推算出n最大为7，能表示的最大数字N为127
        //而最后的方案就是：计算所有子序列能代表的数字，看是否覆盖1到N

        if(N > 127)
        {
            return false;
        }

        vector<bool> flags(N+1,false);
        for(int i=0;i<S.size();++i)
        {
            if(S[i] == '0')
            {
                continue;
            }
            flags[1]=true;
            int tmp = 1;
            for(int j=1;j<8 && i+j<S.size();++j)//可以优化，使用N计算位长，比如N=3，那么就只需要考察2位
            {
                tmp <<= 1;
                tmp += S[i+j] == '0' ? 0 : 1;
                if(tmp < flags.size())
                {
                    flags[tmp] = true;
                }
            }
        }

        for(int i=1;i<=N;++i)
        {
            if(!flags[i])
            {
                return false;
            }
        }

        return true;
    }
};
```