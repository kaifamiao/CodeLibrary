## 解法：删除整行或整列

对于该题目而言，其最重要的规律就是每一行从左到右递增，每一列从上到下递增。那么，在解题的时候必然要利用这一规律。

对于这种存在大小顺序且目标是为了查找某一元素的题目，最初始的想法就是利用二分查找的思想。而对于二分查找法，最重要的就是找到删除某一部分的策略。

思路1：对于数组内部的某个元素，以该元素为右下角的数组的元素都小于等于当前元素。但是基于这一规律，剩余的数组元素将会被划分为三块，处理起来过于复杂。

思路2：对于四个角的元素。

* 对于左上角的元素，其余位置的所有元素都大于该元素，不存在小于该元素的元素，无法进行二分查找；
* 对于右下角的元素，其余位置的所有元素都小于该元素，不存在大于该元素的元素，无法进行二分查找；
* 对于左下角的元素，其头顶一列的元素都小于该元素，右侧一行的元素都大于该元素。借助这一特性，可以一次删除一整行或一整列，可以使用类似于二分查找的思路；
* 对于右上角的元素，其左侧一行的元素都小于该元素，下面一列的元素都大于该元素，借助这一特性，可以一次删除一整行或一整列，可以使用类似于二分查找的思路。

这里，使用思路二的第四种思路，如果右上角的元素大于目标元素，则删除左侧一行；如果右上角的元素小于目标元素，则删除下面一列。直到找到目标元素或查处数组的下标限制。

代码如下：

```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty())
            return 0;
        int row = 0;
        int col = matrix[0].size() - 1;
        while (row < matrix.size() && col >= 0 && matrix[row][col] != target) {
            if (matrix[row][col] > target)
                col--;
            else
                row++;
        }

        bool result = true;
        if (row >= matrix.size() || col < 0)
            result = false;
        return result;
    }
};
```

时间复杂度：$O(m+n)$，$m$为行数，$n$为列数；

空间复杂度：$O(1)$。

这道题的难点就是找到删除部分元素的依据，找到了这一依据代码实现就很简单。