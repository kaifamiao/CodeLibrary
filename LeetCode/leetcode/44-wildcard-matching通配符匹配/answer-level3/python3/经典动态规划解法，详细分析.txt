# 1 问题抽象

问题是求 **s(string)** 和 **p(pattern)** 能否匹配。所以，我们可以用函数 $f(i,j)$ 表示 **s** 的前 **i** 个字符和 **p** 的前 **j** 个字符能否匹配。
**这是一个 bool 值函数。**

# 2 状态转移方程

现在我们有 **ss**  和  **pp**  两个子字符串。他们分别是 **s** 的前 **i** 个字符和 **p** 的前 **j** 个字符。**我们应该把目光聚焦到它们的最后一个字符上。**

在下面三种情况下，问题可以用子问题来表示，也就是可以找到状态转移方程。

### 2.1 pp  的最后一个字符是 `*`
这里就有两条道路可以选择。此时这个`*`可以匹配 **ss** 的最后一个字符，也可以什么都不匹配（匹配一个空字符串`''`）。
 1. 当匹配 **ss** 的最后一个字符时，  显然 **ss** 的最后一个字符无论是什么，都能匹配到 `*` 。那么就可以把 **ss** 的最后一个字符的去掉，去看  **ss[:-1]** 的情况了。 => **问题转化为求$f(i-1,j)$的值**;
 2. 当匹配空字符串时， 这个`*`接下来就不能再匹配任何字符了，所以可以去掉这个`*`，看 **pp[:-1]** 能否匹配 **ss**。 => **问题转化为求$f(i,j-1)$的值**。
 
 我们要选择能够走得通的那条道路。在这里，可以回溯一下，先走第一条，走不通的话回来走第二条。

### 2.2 pp 的最后一个字符是`?` 
那么这两个字符串的最后一个字符就互相匹配，我们就可以把这两个字符串的最后一个字符忽略掉，转而去关注 **pp[:-1]** 和 **ss[:-1]**。 => **问题转化为求$f(i-1,j-1)$的值**。

### 2.3 pp 的最后一个字符和 s 的最后一个字符相等
和最后一个字符是 `?` 的情况相同。


上面过程的代码逻辑大概如下，这块代码仅仅展示转移方程部分，其余的后面会进行补充。

```python
def f(i, j):
    ss = s[:i]
    pp = p[:j]

    if pp[-1] == '*':
        return f(i-1, j) or f(i, j-1) # 先尝试匹配ss最后一个字符，如果不行，再匹配空字符
    elif pp[-1] == '?' or pp[-1] == ss[-1]:
        return f(i-1, j-1)
```

# 3 终止条件
显然，如果能够完全匹配，那么 **s** 和 **p** 应该刚好能够对得上，谁也不应该剩下。
如果 **p** 耗尽而 **s** 没有耗尽，此时没有 pattern 可以用来匹配，所以这种情况无法匹配。
刚才在 **2.1-2** 中分析过，当 **s** 耗尽时， 如果 **p** 未耗尽，那么仍然可以进行状态转移。但是，此时只有 `'*'`才能匹配空字符串，其它情况都无法匹配。显而易见，除非此时的 **pp** 全部由`'*'`组成，否则是无法继续下去的。
所以我们得到了三个终止条件：

1. $f(0,0) = True$
2. $f(i, 0) = False(i\neq0)$
3. 当不满足$\forall c \in pp, c\text{=='*'}$ 时，$f(0,j)=False$，否则$f(0,j)=True$

还有一个终止条件是显然的，就是在匹配过程中，如果 **p[j-1]** 不是通配符，而且和 **s[i-1]** 不相等，那么二者肯定不匹配,即:

4. 在$i>0, j>0$时，若`p[j-1] != s[i-i]`，则 $f(i,j) = True$

我们把终止条件加进代码，就变成这个样子：

```python
def f(i, j):
    # 终止条件1
    if i == j == 0:
        return True

    ss = s[:i]
    pp = p[:j]

    # 终止条件2
    if i != 0 and j==0:
        return False

    # 终止条件3
    if i == 0:
        for c in pp:
            if c != '*':
                return False
        return True

    if pp[-1] == '*':
        return f(i-1, j) or f(i, j-1)
    elif pp[-1] == '?' or pp[-1] == ss[-1]:
        return f(i-1, j-1)
    else:  # 终止条件4
        return False
```

# 4 完整题解

在完整的题解中，有些部分会与上面的代码块有一些差异。比如，这里不会用字符串切片(ss=s[:i])，因为这在 python 中是一个深拷贝操作，会增加空间复杂度，这里用游标来代替，因为 **ss[-1]** 和 **s[i-1]** 的含义是一样的, **pp[-1]** 和 **p[j-1]** 也如此。

```python
class Solution:
    def isMatch(self, s: str, p: str) -> bool:
        
        memo = {}

        # 这里使用字典记录已经算出过的值，避免重复计算。遇到重复值时，直接取出。为了不破坏 f 函数的逻辑，使用装饰器来完成这一步骤。
        # 如果不使用字典，就会超时。
        def write_to_memo(func):
            def new(i, j):
                res = func(i,j)
                if res is None:
                    return memo[i, j]
                else:
                    memo[i,j] = res
                    return res
            return new

        @write_to_memo
        def f(i, j):
            # 避免重复计算
            if (i,j) in memo:
                return None
            # 终止条件 1
            if i == j == 0:
                return True

            # 终止条件 2
            if i != 0 and j == 0:
                return False

            # 终止条件 3
            if i == 0:
                while j:
                    if p[j-1] != '*':
                        return False
                    j -= 1
                return True

            if p[j-1] == '*':
                return f(i - 1, j) or f(i, j - 1) # 先尝试匹配 ss 的最后一个字符，如果不行，再匹配空字符
            elif p[j-1] == '?' or p[j-1] == s[i-1]:
                return f(i-1, j-1)
            else:  # 终止条件 4
                return False

        return f(len(s), len(p))

```


测试用例：
- 'aa'
'aa'
- 'abcd'
'a\*d'
- 'abc'
'ab\*\*\*'
- 'abc'
'ad\*\*\*'
- 'abc'
'a?c'
- 'abbabbbaabaaabbbbbabbabbabbbabbaaabbbababbabaaabbab'
'\*aabb\*\*\*aa\*\*a\*\*\*\*\*\*aa\*'