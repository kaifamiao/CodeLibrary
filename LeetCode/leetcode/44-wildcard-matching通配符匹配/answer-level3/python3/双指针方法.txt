大概就是题解里powcai的思路，但是他的注释写的有点粗糙我没看懂，所以用自己的表达翻译一下。
定义两个指针i,j，分别指向两个字符串待匹配的位置，下面有四种情况：
1. s[i] p[j]恰好相同或p[j]为"?",那么i,j同时+1
2. p[j]为"#"时，使用一个变量xing记录最后一个#的位置，但是这时不用#来匹配，因为我们希望尽可能使用p中的正常字符来匹配s，不然p中多余的字符就无法匹配了,j跳过# j+1（此时还需要用一个变量match记录遇到*之前可以匹配到的位置）
3. 当不满足前两种情况时，也就是当前的p[j]无法匹配s[i]了，我们就要借助已记录的最后一个#来匹配，所以只能含泪清空从最后一次遇到#之后所有正常的匹配，也就是i,j都还原到最后一次遇到#的位置也就是match,xing+1。然后使用#来匹配s中的一个字符，剩下的继续尝试正常匹配，即i = match = match+1
4. 当不满足上述三种情况时，说明既无法匹配又没有#了，直接返回False

最后，当i=len(s)-1时说明s全部都能被匹配啦，这时判断一下p，如果p也到头了或者p只剩*了，那就返回True
```
class Solution(object):
    def isMatch(self, s, p):
        i = 0
        j = 0
        matched = 0#在尽量不使用*的情况下，能够匹配到的位置
        xing = -1#最后一个*的位置
        while(i<len(s)):
            if j<len(p) and (p[j]==s[i] or p[j]=='?'):
                i += 1
                j += 1
            elif j<len(p) and p[j]=='*':
                matched = i#发现*后，记录当前可匹配到的位置
                xing = j
                j += 1
            elif xing!=-1:#如果遇到既无法直接匹配、j的位置也不是*的情况,那么辛酸地将i,j都还原到最后一次遇到*时的位置，抠门地用*匹配一个字符，i右移
                i = matched = matched + 1
                j = xing + 1
            else:#如果匹配不了又没有*可以用，直接返回False
                return False
        
        return len(set(p[j:]))==1 and '*' in set(p[j:])
```
