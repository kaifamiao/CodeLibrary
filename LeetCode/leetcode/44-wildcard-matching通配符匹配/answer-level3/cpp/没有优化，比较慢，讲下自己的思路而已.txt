### 解题思路
1.此代码速度并不快，只战胜了5%应该是有思路绕弯的地方吧，应该继续优化。

2.应用的模板是字符串匹配dp，s和t，状态就设置为s的前i个和p的前j个字符是否匹配，如果匹配则true，否则false。

3.起始条件是空与空一定匹配，dp[0][0]=true;s任意长度都不能跟p的空串匹配；当p串为‘*’的时候才能跟s串匹配。

4.匹配过程主要是“*”比较特殊，可以匹配多个字符也可以匹配单个字符，还可以匹配空，因此要分开考虑。

### 代码

```cpp
class Solution {
public:
    bool isMatch(string s, string p) {
        int n=s.size();
        int m=p.size();
        vector<vector<bool>> dp(n+1,vector<bool>(m+1,false));
        dp[0][0]=true;//初始化条件，空和空可以匹配
        /*for(int i=1;i<=n;i++){
            dp[i][0]=false;//因为初始化为false了所以不必要的语句，但是这里表示s串的前多少字符跟空的p串都不匹配
        }*/
        for(int j=1;j<=m;j++){
            if(p[j-1]=='*') dp[0][j]=dp[0][j-1]; //当p串当前字符为*的时候，我们需要考虑前一个是否匹配上了，如果匹配上了，那么当前也可以随意匹配，反之亦然
            //else dp[0][j]=false;
        }
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){//双层循环遍历dp表
                if(p[j-1]=='*'){
                    for(int k=0;k<=i-1;k++){
                        if(dp[k][j-1]) {
                            dp[i][j]=true;//如果当前是一个“*”那么如果匹配多个字符，则之前有过一次匹配即可认为当前“*”匹配了那次匹配之后的所有字符
                            break;
                        }
                    }
                    dp[i][j]=dp[i][j]||dp[i][j-1];//当前是“*”也可以是没用的，匹配了个空字符也行，所以考察一次，也可以合并到上边循环里面
                }else if(p[j-1]=='?') dp[i][j]=dp[i-1][j-1];//如果是‘？’则当前肯定匹配上了，看前i-1和j-1的结果吧
                else dp[i][j]=dp[i-1][j-1]&&(s[i-1]==p[j-1]);//最普通情况
            }
        }
        return dp[n][m];
    }
};
```