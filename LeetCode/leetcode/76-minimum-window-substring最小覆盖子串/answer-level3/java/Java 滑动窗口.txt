### 解题思路
执行用时 :6 ms, 在所有 java 提交中击败了83.30%的用户
内存消耗 :37.9 MB, 在所有 java 提交中击败了93.43%的用户

**思路**
会出现不同字母，但是同种字母可能会出现多次；所以开辟一个数组或者HashMap来记录某个字母出现的次数。key:字母 value : 字母出现的次数；用一个变量记录总共有多少种（个）不同的字母。

*双指针滑动窗口*
右指针一直向右移动，每次移动的时候，代表“窗口”中新容纳了一个字母，所以该字母欠下的次数需要减一（如果该字母欠下的次数为0，那么“不同种字母”的个数应当减一）

左指针有条件向右移动，条件：当前左指针字母不欠次数（欠下的次数为负数），那么当前左指针字母无关紧要，所以可以抛弃（即左指针向右移动，窗口右滑了）

更新答案（最小覆盖子串），条件：欠下的字母数为0（所有字母都还完了，满足条件了） 并且 之前的答案为空，或者之前的答案的长度比现在窗口的长度长，那么截取当前窗口的字符串作为答案（最小覆盖子串）

### 代码

```java
class Solution {
    public String minWindow(String s, String t) {

        int[] st = new int[256];        // 用于记录每个字母出现了几次

        int cnt = 0;                    // 总共需要消除的不同字母的个数（因为可能有相同的字母)
        for (int i = 0; i < t.length(); i++) {
            if (st[t.charAt(i)] == 0) {
                cnt++;                      // 这种字母没出现过，那么是“不同的字母",所以”不同的字母“ 个数+1
            }
            st[t.charAt(i)]++;              // 某种字母的出现的次数+1
        }

        String ans = null;
        for (int right = 0, left = 0; right < s.length(); right++) {    // 每次循环都会右移右指针，那么就会 减少右移后的位置上的字母的 "出现的次数"

            if (st[s.charAt(right)] == 1) cnt--;                       // 如果当前字母出现次数为1(稍后会右移，即窗口中会多一个该字母，所以该字母欠下的”出现的次数"会减一)，则减一后等于0，则该字母不欠次数了（说明该字母匹配完毕)
            st[s.charAt(right)]--;

            while (left < s.length() && st[s.charAt(left)] < 0)  st[s.charAt(left++)]++;  // 左指针可以移动的前提是,left位置上的字母出现的次数为负数，代表不欠该字母的“出现的次数"了，即该字母的有无，无关紧要，所以可以右移左指针抛弃该字母。
                                                                                            // 因为抛弃了left位置上的字母，所以该字母所欠下的”出现的次数"需要+1
            if (cnt == 0) {    // 如果没有字母欠“出现的次数”了，代表所有字母都满足了
                if (ans == null || ans.length() > right - left + 1) {    //更新答案，前提是，之前的答案为空，或者之前的答案的长度比现在的长
                    ans = s.substring(left, right + 1);
                }
            }
        }
        return ans == null ? "" : ans;
    }
}
```

第一次写滑动窗口题目，小白已经尽力陈述了，希望能陈述明白（笑哭..）