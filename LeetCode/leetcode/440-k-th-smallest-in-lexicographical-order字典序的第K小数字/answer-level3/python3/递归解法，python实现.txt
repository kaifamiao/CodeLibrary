这道题做了将近一整天的时间，最终解出，后来看到 @杨兴元 的思路，才发现原来是一个十叉树的遍历。回看自己的解法，看起来思路是差不多的，但是我用了递归的方式，分享出来，供大家参考。

首先，寻找规律：
- 1到2之间会存在10到19共10个数字(树种就是10个子节点)，而10到11之间又会存在100到109，如果分开层次来画出来，就是一个无限递归的金字塔。第L层会新增10的L次方个数字。
- 由第一点可以推断，每个数字之间会最多10的1次方+10的2次方+10的3次方+.....+10的log(n, 10)次方个数字。
- 前面之所以说最多，是因为如果新增的数字如果有大于n的那么会被去除掉。

用上面的规律，我开始尝试算每个数字之间个数的公式：
- 首先还是以1到2之间为例子，如果n为123，那么log(n,10)为2，也就是这个金字塔最多3层(第一层为10的0次方间隔)。
- 那么1到2之间就包含，10-19，100-123这几个数字，很明显，最大值的计算公式为算出每一个10的次方结果，先是10，然后是100。但是100(就是100到199)这几个数字不是全部的，而是剔除掉123-199这几个数字的。
- 那么当n为123时，1到2之间包含了10-19 + 100-123这几个数字，一共34个。而2到3之间，找20-29 + 200-299这个区间内与1-123的交集，发现200-299没有交集，所以仅包含20-29一共10个数字。然后如果是算10-11之间，那么就是100-109与1-123之间的交集，一共10个，这样每个数字之间的距离就搞定了。

搞定了距离，然后就可以去找数字的位置了。
- 首先要想明白的是，如果确定一个序号不在某个区间内，那么这个区间就可以直接跳过。
- 那么我们从最大的范围开始走，假设我们需要解n=123,k=37，根据上面距离公式，1-2之间有34个数字，达不到37，直接跳过。
- 这时候2的序号是36，2-3之间有10个数字，3的序号是48，已经大于37了，那么k=15就在2-3之间。
- 这时候进行递归，去找20-29这里面每个数字的间隔，发现20就是解。

递归的实现：
- 结束条件是当累加起来的距离等于序号k的时候返回当前的数字。
- 如果发现跳过某个区间之后，位置比k小，那么直接搜索下一个区间。
- 如果发现跳过某个区间之后，位置比k大，那么进到这个区间里面去找下一层的区间。

```python
class Solution:
    def findKthNumber(self, n: int, k: int) -> int:
        return self.getNum(n, k, 0, 1, [1])

    # base值当前遍历到底基层，从0开始计算
    # i表示当前是哪个数字
    # pos表示数字i当前在哪个位置上
    def getNum(self, n, k, base, i, pos) -> int:
        # 金字塔高度
        height = int(math.log(n, 10))
        # 设置一个标志量，如果前面已经没有下层了，那么后面就不必要再计算下层了
        noDeeper = False
        # 因为开始是从个位数1开始，塔下层是从个位数0开始，所以第一次遍历是9次，后面是10次
        for j in range(i, i - (i % 10) + 10):
            # 如果到了位置，直接返回
            if pos[0] == k:
                return j
            if noDeeper:
                pos[0] += 1
            # 根据距离公式，算j到j+1之间有多少个受罪
            dis = 0
            for x in range(1, height - base + 1):
                if (10 ** x) * (j + 1) > n:
                    dis += max(n - (10 ** x) * j + 1, 0)
                else:
                    dis += 10 ** x
            # 如果直接跳过比k小，那么直接跳过
            if pos[0] + dis < k:
                pos[0] += dis
                pos[0] += 1
                continue
            # 如果跳过比k大，那么到下一层继续遍历
            # 当然前提是，还有下一层
            elif j * 10 <= n:
                pos[0] += 1
                result = self.getNum(n, k, base + 1, j * 10, pos)
                if result > 0:
                    return result
            # 如果没有下一层了，那么直接下一个看j+1
            else:
                # 后面不会再有下层
                noDeeper = True
                pos[0] += 1
        # 返回-1表示，当前区间内没有
        return -1
```
