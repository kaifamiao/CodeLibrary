自己总结的，希望能帮到大家，大佬不要喷我谢谢,博文地址在这里：[Python3解法](https://blog.csdn.net/weixin_43071838/article/details/104533872)~
题目要求：给定一个包含 0, 1, 2, …, n 中 n 个数的序列，找出 0 … n 中没有出现在序列中的那个数。
题目解析：简单题的题目都不难理解，期初我写了一个代码但是没有通过，他给我的报错是输入0，但是预期的返回结果是1。起初我有点费解，后来捉摸了一下这个题的意思应该是如果是连续的就要返回比这个集合最大值+1。然后我就改了一版代码，当然这是为了实现，什么都没有考虑，代码如下：

    def missingNumber(self, nums) -> int:
        temp = max(nums) + 1
        for i in range(0, temp):
            if not (i in nums):
                return i
        return temp

这个时间复杂度看似是O(len(nums)-1),但是实际max里面也用了迭代器。所以会慢，优化空间很大，官方给出的答案的第一种和第二种我看过了其实半斤八两，看到哈希set的时候我确实有点触动，因为我确实没有考虑到会有重复的这种情况。因为我一开始的理解就是数字顺序是打乱的但是只是少一个，没想到有没有这种坑，不过这都不重要，因为这不是优化的重点，我写出来只是想让大家知道我当时怎么想的。但是官方的第三种解法我真的是狗生难忘，说句实话我从来没见过，之前刷只是为了刷题不怎么关注题解，这把一看真TM强。反正我当时是没想到，可能是我孤陋寡闻。先说下什么是异或，异或就是两个数不相同则为1，相同为0.例如1异或0为1，0异或0为0，1异或1为1。接下来说第二点，两个相同的数异或一定是0的，因为这两个数的二进制完全相同。第三点是异或是满足结合律的，因为一共n个数我们就把角标和该角标对应的值相互异或，因为少一个数所以最后一定是少的那个数的角标异或0，可以看官方给出的这个图片

这里2就是确实缺失的数值，因为我们只能获取到角标2但是获取不到值为2的数字。最后就变成了0异或（缺少的的那个值），这里要知道0异或任何数都等于任何数。至此就是这个解法，下面看代码：

    def missingNumber2(self, nums):
        missing = len(nums)
        #i是角标 num是角标对应的值，可能不是一一对应
        for i, num in enumerate(nums):
            missing ^= i ^ num
        return missing

最后一种就是差值法，反正只是少一个就用角标之减去nums这个集合里面元素的和就可以了这里面就不赘述了，真心没难度，代码如下：

    def missingNumber3(self, nums):
        return sum(range(len(nums) + 1)) - sum(nums)
————————————————
版权声明：本文为CSDN博主「Scala没有静态」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_43071838/article/details/104533872
