这道题可以用哈希表或者求和的方法，都是不错的方法，不过既然这个题目是关于位运算的，就用经典的位运算吧。

对于数字的位运算，按位异或有一个很重要的性质，对于数字`a`和`b`有：

`a^a=0`

`a^0=a`

`a^b^a=b`

以此类推可以发现如果对于一个数组里面的每一个元素都进行按位异或，里面的出现频率是偶数的元素都会变成`0`，如果数组里面每个元素的出现频率都是偶数次，那么整个数组的按位异或的结果就是`0`，如果只有一个元素出现了奇数次，按位异或的结果就是这个元素。

回到这道题，数组中所有的数字出现的次数是`1`，没有出现的数字次数是`0`，明显不能直接按位异或，那我们就再这个数组后面添加一个`0..n`的数组，包含所有的元素，这样两个数组合起来原来出现的数字的出现次数是`2`，而原来没有出现的数字的出现次数是`1`，就可以用按位异或了。

不过这里并不需要显性的添加数组，而是在循环内部再进行异或操作，代码如下：

```java
public int missingNumber(int[] nums) {
    int xor = 0;
    for (int i = 0; i < nums.length; i++) {
        xor ^= i^nums[i];           // 循环内部尽量按位异或虚拟的新增数组
    }
    return xor^nums.length;         // 补齐循环中漏掉的最后一个数字n
}
```

更多内容请看我的[**个人博客**](http://sunshuyi.vip)