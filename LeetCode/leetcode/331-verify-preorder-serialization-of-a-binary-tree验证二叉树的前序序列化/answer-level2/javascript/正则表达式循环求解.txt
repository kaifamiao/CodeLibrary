首先看到这一题，想到的就是如何将一个数字和两个#号同时替换成一个#号，这样将字符串重复的进行替换，最后剩下的就一定是一个#号。这样说可能不是很明白，我来做个示范。
初始：9，3，4，#，#，1，#，#，2，#，6，#，#
替换一次：9，3，#，#，2，#，#
再替换一次：9，#，#
最后替换一次：#
所以如果说一个树能够被前序遍历，最后一定是能被替换成一个#的。
理由就是相当于对于二叉树从下往上进行了推断，如果下面的子节点和子节点的两个叶子节点能够组成一个正确的结构，那么这个子节点在这个树中是不会造成错误的。至于为什么要替换为#，而不是替换为一个数字，是因为你想不管这个子节点结构了，所以就将这个子节点看作null了，更深层的理由其实是为了方便我们循环替换。
初始代码版本：
```
    preorder=preorder.split(",").join("")
    const reg=/\d##/g
    while(reg.test(preorder)){
        preorder=preorder.replace(reg,"#")
    }
    return preorder=="#"
```
看似没有什么问题，也可以跑通示例代码，但是当节点的数字为两位数时，通过字符串的正则处理就会出错，例如
92，#，#
变化为字符串就成了：92##
替换之后就成了：9# 
那么就会被判断错误。
所以我们要先将所有的数字都转换为一位的数字，记住这时候不方便使用字符串来直接替换，因为可能出现下面这种情况
9，2，#       ---------->   92#  ------------------>n#   (这里的n表示任意个位数  1# 2# 都可以)
最后决定用数组来进行转换后再转换成字符串 于是有了下面最终的版本
```
    let arr=preorder.split(",")
    for(let i=0;i<arr.length;i++){
        if(Number(arr[i])){ //如果这个字符是“#” 转换为数字类型为NaN
            arr[i]=3   //这里随便为几都可以
        }
    }
    preorder=arr.join("")
    const reg=/\d##/g
    while(reg.test(preorder)){
        preorder=preorder.replace(reg,"#")
    }
    //console.log(preorder)
    return preorder=="#"
```

题外话，你们喜欢林子祥吗？
