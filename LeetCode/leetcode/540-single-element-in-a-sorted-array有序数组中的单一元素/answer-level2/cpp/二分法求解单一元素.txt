### 解题思路
二分法，
由于只有一个数只出现一次，其他数均出现两次，而且数组是有序的。
因此在只出现一次的数之前，
偶数位的数一定与后面相邻的奇数位的数相同，
在该数之后，奇数位的数与后面相邻的偶数位的数相同
(例如数组[1,1,2,3,3,4,4,8,8]中，序号2之前，nums[0] == nums[1]，序号2之后，nums[3] == nums[4]等等)

因此判断条件就是偶数位与后面相邻的奇数位是否相同，
若相同，则表明要求的答案在当前结果的后面，
否则，表明答案不在当前结果后面。

给定一个序号p，求该序号所在的 偶数位-奇数位 位置时，可以通过 (p/2)*2 和 (p/2)*2 + 1求取，少了一个判断。

### 代码

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int l = 0, r = nums.size()-1;        
        while(l<r)
        {
            int mid = (l+r)>>2;
            int ll = 2*mid, rr = ll+1;
            if(nums[ll] == nums[rr])l = (mid + 1)*2;
            else r = (l+r)>>1;
        }
        
        return nums[r];
    }
};
```