### 题解:

- 这题其实挺难的!因为得运用数学来解
- 首先,如果是环形,快慢指针肯定会相遇,而且快的指针是慢指针 跑过的距离的两倍! 

### 思路:

- 作弊做法(未实践): 就定一个指针,每次移动一步,把每个节点的地址存到map里,每走一个,校验一遍,map里key存地址,value存index,如果走到nil,那么没有环,如果遇到同一个地址,那么就是环入口了!
- 正常解法:
  - 首先,得理解如果正常环形链表什么时候相遇! 假设链表是个圆环! A B 两指针从原点0出发,当A到达圆环一半的时候,B应该回到了原点,当A到原点,正好一圈的时候,B也到了原点,两指针相遇
  - 如果像示例1一样的链表!那么依然还是快一圈相遇,不过不是入口原点! 可能往右偏移了几个点
  ```
    #                              .----.   
    #                             /      \  
    #      ___________X__________(O)     |(P) 
    #                             |      |  
    #                             \      /  
    #                              '----'   
    #                              (Y)                                        
  ```
  - 假设 上图左侧`非环形链表的长度为X`,O表示环形入口处! `环整体长度为Y`,然后假设快慢指针在P处相遇,`OP距离为 L`
  - 相同时间,快指针速度是慢指针的两倍,所以快指针走过的路程肯定也是慢指针的两倍 (速度 * 时间 = 距离)
  - 慢指针走 `X + L`, 那么快指针走过的距离 是慢指针的两倍 即 `2(X + L)`
  - 快指针走过的路线是  `X + Y + L`
  - 那么 `2X + 2L = X + Y + L`
  - 得出 `X + L = Y`, 也就是`X和OP的和等于环的长度`,那么从`P点到O点的长度`也等于 `X的长度`
  - 那么当相遇的时候,把快指针变成一次走一步,然后另外一个指针从开始的位置走,最后相遇的点肯定就是`O点`,也就是原点即环形入口的点了

### 代码:

```

func detectCycle(head *ListNode) *ListNode {
	// 如果直接nil或者下一个节点为nil,那么就肯定没有环了
	if head == nil || head.Next == nil {
		return nil
	}

	// 定义两个节点,一个为快指针,一个慢指针
	fast := head
	slow := head
	for fast.Next != nil && fast.Next.Next != nil {
		// 快指针肯定跑得快,快指针如果走到了nil,那么说明没有环
		if fast.Next == nil {
			return nil
		}
		// 快指针每次跳两步
		fast = fast.Next.Next
		// 慢指针每次跳一步
		slow = slow.Next
		// 当 快指针和慢指针相遇了
		if fast == slow {
			// head 节点开始走,fast指针改成每次走一步,相遇的时候 就是环形的起点
			for head != fast {
				head = head.Next
				fast = fast.Next
			}
			return head
		}
	}
	return nil
}

```