### 解题思路
注：这一题的思路可以用来解题目 [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

双指针，官方题解 1 有些不清晰。

不过官方题解 1 下面的回复倒是讲的很清晰
```
看不懂算式证明的话，或者你可以这样解释性地来理解阶段2：

快指针1次走2步，慢指针1次走1步。所以快指针总是走了慢指针两倍的路。
回顾一下阶段1的过程，设头节点到入环点的路途为 n, 那么慢指针走了入环路途的一半（n/2）时，快指针就到达入环点了(走完n了)。
慢指针再继续走完剩下的一般入环路途（剩下的n/2），到达入环点时，快指针已经在环内又走了一个 n 那么远的路了。
为了方便理解，这里先讨论环很大，大于n的情况（其他情况后文补充）。此时，慢指针正处于入环点，快指针距离入环点的距离为n。环内路，可以用此时快指针的位置分割为两段，前面的 n 部分，和后面的 b 部分。
此时开始继续快慢指针跑圈，因为已经在环内了，他们其实就是在一条nbnbnbnbnbnbnb（无尽nb路）上跑步。
慢指针从入环处开始跑b步，距离入环处就剩下了n。此时，快指针则是从距离入环处n步远的位置开始跑了2b步，距离入环处也是剩下了n。他们相遇了，并且距离入环处的距离就是n，n就是头节点到入环点的距离阿!!! 后面的不用说了吧。
环很小的情况，其实跟环很大是一样的，比如你可以理解为将多个小环的循环铺开，虚拟扩展成一个大环来理解。
```

设相遇时，慢指针跑了m1圈，快指针跑了 m2 圈, 环的总长度 a, 从环入口跑到相遇处的距离为 x, 0=<x<=a-1。

当慢指针入环后，快指针为了追上慢指针会比慢指针多跑一圈。
但在慢指针入环前，快指针可能已经在环内绕了许多圈，如果环比较小的话， 故不一定有 m2 = m1+1。
并且，慢指针跑不满一圈。因为当慢指针跑一圈的时候，快指针已经跑了两圈，必然早就追上了慢指针。
也可从另一个角度看，设快指针追慢指针的距离为 y, 也即快指针接着跑到环入口还要跑的距离， y<a, 于是当慢指针在跑 y 时，快指针跑了 2y, 已经追上慢指针了.
故必有 m1 = 0, m2 >= 1

慢指针的总距离: n + m1*(a) + x  (m1 = 0)
快指针的总距离: n + m2*(a) + x
一方面，快慢指针起点相同，最终也相遇，说明了快指针必然比慢指针在总距离上多跑了某些圈（这里要小心，不一定是1圈，在慢指针上环前，快指针跑的圈数可能绕了好多圈，不是 m1 = m2 +1），也即: n +m1*(a) + x =  n + m2*(a) + x - k*a    => None  

而总有快指针是慢指针跑的距离的两倍： 2(n +m1*(a) + x) =  n + m2*(a) + x   =>  a-x = n - (m2-2*m1+)a
也即:  (a-x) + (m2-2*m1)a = n  且 m1 = 0

所以如果此时让一个新的慢指针从head出发，而继续让慢指针在环内转圈，当慢指针跑了 n 距离到达环的入口处，则这两个慢指针总会在环入口处相遇。



### 代码

```python3
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        a, b = head, head
        flag = False
        while (a!=None) and (b!=None) and (b.next!=None):
            a = a.next
            b = b.next.next
            if a == b:
                flag = True
                break
        if not flag:
            return None
        
        c = head
        while c!=b:
            c = c.next
            b = b.next
        return c 
```