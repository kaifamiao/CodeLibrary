这道题比较简单,主要说一下思想:         
#### 有一个数组[a1,a2,...,an]，我们怎么把它排成摇摆序列呢？

由摇摆序列的定义:`nums[0] < nums[1] > nums[2] < nums[3]...`，我们知道了可以分成较大一部分的数和较小一部分数，然后互相穿插即可。比如一个数组排序后为：`A=[a1,a2,...,an]` `(a1<=a2<=....<=an)`，然后分成较小和较大的两部分`[a1,a2,...,a(n/2)]`，`[a(n/2+1),...,an]`（数组长度为奇数时不影响），再进行穿插操作。

#### 那是不是穿插成[a1,a(n/2+1),a2,a(n/2+2),...,an]就行了呢？

其实不对，可以验证特殊情况：n比较小时且为偶数时，穿插后的序列需要满足`a(n/2+1)>a2`，如果`a1<a2<=a(n/2+1)<an`，`a(n/2+1)`正好是`a2`的后一项且与`a2`相等呢？即如果是`[4,5,5,6]`的情况呢？
那就分成了`[4,5]`，`[5,6]`两部分，之后穿插成的是`[4,5,5,6]`并不是摇摆序列。

#### 应该怎样排列呢？

1. 把较小和较大的两部分`[a1,a2,...,a(n/2)]`，`[a(n/2+1),...,an]`翻转成`[a(n/2),...,a1]`，`[an,...,a(n/2+1)]`
2. 排列成`B=[a(n/2),a(n),a(n/2-1),a(n-1),...,a1,a(n/2+1)]`即可。

这样相邻两个数一定不存在相等的情况，而且满足摇摆序列的要求。
* `n=1`时显然正确
* `n=2或n=3`时也显然正确。
* `n>=4时`：
   1. 首先，判断相邻的情况，如果B中现在相邻两数在原来的有序序列A也相邻，此时令`n-n/2=1， (n-1)-(n/2-1)=1，...`都解得`n=2`，意思是`n=2`是他们的公共解，而`n>=4`时，`n-n/2， (n-1)-(n/2-1)`等于`n/2>=2`，说明B中相邻两数一定在原来的有序序列A中不相邻；
   
   2. 有人会说也存在原本(在A中)不相邻但是相等的情况，即几个数连续相等，但其中两个相等的数并不相邻，比如`aq=a(q+1)=a(q+2)`，`aq=a(q+2)`相等但是不相邻，但是我们知道如果`a(n/2-k)=a(n-k)`即不相邻相等，那么由于他们中间的所有数都要相等，而且与这两个数相等才能保证不相邻相等：即`a(n/2-k)=a(n/2-k+1)=a(n/2-k+2)=...=a(n-k-2)=a(n-k-1)=a(n-k)`，一共`n/2+1`个数相等。
   
   3. 而不相邻相等这种情况是不行的：虽然只有`a(n/2-k),a(n-k)`（在B中相邻）在原序列A中不相邻相等，但也违背了摇摆序列的定义，所以这道题有一个隐藏的条件：输入序列在排序后最多只有序列长度一半(`n/2`)的相邻的数连续相等。
* 在这个条件下：这道题按此排列就没问题。大家可以用🖊验证一下。

代码如下:
```Java []
class Solution {
    
    /**
     * 先排序再穿插
     * O(nlogn)+O(n)=O(nlogn)
     * @param nums
     */
    public void wiggleSort(int[] nums) {
        //排序
        Arrays.sort(nums);
        int len=nums.length,i = 0;
        int[] smaller=new int[len%2==0?len/2:(len/2+1)],bigger=new int[len/2];
        //复制
        System.arraycopy(nums,0,smaller,0,smaller.length);
        System.arraycopy(nums,smaller.length,bigger,0,len/2);
        //穿插
        for (; i < len / 2; i++) {
            nums[2*i]=smaller[smaller.length-1-i];
            nums[2*i+1]=bigger[len/2-1-i];
        }
        if (len%2!=0) nums[2*i]=smaller[smaller.length-1-i];
    }
}
```
