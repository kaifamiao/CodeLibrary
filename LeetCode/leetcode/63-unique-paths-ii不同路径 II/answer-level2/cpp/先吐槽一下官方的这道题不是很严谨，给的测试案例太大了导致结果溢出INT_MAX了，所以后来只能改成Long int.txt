首先建议一下大家做这道题之前先做一下之前的62题，即无障碍版本的，这道题在他的基础上加了障碍，那么只需要将动态规划加一个条件即可。
即if(该处无障碍)
    那么该处的路径数=当前位置上方的路径数与当前位置左方的路径数的和
  else
    该处的路径数=0
理论上这么做其实便可以得到正确答案了，但不幸的是官方给了一个22行33列（没记错的话）的二维数组，导致存储路径数的值超过了INT_MAX,因此为了存放下这么大的数，我将返回值改为了long int。。。
以下便是代码
里面附上了我所说的超长的测试案例。
```
#include<iostream>
#include<vector>
using namespace std;
//解法与之前的类似，只需要将障碍物处的路径数设置为0，那么当前格子（无障碍）的路径数为其左方的路径数与上方路径数的和
class Solution {
public:
	long int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
		int m = obstacleGrid.size();
		if (m==0)
		{
			return 0;
		}
		int n = obstacleGrid[0].size();
		if (n==0)
		{
			return 0;
		}
		//构建二维数组nums,nums[m][n]代表m,n位置处的路径数
		long int**nums = new long int*[m];
		for (int i = 0; i < m; i++)
		{
			nums[i] = new long int[n];
		}
		if(obstacleGrid[0][0]!=1 && obstacleGrid[m - 1][n - 1]!=1) //起点和终点都不是障碍
		{
			nums[0][0] = 1;
		}
		else
		{
			return 0;
		}
		
		//初始化第一行，如果该位置前方不为障碍，那么其路径数为其左方的格子的路径数，因为只能向右或者向下走
		for (int i = 1; i < n; i++)
		{
			if (obstacleGrid[0][i]!=1)
			{
				nums[0][i] = nums[0][i - 1];
			}
			else
			{
				nums[0][i] = 0;
			}
		}
		//初始化第一列，道理同上
		for (int j = 1; j < m; j++)
		{
			if (obstacleGrid[j][0]!=1)
			{
				nums[j][0] = nums[j - 1][0];
			}
			else
			{
				nums[j][0] = 0;
			}
		}

		for (int i = 1; i < m; i++)
		{
			for (int j = 1; j < n; j++)
			{
				if (obstacleGrid[i][j]!=1)
				{
					nums[i][j] = nums[i - 1][j] + nums[i][j - 1];
				}
				else
				{
					nums[i][j] = 0;
				}
			}
		}
		return nums[m - 1][n - 1];
	}
};
int main()
{
	vector<vector<int>> a = { {0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1},{0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0},{1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,1},{0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0},{0,0,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1,0},{1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0},{0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0},{0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,0},{0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0},{0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0},{1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,1},{0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0},{0,1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0},{0,1,0,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,1,0,1 }, { 1,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }, { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0 }, { 0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,1,1 }, { 0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1 }, { 1,1,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0 }, { 0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1 }, { 0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0 } };
	Solution test;
	int road=test.uniquePathsWithObstacles(a);
	cin.get();
}
```
