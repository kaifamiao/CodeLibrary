这种题目一般需要一点比较特殊的数法。  
例如：设`i`为`S`对应的下标，计数`S`中以`S[i]`结尾的子序列的个数。  
但是这样就会遇到一个问题，因为`S[i]`前面`S[k]`,`k<i`时可能已经有以`S[i]`结尾的序列被计算过了，例如：`aba`,`S[2]`表示以`a`结尾的，但是`S[0]`也是以`a`结尾，因此这就会导致在计算S[2]时会有一部分被重复计算。因此我们需要改进下：  

设`i`为`S`中对应的下标，使用`map`记录`i`之前的所有位置`k`对应的字符`S[k]`结尾的子序列的个数，因此`S[i]`结尾的个数为：  
1. `map`中以`S[i]`结尾的个数加`1`，例如`xxxb`后面再加上一个`b`,必定不会重复  
2. `map`中不以`S[i]`结尾的个数之和，例如`xxxx`后面再加上一个`b`,必定不会重复  

计算方式为:
  
```math
ans = (map.get(c)+1) + all(map.get(!c))
```  

其中`!c`表示不以`c`结尾的

由于题目最终要求的是所有序列，那么结果便是`map`中以对应字符结尾的所有序列之和了  

例如：`abaa`  

* 当`i`为`0`时，`map`为`{ 'a' => 1 }`，以`a`结尾的：(0+1)+0 
* 当`i`为`1`时，`map`为`{ 'a' => 1, 'b' => 2 }`，以`b`结尾的:`(0+1)+1=2`  
* 当`i`为`2`时，`map`为`{ 'a' => 4, 'b' => 2 }`，以`a`结尾的:`(1+1)+2=4`
* 当`i`为`3`时，`map`为`{ 'a' => 7, 'b' => 2 }`，以`a`结尾的:`(4+1)+2=7`  

因此最终结果为`7+2=9`

```javascript
var distinctSubseqII = function(S) {
    let MOD=Math.pow(10,9)+7;
    let hash=new Map();
    for(let i=0;i<S.length;i++){
        let n=(hash.get(S[i])||0)+1;
        for(let [k,v] of hash){
            if(k!=S[i]){
                n=(n+v) % MOD;
            }
        }
        hash.set(S[i],n);
    }
    let ans = 0;
    for(let [k,v] of hash){
        ans=(ans+v) % MOD;
    }
    return ans;
};
```