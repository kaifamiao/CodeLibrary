最开始用的是暴力求解方法，显然时间复杂度是O(n^2), 毫无疑问的超时了，因此看了题解，按照自己的理解用C语言进行了实现。

以题目描述为例

```
 4 0100
14 1110
 2 0010
```

对于每一个数，我们先按位统计每一位上1的数目，代码是`nums[i] !=0; cnt= nums[i] &0x1; nums[i] >>=1` ，也就是每次看最后一位是不是1(`numi[i] & 0x1`)，然后整体右移动一位`>>1`

统计完全之后，结果应该是1220, 这意味着什么？我们一共有3个数，

- 对于0而言，说明大家都是一样的，都是0，也就是 0 * (3 - 0) = 0
- 对于1而言，说明这位置上只有一个1，那么剩下的都是0，也就是有2个人和他不一样。也就是 1 * ( 3 -1) = 2.
- 对于2而言，说明这个位置上有2个1，那么剩下的只有一个0，也是2个1和0不一样，也就是 2 * ( 3 - 2) = 2
- 对于3而言，说明这个位置上都是1，大家都一样，也就是 3 * ( 3- 3) =0;

最后的代码如下

```c
int totalHammingDistance(int* nums, int numsSize){

    // 32位的数组
    int bit_arr[32] = {0};
    // 统计每一位的1的数目
    int i ;
    int cnt;
    for ( i = 0; i < numsSize; i++){
        int j = 0;
        while ( nums[i] != 0){
            cnt = nums[i] & 0x1; //末尾为1则范围1，否则是0
            bit_arr[j++] += cnt;
            nums[i] >>= 1;
        }
    }
    int sum = 0;
    for (int k = 0; k <  32; k++){
        sum = sum + bit_arr[k] * ( numsSize - bit_arr[k]);
    }
    return sum;

}
```