## 思路
拿到手之后，是直接使用的递归的做法，看评论区大家好像对递归的过程都觉得很绕，其实我个人觉得大家把这个想复杂了，下面我来试着帮大家一起理解一下！
递归，就是三部曲：
* 1、找到递归出口
* 2、确定返回值
* 3、分析单次递归需要做的事情

下面，我们来具体分析一下：
* 首先，找到递归出口，这个还是非常简单的，就是当前即将反转的节点为 null 或者是 反转链表 为 null 时（**一轮递归其实就只有两个节点，后面会讲**），说明已经全部反转完毕了，即递归出口；
* 其次，确定返回值，我们只需要返回反转链表的头结点即可；
* 最后，分析单次递归需要做的事情，我觉得大家觉得递归比较难理解的地方就是在这，其实是大家把递归复杂化了，递归其实每一轮做的事情都是一样的，我们不需要去重复考虑，这样反而会很乱，只需要考虑单轮递归需要做什么就可以了。***在这里，我们就只有两个节点，一个是即将反转的节点元素，一个是已经反转完毕的链表头结点。*** 我们要做的一轮递归只是 ***将当前节点加入到反转链表中，仅此而已。*** 

## 代码
```java
public ListNode reverseList(ListNode head) {
    // 如果当前要反转的节点为 null 或者反转链表为 null
    // head.next 为 null，即反转链表的尾结点不存在，即反转链表不存在
    if (head == null || head.next == null) return head;
    // 节点 p 其实就是反转链表的头节点 
    ListNode p = reverseList(head.next);
    // 我们将反转链表的尾结点（head.next）的 next 指向当前即将反转的节点
    head.next.next = head;
    // 然后让当前节点变成反转链表的尾结点
    head.next = null;
    // 返回反转链表的头结点
    return p;
}
```