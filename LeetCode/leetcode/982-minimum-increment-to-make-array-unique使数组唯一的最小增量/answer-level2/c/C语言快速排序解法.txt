### 解题思路
1.首先将代码排好序 如[3,2,1,2,1,7] 排序后[1,1,2,2,3,7]
2.i从1开始 只要数组前面的元素大于等于当前元素 那么当前元素就应该加一以避免和前一个元素重复 体现在 A[i]=A[i-1]+1;
3.那么最少需要几次 只需要用前一个元素和当前元素相减就可以得到 举个例子[1,1,2,2]=>[1,2,3,4] 那么第二个1需要加一次变成2
因为1-1+1=1 第一个2需要加一次变成三 2-2+1=1 第二个2需要加两次变成四 3-2+1=2 也就是说当前元素前面的数都已经是唯一的数
那么需要加几次变成和前面那一个元素不一样的数字 需要前面一个元素和当前元素差值+1(因为需要和前面一个元素不同)。
4.cnt本质计算的是需要加几次才可以唯一,由于每一个都是和前面那一个数比较,所以需要加的数就是差值加1。

C代码

```c
int cmp(const void* a,const void* b)
{
     return *(int *)a-*(int *)b;
}
int minIncrementForUnique(int* A, int ASize){
    int cnt=0;
    if(!A || ASize<=0)
      return 0;
      qsort(A,ASize,sizeof(int),cmp);
      for(int i=1;i<ASize;i++)
      {
          if(A[i-1]>=A[i])
          {
              cnt+=A[i-1]-A[i]+1;
              A[i]=A[i-1]+1;
          }
      }
      return cnt;
}
```