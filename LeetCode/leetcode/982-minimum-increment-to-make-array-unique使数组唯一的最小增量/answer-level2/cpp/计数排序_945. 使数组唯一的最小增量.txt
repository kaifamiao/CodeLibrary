### 解题思路
    /*
     * 计数排序 实现1
     *
     * 将数组A中的每个数以它本身的大小为索引，出现的次数为数值存储到桶中。
     * 定义数组buckets为桶，因为A[i]最大为40000，考虑到可能有40000个40000，
     * 所以将桶数组大小定义为80000。对数组中的数遍历，将每个数出现的次数存储到数大小对应的索引上。
     *
     * 存储到桶中后，对桶中的数遍历。当桶中的次数大于1时，表示该索引需要递增当前次数减一次。
     * 将递增的次数加入结果中，同时增加到该索引的后一个索引上，再对后一索引做相同操作。
     * */
### 代码

```cpp
int minIncrementForUnique(std::vector<int> &A) {
    if (A.empty()) {
        return 0;
    }

    int ans = 0;
    // 将数组中的每个数出现的次数存储到该数对应的索引处
    int buckets[80000] = {0};
    for (int a : A) {
        buckets[a]++;
    }

    // 对次数数组进行遍历
    for (int i = 0; i < 80000; i++) {
        // 如果该索引处的次数大于1
        if (buckets[i] > 1) {
            // 将递增操作加入结果中
            ans += buckets[i] - 1;
            // 将递增后数的次数放入它后一桶中，
            // 对后一桶中的次数重复上述的操作
            buckets[i + 1] += buckets[i] - 1;
        }
    }

    return ans;
}
```

### 解题思路
    /*
     * 计数排序 实现2
     *
     * 将数组A中的每个数以它本身的大小为索引，出现的次数为数值存储到桶中。
     * 定义数组buckets为桶，因为A[i]最大为40000，考虑到可能有40000个40000，
     * 所以将桶数组大小定义为80000。对数组中的数遍历，将每个数出现的次数存储到数大小对应的索引上。
     *
     * 与实现1不同的是，在遍历次数数组时，如果次数大于1则将需要递增的操作先累加起来，
     * 同时结果减去索引与递增操作的乘积。当遍历遇到次数等于0的桶，则将某一次递增的数放入该桶中，
     * 同时将索引值加入结果。理由是从 x 到 y，从 p 到 q，增加的次数是 (y + q) - (x + p)。
     *
     * 例如：A为 {1, 1, 1, 3, 5}时，有3个重复的1，且没有出现过2,4,6，因此增加的操作为：(2+4+6)-3*1。
     * */
### 代码

```cpp
int minIncrementForUnique2(std::vector<int> &A) {
    if (A.empty()) {
        return 0;
    }

    int ans = 0;
    int count = 0;
    // 将数组中的每个数出现的次数存储到该数对应的索引处
    int buckets[80000] = {0};
    for (int a : A) {
        buckets[a]++;
    }

    // 对次数数组进行遍历
    for (int i = 0; i < 80000; i++) {
        // 如果该索引处的次数大于1
        if (buckets[i] > 1) {
            // 计算需要递增的操作
            count += buckets[i] - 1;
            // 结果减去索引乘递增操作
            ans -= i * (buckets[i] - 1);
        } else if (count > 0 && buckets[i] == 0) {
            // 如果遇到次数为0的桶，
            // 则将某一次递增操作放入该桶中
            count--;
            // 结果加上该索引值
            ans += i;
        }
    }

    return ans;
}
```