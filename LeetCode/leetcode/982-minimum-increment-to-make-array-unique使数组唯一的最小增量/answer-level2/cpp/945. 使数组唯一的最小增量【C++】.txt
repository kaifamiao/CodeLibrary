### 解题思路

解题思路不算很复杂，一开始我上来就暴力解，遍历数组，然后对每一个数往前找是否有跟它相同的数，有的话就将其自身+1，操作步数+1，然后再来一遍，直到这个数的前面没有跟它相同的数。解题思路是对的，能得到正确结果，但是时间复杂度太高了，提交到 Leetcode 就会超时。

然后我想到了先对数组进行排序，排序我直接调用了 `sort()` 函数，这样就只需要遍历一次数组即可，对于每一个数只需要比较相邻的数是否相等，事实上由于对数组进行了修改，排序过的数组的顺序就可能打乱导致前面的数大于后面的数，但是操作步数始终应该等于 `A[i - 1] - A[i] + 1` ，因为顺序未打乱前，前一个数应该是小于或者等于当前的数的，而顺序打乱后，只需要让当前的数变得比前一个数大即可。

特殊情况数组A的长度为0的时候操作步数显然为0，同时长度为1的时候，显然操作步数也是0，将A的长度为0和1的情况特殊处理，后续的判断就可以直接从 `A[1]` 开始，每一个数和前一个数作比较。

### 代码

```cpp
class Solution {
public:
    int minIncrementForUnique(vector<int>& A) {
        if (A.size() <= 1)
            return 0;
        int operations = 0;
        //for (int i = 1; i < A.size(); i++) {
        //    for (int j = i - 1; j >= 0; j--) {
        //        if (A[j] == A[i]) {
        //            A[i]++;
        //            operations++;
        //            j = i;
        //            continue;
        //        }
        //    }
        //}
        sort(A.begin(), A.end());
        for (int i = 1; i < A.size(); i++) {
            if (A[i] <= A[i - 1]) {
                int tmp = A[i - 1] - A[i];
                A[i] += tmp + 1;
                operations += tmp + 1;
            }
        }
        return operations;
    }
};
```