### 解题思路
此处撰写解题思路
最初的做法是采用遍历数组的形式，通过Set集合保存每次遍历的数字，如果存在重复的，则增1后再次判断，由于十分耗时，因此采用空间换时间
1.可以用一张临时表，对数字出现次数进行统计，虽然数字范围在1到40000，长度最大为40000，但是若最小数字为40000，那么最终形成的唯一数组，最大值为80000，因此临时表长度为8w
2.对数组遍历，统计数字出现次数，同时建立两个变量sameCount与count，分别表示遇到的相同数字个数-1，代表需要的未出现的数字个数，例如[1,1,1,3,5],1出现3次，sameCount=2,因此后续遍历需要2个次数出现为0的数字，count记录需要增加的量，比如[1,1,1,3,5]到[1,2,4,3,5]，需要的增量是count-（2*1）+2+4，其中2*1代表额外相同的数字1出现2次，2+4代表未出现的两个数字2，4
3.最终count为最小增量
### 代码

```java
class Solution {
    public int minIncrementForUnique(int[] A) {
        //对A中各个数字出现次数统计，虽然长度最大40000，出现数字最大40000，但是保证唯一的时候，最大范围是40000+40000=80000
        int[] B = new int[80000];
        for(int i = 0;i<A.length;i++){
            int k = A[i];
            ++B[k];
        }
        int sameCount = 0;//出现相同的个数,即需要找的唯一数个数
        int count = 0;//出现相同数的和
        for(int i = 0;i<B.length;i++){
            if(B[i] > 1){
                sameCount += (B[i]-1);
                count -= ((B[i]-1) * i);
            }else if(B[i] == 0 && sameCount > 0){
                B[i] = 1;
                sameCount--;
                count += i;
            }
        }
        return count;
    }
}
```