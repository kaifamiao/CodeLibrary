### 解题思路
遇事不决先排序

排序后相同的值就在一起了，然后我们两两比较
- 如果后一项比前一项大，那是应该的，因为我们排过序了
- 但四，如果后一项和前一项相等，那就不得不做调整，为了让`+1`的次数尽量少，每次只多`+1`就不往上加了

这样做会出现一个问题，虽然之前排序过，但有可能调整后的前一项会比后一项还大
- 如果前一项比后一项大，就让后一项一直加到比前一项多1为止

可能这里有同学会问既然不相等，为啥还要调整，那是因为这里暗含了这样一个事实：
既然前一项本来并不大于后一项（排序过），现在被迫营业到。。比如说N，就说明N-1，N-2...这些高度都已经被之前项用掉了，因为每次只比前一项多一点点，所以递增应该是连续的，这之间并没有漏掉没用到的高度
所以加到比前一项多1的做法既保证了与之前所有项都不相同，又保证了到目前为止`+1`操作都是尽量少的，所以结束遍历时，累计的操作数对于整个数组来说也是最少操作

### 代码

```java
class Solution {
    public int minIncrementForUnique(int[] A) {
        Arrays.sort(A);
        int res = 0;
        for(int i=1; i<A.length; i++) {
            if(A[i-1] >= A[i]) {
                res += A[i-1] - A[i] + 1;
                A[i] = A[i-1] + 1;
            }
        }
        return res;
    }
}
```