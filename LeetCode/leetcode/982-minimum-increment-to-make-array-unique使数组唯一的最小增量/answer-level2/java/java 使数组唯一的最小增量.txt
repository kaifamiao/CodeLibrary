思路：
由于 A[i] 的范围为 [0, 40000)，可以用数组统计出每个数出现的次数，然后对于每个重复出现的数，暴力地将它递增，直到它增加到一个没有重复出现的数为止。但这样的方法的时间复杂度较大，可以达到 O(N^2)，例如数组 A 中所有元素都是 1 的情况。

因此，不能对重复出现的数暴力的进行递增，而是用以下的做法：当找到一个没有出现过的数的时候，将之前某个重复出现的数增加成这个没有出现过的数。注意，这里 「之前某个重复出现的数」 是可以任意选择的，它并不会影响最终的答案，因为将 P 增加到 X 并且将 Q 增加到 Y，与将 P 增加到 Y 并且将 Q 增加到 X 都需要进行 (X + Y) - (P + Q) 次操作。

例如当数组 A 为 [1, 1, 1, 1, 3, 5] 时，发现有 3 个重复的 1，且没有出现过 2，4 和 6，因此一共需要进行 (2 + 4 + 6) - (1 + 1 + 1) = 9 次操作。


算法

首先统计出每个数出现的次数，然后从小到大遍历每个数 x：

如果 x 出现了两次以上，就将额外出现的数记录下来（例如保存到一个列表中）；

如果 x 没有出现过，那么在记录下来的数中选取一个 v，将它增加到 x，需要进行的操作次数为 x - v。

还可以对该算法进行优化，使得不需要将额外出现的数记录下来。还是以 [1, 1, 1, 1, 3, 5] 为例，当发现有 3 个重复的 1 时，先将操作次数减去 1 + 1 + 1。接下来，当发现 2，4 和 6 都没有出现过时，依次将操作次数增加 2，4 和 6。这种优化方法在方法二中也被使用。
