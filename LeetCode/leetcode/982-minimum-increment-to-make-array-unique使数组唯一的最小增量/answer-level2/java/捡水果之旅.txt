### 代码

```java
/**
 * 思路 1：计数排序
 *
 * 先将所有的数字放入 [0, 40000] 的数组中，然后假设数组中的每个数字代表每一步的地上有多少个水果，有个背包用于装水果，初始为 0。
 *
 * 接着从下标 0 开始向前走，遇到地上 1 个水果则继续走，遇到大于 1 个水果则只留 1 个在地上，剩下的装进背包，
 * 如果地上没有水果，则看看背包有没有多余的水果，有的话就拿走一个放在地上。就这样一直走到下标 40000 处。
 *
 * 如果最后背包里还有 n 个水果，则依次放在 40001 40002 ... 40000+n 处。
 *
 * 规定：背着 1 个水果走一步消耗能量 1，那么最后消耗的总能量就是题目要求的最少操作次数。
 *
 * 执行用时 :6 ms, 在所有 Java 提交中击败了95.94%的用户
 * 内存消耗 :46 MB, 在所有 Java 提交中击败了92.16%的用户
 */
class Solution {
    /**
     * 给定整数数组 A，每次 move 操作将会选择任意 A[i]，并将其递增 1。
     *
     * 返回使 A 中的每个值都是唯一的最少操作次数。
     *
     * 提示：
     *  0 <= A.length <= 40000
     * 0 <= A[i] < 40000
     *
     * 来源：力扣（LeetCode）
     * 链接：https://leetcode-cn.com/problems/minimum-increment-to-make-array-unique/
     * 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
     *
     * @param A 整数数组
     * @return 使 A 中的每个值都是唯一的最少操作次数。
     */
    public int minIncrementForUnique(int[] A) {
        int[] dict = new int[40001];

        // 先将所有的数字放入 [0, 40000] 的数组中
        for (int a : A) {
            dict[a]++;
        }

        // 消耗的能量，或者操作次数
        int ans = 0;
        // 背包里水果的个数，或者有冲突的值的个数
        int bag = 0;

        // 遍历计数数组
        for (int num : dict) {
            // 地上没有水果，但包里也没有
            if (num == 0 && bag == 0) continue;
            // 背着背包里的水果走了一步
            ans += bag;
            // 地上没有水果，从背包中拿出一个
            if (num == 0) bag--;
            // 地上很多水果，将多余的水果装入背包
            else if (num > 1) bag += (num-1);
            // 地上只有一个水果的时候，什么都不用做
            // else
        }
        // 到 40000 时还有剩余，需要消耗 bag + (bag-1) + (bag-2) + ... + 1 的能量，利用等差数列求和
        if (bag != 0) {
            ans += (bag+1)*bag >> 1;
        }

        return ans;
    }
}

```