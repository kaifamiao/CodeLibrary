第一步是排序，从小到大。

然后需要明确一个事实，a<b<c，如果a重复了，并且只有增加到c才保证不重复，那么从a直接增加到c的增加次数，和先从a增加到b，然后b重复了，再从b增加到c，所用的增加次数是一样的。即，c-a = b-a+c-b。所以，增加的过程不重要，只要注重最后得到的结果就行，确保增加后的数组数字的总和，与A的数字总和差最小就行了。

对于已经从小到大排序的数组，其和最小应该就是从最小的那个元素，也就是第一个元素，不断连续到最后一个元素，举个例子，从1开始，那么1,2,3,4,5...是和最小的排列。所以对于[1,1,1]来说，增加到[1,2,3]是最好的情况。但是如果是[1,1,1,a]的话，如果a不大于3，那么应该增加到[1,2,3,4]，都是后一个元素等于前一个加1；如果a比3大，那结果就是[1,2,3,a].

所以，在对排序后的A进行遍历时，如果，A[i] <= A[i-1]，那么我们只需把A[i]增加到A[i-1]+1即可。


```Python
class Solution:
    def minIncrementForUnique(self, A: List[int]) -> int:
        # 排序
        A.sort()
        res = 0
        for i in range(1, len(A)):
            # 如果后一个数不比前一个大
            if A[i] <= A[i - 1]:
                # 则增加后一个数，使得其比前一个数大一
                res += A[i - 1] - A[i] + 1
                A[i] = A[i - 1] + 1
        return res
```
