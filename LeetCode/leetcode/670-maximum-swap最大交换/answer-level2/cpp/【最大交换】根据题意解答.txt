### 分析
题目中最重要的一个要求，只交换一次。
分析这个条件，得出的结论：
1. 把**原数字**所有**数字**都拿出来，按照从大到小排序，就得到了一个**排序数组**。
> **原数字**是指输入的数字。
> **数字**的意思是拆解成每一位，0-9的单个数字。
2. 如果没有只能交换一次的要求，那么按照**排序数组**的顺序进行组合，就能重新组合出最大数。
3. 但是只能交换一次，所以可以交换的只有两个**数字**。
4. 前面的**数字**，从前往后找第一个不是剩余最大的。后面的**数字**，从后往前找第一个剩余最大的。
   > 比如 8 5 6 7。
   > 从前往后，8 是剩余最大的，第二个数字应该是 7，所以 5 就不是剩余最大的。
   > 然后从后往前找，找到 7，是第一个剩余最大的。
   > 交换 5 和 7。
   41. 那么把需要交换的这两个**数字**，前面（左边，高位）的那个位置（索引）叫做 A；后面（右边，低位）的那个位置（索引）叫做 B。
   42. 按照从前往后的顺序，将**原数字**和**排序数组**中的**数字**进行一一比较，找到第一个不相等的数字。
   43. 那么**原数字**中的这个位置就是 A ，**排序数组**中的数值，T。
   44. 再将**原数字**按照从后往前的顺序，查找第一个等于 T 的位置，就是 B。
5. 交换 A 和 B，得到最大数。

举几个例子：
```
输入： 8  7  6 [2] 4  3 [5] 1
排序： 8  7  6 (5) 4  3  2  1
输出： 8  7  6  5  4  3  2  1
```

```
输入： 8  8 [1] 8  1  1 [8] 1
排序： 8  8 (8) 8  1  1  1  1
输出： 8  8  8  8  1  1  1  1
```

```
输入： 8  7  6 [2] 1  3 [5] 4
排序： 8  7  6 (5) 4  3  2  1
输出： 8  7  6  5  1  3  2  4
```


### 思路
1. 转成字符串
2. 再复制成一个char数组，从大到小排序
3. 这样依次比较下来，就能找到第一个不是剩下数字中最大的数，和他的位置
4. 从后往前查找这个数，得到他的位置
5. 交换
6. 转成数字输出

### 答题
```C++
int maximumSwap(int num)
{
	// 转换为字符串，并切割成数组，然后从大到小排序
	string ss = to_string(num);
	vector<char> vc;
	for (auto c : ss) vc.push_back(c);
	sort(vc.rbegin(), vc.rend());

	// 从前往后找需要交换的数字
	size_t i = 0;
	while (ss[i] == vc[i])
	{
		// 如果没有找到需要交换的表示已经是最大数了
		if (++i == ss.size()) return num;
	}

	// 从后往前找需要交换的数字
	size_t j = ss.find_last_of(vc[i]);

	// 交换
	swap(ss[i], ss[j]);
	return stoi(ss);
}
```

### 一些细节变更
思路一样，但是不使用char数组，不用给char数组排序。  
使用int[10]，记录每个数字的个数。  
找前面的数的时候，控制会麻烦一点。  
> 但是实际上这道题最多8个数字，差别不大。  

```C++
int maximumSwap(int num) 
{
	string ss = to_string(num);
	vector<int> cnts(10, 0);
	for (auto c : ss) cnts[c - '0']++;

	size_t i = cnts.size() - 1;
	size_t j = 0;
	while (true)
	{
		if (cnts[i] == 0)
		{
			i--;
			if (i >= cnts.size()) return num;
			continue;
		}
		if (j < ss.size() && ss[j] - '0' != i) break;
		cnts[i]--;
		j++;
	}

	size_t k = ss.size() - 1;
	while (k < ss.size())
	{
		if (ss[k] - '0' == i) break;
		k--;
	}

	swap(ss[j], ss[k]);
	return stoi(ss);
}
```



### 致谢
感谢您的观看，希望对您有帮助，欢迎热烈的交流！  

[我的leetcode](https://github.com/AhJo53589/leetcode-cn)

