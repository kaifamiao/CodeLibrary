作为新手，看到这个题目，首先想到的是**冒泡排序**，只要遇到0，就把0一直往后挪动，这个复杂度是**O(n^2)**。

看完题解第一次知道了**双指针**这个方法，复杂度是**O(n)**,自己还是太年轻了:)

记录一下，嘿嘿

方法：
1.把非0往前移动
```
// j 起始位置是0，慢指针，用于记录非0元素要移动的目标位置
// 移动之后 j 就需要标记下一次非0要移动的目标位置，此时，j和j以前的元素已经完成了处理，所以j就往后移动 j++；
            if (nums[i] != 0) {
                nums[j] = nums[i];
            }
            j++;
```
2.补齐0元素
```
//在 1 中移动非0的时候，如果不进行操作，就需要再开一个循环来补上剩余的0
    while (j < nums.size()) {
        nums[j++] = 0;
    }
```
但是我想在一个循环里完成:)

在移动完非0之后，原来非0的位置，也就是 sums[i],就没有了意义，这时候使sums[i] = 0;这样就确保了0会一直在非0的后面

但是当数组为{1，2，3，5}，也就是j和i指向同一个数的时候就出现问题，这时候只要判断 j和i是否指向同一个元素即可，如果 j != i

就 nums[i] = 0;
```
            if (nums[i] != 0) {
                nums[j] = nums[i];
                if(j != i) nums[i] = 0;
                j++;
            }
```
**废话了那么多完整代码如下**

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int j = 0;
        for (int i = 0;i < nums.size(); i++) {
            if (nums[i] != 0) {
                nums[j] = nums[i];
                if(j != i) nums[i] = 0;
                j++;
            }
        }
    }
};
```
如有不当之处请各位大佬指正:)


