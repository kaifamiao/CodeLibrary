## 思路

### 缓存满足条件的最大索引
- 使用HashMap(key——字母为key,value——字母在chars中的最大索引值).
- 利用indexOf(string,startIndex),确定字母下一个出现有效位置.
- 返回结果不等于-1,则记录最新的索引到HashMap,累加有效字母数量;结果等于-1,则跳出本次循环.
- 判断有效字母数量是否等于单词长度,等于,则累加结果.
- 缺点:计算时间/内存利用都不理想.
- 优点:方法使用场景广.

### 利用ASCII码差值,生成字典数组
- 定义两个长度均为26的整形数组:dicArr——记录chars中字符出现的次数、indexArr——记录每个单词中字符出现的次数.
- 利用a-z的ASCII码的差值作为数组索引,例:char-'a'.
- 遍历words数组,每次将indexArr进行清零.遍历单词的每个字母,indexArr[char-'a']累加.
- 判断dicArr中对应数量是否大于等于indexArr中的数量,如不满足条件,则跳出本次循环;满足条件,则累加结果.
- 缺点:适用范围有限,前提需明确字典的范围.
- 优点:利用数组索引,提升处理速度.

## 注意

1. String的toCharArray()是生成一个新数组返回.如果只为遍历字符,可利用charAt(index)代替,直接读取String.value对应的字符.
2. String的indexOf()也是遍历String.value,考虑具体的使用场景再使用.
3. 数组的索引检索,比Map的key检索有优势,尽可能利用.
4. 考虑应用场景是否可穷举,可提升方法的处理效率.
