![1585315505(1).png](https://pic.leetcode-cn.com/ca02b7dcf776d9312db6af2ee4673d965f64cba9595b69c7b0d31937ad52b966-1585315505\(1\).png)

```
class Solution {
    public int sumNums(int n) {
        return
        ((((n+1)&(0-((n>>>13)&1)))<<13)+
        (((n+1)&(0-((n>>>12)&1)))<<12)+
        (((n+1)&(0-((n>>>11)&1)))<<11)+
        (((n+1)&(0-((n>>>10)&1)))<<10)+
        (((n+1)&(0-((n>>>9)&1)))<<9)+
        (((n+1)&(0-((n>>>8)&1)))<<8)+
        (((n+1)&(0-((n>>>7)&1)))<<7)+
        (((n+1)&(0-((n>>>6)&1)))<<6)+
        (((n+1)&(0-((n>>>5)&1)))<<5)+
        (((n+1)&(0-((n>>>4)&1)))<<4)+
        (((n+1)&(0-((n>>>3)&1)))<<3)+
        (((n+1)&(0-((n>>>2)&1)))<<2)+
        (((n+1)&(0-((n>>>1)&1)))<<1)+
        ((n+1)&(0-(n&1))))>>>1;
    }
}
```

因为题目设定n<10000，n可能的最大拆分项为2^13=8192，问题是如何确定2的0-13次幂什么时候需要。比如11=8+2+1，只需要2的0、1、3次幂，所以要保证我们在加上其他次幂时无效。举例：(n>>>3)&1可以通过结果判断n的二进制第3位是0或者1，(0-((n>>>3)&1))可以决定此次相加是否有效，如果有效(0-((n>>>3)&1))=-1，然后(n+1)&(-1)=(n+1)还是其本身,再通过左移3位实现×8的效果，如果无效(0-((n>>>3)&1))=0，(n+1)&0=0,此时在左移3位，结果还是0.
