## 105.从前序与中序遍历序列构造二叉树
[原题链接](https://leetcode-cn.com/problems/maximum-binary-tree-ii/)
**这里我给出比较精简的题目说明**

最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。

给出最大树的根节点 ```root```。
> A是中序遍历的结果，B是加入 val 之后中序遍历的结果

之后给你一个新的元素 ```val```，要求你将这个元素加在 **中序遍历** 这个结果的尾部。求出构成的树。

### 要点
中序遍历的过程 **左 中 右**，当我们这个```val```加入到中序遍历的末尾，那么它一定是在 **根节点或者根节点的右子树** 的某个根节点。
**举个例子(中序遍历的结果)：** 
```
A = [2,1,5,3]  
```
根节点为 **5** 的时候才能满足大于左右两侧的任何值
很明显此时新加入一个元素到末尾，这个值肯定是在以5为根节点其右侧。

**证明过程:**
那么假如 我们假如末尾假如一个 **4** 呢?
此时右侧应该构成 以 **4** 为根节点的子树。

那么假如 我们假如末尾假如一个 **1** 呢?
此时右侧应该构成 以 **3** 为根节点的子树。然后 **1** 处在 **3** 的右侧

你能发现 新加入的```val```总会处在某个结点的右侧。
### 解法
也就说我们已经知道了新的节点处在 **以根节点往右这条路径上的某个位置** 。
还有一种情况就是新加入的```val```是最大的值，那麼整个```val```的左侧元素都是位于左子树。

那么如果现在你将这两种情况合并呢？其实就是在 **以根节点到最右侧节点找到一个合适的位置插入该元素** 。
#### 代码片段
```java
public TreeNode insertIntoMaxTree(TreeNode root, int val) {
	TreeNode head = new TreeNode(0);//1.创建一个头结点
	head.right = root;//1.1. 构成从头结点到最右侧节点的一条路径。
	TreeNode pre = head;//2.记录上一个节点，方便你知道在哪个位置插入元素
	TreeNode cur = root;//3.记录当前节点
	while (cur != null && cur.val > val) {//4.找到一个合适的插入位置，此时 cur.val < val , 也就 val元素应该插入的位置 位于 pre 与 cur 之间。
		pre = cur;
		cur = cur.right;
	}
	TreeNode node = new TreeNode(val);//5.创建这个节点。
	node.left = cur;//6.在第4步提到了 val 位于 pre 与 cur 之间，所以 val> cur.val ,也就是说 cur 这个节点在 val元素节点的左侧。
	pre.right = node;//7.val<pre.val 在右侧。
	return head.right;//8. 头结点是不需要保留的，头结点就是条牵引绳，用完了当前就先扔一边去了。
}
```
#### 代码解释
1. 创建头结点的意义：让整条查找路径构成一条直线，便于查找。否则根结点难以理解是在左边还是右边。
---
## 结尾 
##### [1.博客地址](https://blog.csdn.net/weixin_42322309)
##### [2.源代码仓库](https://gitee.com/Gre-Z/Algorithm")
> 如果你在代码里看到了用 数字标记的注释 如 //1.xxx 这是我写代码的顺序，希望能给你一点启发。