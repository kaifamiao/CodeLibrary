golang ，动态规划思路：
执行用时 : 0 ms , 在所有 golang 提交中击败了 100.00% 的用户。
内存消耗 : 2.8 MB , 在所有 golang 提交中击败了 78.72% 的用户。
时间复杂度 ：O(n)

dp作用 ：存储 s 中的 以第 i 个元素为结尾的当前最长有效子字符串的长度。例 ：s ：= “()()”,df : {0 , 2 , 0 , 4} , df[3] = 4. 就是我们处理第i 个点 做逻辑判断的依据。
思路，当字符串以 ')' 结尾才是有效的 , 所以当s[i] == ')', 判断：
    1：如果 s[i-1] == '('
    2：如果 s[i-1] == ')' , 此时我们需要知道 第 i-1在df 中所对应的有效长度,也就是之前的最长有效长度，我们再加上 2 ，就是当前点的有效长度，并更新dp 中对应的元素的值。
    3: 要注意，1， 2 两种情况，都要注意同级别，例子 ：
        1): ()() : dp[3] = dp[1] + 2 (2是指 '(',')'有效长度)
        2): (()())(()()) : dp[11] = dp[10] + 2 + dp[5]:
                dp[10]: s[11]之前的最长右线长度（注意 例子中是 从 s[6]开始 ）

```
func Solution(s string) int {
	length := len(s)
	dp := make([]int , length , length)
	var max int
	for i := 0 ; i < length ; i++ {
		if s[i] == ')' {
			if i >= 1 && s[i - 1] == '(' {
				if i >= 2 {
					dp[i] = dp[i - 2] + 2
				}else {
					dp[i] = 2
				}
			}else {
				if i - 1 >= 0 && i - dp[i - 1] - 1 >= 0 && s[i - dp[i - 1] - 1] == '(' {
					if i - dp[i - 1] - 2 >= 0 {
						dp[i] = dp[i -1] + 2 + dp[i - dp[i - 1] - 2]
					}else {
						dp[i] = dp[i -1] + 2
					}
				}
			}
			if max == 0 || max < dp[i] {
				max = dp[i]
			}
		}
	}
	return max
}
```



