执行用时 :4 ms, 在所有 C++ 提交中击败了98.94%的用户

内存消耗 :9.1 MB, 在所有 C++ 提交中击败了97.46%的用户

首先肯定可以用dp，很容易想到的O(n^2)，保存两个下标之间的有效长度，不赘述。

看题的时候觉得可以用贪心做，大概过程是：
1. 遍历一遍找最长的合法串，如果出现右括号多于左括号了就重新开始。下文将这种下标称为重置点。
2. 有可能出现到结束为止左括号比右括号多的情况，这种时候就要往回查找了。
3. 在这里我犯了一个错误，是从右侧开始查找到第一次“左括号多于右括号”时结束，看此时的有效长度是否超过从左到右遍历的最大长度，导致了两次wa。待会会分析这个问题。
4. 改为从右到左也遍历完整的串，正确。

到这里我还是不确定这个贪心算法是正确的，即这个局部最优解一定是全局最优解。于是又想了想，发现是容易证明的。即：

**对任何一个在该规则下会重置的下标，都不存在包含它的合法串。**

首先排除掉字符串最左侧所有连续的')'和最右侧所有连续的'('。
考虑由左到右的情况，假设存在一个下标t及区间[x1,x2]使这个区间合法，且x1<t<=x2。(t一定是')' 所以t > x1)
由于是存在性假设且s长度有限，可以另外假设t是大于x1的第一个重置点。
可知[x1,t)区间内'('数量大于')'否则区间不合法。
设t之前最近的一个重置点t0(若不存在则t0=-1), 可知(t0, t)区间内'('数量等于')'否则在t处不会重置。
t0 < x1, ∴(t0,x1)区间内')'数量大于'('，这和区间内不再有重置点矛盾。
同理可知，从右到左遍历时，一样不存在符合要求的重置点。

为什么在从右向左只遍历到出现第一个重置点时结束会出现问题呢？其实就是因为从右向左的第一个重置点并不是从左向右的最后一个重置点，只遍历到这里并不能解决从左向右遍历时最后一个重置点之后的字符串中最大合法串的问题。
反例很好写，比如'(((())(()'

**并且：可以将反向遍历优化为只遍历到正向的最后一个重置点。证明略**

Code:
```cpp []
class Solution {
public:
    int longestValidParentheses(string s) {
        int sz = s.size();
        int maxlen = 0;
        int curhigh = 0;
        int lastreset = -1;
        int lastresetr = sz;
        for(int i = 0; i < sz; ++i)
        {
            if(s[i] == '(')
                ++curhigh;
            else
                --curhigh;
            if(curhigh == 0)
            {
                if(i - lastreset > maxlen)
                    maxlen = i - lastreset;
            }
            if(curhigh < 0)
            {
                lastreset = i;
                curhigh = 0;
            }
        }
        curhigh = 0;
        if(lastreset == -1)
            lastreset = 0;
        for(int i= sz - 1; i >= lastreset; --i)
        {
            if(s[i] == '(')
                --curhigh;
            else
                ++curhigh;
            if(curhigh == 0)
            {
                if(lastresetr - i > maxlen)
                    maxlen = lastresetr - i;
            }
            if(curhigh < 0)
            {
                lastresetr = i;
                curhigh = 0;
            }
        }
        return maxlen;
    }
};
```
