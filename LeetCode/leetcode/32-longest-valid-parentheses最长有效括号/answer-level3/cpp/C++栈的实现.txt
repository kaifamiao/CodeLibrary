### 解题思路
代码是最终的思路的代码，但一开始不是这样的思路。
一开始我的思路是这样的：是用一个vector作为栈，里面放的是pair<char, int>，分别存放字符和它在源字符串上的位置。在遍历时：

遇到“(”就把它及下标放在栈里。
遇到“)”就看看栈顶是否是“(”：
     匹配的话就pop它。
     不匹配的话就把它和下标也放在栈里。
这样的话，假设源字符串是“()()))((())(”，遍历完之后栈里就剩下了“))((”，他们的index分别是4,5,6,11，也就是说，能配对有效的都被“抽走”了，剩下的就是无法配对的字符。所以遍历栈中剩下的这些元素的index，他们空缺的长度（注意两端还有0和源字符串的最后一位）最大值就是答案。

第一次提交的就是这样的思路的代码，发现运行效率不高，打败了30%，因为里面每次push都会make_pair产生一个pair对象，用的内存也很大，毕竟存的东西比较多。后来看了官方题解，才得知，其实这个思路可以不用在栈里存放元素本身，只需要存放index就行。

关键要理解的是，碰到“)”也直接pop栈里的元素，无需关注它和栈顶元素是否配对。为什么可以这样做？

当遇到“(”我们都入栈。当遇到一个“)”，我们执行pop_back()，要么弹出的是个“(”恰好和“)”配对，要么弹出的是个很久的“)”。

由于我们把“)”入栈的前提条件是栈中为空，才会入栈，所以栈里出现“)”那么它一定会在栈底。

如果栈里只有一个“)”且连续碰到“)”时我们处理的方式是保持栈里只有一个“)”（pop出里面的，入栈新的）。
栈里可能出现的情况如下：“)”，“)(”，“)((((”，“((((”, “-1”。

在pop的过程中，栈顶第二个元素为第一个元素指代它前面的计算边界。用遍历到的i减去这个边界，就是中间空缺的长度，也就是成功配对的长度。

当最后一个“(”被匹配成功，那么栈底的“)”就指定了这个左边界，参与本次最大长度的计算。
如果再来一个“)”，就替换了栈底的“)”，因为对于原来的栈底的“)”来说，再来一个新“)”时，它已经没用了，新的有效长度只会从新碰到的“)”开始计算。
这样后来的长度的计算变成了自己减自己，无关最大长度的影响，但边界推进到了新的“)”的下标。

以后再发生pop就用这个下标作为边界去计算长度。
在遇到第一个“)”入栈之前，我们用-1来代替。

### 代码

```cpp
class Solution {
public:
    int longestValidParentheses(string s) {
        if (s.size() == 0) {
            return 0;
        }
        vector<int> stack;
        stack.push_back(-1);

        int longest = 0;
        for (int i = 0; i < s.size(); ++ i) {
            if (s[i] == '(') {
                stack.push_back(i);
            }
            else {
                stack.pop_back();
                if (stack.empty()) {
                    stack.push_back(i);
                }

                if (i - stack.back() > longest) {
                    longest = i - stack.back();
                }

            }
        }
        
        return longest;
    }
};
```

![微信图片_20191231145430.png](https://pic.leetcode-cn.com/3db338d48b5328dd4b0415de943c7e333f25a60820580bf42e4ccd1a432de853-%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20191231145430.png)

