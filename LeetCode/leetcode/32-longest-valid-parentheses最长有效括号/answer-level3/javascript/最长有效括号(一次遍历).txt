```
/**
 * @param {string} s
 * @return {number}
 */
var longestValidParentheses = function (s) {
    var max = 0, arr = [], l = 0;
    for (let i = 0; i < s.length; i++) {
        if ((arr.length == 0 || arr[arr.length - 1] < 0) && s[i] == ")") {
            arr.push(-1);
            max = Math.max(max, l);
            l = 0;
            continue;
        }
        if (s[i] == ")") {
            l = l + 2 + arr[arr.length - 1];
            max = Math.max(max, l);
            arr.pop();
        }
        else {
            arr.push(l);
            l = 0;
        }
    }
    return max;
};

/**
 * 思路：
 * 
 * 引用数组栈，记录每个"("前对应的有效括号数：
 * l=0记录"("前的有效括号数
 * 
 *  " ) ) ( ) ( ) ( ) ( ( ) ( ) ( ( ) ( ) ) ) "  
 * 
 * 在数组中，-1代表的是")",大于等于0的数代表"("
 * 
 *  i=0 ==> s[i]等于")"  数组：[-1]
 *  i=1 ==> s[i]等于")"  数组：[-1,-1]
 *  i=2 ==> s[i]等于"("  数组：[-1,-1,0] 在这之前出现的有效括号长度为l=0
 *  i=3 ==> s[i]等于")"  数组：[-1,-1] 出现了")",并且数组最后一位是0,删除数组最后一位,l=l+2+0数组随后一位的值(有效括号长度)
 *  i=4 ==> s[i]等于"("  数组：[-1,-1,2] 在这之前出现的有效括号长度为l=2，再将l置为0
 *  i=5 ==> s[i]等于")"  数组：[-1,-1] 出现了")",并且数组最后一位是2,删除数组最后一位,l=l+2+2数组随后一位的值(有效括号长度)
 *  i=6 ==> s[i]等于"("  数组：[-1,-1,4] 在这之前出现的有效括号长度为l=4，再将l置为0
 *  i=7 ==> s[i]等于")"  数组：[-1,-1] 出现了")",并且数组最后一位是4,删除数组最后一位,l=l+2+4数组随后一位的值(有效括号长度)
 *  i=8 ==> s[i]等于"("  数组：[-1,-1,6] 在这之前出现的有效括号长度为l=6，再将l置为0
 *  i=9 ==> s[i]等于"("  数组：[-1,-1,6,0] 在这之前出现的有效括号长度为l=0，再将l置为0
 *  i=10 ==> s[i]等于")"  数组：[-1,-1,6] 出现了")",并且数组最后一位是0,删除数组最后一位,l=l+2+0数组随后一位的值(有效括号长度)
 *  i=12 ==> s[i]等于"("  数组：[-1,-1,6,2] 在这之前出现的有效括号长度为l=2，再将l置为0 
 *  i=13 ==> s[i]等于")"  数组：[-1,-1,6] 出现了")",并且数组最后一位是2,删除数组最后一位,l=l+2+2数组随后一位的值(有效括号长度)
 *  i=14 ==> s[i]等于"("  数组：[-1,-1,6,4] 在这之前出现的有效括号长度为l=4，再将l置为0
 *  i=15 ==> s[i]等于"("  数组：[-1,-1,6,4,0] 在这之前出现的有效括号长度为l=0，再将l置为0
 *  i=16 ==> s[i]等于")"  数组：[-1,-1,6,4] 出现了")",并且数组最后一位是0,删除数组最后一位,l=l+2+0数组随后一位的值(有效括号长度)
 *  i=17 ==> s[i]等于"("  数组：[-1,-1,6,4,2] 在这之前出现的有效括号长度为l=2，再将l置为0
 *  i=18 ==> s[i]等于")"  数组：[-1,-1,6,4] 出现了")",并且数组最后一位是2,删除数组最后一位,l(4)=l+2+2数组随后一位的值(有效括号长度)
 *  i=19 ==> s[i]等于")"  数组：[-1,-1,6] 出现了")",并且数组最后一位是4,删除数组最后一位,l(10)=l+2+4数组随后一位的值(有效括号长度)
 *  i=19 ==> s[i]等于")"  数组：[-1,-1,6] 出现了")",并且数组最后一位是4,删除数组最后一位,l(18)=l+2+6数组随后一位的值(有效括号长度)
 * 
 * 注意：如果数组长度为0或者是数组最后一位小于0时，需要特殊处理")"
 * 1.将")"对应保存为"-1",有个特点：无论后面出现什么符号，只要被-1截断的有效括号，永远不可能再进行合并
 * 2.这时必须要将此时的有效括号长度与最长长度的临时变量max比较，如果比max大，则要更新max。
 * 
 * 当s被遍历完成后，有个特点是：
 *  要么最大值是max：每次数组长度为0或者是数组最后一位小于0时,被")"截断时记录的最长有效括号长度。
 * 
 *  要么最大值是l：
 *      最后一位刚好是")"时，l是最大值，且不会记录到数组中
 *      最后一位是"(",那么最大值会存入数组，且和l相同
 * 
 *  最后将max和l进行比较就能得出包含有效括号的子串的长度Math.max(max,l)
 * 
 *  时间复杂度O(n)
 */
```
