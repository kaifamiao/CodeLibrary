# 562 矩阵中最长的连续1线段
1. 1维只有一个水平方向，更好理解，我们可以将题目中的2维矩阵降为1维，求M[n]连续1线段的最大长度；用dp(i)表示第i个点的最长连续1的值，该值有两种情况：
- 1) M[i] = 0时，不论前0...i-1是什么值，由于第i点为0，都不可能满足连续1的条件，转化为方程：dp(i)=0;
- 2) M[i] = 1时，第i点的连续1也就等于它前一个点（i-1）的连续1的值 + 1，转化为方程：dp(i) = dp(i-1) + 1;
- 3) 根据状态转移方程，可以看出i=0时是一个边界值：dp(i-1) = dp(-1)，M[-1]并不存在，意味着没有连续1的线段，因此dp(-1) = 0;
     当M[0] = 0时，dp(0) = 0;M[0] = 1时，dp(0) = dp(-1) + 1;所以边界值dp(0) = M[0];
```
        int ans = 0;
        int[] dp = new int[n];
        dp[0] = M[0];
        for(int i = 1;i<n;i++){
            if(M[i] == 1){
                dp[i] = dp[i-1] + 1;
            }
            ans = Math.max(ans,dp[i]);
        }
        return ans;
```
- 对于边界值的处理，还有一个方法：将dp长度定义为n+1；从1开始循环，就不用对dp(0)进行单独定义，代码如下：
```
        int ans = 0;
        int[] dp = new int[n+1];
        for(int i = 1;i<=n;i++){
            if(M[i-1] == 1){
                dp[i] = dp[i-1] + 1;
            }
            ans = Math.max(ans,dp[i]);
        }
        return ans;
```
2. 下来我们来考虑2维情况，根据1维的思路，可以使用dp(i)(j)表示第i,j点在水平方向的最长连续1的值，类似的，水平场景下的2维状态转移方程如下：
- M[i][j] = 0 : dp(i)(j) = 0;
- M[i][j] = 1 : dp(i)(j) = dp(i)(j-1) + 1;
   题目中有4个方向（水平，垂直，对角线，反对角线），方向也是一个状态变化点，我们可以引入第3维，用于表示方向上的变化:
- 水平方向上第i,j点最大连续1的值：dp(i)(j)(0)
- 垂直方向上第i,j点最大连续1的值：dp(i)(j)(1)
- 对角反向上第i,j点最大连续1的值：dp(i)(j)(2)
- 反对角线上第i,j点最大连续1的值：dp(i)(j)(3)
   通过水平方向，我们知道，M[i][j] = 1时 dp(i)(j) 等于在该方向上前一个点的dp(i)(j-1) + 1；同样的其他方向是一样的原理，它们之间只是方向的差异，不同方向，前一个点的下标如下：
 ![image.png](https://pic.leetcode-cn.com/1ab2430679675d57433101a903fe989d34c38b468367a2c00d0dda7297884c37-image.png)
   结合上图我们可以得到，不同方向上dp(i)(j)的状态转移方程：
- M[i][j] = 0 ：dp(i)(j)(0) = dp(i)(j)(1) = dp(i)(j)(2) = dp(i)(j)(3) = 0;
- M[i][j] = 1 :
-   水平方向：dp(i)(j)(0) = dp(i)(j-1)(0) + 1
-   垂直方向：dp(i)(j)(1) = dp(i-1)(j)(1) + 1
-   对角方向：dp(i)(j)(2) = dp(i-1)(j-1)(2) + 1
-   反对角线：dp(i)(j)(3) = dp(i-1)(j+1)(3) + 1
   边界值：通过状态方程可以看到：i = 0;j = 0;j = n-1,这3种情况都是边界值，方程式中的下标值超出了M的范围，按照1维的情况，这些情况下值都为0.
   我们采用扩充dp大小的方式来规避对这些边界值的单独定义，最终代码如下：
```
        int ans = 0;
        int rows = M.length;
        int cols = (rows > 0) ? M[0].length : 0;
        if (rows * cols == 0) return 0;
        int[][][] dp = new int[rows + 1][cols + 2][4];
        for (int i = 1; i <= rows; i++) {
            for (int j = 1; j <= cols; j++) {
                if (M[i - 1][j - 1] == 1) {
                    dp[i][j][0] = dp[i][j - 1][0] + 1;
                    dp[i][j][1] = dp[i - 1][j][1] + 1;
                    dp[i][j][2] = dp[i - 1][j - 1][2] + 1;
                    dp[i][j][3] = dp[i - 1][j + 1][3] + 1;
                    ans = Math.max(ans, Math.max(Math.max(dp[i][j][0], dp[i][j][1]), Math.max(dp[i][j][2], dp[i][j][3])));
                }
            }
        }
        return ans;
```
