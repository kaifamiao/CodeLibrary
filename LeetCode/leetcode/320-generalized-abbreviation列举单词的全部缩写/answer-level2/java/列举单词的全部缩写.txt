### 概要
这篇文章主要是写给中等水平的读者。它涉及到的算法包括：回溯和位操作。

#### 方法 1：回溯

**想法**

对于一个长度为 $n$ 的单次有多少种缩写？答案是 $2^n$ 种，因为每个字符可以被缩写或者不被缩写，都将导致不同的缩写。

**算法**

回溯算法穷举了问题一系列可能的部分候选串。抽象地说，部分候选串可以被看作是一棵潜在的搜索树的节点。每一个部分候选串都是某些候选串的父节点，树的叶子节点就是部分候选串没法继续扩展的结果。

部分候选串可以被扩展应该是以下两种情况之一：

1. 保留下一个字符
2. 将下一个字符缩写

我们按深度优先的顺序扩展所有的潜在候选串。当在搜索树中遇到一个叶子节点的时候开始回溯。搜索树中所有的椰子节点都是有效的缩写并被放到全局的列表中，以便最后返回。

```Java []
public class Solution {
    public List<String> generateAbbreviations(String word){
        List<String> ans = new ArrayList<String>();
        backtrack(ans, new StringBuilder(), word, 0, 0);
        return ans;
    }

    // i is the current position
    // k is the count of consecutive abbreviated characters
    private void backtrack(List<String> ans, StringBuilder builder, String word, int i, int k){
        int len = builder.length(); // keep the length of builder
        if(i == word.length()){
            if (k != 0) builder.append(k); // append the last k if non zero
            ans.add(builder.toString());
        } else {
            // the branch that word.charAt(i) is abbreviated
            backtrack(ans, builder, word, i + 1, k + 1);

            // the branch that word.charAt(i) is kept
            if (k != 0) builder.append(k);
            builder.append(word.charAt(i));
            backtrack(ans, builder, word, i + 1, 0);
        }
        builder.setLength(len); // reset builder to the original state
    }
}
```

**复杂度分析**

* 时间复杂度： $O(n 2^n)$ 。对于每一次 `backtrack` 调用，要么到达椰子节点，要么分支成两个回溯调用。所有这些回溯调用共同构成了一个 $2^n$ 的完全二叉回溯树，它有 $2^n$ 个叶子节点和 $2^n - 1$ 个内部节点。对于每个叶子节点，需要 $O(n)$ 的时间构建缩写字符串。对于每个内部节点，只需要常数级别的时间。因此，总时间复杂度由叶子节点决定，总共是 $O(n2^n)$ 。

* 空间复杂度： $O(n)$ 。如果不算上返回列表，我们只需要 $O(n)$ 的空间在 `StringBuilder` 中保存字符以及额外的 $O(n)$ 的系统栈空间。在回溯的题目中，系统栈空间跟最大回溯深度呈线性关系，此题中为 $n$ 。

#### 方法 2：位操作

**想法**

如果我们使用 $0$ 代表没有被缩写的字符， $1$ 代表缩写的单次。那么每一个缩写都对应到一个 $n$ 位的二进制数字，每一个二进制数字也对应一个缩写。

**算法**

为了无遗漏、无重复地产生所有 $2^n$ 个缩写，我们需要遵循如下的规则。在方法 1 中，规则提现在回溯的过程中。这里我们用另外一种方法。

在想法的部分我们知道，每一个缩写与 $n$ 位二进制数字 $x$ 一一对应，我们可以把这些数字作为参考去建立对应的缩写。

比方说：

给定单次 `"word"` 和 `0011`

这表示 `'w'` 和 `'o'` 被保留，而 `'r'` 和 `'d'` 被缩写了，所以最终结果是 `"wo2"` 。

因此，对于一个数字 $x$ ，我们只需要检查它的每一位，当做一个数组来处理，就可以知道哪些位应该被保留哪些位应该被缩写。

逐位检查数字 $x$ 的话，我们可以通过 `b = x & 1` 来获取最低位并将 $x$ 右移一位，也就是 `x >>= 1` 来去掉最低位。重复这个过程，我们就能得到 $x$ 从低到高每一位的数了。

```Java []
public class Solution {
    public List<String> generateAbbreviations(String word) {
        List<String> ans = new ArrayList<>();
        for (int x = 0; x < (1 << word.length()); ++x) // loop through all possible x
            ans.add(abbr(word, x));
        return ans;
    }

    // build the abbreviation for word from number x
    private String abbr(String word, int x) {
        StringBuilder builder = new StringBuilder();
        int k = 0, n = word.length(); // k is the count of consecutive ones in x
        for (int i = 0; i < n; ++i, x >>= 1) {
            if ((x & 1) == 0) { // bit is zero, we keep word.charAt(i)
                if (k != 0) { // we have abbreviated k characters
                    builder.append(k);
                    k = 0; // reset the counter k
                }
                builder.append(word.charAt(i));
            }
            else // bit is one, increase k
                ++k;
        }
        if (k != 0) builder.append(k); //don't forget to append the last k if non zero
        return builder.toString();
    }
}
```

**复杂度分析**

* 时间复杂度： $O(n 2^n)$ 。从 $x$ 得到每一位的值需要扫描一遍 $n$ 个位。除此以外， `StringBuilder::toString` 函数也是线性时间的。所以要得到所有的 $2^n$ 个数，总共需要 $O(n 2^n)$ 的时间。

* 空间复杂度： $O(n)$ 。如果不算返回列表，我们只需要在 `StringBuilder` 中使用 $O(n)$ 的空间。
