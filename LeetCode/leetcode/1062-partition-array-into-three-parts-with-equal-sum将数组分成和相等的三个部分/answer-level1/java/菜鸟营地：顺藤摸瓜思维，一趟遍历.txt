### 解题思路
![QQ图片20200311134924.png](https://pic.leetcode-cn.com/c4f41d05f33bdfbbc11d64b15df9e4c4e5a28a47419e25174fdefd041e38381d-QQ%E5%9B%BE%E7%89%8720200311134924.png)
下面是我刚拿到此题时立刻想到得思路：
1. 首先通过题目的条件，可以推想：若这一组数能够满足题目的要求，那么这一组数之和肯定会被3整除，否则，不合题意，返回false，这就是一个最抽象的框架，即先求和，作一次判断，满足进行后面的操作，不满足，直接返回false；
2. 当满足第一点条件之后，还要看这三组数从左往右能否分别连续地出现，而且至少要判断两组，因为如果只判断第一组，也有返回false的情况，如：A=[1,1,-1,1,4,0]，所以至少判断出两组的存在之后，第三组肯定存在。本题中也只需要判断两组就可；
3. 如何判断两组的存在：首先要根据数组之和求出每组的和each。数组从左往右进行遍历，这个地方要注意用作遍历的变量j的值，在找第一组时候的上限是A.length-2，小伙伴不妨在草稿纸上比划比划就可得出。当在范围内找到了第一组，就要立刻从当前j的下一个找第二组，这时的方法可以同找第一组的方法，设置变量来求和判断，只不过这个时候遍历变量j的上限有变化，变成A.length-1，原因很简单，小伙伴可以考虑考虑极端情况，即假设第二组是数组的倒数第二个数就可。另外，这个地方找第二组我用的是一个小技巧，我们已经可以得到第一组的和sum1==each了，可以直接利用sum1逆向作减的操作，判断结果是否有为0，这样一来就可以节省一个变量的空间了；
4. 这样一来，我们整体的逻辑思路就理清了。加上我们判断过程中需要使用的变量以及控制好变量的自增和结果的返回就可了。

### 不足之处
以上的分析方法也有不足之处：
1. 上述方法在分组较少的情况下适合，题中的分3组，小伙伴可以发现在下面代码中的嵌套已经有点复杂了；
2. 这是十分基础的方法，思维方式就是顺藤摸瓜，由所给信息一步一步分析；
3. 大家平时编码的时候也注意一些细节，有些操作是可以提升代码的执行用时和内存消耗的；
4. 若小伙伴们发现错误或者不足之处，欢迎指正，大家一起交流。

### 代码

```java
class Solution {
    public boolean canThreePartsEqualSum(int[] A) {
        int sum = 0;    //存放数组数之和
        int sum_1 = 0;     //存放判断过程中的数之和
        for (int i = 0; i < A.length; ++i) {    //求和
			sum+=A[i];
		}
        if (sum % 3 == 0) {         //若能被3整除，继续
            int each = sum / 3;     //each存放每组的和
            int j = 0;              //遍历遍变量
            while(j < (A.length-2)) {
                sum1 += A[j];
                if(sum1 == each) {
                    while(j+1 < (A.length-1)) {
                        sum2 += A[j+1];
                        if(sum2 == each){
                            return true;
                        }
                        ++j;    //第二组判断过程，后移
                    }
                }
                ++j;            //第一组判断过程，后移
            }
			return false;       //未找到，返回false
		} else {                //不能被3整除，直接返回false
			return false;
		}
    }
}
```