
### 解题思路
#### 哪怕交换的两个数不相同，也要考虑右边的数等值的数之前有没有被放到左边过。
借鉴大佬的代码和思路。
增加一点对去重的解释，记录一下。
例子：   adcad
这里面两个a，两个d。
从最开始，a与包括自己在内的后面各个字符交换。
每次交换之后的深度搜索，都意味着这个位置放这个字符的后面的所有情况都被遍历到，并且不重复。
也就是说，第一个字符放a，然后深度搜索，结果就是，第一个字符放a，后面的所有情况都被搜索到，完了之后，再交换的时候，必须保证第一个位置不会再被放上a。所以显然当程序尝试将第一个a和第二个a交换的时候，应该跳过。

重点来了：
### 当第一个a尝试与第二个d交换的时候，也是不可以的。因为第一个a已经和第一个d交换过了，也就是说，这个位置放d，已经考虑完了。

所以每当我们考虑当前位置和一个目标位置进行交换的时候，要考虑目标位置的数是否已经在这里放过了。如果放过来，显然不能继续再放。如何判断呢？因为我们是从左到右交换的，所以如果当前位置与目标数位置之间存在和目标位置等值的数，那么一定考虑过，也就是说一定不能交换。

### 这种方法的优点：
- 不需要排序
- 不需要额外空间
- 每次只是往后交换，而不需要考虑所有该位置可能存放的所有的数。（也就是说下标不是从0开始）
- 理解起来较为简单，可以用分类讨论的思想来证明其完备性。

在LeetCode47题中，关于去重的最高赞回答，采用的是**排序+额外标记数组**的方式来实现。可供参考。
但个人认为，本题解所述方法要可行得多。



### 代码

```cpp
class Solution {
public:
    vector<string> result;
    vector<string> permutation(string s) {
        dfs(s, 0);
        return result;
    }
    void dfs(string& s, int pos) {
        if (pos >= s.size()) {
            result.push_back(s);
            return;
        }
        for (int i = pos; i < s.size(); ++i) {
            if (judge(s, pos, i)) continue;   // 如果pos和i之间有字符等于s[i]，则跳过。
            // s： dbaca
            swap(s[pos], s[i]);
            dfs(s, pos+1);
            swap(s[pos], s[i]);
        }
    }

    bool judge(string& s, int start, int end) { // end指向右边的尝试交换的数。
        // 需要检查在此之前有没有与s[end]等值的数已经被放到start位置过。
        for (int i = start; i < end; ++i) {
            if (s[i] == s[end]) return true;
        }
        return false;
    }
};
```

后记：关于全排列去重问题，两个月前就想了好久好久，才算明白**排序+标记数组**的方式，两个月之后的现在，发现又完全不会了，凭自己感觉写出来的，总是不能全部通过，很气。

所以这里借鉴了大佬的解答，记录一下，我认为这个方法很好理解，退一步说，也更方便记忆啊，摔