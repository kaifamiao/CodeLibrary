值得一提的是，题目中所给出的设定**“假如手势中有两个点是顺序经过的，那么这两个点的手势轨迹之间是绝对不能跨过任何未被经过的点”**并没有明确说明，**什么样的点属于“顺序经过的两个点之间跨过的点”**。


例如，数字2和9之间穿越了数字5和6，但是由于穿越过程中，没有经过这两个数字所属格子的中心，所以5和6不算作被数字2和9跨过的点。

![微信截图_20191123074753.png](https://pic.leetcode-cn.com/f287730ef510161a8b6966d5f33fccbc738d2ff0fe97304a2bfb77b6d0d09c4c-%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123074753.png)

**换言之，数字2和9是可以直接互连的。**

**也就是说，只有当两个数字连接时，穿越了其他数字所在格子的中心时，被穿越的数字才被视为被跨过的点。**

在这个基础上我们可以看到，在遍历过程中，需要跨过点的数字对和其跨过的点为：
(1,3) -> 2   对应于   (3,1) -> 2
(1,7) -> 4   对应于   (7,1) -> 4
(1,9) -> 5   对应于   (9,1) -> 5
(2,8) -> 5   对应于   (8,2) -> 5
(3,7) -> 5   对应于   (7,3) -> 5
(3,9) -> 6   对应于   (9,3) -> 6
(4,6) -> 5   对应于   (6,4) -> 5
(7,9) -> 8   对应于   (9,7) -> 8

我们可以简单地建立列表，将上述点保存。也可以建立循环，可以发现，上述点的规律为**在九宫格中，两个数字的行数和列数至少有一个相差值为2，同时两数之和为偶数**


代码如下：

```
class Solution:
    def numberOfPatterns(self, m: int, n: int) -> int:
        '''
        dfs算法，带入的参数分别为：
        index: 上一次滑动经过的数字
        used: 数字的使用情况，由于题目于要求点不能重复，所以如果数字被使用过，则略过该情况
        limit: 保存数字滑动限制条件的列表
        num: 已经滑动的数字个数
        res: 计算结果
        m,n: 题目中提供的上下界

        dfs算法的一般流程为：
        1. 设置返回/终止条件，本题中终止条件为数字个数超过上界
        2. 考虑返回值，题目中的返回值为res
        3. 进行循环遍历，值得注意的是，每次遍历结束后，都应将条件初始化，防止影响下一次计算
        '''


        def dfs(index,used,limit,num,res,m,n):
            '''
            1. 设置终止条件：当num超过上界时，返回res值
            '''
            if num>n:
                return res

            '''
            2. 考虑当计算过程中的返回值，num在[m,n]之间时，res+1
            '''
            if m<=num<=n:
                res += 1

            '''
            3. 开始循环遍历，每次从[1,9]中选择一个数值作为下一步要经过的数字i，
            当这个数值未被使用过，且上一步经过的数字index与i之间需要经过的数字
            已经被使用过时，才进行循环。
            '''
            for i in range(1,10):
                if used[i] == False and used[limit[index][i]]==True:

                    # i被使用了，所以标记为使用过的数字
                    # 经过的数字数num也要相应+1
                    used[i] = True
                    num += 1

                    #开始循环
                    res = dfs(i,used,limit,num,res,m,n)

                    # 初始化条件，即i未被使用过
                    # 同时经过的数字数为原来的num
                    used[i] = False
                    num -= 1
            return res

        '''
        为了建立保存数字滑动限制条件的列表limit，首先要考虑每个数字在手机键盘中的位置
        '''    
        pos={}
        for i in range(1,10):
            pos[i] = [(i-1)//3,i-1-(i-1)//3*3]

        '''
        计算limit列表
        为了使数字与行列数一致，这里建立了一个10*10的列表，初始值为0
        列表中任意值limit[i][j]的含义为从数字i到j需要经过limit[i][j]
        如果limit[i][j]=0，说明两个数值可以直接到达
        也就是说默认used[0]=True
        '''
        limit = [[0]*10 for i in range(10)]

        for i in range(1,10):
            for j in range(i+1,10):
                x_i,y_i = pos[i]
                x_j,y_j = pos[j]
                
                #判断条件：九宫格中，两个数字的行数和列数至少有一个相差值为2，同时两数之和为偶数
                if (abs(x_i-x_j)==2 or abs(y_i-y_j)==2) and (i+j)%2==0:
                    limit[i][j] = (i+j)//2
                    limit[j][i] = (i+j)//2

        #所有值的初始化
        index = 0
        used = [True]+[False]*9
        num = 0
        res = 0
        res = dfs(0,used,limit,num,res,m,n)

        return res
```


也可以直接将limit初始化为
```
limit = {0:[],1:[3,7,9],2:[8],3:[1,7,9],4:[6],5:[],6:[4],7:[1,3,9],8:[2],9:[1,3,7]}
```
相应地，dfs中的判断条件要变更为：
```
if used[i] == False and (i not in limit[index] or used[(index+i)//2]):
```
即判断i不在limit中，或者要经过的点(index+i)//2已经被使用过。
