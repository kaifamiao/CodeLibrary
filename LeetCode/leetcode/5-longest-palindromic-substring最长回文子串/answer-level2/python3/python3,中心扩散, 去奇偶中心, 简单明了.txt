### 解题思路
##### 初步解题思路: 中心扩散.  长度为n的字符串, 中心点有2n-1个, 即字符本身为中心(n) + 字符串之间的中心(n-1).

使用变量c遍历, 从索引(0)开始, 每次增加0.5, 可以遍历所有中心点.  
当元素个数是偶数时:
index  01234567  偶数个元素 中心点: 0, 0.5, ... 6.5, 7  
  a = '12345678'
当元素个数是奇数数时: 
index  012345678  奇数个元素 中心点 0, 0.5, ... 7.5, 8  
  a = '123456789'

由上面的例子可以得到, 不管是奇数还是偶数长度, 遍历中心点退出条件都是是 c > len(s) -1, 

##### 扩散原则:
如果 c%1.0 == 0.5 说明正在以2个值的中间作为中心扩散, 这个时候前后加上0.5的基础偏移, 就能得到前后2个值, 然后继续按照1的偏移进行比较,直到发现不对称(相同偏移, 左右不相等) 或者越界就退出扩散,
如果 c%1.0 == 0.0 说明正在以一个值作为中心扩散. 这个时候只要加上1的基础偏移, 就可以得到前后2个值, 然后同上面的道理处理即可.

### 代码

```python3
class Solution:
    def longestPalindrome(self, s: str) -> str:
        length = len(s)
        if length == 0:  # 长度为0 直接返回""
            return ''
        else:
            cur_palindrome = s[0]  # 如果不是空元素, 直接先去一个元素再说.
        c = 0
        while c <= length - 1:
            if c%1.0 == 0.5:  # 这一个判断是在判断当前中心是一个值还是2个值的中间点.
                m = 0.5
            else:
                m = 1
            while (c + m) <= length - 1 and (c - m) >= 0:  # 扩散的退出条件--越界 
                if s[int(c - m)] == s[int(c + m)]:
                    if len(cur_palindrome) < (2 * m + 1):   # 如果对称, 判断长度
                        cur_palindrome = s[int(c - m): int(c + m +1)]  #
                else:
                    break # 扩散的退出条件--不对称
                m += 1.0   #
            c += 0.5  # 每个中心点距离是0.5
        return cur_palindrome
```