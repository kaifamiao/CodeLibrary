```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        return s if s==s[::-1] else max([s[j:i+1] for i in range(len(' '+s+' '))for j in range(i+1) if ' '+s[j:i+1]+' '==' '+s[j:i+1][::-1]+' '],key=len)
```
1.一个列表生成式中两个for循环，对字符串s一一遍历判断是否为回文数（可以参照9*9乘法实现），回文数判断方法：字符串s倒过来还是与s相等，即：s==s[::-1]，是回文数就储存在列表生成式的列表中
2.max(list,key=len)返回list中最长的字符串(有多个相同的也只返回一个)，即结果
3.三元表达式弥补当字符串很长时判断时间太长的缺陷：如果该字符串倒过来也相等：s==[::-1]，就直接返回s
4.修正当字符串s=''（为空）时报错：在字符串前面和后面都加上一个空格:' '+s+' '帮助判断，返回时只返回s里面的部分，不影响结果

其中有很多地方可修改来提升速度