## 最长回文串

### 题目描述

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

回文串：正读和反读都一样，最短的回文串是由一个字符构成

示例 1：

```
输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案
```

### 思路

采用动态规划的思想

#### 状态

子串问题：可以定义一个二维数组作为动态规划数组 `dp[i][j]` 表示 `s[i][j]` 是否为回文串，1表示为是回文串，0表示不是回文串。且`i < j`

#### 状态转移方程

- ##### 问题拆解：大问题的最优解如何由小问题的最优解得到

  根据回文串的定义，是否是回文串首先看其两边的字符是否相等 即`s[i] == s[j]`,

  - 如果相等，是否为回文串依赖于去掉两端的字符的子串是否是回文串 即`dp[i + 1][j - 1] `是0还是1
  - 如果不相等，则一定不是回文串

- ##### 状态转移方程

  ```java
  dp[i][j] = s[i] == s[j] ? dp[i + 1][j - 1] : 0;
  ```

- ##### 得到状态转移方程的条件

  - 子串两边的字符是否相等，即 `s[i] == s[j]  `  时，才执行状态转移

  - 同时注意到 `dp[i + 1][j - 1]` 要考虑到数组边界的情况，要保证 `[i + 1][j - 1]` 能构成区间的有效性。 如下面这个例子：

    ```java 
    s = "cabbad";
    当 i = 2,j = 3 时 s[2] == s[3], 若按照只之前分析的状态转移方程
    dp[2][3] == dp[3][2] 注意 dp[3][2] 时没有意义的，因为规定 i < j
    ```

    长度为1 的字符串也算回文串，所以 `[i - 1][j + 1]` 的长度要小于2 即 `j - 1 - (i + 1) + 1 < 2    j - i < 3`  。当其长度为1 或 0 时 一定是回文串了，无须再以依赖状态转移方程

#### 初始化

单个字符一定是字符串，对角线初始化为1

#### 输出

要得到的是最长的一个回文串，动态规划的数组记录了子串是否是字符串的情况，因此我们在更新动态规划数组时就随时记录和更新回文串的最大长度和起始值。更新完数组后按照最长回文子串的 起始位置 和 长度 截取字符串返回即可

### Q & A

dp数组如何遍历更新？是按行的遍历更新还是按列遍历更新？为何要按照列遍历更新？

`s  =  "cabbad"`

- 按行遍历更新

  ```java 
  for (int i = 0; i < len; i ++){
      for (int j = i + 1; i < len; j ++){
          if (s.charAt(j) == s.charAt(i)){
              // code......
          }
      }
  }
  ```

  按照行来遍历更新的话，相当于固定子串的开头位置，不断**扩大**字串的结尾位置。结果发现dp数组不更新。debug一下发现首先遍历到 `i = 1, j = 4 时 s[i] == s[j] 且 j - i >= 3` 其是否为回文串依赖于     `dp[i + 1][j - 1] `  结果 即 `dp[2][3]` 然而 `dp[2][3]` 还为遍历到 ，因此dp数组不更新。

- 按列遍历更新

  ```Java
   for (int j = 1; j < len; j++){
       for (int i = 0; i < j; i++){
           if (s.charAt(j) == s.charAt(i)){
               // code....
           }
       }
   }
  ```

  按照列遍历更新的话，相当于固定字串结尾部分，让开始部分 `i` 不断接近结尾位置，**缩小**字串的区间。还看之前例子：当遍历到 `i = 1, j = 4 时 s[i] == s[j] 且 j - i >= 3` 其是否为回文串依赖于    `dp[i + 1][j - 1] ` 。因为是按照列来遍历，`j - 1` 一定遍历过，而对于 `j - 1` 的一切 `i`  的取值之前都已经遍历到了。dp数组可以更新。



### 代码

```java
    public  String longestPalindromeII(String s) {
        
        int len = s.length();
        if (len < 2) return s;

        // dp[i][j] 表示i开始j结束的子串是否为回文串
        int[][] dp = new int[len][len];
        
        // 初始化：对角线一定是子串
        for (int i = 0; i < len; i++){
            dp[i][i] = 1;
        }
        int start = 0;
        int maxLen = 1;

        for (int j = 1; j < len; j++){
            for (int i = 0; i < j; i++){
                if (s.charAt(j) == s.charAt(i)){
                    // 状态转移
                    if (j - i < 3) dp[i][j] = 1;
                    else dp[i][j] = dp[i + 1][j - 1];
                }
                if (dp[i][j] == 1){
                    // 更新回文串长度和最大值
                    maxLen = Math.max(maxLen, j - i + 1);
                    start = maxLen == j - i + 1 ? i : start;
                }
            }
        }
		// 截取子串返回
        return s.substring(start, start + maxLen);

    }
```

