### 解题思路

#### 1.题目分析
+ 找回文串

#### 2.思路整理
##### 2.1 回文串两种情况
回文串有两种情况需要分开考虑，分别是奇数回文串和偶数回文串。
+ 奇数回文串最中间为一个字符，例如`abcba`
+ 偶数回文串最中间两个字符相同，例如`cabbac`

##### 2.2 最长回文子串
回文串的特征是从中心向外总是能相同。因此最长回文字串可以采用中心向外比对，找到最大匹配成功的长度即可。

##### 2.3 边界条件
+ 代码需要考虑s长度为0，即`""`的情况下能正确输出。
+ 代码需要考虑s为最短奇数回文串和偶数回文串的情况，即`a`或`aa`的情况下能正确输出。

#### 3.算法实现
1. 开始遍历原字符串。
2. 从中心向外扩散，考虑奇数回文串和偶数回文串两种情况
3. 记录最长的回文串长度和字串的起始位置。
4. 当最长字串的长度max较长，长度大于该位置理论上能产生的字串长度时，即可不用遍历。
例如`abcdcba`，遍历到d位置时，max为7，即无需遍历后面的`cba`了。

采用两次循环遍历的方法，时间复杂度为o(n^2)

#### 4.运行结果
执行用时 :
16 ms, 在所有 C 提交中击败了92.01%的用户
内存消耗 :
7.1 MB, 在所有 C 提交中击败了78.66%的用户

### 代码

```c
#define MAX(a, b) (((a) >= (b)) ? (a) : (b))

char * longestPalindrome(char * s){
    int max = 0;
    int i,j,k,head = 0;
    char *ret = "";

    for (i = 0; i < strlen(s); i++) {

        //如果此时最长已经不可能大于max了，那后面就不需要遍历了
        if (max >= 2 * (strlen(s) - i) - 1)
            break;

        //奇数回文串情况
        for(j = 0; j <= i; j++ ) {
            if ( s[i - j] != s[i + j] )
                break;
        }
        //偶数回文串情况
        for(k = 0; k <= i; k++ ) {
            if ( s[i - k] != s[i + k + 1] )
                break;
        }
        
        //取max、奇数回文情况、偶数回文情况的最大值
        if(max < MAX(2 * j - 1, 2 * k)) {
            //记录该回文的头部位置
            max = MAX(2 * j - 1, 2 * k);
            head = i - (max - 1) / 2;
        }
    }

    //截断原字符串
    ret = s + head;
    ret[max] = '\0';

    return ret;
}
```