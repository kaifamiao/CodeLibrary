周赛的时候没做出来，看了第一名大佬的解答，感到豁然开朗。
不过就算是知道用动态规划，也是很难写的
dp[i][j][k] 表示是蛇尾在(i,j)处，并且状态为k时候的最小步数(0:水平 1:竖直)
但是在写动态规划的时候，旋转的操作比较难处理
比如在dp[2][2][0] 的时候 
我可以是d[2][1][0] 右移一步得到
也可以是d[1][2][0] 下移一步得到
我也可以d[2][2][1] 逆时针转一下得到
但是问题就来了 我可能在处理 dp[2][2][0]的时候还没有处理dp[2][2][1];

(仔细想一想 是不是有点绕)

所以这里的动态规划应该是往后写的，遍历到dp[2][2][0] 的时候 应该去填 dp[2][3][0],dp[2][2][1],dp[3][2][0]
情况可以分成简单的两类情况 
一种是有2X2的方框可以填
另一种就是没有2X2的方框可以填

```
class Solution {
public:
	int minimumMoves(vector<vector<int>>& grid) {
		int n = grid.size();
		int f[101][101][2],ans;
		memset(f, 127, sizeof(f)); 
		f[0][0][0] = 0;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				if (!grid[i][j]) {
					//如果以当前点，存在一个2*2的方框
					if (i + 1 < n && j + 1 < n && !grid[i + 1][j] && !grid[i][j + 1] && !grid[i + 1][j + 1]) {
						f[i][j][0] = min(f[i][j][0], f[i][j][1] + 1);
						f[i][j][1] = min(f[i][j][1], f[i][j][0] + 1);
						f[i + 1][j][0] = min(f[i + 1][j][0], f[i][j][0] + 1);
						f[i][j + 1][1] = min(f[i][j + 1][1], f[i][j][1] + 1);
					}
					if (j + 2 < n && !grid[i][j + 1] && !grid[i][j + 2]) f[i][j + 1][0] = min(f[i][j + 1][0], f[i][j][0] + 1);
					if (i + 2 < n && !grid[i + 1][j] && !grid[i + 2][j]) f[i + 1][j][1] = min(f[i + 1][j][1], f[i][j][1] + 1);
				}
			}
		}
		ans = f[n - 1][n - 2][0] == 2139062143 ? -1 : f[n - 1][n - 2][0];
		return ans;
	}
};
```
