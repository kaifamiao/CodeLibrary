### 思路：
动态规划，维护一个一维数组`dp`，其含义为：
在第`i`轮循环开始时，`dp[j]`表示在所有由`i`个不同的数组成的序列中，以第`j`大的数为尾，且这`i`个数的排列满足`S[0, i-1)`的要求的可能排列数。`(0<=j<i)`
当`i = n+1`时，即结束循环，此时`dp`中所有元素的和即为所求。

#### 初始化：
`i = 1, dp = [1]`

#### 递推：
第`i`轮循环时，`dp[j]`表示在所有由`i`个不同的数组成的序列中，以第`j`大的数为尾，且这`i`个数的排列满足`S[0, i-1)`的要求的可能排列数。`(0<=j<i)`

现要将它更新为所有由`i+1`个不同的数组成的序列中，以第`j`大的数为尾，且这`i+1`个数的排列满足`S[0, i)`的可能排列数。`(0<=j<=i)`

一个序列由`i+1`个不同的数组成，且这`i+1`个数的排列满足`S[0, i+1)`的要求，当且仅当：
`1.`该序列的前`i`个数的排列满足`S[0, i-1)`的要求
`2.`该序列的第`i-1`和第`i`个数满足`S[i-1]`的要求

当`S[i-1] == 'D'`时，第`i`个数应小于第`i-1`个数。
此时，第`i`个数不能是这`i+1`个数中最大的数(排行第`i`位)，故`dp[i] = 0`。
假设第`i`个数在这`i+1`个数中排行第`j`位`(0<=j<i)`，那么第`i-1`个数可以在这`i+1`个数中排行第`j+1`, `j+2`, ..., `i`位, 也就是在前`i`个数中排行第`j`, `j+1`, ..., `i-1`位, 故有：
`dp[j] = dp[j] + dp[j+1] + ... + dp[i-1]`
按照`j`由大到小的顺序更新，则可简写为：
`dp[j] = dp[j] + dp[j+1]`
当`S[i-1] == 'I'`时，可类似分析。

### 代码：
```
class Solution:
    def numPermsDISequence(self, S: str) -> int:

        i = 1
        x = int(pow(10, 9)) + 7
        n = len(S)
        dp = [1]

        while (i <= n):

            if S[i-1] == 'D':
                dp.append(0)
                for j in range(i-1, -1, -1):
                    dp[j] += dp[j+1]
                    dp[j] %= x

            else:
                last = dp[0]
                dp[0] = 0
                for j in range(1, i):
                    temp = dp[j]
                    dp[j] = last + dp[j-1]
                    dp[j] %= x
                    last = temp
                dp.append((last + dp[i-1]) % x)

            i += 1

        return sum(dp) % x
```
