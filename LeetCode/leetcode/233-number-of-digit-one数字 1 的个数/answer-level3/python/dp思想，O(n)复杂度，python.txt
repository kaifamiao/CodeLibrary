整体思路是dp的思想。一开始想的是从左到右dp，后来怎么算都不对，最后才发现只能从低位到高位dp。
整体的思想是：当前位之后所有的1（比如287，当前位置是8时，就是指87之前所有的1，当前位置是2是就是287之前所有的1）由三部分组成：
拿287举例:Sum(287)=Sum(87)+1*100+2*20.Sum(87)是上一步dp的结果，也就是对应的201-287中的1的个数。1*100对应的是101-199之间的个数。
2*20对应的是0-99，和101-199之间的1的个数（这里只统计101-109后两位的1的个数，所以20*2就可以了，第一位上的1在1*100统计过了），20
怎么来的呢，通过def getInterNum(self,n)这个函数来的，整体思想和上面一样的，在代码里写了。可以找到规律，0:0,10:1,100:20,1000:300,10000,：4000.所以20*2就可以了，第一位上的1在1*100统计过了），20直接
用O1的时间复杂度去获得，节省时间。
当0的时候直接跳过即可，当1的时候需要特殊处理，比如Sum(187)=Sum(87)+(1+87)+1*20,中间的一项变了，是因为不能100了，因为最多只能到达187,188-199的后两位
的1不能统计。
```
class Solution(object):
    def getInterNum(self,n):#这里相当于都是定值了，因为传进来的都是
    #0,10,100,1000这样的数，对应分别是0,1,20,300,4000，比如n=1000时表示0-999所包含的1的
    #个数 算法也是从低位向高位算，输入10（其实在算小于等于9的）的就是返回1，100（其实是99）就是1+9*1+10,1是91到99之间的1，也就是上一步dp的结果，9*1是上一步的1，我在前面添加了9个不同的数，所以是9*1,10是10-19的1,11中的一个1在9*1的时候算过了，所以并没有少算。
        s = math.pow(10,n-1)
        return n*s
    def countDigitOne(self, n):
        if n <= 0:
            return 0
        Sum = 0;
        cir = 0
        N = n
        while n:
            t = n%10
            n = n/10
            if t==0:
                cir+=1
            elif t != 1:
                Sum = Sum+t*self.getInterNum(cir)+math.pow(10,cir)
                cir+=1
            else:
                Sum = Sum+N%math.pow(10,cir)+1+self.getInterNum(cir)
                cir+=1
        return int(Sum)
```
