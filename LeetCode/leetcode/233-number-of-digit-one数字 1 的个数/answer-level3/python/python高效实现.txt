本题只要遍历0~n，不管如何优化，都无法在规定的时间内通过。因此思路要改变。

经验中还找不到某个套路能套进去的时候，就开始通过分析案例，果然发现是有规律可循的。

如下，右边为1出现次数：
> 0~9: 1

> 0~99: 10 * 1 + 10 = 20

> 0~999: 10 * 20 + 100 = 300
 
> 0~9999: 10 * 300 + 1000 = 4000

比如说，21中出现了1，那么121, 221, 321,....921中都会出现1，相当于两位数21左边添加1~9任何一个数字变成了三位数。
简单说起来就是，每个个位数会在两位数中再出现9次，每个两位数会在三位数中再出现9次，以此类推。这就是乘10的原因。
但1开头的数也要计算进去，如在0~999中，还要再加上100~199这一百个数中出现在开头的1。

这样就可以算出100,1000,10000....这些数的答案
```python
    def countPart(t):            
        if t == 10:
            return 1            
        s = t/10
        return 10 * countPart(t/10) + s
```

基于这个，稍作修改即可写出答案。比如输入388，可以这样分成0~299和300~388。

0~299，因为0~99的这些数出现1的次数为countPart(100)，再加上100~199中100个出现在开头的1即可。 
300~388，等于0~88中1出现的次数，这部分的计算就可以通过递归来算。

代码如下：
```python
class Solution(object):
    def countDigitOne(self, n):
        """
        :type n: int
        :rtype: int
        """        
        if n < 1:
            return 0
        if n < 10:
            return 1
        
        # t需要能被10整除
        def countPart(t):      
            if t == 10:
                return 1            
            s = t/10
            return 10 * countPart(t/10) + s
        ans = 0        
        # 判断n是几位数，如n=388,l就是100
        y = 10
        while y <= n:
            y *= 10
        l = y / 10
        subn = n % l
        ans += self.countDigitOne(subn)
        c = n / l        
        ans += c * countPart(l) + (l if c != 1 else subn+1) # 这里要注意下以1开头的情况
        return ans
```