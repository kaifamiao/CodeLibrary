思路：统计每一位上1出现的次数，分别假设n=203,213,253，统计十位出现1的次数：

将数字分为前缀，中间数，后缀，如203的前缀为2，中间数（正在统计的那一位）为0，后缀为3，根据中间数可分为以下三种情况：
1.中间数为1，此时所包含1的数共有：前缀数值*pow(10, 后缀长度) + 后缀数值 + 1；
2.中间数为0， 此时所包含1的数共有：前缀数值*pow(10, 后缀长度)；
3.中间数为(2~9)，此时所包含1的数共有：(前缀数值+1)*pow(10, 后缀长度)；

例如，
若n=213，十位出现1的次数为：2*pow(10, 1) + 3 + 1=24次；
若n=203，十位出现1的次数为：2*pow(10, 1)=20次；
若n=253，十位出现1的次数为：(2 + 1)*pow(10, 1)=30次；

以同样的方法统计个位和百位，注意边界条件(代码中没有特别处理刚好可行)，求和可得结果。

c++代码如下：

```
    int countDigitOne(int n) {
        if(n<=0)
            return 0;
        string s = to_string(n);
        int len = s.size();
        int res = 0;
        for(int i=0; i<len; i++)
        {
            if(s[i] == '1')
                res += atoi(s.substr(0, i).c_str()) * pow(10, len-i-1) + atoi(s.substr(i+1).c_str()) + 1;
            else
                res += (atoi(s.substr(0, i).c_str()) + (s[i] == '0' ? 0 : 1)) * pow(10, len-i-1);
        }
        return res;
    }
```
速度还是挺快的...
对atoi函数复杂度不是很了解，谢谢大家批评指正！
