### 解题思路
本题目其实看上去很简单，重要的是要找规律。
先拿样例来说：
13可以划分为两个位数，十位数1 和 个位数3.
c[13] = 1 * 3 + 1 + 1 = 5;
c[1] = 0 * 1 + 1 = 1;
故一共有6个1.

同样的，我们换个数据来79；
79也可以划分为两个位数，十位数7和个位数9.
首先计算十位数的值：
c[79] = 7 * 1 + 10 = 17;
c[9]  = 0 * 1 + 1 = 1;
故一共有18个1.

因此，我们可以推导出相应的公式：
0-9可以发现只有1符合。
0-99可以发现，一共有十位数上可以排0-9，个位数为1，共10*1 = 10个；
然后，需要注意十位数为1的特殊情况，即为10 + 10 = 20。
0-999可以发现，共有10个0-99的情况，故为10 + 20 = 200；
而对于1xx（100-199）而言，又有100个数据，故为200+100 = 300。
同样的道理可以一直延续下去。

```
0 - 9:    10 * 0 + 1        = 1; //个位数1个1
0 - 99:   10 * 1 + 10      = 20; //0-9都可以为十位数，当1x时，0-9都可以出现；
0 - 999:  10 * 20 + 100     = 300;//0-9都可以为百位数，当1xx时，0-99都可以出现；
0 - 9999: 10 * 300 + 1000   = 4000;//0-9都可以为千位数，当1xxx时，0-999都可以出现
```

以2020为例，可以列出公式：
c[2020] = c[0 - 1999] + c[0 - 20] + c[0 - 0];
        = (2 * 300 + 1000) + (2*1 + 10)
        = 1612
这样我们就可以得到最终的结果了。

### 代码

```cpp
class Solution {
public:
    //还是找公式，理解清楚
    int countDigitOne(int n) {
        long factor = 0;
        long digital = 1;
        int count = 0;
        int low_digit = 0;
        while(n != 0){
            //求得是末位的数字
            int num = n % 10;
            //这里分两种情况讨论
            if(num == 1) count = count + (num * factor + low_digit + 1);
            else if(num > 1) count = count + (num * factor + digital);
            low_digit = low_digit + num * digital;
            factor = 10 * factor + digital;
            digital = digital * 10;
            n = n / 10;
        }
        return count;
    }
};
```