## 思路
碰到这种题，第一想法就是找规律咯。可惜我是一个大懒人，实在不想慢慢去理这其中的关系。那么，使用**递归**就是一个蛮好的选择了，毕竟递归算法逻辑简单，设计容易。
那么，具体到这一题之上，递归就需要将当前的数字分解为**最高位**上`1`的出现次数加上其它位上出现`1`的次数。例如数字`222`，就需要将其分解为3个部分：
1. 在百位上出现的`1`的情况为：`100`~`199`；
2. 在百位下`1`~`99`出现的`1`的个数；
3. 在百位下`1`~`22`出现的`1`的个数。  

如此逐层分解到个位上，将所有答案累加起来，便可以得到`1`~`222`的所有1的个数。

## 缺陷
递归算法虽然简单，但是相较于迭代算法而言会占用更多空间以及时间。在本题算法中有一个很明显的问题即是有许多子问题被重复计算。那么可以使用记忆，将一些频繁计算到的项存储起来，用以节省时间。很明显的一个被重复计算的子项是：10^i-1。那么，可以将对应的结果存储到字典之中。便可以加速运算。

## 代码
代码写得凌乱，将就着看吧T_T...
![image.png](https://pic.leetcode-cn.com/d99a844431dd6c07ec66eddc0d112a670adb77b88ab96fbd55939fd08491190b-image.png)
最好的一次时间（其余两次是44，80）
```python []
class Solution:
    def __init__(self):
        self.map = {0:0, 9:1}
        for i in range(1, 10):
            self.map[10**(i+1)-1] = 10**i+10*(self.map[10**i-1])
    
    def countDigitOne(self, n):
        if n<=0:
            return 0
        i = 1
        while i*10<=n:
            i *= 10
        return int(self.count(n ,i))

    def count(self, n, i):
        if n==0:
            return 0
        else:
            while i>n:
                i /= 10
            n_1 = self.map[i-1]
            return min(i, n-i+1)+n//i*n_1+self.count(n%i, i/10)
```
