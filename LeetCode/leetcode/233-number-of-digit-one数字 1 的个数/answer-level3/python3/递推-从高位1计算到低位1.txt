## 感受
遇到这种计数的题，一般的思路就是固定一位，看剩下的位有多少种组合可能。

由于数位DP惯性思维以及可拆解性，所以一般都是从高位到低位拆成 “零-整” 进行计算。“零”表示当前还在“数值边界”上，后面的数直接取 0-9可能会超出上界`n`，而“整” 表示高位取的数确保后面无论如何取都能保证在范围内。

P.S.: 官方的题解逆向思维从低位计算到高位，计算过程和`n`按位从低到高的计算过程吻合，直接递推计算使得代码非常简洁，但这种递推式子理解起来有点费劲:\ 

## 思路
根据“零-整”思路，每次考虑一位时，如果之前的高位使得当前状态是“零”状态，则当前位取值最大只能是从`n`中计算得到的值digit. 当当前位取值小于`digit`时，之后的就是整，含`0`在内有`digit`个”整“，这样就计算完了”整“中**当前位之后** 1出现的次数，还需要看`digit`是否为1，从而累计当前位1到结果中。如果`digit`是1，则当前位只有$n%10^i$当前位之后的个数+1个1，否则有$10^i$个1.

## 具体编码实现
### 预处理得到”整“
`arr[i]`：表示[0, 10^i)中含有1的个数：`arr[i] = 10 ^ (i-1) + 10 * arr[i-1]`, 其中 `10 ^ (i-1)`即`base10[i-1]`表示第`i`位的1后面有`base10[i]`个数，得到第`i`位1的个数；`10 * arr[i-1]`中的`10`表示第`i`位的数字可取10个数字，其中`0`代表第`i`位为空，即只有`i-1`位；
### 按位从高位到低位对”零“进行处理，在”零“中计算”整“

```python
class Solution:
    def countDigitOne(self, n: int) -> int:
        arr = [0] # [0, 10^i) 之间 1的个数
        base10 = [10 ** i for i in range(20)]
        for i in range(1, 20):
            arr.append(base10[i-1] + 10 * arr[-1])
        bits, aux = [], n
        while aux > 0:
            bits.append(aux % 10)
            aux //= 10
        res = 0
        for i in range(len(bits)-1, -1, -1): # 每次进入都是零的状态
            res += bits[i] * arr[i] # 所以是 bits[i] 个"整" -> 得到"整”的1的个数；
            if bits[i] > 1: # 特判当前位累计当前位1的个数
                res += base10[i] # + 100 -> 280
            elif bits[i] == 1:
                res += n % base10[i] + 1
            # print(res)
        return res
```
> time: 24ms, 97.75%; 
> memory: 12.9MB, 65.80%.