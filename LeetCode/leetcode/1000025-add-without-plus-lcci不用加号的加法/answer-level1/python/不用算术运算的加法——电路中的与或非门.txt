### 解题思路
刚开始想到的是取a、b的每个位，按位通过判断 ai bi关系进行每一位的运算（包含标记位，代码比较复杂,提交发现time out, 原来python -1 >> 1 == -1 死循环了，看了各路大神的算法，python不太好搞定负数位移，sui迁到c++）
根据 a&b 获取不带进位的求和， a^b 获取标记位， 通过标记位左移1位， 进一步和不带进位的结果进行求和与求进位，直至进位为0，结束循环。
#### 贴下 add(-1，2)的执行过程：
a:b:a^b:a&b:(unsigned int)a&b:
-1 2 -3 2 2
-3 4 -7 4 4
-7 8 -15 8 8
-15 16 -31 16 16
-31 32 -63 32 32
-63 64 -127 64 64
-127 128 -255 128 128
-255 256 -511 256 256
-511 512 -1023 512 512
-1023 1024 -2047 1024 1024
-2047 2048 -4095 2048 2048
-4095 4096 -8191 4096 4096
-8191 8192 -16383 8192 8192
-16383 16384 -32767 16384 16384
-32767 32768 -65535 32768 32768
-65535 65536 -131071 65536 65536
-131071 131072 -262143 131072 131072
-262143 262144 -524287 262144 262144
-524287 524288 -1048575 524288 524288
-1048575 1048576 -2097151 1048576 1048576
-2097151 2097152 -4194303 2097152 2097152
-4194303 4194304 -8388607 4194304 4194304
-8388607 8388608 -16777215 8388608 8388608
-16777215 16777216 -33554431 16777216 16777216
-33554431 33554432 -67108863 33554432 33554432
-67108863 67108864 -134217727 67108864 67108864
-134217727 134217728 -268435455 134217728 134217728
-268435455 268435456 -536870911 268435456 268435456
-536870911 536870912 -1073741823 536870912 536870912
-1073741823 1073741824 -2147483647 1073741824 1073741824
-2147483647 -2147483648 1 -2147483648 2147483648


### python代码 （针对负数失效，会time out）
```python
    def add(self, a, b):
        """
        :type a: int
        :type b: int
        :rtype: int
        """
        res = []
        flag = 0
        while a or b:
            l = a & 1
            r = b & 1
            a = a >> 1
            b = b >> 1
            if l == r:
                tmp = 0
                if l == 1:
                    cur_flag = 1
                else:
                    cur_flag = 0
            else:
                tmp = 1
                cur_flag = 0
            if flag:
                if tmp:
                    tmp = 0
                    cur_flag = 1
                else:
                    tmp = 1
                flag = 0
            flag = cur_flag
            res.append(tmp)
        if flag:
            res.append(1)
        t = 0
        for i in xrange(len(res)-1,-1,-1):
            t = (t << 1)|res[i]
        return t
```
### 代码（accepted）

```cpp
class Solution {
public:
    // add without using + - method
    int add(int a, int b) {
        int s1,s2;
        while (b) {
            s1 = a ^ b;
            s2 = a & b;
            a = s1;
            b = (unsigned int)s2 << 1;
        }
        return a;
    }
};
```