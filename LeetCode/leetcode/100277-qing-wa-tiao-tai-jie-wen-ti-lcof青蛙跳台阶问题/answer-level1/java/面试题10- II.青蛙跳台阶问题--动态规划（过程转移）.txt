### 解题思路
借鉴了题解中最广泛的思想：动态规划的思想，转移过程类似于斐波那契数列，只不过斐波那契数列的dp[i] = 0,(i = 0)。
dp[i] = 1,(i = 0,1);
dp[i] = dp[i - 1] + dp[i - 2],(i = 2,3,...,n-1,n)。

### 时间复杂度：
### O(n)
### 空间复杂度：
### O(1)--空间复用的情况
### O(n)--数组存储的情况
                
### 代码

```java
class Solution {
    public int numWays(int n) {
        //本题中0个台阶是1种跳法：即--不跳
        if(n == 0 || n == 1) return 1;
        //法一：内存复用的过程转移，节省空间
        int a = 1;
        int b = 1;
        int res = 0;
        for(int i = 2; i <= n; i++){
            //在循环的过程中即进行取模处理，以防止大数溢出
            res = (a + b) % 1000000007;
            a = b;
            b = res;
        }
        return res;
        //法二：使用数组存储每步的数据，浪费空间
        // int[] dp = new int[n + 1];
        // dp[0] = 1;
        // dp[1] = 1;
        // //使用数组占用内存大
        // for(int i = 2; i <= n; i++){
        //     dp[i] = (dp[i - 1] + dp[i - 2]) % 1000000007;
        // }
        // return dp[n];    
    }
}
```
### 引用用户@ajslpzcd对取模的解释：

“PS : 为什么要模1000000007。参考https://www.liuchuo.net/archives/645。
大数阶乘，大数的排列组合等为什么要取模：
1000000007是一个质数（素数），对质数取余能最大程度避免冲突
int32位的最大值为2147483647，所以对于int32位来说1000000007足够大。
int64位的最大值为2^63-1，对于1000000007来说它的平方不会在int64中溢出。
所以在大数相乘的时候，因为(a∗b)%c=((a%c)∗(b%c))%c，所以相乘时两边都对1000000007取模，再保存在int64里面不会溢出。
这道题为什么要取模，取模前后的值不就变了吗？
确实：取模前 f(43) = 701408733, f(44) = 1134903170, f(45) = 1836311903, 但是 f(46) > 2147483647结果就溢出了。
对齐，取模后 f(43) = 701408733, f(44) = 134903163 , f(45) = 836311896, f(46) = 971215059没有溢出。
这道题的测试答案与取模后的结果一致。
总结一下，这道题要模1000000007的根本原因是标准答案模了1000000007。不过大数情况下为了防止溢出，模1000000007是通用做法，原因见第一点。”
