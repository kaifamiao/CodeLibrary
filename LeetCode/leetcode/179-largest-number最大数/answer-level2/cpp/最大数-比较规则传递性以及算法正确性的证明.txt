# 最大数

给定一组非负整数，重新排列它们的顺序使之组成一个最大的整数。

---

虽然仅仅是一道中等难度的题，但是一开始还是有点懵。最开始的想法是设计一个类似从高位开始的基数排序。但在处理不同位长数的排序时，我发现很难给出一个统一的大小判别规律，例如$962,96,9$的最优排序是$996962$,而$162,16,1$的最优排序是$162161$。因此这个思路就只能毙掉了Orz。

官方提供的题解是定义一个新的比较逻辑`bool cmp(string s1, string s2){s1+s2 > s2+s1};`，下面证明一下这个比较逻辑的正确性。

1. 传递性

   `cmp(s1,s2)` and `cmp(s2,c3)`$\rightarrow$ `cmp(s1,s3)`

   **Proof**

   假设$s_1,s_2,s_3$,长度分别为$l_1,l_2,l_3$，对应数分别为$n_1,n_2,n_3$。
   $$
   s_1 + s_2 \geq s_2 + s_1 \rightarrow n_1l_2 + n_2 \geq n_2l_1 + n_1\\
   s_2 + s_3 \geq s_3 + s_2 \rightarrow n_2l_3 + n_3 \geq n_3l_2 + n_2\\
   n_1(l_2 - 1) \geq n_2(l_1 - 1)\\
   n_2(l_3 - 1) \geq n_3(l_2 - 1)\\因为(3)(4)式左右均非负，可得
   $$
   因为(3)(4)式左右均非负，可得
   $$
   n_1n_2(l_2-1)(l_3-1) \geq n_2n_3(l_1-1)(l_2-1)
   $$

   * 如果$l_2 = 1$，由(3)可知$l_1 = 1$
     $$
     n_1(l_3-1) \geq 0 = n_3(l_1-1)
     $$

   * 如果$l_2 \neq 1$，由(5)可得
     $$
     n_1(l_3-1) \geq n_3(l_1-1)
     $$

   综上均有
   $$
   n_1(l_3-1) \geq n_3(l_1-1)
   $$
   即
   $$
   s_1+s_3 \geq s_3 + s_1
   $$

2. 算法正确性
   假设存在一个最优序列不满足该排序规则，即至少存在一对相邻字符串$s_1,s_2$满足$s_2 + s_1 < s_1 + s_2$而$s_1$优先于$s_2$被选取。由于交换$s_1,s_2$不会改变其他字符串对最终值的贡献（这是因为$s_1,s_2$相邻），因此根据我们定义的比较逻辑，交换$s_1,s_2$后字符串的值严格增加，这与序列的最优性矛盾。由此得证最优序列满足该排序规则。

   

事实上，这道题的关键并不在于代码的实现上，算法正确性的证明显然更加重要。浏览了一下中文站的评论区几乎没有提到这一点，说明很多人在这上面还是模棱两可的，这也违背了我们做算法题的初衷，固以此作为补充。





