我看了好几个回答，感觉好几个人都是照抄的代码。
动态规划的公式很多人一看就觉得懂了，但实际上有些隐含条件没分析到位的话，你不一定真的是想明白了。

这道题有一个隐含条件
```
如果颜色大于两种为n，那么任意一个栏杆都可以着n种颜色. 
    证明如下 
    第一步，前两个栏杆肯定是所有的颜色组合都可以。 
    第二步，如果第二，三可以有所有的颜色组合，那么就说明，第n个也是跟第n-1有所有的颜色组合。 
    这个举个例子就能想明白，就不说了。
```
有了这一点，我们再去想就很容易了。

动态规划的三板斧。

第一板斧——找思路，看如何自底部向上。
```
    之所以加这一步，是因为有的题目抽象的比较厉害。需要加一些特殊处理才行
    这个就没啥好说的，挨个栏杆遍历
```
第二板斧——确认公式
```
    分成两块
        如果当前栏杆颜色跟前一个栏杆颜色相同，那么可能组合 F(N- 2) * (K - 1)
        如果当前栏杆跟前一个颜色不同，那么可能组合 F(N - 1) * (k - 1)
    具体解释下第二个假设的分析
        既然所有的栏杆都可以着色n种 如果，当前栏杆和前一个栏杆颜色不同。 那么前一个栏杆每一个路线，
        都可以跟后面的栏杆跟这个路线最后一个颜色不同的k-1个颜色组合方案。 所以就是 F(N - 1) * (K - 1)
    第一个假设的分析同上
   
```
第三板斧——确认需要存储的上1/N步信息是否找对了
```
    这个就没啥特殊的，但之所以加这一步。
    因为两点
    第一，这一步确认了，代码也就差不多确认了
    第二，通过这一步反向来确认第二步是否真的完美了，double check下。
```

代码

```


class Solution {
public:
    int numWays(int n, int k) {
        int pre_count = 0;
        int pre_pre_count = 0;
        int result = 0;
        for (int i = 0; i < n; ++i) {
            if (i == 0) {
                pre_pre_count = k;
                result = pre_pre_count;
                continue;
            }
            if (i == 1) {
                pre_count = k * k;
                result = pre_count;
                continue;
            }
            result = pre_count * (k - 1) + pre_pre_count * (k -1);
            pre_pre_count = pre_count;
            pre_count = result;
        }
        return result;
    }
};
```

